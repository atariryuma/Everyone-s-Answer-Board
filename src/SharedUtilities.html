<script>
// =========================================================================
// Unified Logger: development-friendly logs with environment-based levels
// - Production: WARN/ERROR only
// - Development: DEBUG/INFO/WARN/ERROR with clear prefixes
// =========================================================================
(function() {
  'use strict';

  /**
   * ログレベル定義（小さいほど重要）
   */
  const LEVELS = { error: 0, warn: 1, info: 2, debug: 3 };

  /**
   * 現在のログレベルを取得
   * 優先順: window.LOG_LEVEL -> window.DEBUG_MODE -> 'warn'
   * @returns {'error'|'warn'|'info'|'debug'}
   */
  function getCurrentLevel() {
    try {
      const lvl = (window.LOG_LEVEL || '').toString().toLowerCase();
      if (lvl && LEVELS.hasOwnProperty(lvl)) return lvl;
      if (typeof window.DEBUG_MODE !== 'undefined') {
        return window.DEBUG_MODE ? 'debug' : 'warn';
      }
      return 'warn';
    } catch (_) {
      return 'warn';
    }
  }

  /**
   * ログ出力の可否
   * @param {'error'|'warn'|'info'|'debug'} level
   */
  function shouldLog(level) {
    const current = getCurrentLevel();
    return LEVELS[level] <= LEVELS[current];
  }

  /**
   * タイムスタンプ生成
   */
  function ts() {
    try { return new Date().toISOString(); } catch (_) { return ''; }
  }

  /**
   * 構造化プレフィックス
   */
  function prefix(level, module) {
    const mod = module ? `[${module}]` : '';
    return `[${ts()}] ${level.toUpperCase()}${mod}:`;
  }

  /**
   * AppLogger API（開発者向け）
   */
  const AppLogger = {
    /** @param {string} module */
    scope(module) {
      return {
        debug: (...args) => AppLogger.debug(module, ...args),
        info: (...args) => AppLogger.info(module, ...args),
        warn: (...args) => AppLogger.warn(module, ...args),
        error: (...args) => AppLogger.error(module, ...args),
      };
    },
    /** @param {string} [module] */
    debug(module, ...args) { if (shouldLog('debug')) { try { console.log(prefix('debug', module), ...args); } catch (_) {} } },
    /** @param {string} [module] */
    info(module, ...args) { if (shouldLog('info')) { try { console.log(prefix('info', module), ...args); } catch (_) {} } },
    /** @param {string} [module] */
    warn(module, ...args) { try { if (shouldLog('warn')) console.warn(prefix('warn', module), ...args); } catch (_) {} },
    /** @param {string} [module] */
    error(module, ...args) { try { console.error(prefix('error', module), ...args); } catch (_) {} },
    /** @param {'error'|'warn'|'info'|'debug'} level */
    setLevel(level) { if (LEVELS.hasOwnProperty(level)) window.LOG_LEVEL = level; },
    getLevel() { return getCurrentLevel(); },
  };

  // グローバル公開
  window.AppLogger = AppLogger;

  // consoleラッパー: 既存のconsole呼び出しもレベル準拠で動作
  try {
    const original = {
      log: console.log,
      info: console.info,
      debug: console.debug || console.log,
      trace: console.trace || console.log,
      warn: console.warn,
      error: console.error,
    };

    console.log = function(...args) { if (shouldLog('debug')) { try { original.log.apply(console, args); } catch (_) {} } };
    console.info = function(...args) { if (shouldLog('info')) { try { original.info.apply(console, args); } catch (_) {} } };
    console.debug = function(...args) { if (shouldLog('debug')) { try { original.debug.apply(console, args); } catch (_) {} } };
    console.trace = function(...args) { if (shouldLog('debug')) { try { original.trace.apply(console, args); } catch (_) {} } };
    console.warn = function(...args) { if (shouldLog('warn')) { try { original.warn.apply(console, args); } catch (_) {} } };
    console.error = function(...args) { try { original.error.apply(console, args); } catch (_) {} };
  } catch (_) {}

  // 初回ロード時のバナー（開発モード時のみ）
  try {
    if (getCurrentLevel() === 'debug') {
      AppLogger.info('Logger', '開発モード: 詳細ログが有効です。必要に応じてカテゴリやレベルを調整してください。');
      AppLogger.info('Logger', 'logレベル変更: window.AppLogger.setLevel("warn"|"info"|"debug")');
    }
  } catch (_) {}
})();

/* =============================================================================
   StudyQuest - Shared JavaScript Utilities
   GAS Compatible utility functions for all HTML files
   ============================================================================= */

// =============================================================================
// ENHANCED ERROR HANDLING FOR ASYNC/AWAIT ISSUES
// =============================================================================

// Global error handling for Google Apps Script compatibility issues
(function() {
  // Enhanced error suppression for GAS-specific issues
  const suppressedErrors = [
    'document.write',
    'Failed to execute \'write\' on \'Document\'',
    'await is only valid in async functions',
    'await is only valid in async functions and the top level bodies of modules',
    'Unexpected token',
    'SyntaxError: Failed to execute \'write\'',
    'SyntaxError: await is only valid',
    'mae_html_user_bin_i18n_mae_html_user',
    'warden_bin_i18n_warden',
    'unrecognized feature',
    'PostCSS plugin',
    'Tailwind CLI',
    'Promise constructor',
    'TypeError: Cannot read properties of undefined'
  ];

  // Override default error handling
  const originalErrorHandler = window.onerror;
  window.onerror = function(message, source, lineno, colno, error) {
    const errorMessage = message ? message.toString() : '';
    const shouldSuppress = suppressedErrors.some(pattern => 
      errorMessage.includes(pattern)
    );
    
    if (shouldSuppress) {
      console.debug('Suppressed GAS internal error:', errorMessage);
      return true; // Prevent default error handling
    }
    
    // Call original handler if not suppressed
    if (originalErrorHandler) {
      return originalErrorHandler.call(this, message, source, lineno, colno, error);
    }
    return false;
  };

  // Enhanced promise rejection handling
  window.addEventListener('unhandledrejection', function(event) {
    const reason = event.reason?.toString() || '';
    const shouldSuppress = suppressedErrors.some(pattern => 
      reason.includes(pattern)
    );
    
    if (shouldSuppress) {
      console.debug('Suppressed internal promise rejection:', reason);
      event.preventDefault();
      return;
    }
    
    console.warn('Unhandled promise rejection:', event.reason);
  });
})();

// =============================================================================
// PERFORMANCE UTILITIES
// =============================================================================

// Debounce function with key-based tracking
class DebounceManager {
  constructor() {
    this.timers = new Map();
  }

  debounce(func, key, delay = 1000) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }
    
    const timeoutId = setTimeout(() => {
      func();
      this.timers.delete(key);
    }, delay);
    
    this.timers.set(key, timeoutId);
  }

  clear(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
  }

  clearAll() {
    this.timers.forEach(timer => {
      clearTimeout(timer);
    });
    this.timers.clear();
  }
}

// Throttle function with key-based tracking
class ThrottleManager {
  constructor() {
    this.timers = new Map();
    this.lastExecution = new Map();
  }

  throttle(func, key, delay = 100) {
    const now = Date.now();
    const lastRun = this.lastExecution.get(key) || 0;

    if (now - lastRun >= delay) {
      func();
      this.lastExecution.set(key, now);
    } else if (!this.timers.has(key)) {
      const timeoutId = setTimeout(() => {
        func();
        this.lastExecution.set(key, Date.now());
        this.timers.delete(key);
      }, delay - (now - lastRun));
      this.timers.set(key, timeoutId);
    }
  }

  clear(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    this.lastExecution.delete(key);
  }

  clearAll() {
    this.timers.forEach(timer => {
      clearTimeout(timer);
    });
    this.timers.clear();
    this.lastExecution.clear();
  }
}

// =============================================================================
// DOM UTILITIES
// =============================================================================

// Enhanced DOM utility functions
class DOMUtilities {
  constructor() {
    this.elementCache = new Map();
  }

  // Safe element creation
  createSafeElement(tag, className, textContent) {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (textContent) element.textContent = textContent;
    return element;
  }

  // Safe element selection with caching
  getCachedElement(id) {
    if (this.elementCache.has(id)) {
      return this.elementCache.get(id);
    }

    const element = document.getElementById(id);
    if (element) {
      this.elementCache.set(id, element);
    } else {
      console.warn('Element not found:', id);
    }
    return element;
  }

  // Batch cache multiple elements
  cacheElements(elementIds) {
    const cached = {};
    elementIds.forEach(id => {
      cached[id] = this.getCachedElement(id);
    });
    return cached;
  }

  // Clear element cache
  clearElementCache(id = null) {
    if (id) {
      this.elementCache.delete(id);
    } else {
      this.elementCache.clear();
    }
  }

  // Safe button state management
  setButtonState(button, isDisabled, text) {
    if (!button) return;
    button.disabled = isDisabled;
    if (text) button.textContent = text;
  }

  // Safe text content setting
  setSafeTextContent(element, text) {
    if (!element) return;
    element.textContent = text || '';
  }

  // Safe class toggling
  toggleClass(element, className, condition) {
    if (!element) return;
    if (condition) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }

  // Safe event listener management
  addSafeEventListener(element, event, handler, options = {}) {
    if (!element) return null;
    element.addEventListener(event, handler, options);
    return handler;
  }

  removeSafeEventListener(element, event, handler) {
    if (!element || !handler) return;
    element.removeEventListener(event, handler);
  }
}

// =============================================================================
// CACHE MANAGEMENT
// =============================================================================

// Enhanced cache manager with TTL and size limits
class EnhancedCache {
  constructor(maxSize = 100, defaultTTL = 300000) { // 5 minutes default
    this.cache = new Map();
    this.timestamps = new Map();
    this.ttls = new Map();
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;
  }

  set(key, value, ttl = null) {
    const now = Date.now();
    const actualTTL = ttl || this.defaultTTL;

    // If cache is full, remove oldest entry
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.removeOldest();
    }

    this.cache.set(key, value);
    this.timestamps.set(key, now);
    this.ttls.set(key, actualTTL);
  }

  get(key) {
    if (!this.cache.has(key)) {
      return null;
    }

    const now = Date.now();
    const timestamp = this.timestamps.get(key);
    const ttl = this.ttls.get(key);

    if (now - timestamp > ttl) {
      this.delete(key);
      return null;
    }

    return this.cache.get(key);
  }

  has(key) {
    return this.get(key) !== null;
  }

  delete(key) {
    this.cache.delete(key);
    this.timestamps.delete(key);
    this.ttls.delete(key);
  }

  clear() {
    this.cache.clear();
    this.timestamps.clear();
    this.ttls.clear();
  }

  removeOldest() {
    let oldestKey = null;
    let oldestTime = Infinity;

    this.timestamps.forEach((timestamp, key) => {
      if (timestamp < oldestTime) {
        oldestTime = timestamp;
        oldestKey = key;
      }
    });

    if (oldestKey) {
      this.delete(oldestKey);
    }
  }

  cleanup() {
    const now = Date.now();
    const expiredKeys = [];

    this.timestamps.forEach((timestamp, key) => {
      const ttl = this.ttls.get(key);
      if (now - timestamp > ttl) {
        expiredKeys.push(key);
      }
    });

    expiredKeys.forEach(key => {
      this.delete(key);
    });
  }

  get size() {
    this.cleanup(); // Clean expired entries before returning size
    return this.cache.size;
  }

  getStats() {
    this.cleanup();
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      defaultTTL: this.defaultTTL
    };
  }
}

// =============================================================================
// ERROR HANDLING UTILITIES
// =============================================================================

class ErrorHandler {
  constructor() {
    this.errors = [];
    this.maxErrors = 50;
  }

  logError(error, context = '') {
    try {
      const errorInfo = {
        message: (error && error.message) ? error.message : (error && error.toString) ? error.toString() : 'Unknown error',
        stack: (error && error.stack) ? error.stack : 'No stack trace available',
        context: context || 'No context provided',
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        errorType: typeof error,
        isObject: typeof error === 'object'
      };

      this.errors.push(errorInfo);

      // Keep only recent errors
      if (this.errors.length > this.maxErrors) {
        this.errors.shift();
      }

      // シンプルなエラーログ
      console.error(`🚨 ${errorInfo.context}: ${errorInfo.message}`);
      
      // Syntax Errorなど重要なエラーのみ自動送信
      if (errorInfo.message.includes('Unexpected token') || 
          errorInfo.message.includes('SyntaxError') ||
          errorInfo.message.includes('is not defined')) {
        this.sendToBackend(errorInfo);
      }
    } catch (loggingError) {
      console.error('Error in error logging:', loggingError);
      console.error('Original error:', error);
    }
  }

  getRecentErrors(count = 10) {
    return this.errors.slice(-count);
  }

  clearErrors() {
    this.errors = [];
  }

  sendToBackend(errorInfo) {
    try {
      if (typeof google !== 'undefined' && google.script?.run) {
        google.script.run.logClientError({
          message: errorInfo.message,
          userId: window.AdminPanel?.currentUserId || 'unknown'
        });
      }
    } catch (e) { /* ignore */ }
  }

  setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      this.logError(event.error, 'Global error handler');
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.logError(event.reason, 'Unhandled promise rejection');
    });
  }
}

// =============================================================================
// LOADING STATE MANAGEMENT
// =============================================================================

class LoadingManager {
  constructor() {
    this.loadingStates = new Map();
  }

  setLoading(key, isLoading, message = '') {
    this.loadingStates.set(key, { isLoading: isLoading, message: message, timestamp: Date.now() });

    // Emit custom event for UI updates
    const event = new CustomEvent('loadingStateChange', {
      detail: { key: key, isLoading: isLoading, message: message }
    });
    document.dispatchEvent(event);
  }

  isLoading(key) {
    const state = this.loadingStates.get(key);
    return state ? state.isLoading : false;
  }

  getLoadingMessage(key) {
    const state = this.loadingStates.get(key);
    return state ? state.message : '';
  }

  clearLoading(key) {
    this.loadingStates.delete(key);
    this.setLoading(key, false);
  }

  clearAllLoading() {
    const keys = Array.from(this.loadingStates.keys());
    keys.forEach(key => {
      this.clearLoading(key);
    });
  }
}

// =============================================================================
// GAS INTEGRATION UTILITIES
// =============================================================================

class GASUtilities {
  constructor() {
    this.callCache = new EnhancedCache(50, 1000); // 1 second cache for API calls
  }

  // Cached GAS function call
  callWithCache(functionName, cacheKey, ttl, ...args) {
    const cached = this.callCache.get(cacheKey);
    if (cached) {
      return Promise.resolve(cached);
    }

    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(result => {
          this.callCache.set(cacheKey, result, ttl);
          resolve(result);
        })
        .withFailureHandler(reject)
        [functionName](...args);
    });
  }

  // Simple GAS function call
  call(functionName, ...args) {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)
        [functionName](...args);
    });
  }

  // GAS function call with loading overlay - 重複リクエスト防止版
  callWithLoading(functionName, message = '処理中...', loadingType = 'overlay', ...args) {
    // Support legacy calls where message is an object with config
    if (typeof message === 'object' && message !== null) {
      const config = message;
      message = config.message || '処理中...';
      loadingType = config.type || loadingType;
    }
    
    // 重複リクエスト防止: 同じ関数が実行中の場合は既存のPromiseを返す
    // ただし、特定の条件下では強制実行を許可
    const requestKey = `${functionName}_${JSON.stringify(args)}`;
    const isForceRequest = (
      window.FORCE_REQUEST_MODE ||  // グローバルフォースモード
      (functionName === 'getInitialData' && args && args[1] === true) ||  // getInitialData(userId, true)
      (functionName === 'getInitialData' && args && args[0] === true) ||  // getInitialData(true) - direct call
      (message && message.includes('bypassCache'))  // バイパスメッセージ
    );
    
    if (this.pendingRequests && this.pendingRequests.has(requestKey) && !isForceRequest) {
      console.log(`🚫 Duplicate request prevented: ${functionName}`);
      return this.pendingRequests.get(requestKey);
    } else if (isForceRequest && this.pendingRequests && this.pendingRequests.has(requestKey)) {
      console.log(`🔄 Force request override: ${functionName}`);
      // 既存のリクエストを削除して新しいリクエストを許可
      this.pendingRequests.delete(requestKey);
    }
    
    // pendingRequestsがない場合は初期化
    if (!this.pendingRequests) {
      this.pendingRequests = new Map();
    }
    
    const promise = new Promise((resolve, reject) => {
      // Use appropriate loading method based on type
      if (loadingType === 'transparent') {
        window.unifiedLoading.showTransparent(message);
      } else {
        window.unifiedLoading.showSimple(message);
      }

      google.script.run
        .withSuccessHandler(result => {
          window.unifiedLoading.hide(); // Hide loading overlay on success
          this.pendingRequests.delete(requestKey); // 完了後にキャッシュから削除
          resolve(result);
        })
        .withFailureHandler(error => {
          window.unifiedLoading.hide(); // Hide loading overlay on failure
          this.pendingRequests.delete(requestKey); // エラー時にもキャッシュから削除
          // Log the error using the shared error handler
          window.sharedUtilities.errors.logError(error, `GAS call failed: ${functionName}`);
          reject(error);
        })
        [functionName](...args);
    });
    
    // 実行中リクエストとしてキャッシュ
    this.pendingRequests.set(requestKey, promise);
    return promise;
  }

  // Check if running in GAS environment
  isGASEnvironment() {
    return typeof google !== 'undefined' &&
           google.script &&
           google.script.run;
  }
}

// =============================================================================
// SECURITY UTILITIES
// =============================================================================

// Security utilities for XSS prevention and data sanitization
class SecurityUtilities {
  // Escape HTML characters to prevent XSS attacks
  escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Sanitize HTML content by removing dangerous tags
  sanitizeHtml(html) {
    if (!html) return '';
    const div = document.createElement('div');
    div.innerHTML = html;
    
    // Remove script tags and other dangerous elements
    const scripts = div.querySelectorAll('script, object, embed, iframe, form');
    scripts.forEach(script => {
      script.remove();
    });
    
    return div.innerHTML;
  }

  // Validate email format
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

// =============================================================================
// MESSAGE DISPLAY UTILITIES
// =============================================================================

/**
 * 統一されたメッセージ表示システム
 * アプリ設定管理のデザインを基準とし、ヘッダーに応じて動的に位置調整
 */
class MessageManager {
  constructor() {
    this.messageContainer = null;
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        this.init();
      });
    } else {
      this.init();
    }
  }

  init() {
    // メッセージコンテナの作成
    if (!document.getElementById('notification-container')) {
      const container = document.createElement('div');
      container.id = 'notification-container';
      container.className = this.getContainerClasses();
      document.body.appendChild(container);
      this.messageContainer = container;
    } else {
      this.messageContainer = document.getElementById('notification-container');
      // 既存コンテナのクラスを更新
      this.messageContainer.className = this.getContainerClasses();
    }
  }

  // ヘッダーの有無に応じて動的に位置を調整
  getContainerClasses() {
    const header = document.querySelector('header, .header, #header, [class*="header"]');
    const adminHeader = document.querySelector('.admin-header, #admin-header');
    
    let topPosition = 'top-4'; // デフォルト位置
    
    if (adminHeader) {
      // 管理パネルヘッダーがある場合 - より下に配置
      topPosition = 'top-28';
    } else if (header) {
      // 一般的なヘッダーがある場合
      const headerHeight = header.offsetHeight;
      if (headerHeight > 60) {
        topPosition = 'top-32';
      } else {
        topPosition = 'top-20';
      }
    }
    
    return `fixed ${topPosition} right-4 z-50 space-y-2 max-w-md min-w-80`;
  }

  show(message, type = 'info', duration = 5000) {
    // コンテナの位置を再チェック（動的対応）
    if (this.messageContainer) {
      this.messageContainer.className = this.getContainerClasses();
    }

    const sanitizedMessage = (message || '').replace(/^[✅❌⚠️ℹ️]\s*/, '');

    const messageEl = document.createElement('div');
    messageEl.className = `notification glass-panel rounded-lg p-4 border shadow-lg flex items-center transition-all duration-300 ease-out transform translate-x-full opacity-0 ${this.getTypeClasses(type)}`;

    messageEl.innerHTML = 
      `<div class="mr-3 text-2xl">${this.getIcon(type)}</div>` +
      `<div class="flex-1 text-sm">${sanitizedMessage}</div>` +
      `<button class="ml-4 text-gray-400 hover:text-white text-xl leading-none" onclick="this.closest('.notification').remove()">✕</button>`;

    this.messageContainer.appendChild(messageEl);

    // アニメーションで表示
    setTimeout(() => {
      messageEl.classList.remove('translate-x-full', 'opacity-0');
      messageEl.classList.add('translate-x-0', 'opacity-100');
    }, 10);

    // 自動削除
    if (duration > 0) {
      setTimeout(() => {
        messageEl.classList.remove('translate-x-0', 'opacity-100');
        messageEl.classList.add('translate-x-full', 'opacity-0');
        messageEl.addEventListener('transitionend', () => {
          messageEl.remove();
        });
      }, duration);
    }

    return messageEl;
  }

  getTypeClasses(type) {
    const classes = {
      success: 'bg-green-600/20 border-green-500/50 text-green-100',
      error: 'bg-red-600/20 border-red-500/50 text-red-100',
      warning: 'bg-yellow-600/20 border-yellow-500/50 text-yellow-100',
      info: 'bg-blue-600/20 border-blue-500/50 text-blue-100'
    };
    return classes[type] || classes.info;
  }

  getIcon(type) {
    const icons = {
      success: '✅',
      error: '❌',
      warning: '⚠️',
      info: 'ℹ️'
    };
    return icons[type] || icons.info;
  }
}

// =============================================================================
// INITIALIZATION AND GLOBAL SETUP
// =============================================================================

// Initialize global utilities
window.sharedUtilities = {
  debounce: new DebounceManager(),
  throttle: new ThrottleManager(),
  dom: new DOMUtilities(),
  cache: new EnhancedCache(),
  errors: new ErrorHandler(),
  loading: new LoadingManager(),
  gas: new GASUtilities(),
  security: new SecurityUtilities(),
  messages: new MessageManager()
};

// Setup global error handling
window.sharedUtilities.errors.setupGlobalErrorHandling();

// Helper functions for backward compatibility
window.debounce = (func, delay, key = 'default') => {
  window.sharedUtilities.debounce.debounce(func, key, delay);
};

window.throttle = (func, delay, key = 'default') => {
  window.sharedUtilities.throttle.throttle(func, key, delay);
};

// Global DOM utility functions for backward compatibility
window.getCachedElement = (id) => {
  return window.sharedUtilities.dom.getCachedElement(id);
};

// Global cache instance for backward compatibility
if (!window.UnifiedCache) {
  window.UnifiedCache = EnhancedCache;
}

// DOM ready utility
window.onDOMReady = function(callback) {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', callback);
  } else {
    callback();
  }
};

// Debug function for console access
window.getSharedUtilitiesStats = function() {
  return {
    debounceTimers: window.sharedUtilities.debounce.timers.size,
    throttleTimers: window.sharedUtilities.throttle.timers.size,
    cacheSize: window.sharedUtilities.cache.size,
    cacheStats: window.sharedUtilities.cache.getStats(),
    domCacheSize: window.sharedUtilities.dom.elementCache.size,
    recentErrors: window.sharedUtilities.errors.getRecentErrors(5),
    loadingStates: Object.fromEntries(window.sharedUtilities.loading.loadingStates),
    gasEnvironment: window.sharedUtilities.gas.isGASEnvironment()
  };
};

// Performance monitoring
window.clearAllSharedUtilities = function() {
  window.sharedUtilities.debounce.clearAll();
  window.sharedUtilities.throttle.clearAll();
  window.sharedUtilities.cache.clear();
  window.sharedUtilities.dom.clearElementCache();
  window.sharedUtilities.errors.clearErrors();
  window.sharedUtilities.loading.clearAllLoading();
  console.log('🧹 All SharedUtilities cleared');
};

// Integration test function
window.testSharedUtilities = function() {
  console.group('🧪 SharedUtilities Integration Test');

  // Test debounce
  let debounceCount = 0;
  const testDebounce = () => debounceCount++;
  window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);
  window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);

  setTimeout(() => {
    console.log('Debounce test:', debounceCount === 1 ? '✅ PASS' : '❌ FAIL');
  }, 150);

  // Test cache
  window.sharedUtilities.cache.set('test', 'value', 1000);
  const cached = window.sharedUtilities.cache.get('test');
  console.log('Cache test:', cached === 'value' ? '✅ PASS' : '❌ FAIL');

  // Test DOM utilities
  const testEl = window.sharedUtilities.dom.createSafeElement('div', 'test-class', 'test');
  console.log('DOM creation test:', testEl.className === 'test-class' ? '✅ PASS' : '❌ FAIL');

  // Test error handling
  window.sharedUtilities.errors.logError(new Error('Test error'), 'Integration test');
  const errors = window.sharedUtilities.errors.getRecentErrors(1);
  console.log('Error handling test:', errors.length > 0 ? '✅ PASS' : '❌ FAIL');

  console.groupEnd();
  return window.getSharedUtilitiesStats();
};

// =============================================================================
// AUTHENTICATION UTILITIES
// =============================================================================

// Shared authentication functions for consistent behavior across pages
window.sharedUtilities.auth = {
  // Account switching functionality shared across pages
  switchToAnotherAccount: function() {
    if (confirm('別のGoogleアカウントでログインしますか？現在のセッションからログアウトされ、アカウント選択画面が表示されます。')) {
      try {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              const url = new URL(window.location.href);
              url.searchParams.set('force_account_selection', 'true');
              window.location.replace(url.toString());
            } else {
              window.sharedUtilities.auth.showAccountSwitchFallback();
            }
          })
          .withFailureHandler(function(error) {
            console.warn('認証リセットエラー:', error);
            window.sharedUtilities.auth.showAccountSwitchFallback();
          })
          .resetUserAuthentication();
      } catch (error) {
        console.warn('アカウント切り替えエラー:', error);
        window.sharedUtilities.auth.showAccountSwitchFallback();
      }
    }
  },

  // Fallback guidance when automatic switch fails
  showAccountSwitchFallback: function() {
    const msg = `
        アカウントを切り替えるには以下の手順をお試しください：

        1. 新しいブラウザタブでGoogle（google.com）にアクセス
        2. 右上のプロフィール画像をクリック
        3. 「別のアカウントを追加」または使用したいアカウントを選択
        4. このページに戻って再度認証を開始

        または、ブラウザのシークレット/プライベートモードで新しいタブを開いてこのページにアクセスしてください。
      `;
    alert(msg);
  },

  // Authentication verification with promise
  verifyAuthentication: function() {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('認証確認がタイムアウトしました'));
      }, 10000);

      google.script.run
        .withSuccessHandler(result => {
          clearTimeout(timeoutId);
          if (result && result.authenticated && result.email) {
            resolve(result);
          } else {
            reject(new Error('認証が必要です'));
          }
        })
        .withFailureHandler(error => {
          clearTimeout(timeoutId);
          reject(error);
        })
        .verifyUserAuthentication();
    });
  },

  // Display authentication info in standardized format
  displayAuthInfo: function(containerId, email, showSwitchOption = true) {
    const container = document.getElementById(containerId);
    if (!container) return;

    // Safely escape email with fallback
    const safeEmail = window.sharedUtilities && window.sharedUtilities.security 
      ? window.sharedUtilities.security.escapeHtml(email) 
      : (email || '').replace(/[<>&"']/g, function(match) {
          switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return match;
          }
        });

    container.innerHTML = `
      <div class="bg-gray-800 rounded-lg p-4 mb-4">
        <p class="text-sm text-gray-400 mb-1">認証済みアカウント:</p>
        <p class="text-white font-semibold">${safeEmail}</p>
      </div>
      ${showSwitchOption ? `
      <div class="text-right">
        <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
          別のアカウントでログイン
        </button>
      </div>` : ''}
    `;
  }
};

// Global function for backward compatibility
window.switchToAnotherAccount = function() {
  window.sharedUtilities.auth.switchToAnotherAccount();
};

// Global message function for unified message display
window.showMessage = function(message, type = 'info', duration = 5000) {
  return window.sharedUtilities.messages.show(message, type, duration);
};

// =============================================================================
// CONFIRMATION MODAL HELPER
// =============================================================================

// Unified confirmation modal function.
// Falls back to window.confirm() if the modal DOM is unavailable.
window.showConfirmationModal = function(title, message, onConfirm, onCancel, options = {}) {
  try {
    const modal = document.getElementById('confirmation-modal');
    const hasModal = !!modal;

    if (!hasModal) {
      // Fallback to native confirm
      const ok = window.confirm((title ? title + '\n\n' : '') + (message || 'この操作を実行しますか？'));
      if (ok) { if (typeof onConfirm === 'function') onConfirm(); }
      else { if (typeof onCancel === 'function') onCancel(); }
      return;
    }

    const titleEl = modal.querySelector('#modal-title');
    const msgEl = modal.querySelector('#modal-message');
    const cancelBtn = modal.querySelector('#modal-cancel-btn');
    const confirmBtn = modal.querySelector('#modal-confirm-btn');

    if (titleEl) titleEl.textContent = title || '確認';
    if (msgEl) msgEl.textContent = message || '';

    // Show modal
    modal.classList.remove('hidden');

    // Focus management
    const defaultAction = options.defaultAction === 'confirm' ? 'confirm' : 'cancel';
    setTimeout(() => {
      try {
        (defaultAction === 'confirm' ? confirmBtn : cancelBtn)?.focus();
      } catch (_) {}
    }, 0);

    // Cleanup helper
    const cleanup = () => {
      try {
        modal.classList.add('hidden');
        document.removeEventListener('keydown', onKeydown);
        cancelBtn?.removeEventListener('click', onCancelClick);
        confirmBtn?.removeEventListener('click', onConfirmClick);
      } catch (e) {
        console.warn('Confirmation modal cleanup error:', e);
      }
      // Restore focus if provided
      if (options.restoreFocus && typeof options.restoreFocus.focus === 'function') {
        try { options.restoreFocus.focus(); } catch (_) {}
      }
    };

    const onCancelClick = () => {
      cleanup();
      if (typeof onCancel === 'function') onCancel();
    };

    const onConfirmClick = () => {
      cleanup();
      if (typeof onConfirm === 'function') onConfirm();
    };

    const onKeydown = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        onCancelClick();
      }
    };

    // Wire listeners (once per show)
    cancelBtn?.addEventListener('click', onCancelClick, { once: true });
    confirmBtn?.addEventListener('click', onConfirmClick, { once: true });
    document.addEventListener('keydown', onKeydown, { once: true });

  } catch (e) {
    console.warn('showConfirmationModal error:', e);
    const ok = window.confirm((title ? title + '\n\n' : '') + (message || 'この操作を実行しますか？'));
    if (ok) { if (typeof onConfirm === 'function') onConfirm(); }
    else { if (typeof onCancel === 'function') onCancel(); }
  }
};

// =============================================================================
// UNIFIED LOADING MANAGER - Centralized loading overlay management
// =============================================================================

class UnifiedLoadingManager {
  constructor() {
    this.currentState = null;
    this.overlay = null;
    this.initialized = false;
    this.variantClasses = ['transparent', 'modal', 'progress', 'quickstart', 'page-specific'];
  }

  // Initialize the loading manager with enhanced error handling and DOM monitoring.
  init(retries = 5, delay = 100, onSuccess = null) {
    if (this.initialized) {
      console.log('UnifiedLoadingManager: Already initialized.');
      if (onSuccess) onSuccess();
      return true;
    }

    // Enhanced DOM readiness check
    if (document.readyState === 'loading') {
      console.log('UnifiedLoadingManager: DOM still loading, waiting for DOMContentLoaded...');
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
          this.init(retries, delay, onSuccess);
        }, 50);
      }, { once: true });
      return false;
    }

    this.overlay = document.getElementById('loading-overlay');
    if (this.overlay) {
      if (!window.unifiedLoadingInitialized) {
        window.unifiedLoadingInitialized = true;
        console.log('✅ UnifiedLoadingManager: Initialized successfully with element:', this.overlay.className);
      }
      this.initialized = true;
      if (onSuccess) onSuccess();
      return true;
    }

    // Enhanced retry logic with DOM mutation observation
    if (retries > 0) {
      console.warn(`⚠️ UnifiedLoadingManager: loading-overlay element not found. DOM state: ${document.readyState}. Retrying in ${delay}ms (${retries} retries left)...`);
      
      // Try to observe DOM changes for the loading-overlay element
      if (retries === 5) { // Only set up observer on first try
        this.setupDOMObserver(onSuccess);
      }
      
      setTimeout(() => {
        this.init(retries - 1, delay * 1.5, onSuccess);
      }, delay); // Exponential backoff
    } else {
      console.error('❌ UnifiedLoadingManager: Critical failure - loading-overlay element not found after multiple retries.');
      console.error('❌ UnifiedLoadingManager: Current DOM structure check:');
      console.error('  - Document ready state:', document.readyState);
      console.error('  - Body exists:', !!document.body);
      console.error('  - Available IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id).join(', '));
      
      // Create fallback overlay as last resort
      this.createFallbackOverlay();
    }
    return false;
  }

  // Setup DOM observer to watch for the loading-overlay element
  setupDOMObserver(onSuccess) {
    if (typeof MutationObserver === 'undefined') return;
    
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          for (const node of mutation.addedNodes) {
            if (node.nodeType === 1 && (node.id === 'loading-overlay' || node.querySelector('#loading-overlay'))) {
              console.log('✅ UnifiedLoadingManager: loading-overlay detected via DOM observer');
              observer.disconnect();
              setTimeout(() => {
                this.init(1, 50, onSuccess);
              }, 10); // Quick retry
              return;
            }
          }
        }
      }
    });
    
    observer.observe(document.body || document.documentElement, {
      childList: true,
      subtree: true
    });
    
    // Disconnect observer after 10 seconds to prevent memory leaks
    setTimeout(() => {
      observer.disconnect();
    }, 10000);
  }

  // Create a fallback overlay if none exists
  createFallbackOverlay() {
    if (document.getElementById('loading-overlay')) return;
    
    console.warn('⚠️ UnifiedLoadingManager: Creating fallback loading-overlay element');
    const fallbackOverlay = document.createElement('div');
    fallbackOverlay.id = 'loading-overlay';
    fallbackOverlay.className = 'loading-overlay page-specific hidden';
    
    // Insert at the beginning of body
    if (document.body) {
      document.body.insertBefore(fallbackOverlay, document.body.firstChild);
      this.overlay = fallbackOverlay;
      this.initialized = true;
      console.log('✅ UnifiedLoadingManager: Fallback overlay created and initialized');
      return true;
    }
    
    return false;
  }

  // Main loading function with a unified API and enhanced error handling.
  setLoading(isLoading, options = {}) {
    if (!this.initialized) {
      console.warn('UnifiedLoadingManager: Not initialized, attempting initialization...');
      if (!this.init()) {
        console.error('UnifiedLoadingManager: Cannot manage loading state - initialization failed.');
        return;
      }
    }

    try {
      if (isLoading) {
        this.show(options);
      } else {
        this.hide();
      }
    } catch (error) {
      console.error('UnifiedLoadingManager: Error during loading state change:', error);
    }
  }

  // Show loading overlay with options.
  show(options = {}) {
    const config = {
      message: options.message || '処理中...',
      type: options.type || 'overlay',
      progress: options.progress || null,
      steps: options.steps || null,
      disableInteraction: options.disableInteraction !== false,
      ...options
    };

    this.currentState = config;
    
    // Clean up previous variant classes
    this.variantClasses.forEach(vc => {
      this.overlay.classList.remove(vc);
    });
    
    // Add the new variant class if it's not the default overlay
    if (config.type !== 'overlay') {
      this.overlay.classList.add(config.type);
    }
    
    // Update content and show the overlay with enhanced visibility enforcement
    this.updateContent(config);
    this.overlay.classList.remove('hidden');
    // Force display override with highest specificity
    this.overlay.style.setProperty('display', 'flex', 'important');
    this.overlay.style.setProperty('visibility', 'visible', 'important');
    this.overlay.style.setProperty('opacity', '1', 'important');
    
    // Manage user interaction
    if (config.disableInteraction && config.type !== 'transparent') {
      document.body.style.overflow = 'hidden';
      document.body.style.pointerEvents = 'none';
      this.overlay.style.pointerEvents = 'auto';
    } else {
      // Allow interaction for transparent overlays or when not disabled
      this.overlay.style.pointerEvents = 'none';
    }
  }

  // Hide loading overlay.
  hide() {
    if (!this.overlay) return;
    
    this.overlay.classList.add('hidden');
    this.overlay.style.display = 'none'; // 明示的にdisplayをnoneに設定
    this.overlay.style.visibility = 'hidden'; // 明示的にvisibilityをhiddenに設定
    
    // Restore interaction
    document.body.style.overflow = '';
    document.body.style.pointerEvents = '';
    
    this.currentState = null;
  }

  // Update loading content based on configuration.
  updateContent(config) {
    let content = '<div class="loading-content">';
    
    if (config.message) {
      content += `<div class="loading-message">${this.escapeHtml(config.message)}</div>`;
    }
    
    if (config.type === 'overlay' || config.type === 'modal') {
      content += '<div class="loading-spinner"></div>';
    }
    
    if (config.progress !== null) {
      const progressValue = typeof config.progress === 'object' 
        ? Math.round((config.progress.current / config.progress.total) * 100)
        : config.progress;
      content += 
        `<div class="loading-progress">` +
          `<div class="loading-progress-bar"><div class="loading-progress-fill" style="width: ${progressValue}%"></div></div>` +
          `<div class="loading-percentage">${progressValue}%</div>` +
        `</div>`;
    }
    
    if (config.steps && Array.isArray(config.steps)) {
      content += '<div class="loading-steps">';
      config.steps.forEach(step => {
        const stepClass = step.status === 'completed' ? 'completed' : (step.status === 'active' ? 'active' : '');
        content += `<div class="loading-step ${stepClass}"><div class="loading-step-dot"></div><div class="loading-step-text">${this.escapeHtml(step.text)}</div></div>`;
      });
      content += '</div>';
    }
    
    content += '</div>';
    this.overlay.innerHTML = content;
  }

  // Simple HTML escaping.
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Convenience methods for common use cases.
  showSimple(message = '処理中...') {
    this.setLoading(true, { message: message, type: 'overlay' });
  }

  showProgress(message = '処理中...', progress = 0) {
    this.setLoading(true, { message: message, type: 'progress', progress: progress });
  }

  showTransparent(message = '処理中...') {
    this.setLoading(true, { message: message, type: 'transparent' });
  }

  showQuickStart(message = 'セットアップ中...') {
    this.setLoading(true, { message: message, type: 'quickstart' });
  }

  showAdminProgress(message, step = 0, percentage = 0) {
    const options = { message: message, type: 'progress', progress: percentage, disableInteraction: true };
    if (step > 0) {
      options.steps = [
        { text: 'システム情報を読み込み中...', status: step > 1 ? 'completed' : step === 1 ? 'active' : 'pending' },
        { text: 'ユーザー情報を取得中...', status: step > 2 ? 'completed' : step === 2 ? 'active' : 'pending' },
        { text: 'シート情報と設定を適用中...', status: step > 3 ? 'completed' : step === 3 ? 'active' : 'pending' },
        { text: 'UIを最終調整中...', status: step > 4 ? 'completed' : step === 4 ? 'active' : 'pending' }
      ];
    }
    this.setLoading(true, options);
  }
}

// Create and initialize the global instance once the DOM is ready.
window.unifiedLoading = new UnifiedLoadingManager();
document.addEventListener('DOMContentLoaded', () => {
  window.unifiedLoading.init();
});

// Backward compatibility wrapper for the global setLoading function.
window.setLoading = function(isLoading, message, step, percentage) {
  if (!isLoading) {
    window.unifiedLoading.setLoading(false);
    return;
  }

  if (typeof message === 'object') {
    window.unifiedLoading.setLoading(true, message);
  } else if (typeof step === 'number' && step > 0) {
    window.unifiedLoading.showAdminProgress(message, step, percentage);
  } else {
    window.unifiedLoading.showSimple(message || '処理中...');
  }
};



// =============================================================================
// TIMING MANAGER INTEGRATION - TimingManagerへの段階的移行
// =============================================================================

// レガシー互換性のためのラッパー関数
window.sharedUtilities = window.sharedUtilities || {};
window.sharedUtilities.debounce = new DebounceManager();
window.sharedUtilities.throttle = new ThrottleManager();

// =============================================================================
// TimingManager 定義
// =============================================================================

// TimingManager は adminPanel-api.js.html で定義されています

// TimingManager統合の遅延実行化（読み込み順序問題の解決）
function initializeTimingManagerIntegration() {
  if (typeof TimingManager !== 'undefined') {
    // 新しいTimingManager機能を既存のインターフェースにマップ
    window.sharedUtilities.debounce.debounceAdvanced = TimingManager.debounce;
    window.sharedUtilities.throttle.throttleAdvanced = TimingManager.throttle;
    
    // 段階的移行用のヘルパー
    window.sharedUtilities.timing = {
      delay: TimingManager.delay,
      sequence: TimingManager.sequence,
      parallel: TimingManager.parallel,
      progressSequence: TimingManager.progressSequence,
      clearTiming: TimingManager.clearTiming,
      clearAllTiming: TimingManager.clearAllTiming
    };

    console.log('🔄 TimingManager integration enabled - Advanced timing features available');
    return true;
  } else {
    return false;
  }
}

// 即座に試行
if (!initializeTimingManagerIntegration()) {
  // DOMContentLoaded後に再試行
  document.addEventListener('DOMContentLoaded', function() {
    if (!initializeTimingManagerIntegration()) {
      // さらに遅延して最終試行
      setTimeout(function() {
        initializeTimingManagerIntegration();
      }, 100);
    }
  });
}

// =============================================================================
// GOOGLE APPS SCRIPT ENVIRONMENT WARNING SUPPRESSION
// =============================================================================

// Suppress iframe and sandbox-related warnings specific to Google Apps Script
(function() {
  const isGoogleAppsScript = window.location.hostname.includes('script.google.com') ||
                           window.location.href.includes('script.googleusercontent.com') ||
                           typeof google !== 'undefined' && google.script;

  if (isGoogleAppsScript) {
    const originalConsoleWarn = console.warn;
    console.warn = function(...args) {
      const message = args.join(' ').toLowerCase();
      
      // Suppress common iframe/sandbox warnings in GAS environment
      const suppressPatterns = [
        'iframe',
        'sandbox',
        'x-frame-options',
        'frame-ancestors', 
        'refused to frame',
        'same-origin policy',
        'cross-origin frame access',
        'document.domain',
        'postmessage',
        'unrecognized feature',
        'Unrecognized feature',
        'allow-scripts',
        'allow-same-origin',
        'feature',
        'permission'
      ];
      
      const shouldSuppress = suppressPatterns.some(pattern => 
        message.includes(pattern)
      );
      
      if (!shouldSuppress) {
        originalConsoleWarn.apply(console, args);
      }
    };

    // Suppress common iframe-related errors
    const originalConsoleError = console.error;
    console.error = function(...args) {
      const message = args.join(' ').toLowerCase();
      
      if (message.includes('iframe') && 
          (message.includes('refused to frame') || 
           message.includes('x-frame-options') ||
           message.includes('frame-ancestors'))) {
        return;
      }
      
      originalConsoleError.apply(console, args);
    };

    // Handle iframe-related window errors silently
    window.addEventListener('error', function(event) {
      if (event.message && typeof event.message === 'string') {
        const message = event.message.toLowerCase();
        if ((message.includes('iframe') || message.includes('frame')) &&
            (message.includes('denied') || message.includes('blocked'))) {
          event.preventDefault();
          return false;
        }
      }
    }, true);
  }
})();

// =============================================================================
// JSON UTILITIES
// =============================================================================

/**
 * userInfo.configJson を安全にパースします。
 * 無効な文字列や空文字列の場合は空オブジェクトを返します。
 * @param {string|Object|null|undefined} configJson JSON文字列またはオブジェクト
 * @returns {Object} パース結果のオブジェクト。失敗時は空オブジェクト
 */
function parseUserConfig(configJson) {
  if (!configJson) return {};
  if (typeof configJson === 'object') return configJson;
  try {
    return JSON.parse(configJson);
  } catch (error) {
    if (typeof AppLogger !== 'undefined') {
      AppLogger.warn('parseUserConfig', 'Invalid configJson detected', error);
    } else {
      console.warn('parseUserConfig: invalid configJson', error);
    }
    return {};
  }
}

// =============================================================================
// 共通ユーティリティ関数（重複排除）
// =============================================================================

/**
 * HTMLエスケープ（全システム共通）
 * @param {string} text エスケープするテキスト
 * @returns {string} エスケープされたテキスト
 */
if (typeof window.escapeHtml === 'undefined') {
  window.escapeHtml = function(text) {
    if (!text) return '';
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  };
}

/**
 * 日付フォーマット（全システム共通）
 * @param {Date|string} date 日付
 * @param {Object} options オプション
 * @returns {string} フォーマットされた日付
 */
if (typeof window.formatDate === 'undefined') {
  window.formatDate = function(date, options = {}) {
    try {
      const d = new Date(date);
      const defaultOptions = {
        year: 'numeric',
        month: 'short', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      return d.toLocaleDateString('ja-JP', { ...defaultOptions, ...options });
    } catch (error) {
      if (typeof logWarn === 'function') {
        logWarn('日付フォーマットエラー:', error);
      } else {
        console.warn('日付フォーマットエラー:', error);
      }
      return '';
    }
  };
}

/**
 * メッセージ表示（全システム共通）
 * @param {string} message メッセージ
 * @param {string} type タイプ ('success'|'error'|'info'|'warning')
 * @param {number} duration 表示時間（ミリ秒）
 */
if (typeof window.showMessage === 'undefined') {
  window.showMessage = function(message, type = 'info', duration = 3000) {
    try {
      // 既存のメッセージエリアを探す
      let messageArea = document.getElementById('message-area') || 
                       document.getElementById('messageArea') ||
                       document.querySelector('.message-area');

      if (!messageArea) {
        // メッセージエリアが存在しない場合は作成
        messageArea = document.createElement('div');
        messageArea.id = 'message-area';
        messageArea.className = 'fixed top-4 right-4 z-50 max-w-sm';
        document.body.appendChild(messageArea);
      }

      // メッセージ要素を作成
      const messageEl = document.createElement('div');
      const baseClasses = 'p-4 mb-2 rounded-lg shadow-lg transition-all duration-300 transform';
      const typeClasses = {
        success: 'bg-green-100 border-green-500 text-green-700',
        error: 'bg-red-100 border-red-500 text-red-700',
        warning: 'bg-yellow-100 border-yellow-500 text-yellow-700',
        info: 'bg-blue-100 border-blue-500 text-blue-700'
      };
      
      messageEl.className = `${baseClasses} ${typeClasses[type] || typeClasses.info}`;
      messageEl.textContent = message;

      // アニメーション付きで表示
      messageEl.style.opacity = '0';
      messageEl.style.transform = 'translateX(100%)';
      messageArea.appendChild(messageEl);

      // フェードイン
      setTimeout(() => {
        messageEl.style.opacity = '1';
        messageEl.style.transform = 'translateX(0)';
      }, 10);

      // 自動削除
      setTimeout(() => {
        messageEl.style.opacity = '0';
        messageEl.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (messageEl.parentNode) {
            messageEl.parentNode.removeChild(messageEl);
          }
        }, 300);
      }, duration);

    } catch (error) {
      if (typeof logWarn === 'function') {
        logWarn('メッセージ表示エラー:', error);
      } else {
        console.warn('メッセージ表示エラー:', error);
      }
      // フォールバック
      alert(`${type.toUpperCase()}: ${message}`);
    }
  };
}

/**
 * 非同期待機関数
 * @param {number} ms 待機時間（ミリ秒）
 * @returns {Promise}
 */
if (typeof window.sleep === 'undefined') {
  window.sleep = function(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  };
}

/**
 * オブジェクトのディープコピー
 * @param {*} obj コピー対象
 * @returns {*} コピー結果
 */
if (typeof window.deepCopy === 'undefined') {
  window.deepCopy = function(obj) {
    try {
      return JSON.parse(JSON.stringify(obj));
    } catch (error) {
      if (typeof logWarn === 'function') {
        logWarn('ディープコピーエラー:', error);
      } else {
        console.warn('ディープコピーエラー:', error);
      }
      return obj;
    }
  };
}

// Prevent duplicate loading messages
if (!window.sharedUtilitiesLoaded) {
  window.sharedUtilitiesLoaded = true;
  console.log('✅ SharedUtilities with common functions loaded');
}
</script>
