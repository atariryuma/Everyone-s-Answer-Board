<script>
  /* =============================================================================
     StudyQuest - Shared JavaScript Utilities
     GAS Compatible utility functions for all HTML files
     ============================================================================= */

  // =============================================================================
  // ENHANCED ERROR HANDLING FOR ASYNC/AWAIT ISSUES
  // =============================================================================

  // Global error handling for Google Apps Script compatibility issues
  (function () {
    // Simplified error suppression - safe for GAS template processing
    const suppressedErrors = [
      'cdn.tailwindcss.com should not be used in production',
      'cdnjs.cloudflare.com',
      'tailwind',
      'TailwindCSS',
      'iframe which has both allow-scripts and allow-same-origin',
      'can escape its sandboxing',
      // ✅ ブラウザサンドボックス警告抑制
      'An iframe which has both allow-scripts and allow-same-origin',
    ];

    // Syntax errors that need special logging (not suppressed)
    const criticalSyntaxErrors = [
      'Unexpected end of input',
      'Unexpected token',
      'SyntaxError: Unexpected',
      'Invalid or unexpected token',
    ];

    // Simplified and safe error handling for GAS template processing
    const originalErrorHandler = window.onerror;
    window.onerror = function (message, source, lineno, colno, error) {
      const errorMessage = message ? message.toString() : '';

      // Only suppress specific known warnings that interfere with GAS
      const shouldSuppress = suppressedErrors.some((pattern) => errorMessage.includes(pattern));

      if (shouldSuppress) {
        return true; // Suppress known warnings
      }

      // ✅ CLAUDE.md準拠: 重要なエラーはユーザーにも通知
      const isCritical = criticalSyntaxErrors.some((pattern) => errorMessage.includes(pattern));
      if (isCritical && window.notifications) {
        window.notifications.error('ページでエラーが発生しました。再読み込みをお試しください。', 8000);
      }

      // Let all other errors (including syntax errors) pass through to original handler
      if (originalErrorHandler) {
        return originalErrorHandler.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    // Console.warn suppression for Permissions Policy warnings
    const originalWarn = console.warn;
    console.warn = function (...args) {
      const message = args.join(' ');
      const shouldSuppress = suppressedErrors.some((pattern) => message.includes(pattern));

      if (shouldSuppress) {
        return; // Suppress known warnings
      }

      originalWarn.apply(console, args);
    };

    // Enhanced promise rejection handling
    window.addEventListener('unhandledrejection', function (event) {
      const reason = event.reason?.toString() || '';
      const shouldSuppress = suppressedErrors.some((pattern) => reason.includes(pattern));

      if (shouldSuppress) {
        console.debug('Suppressed internal promise rejection:', reason);
        event.preventDefault();
        return;
      }

      // ✅ CLAUDE.md準拠: 重要なPromise rejectionはユーザーにも通知
      const isUserImpacting = reason.includes('Failed to fetch') ||
                              reason.includes('Network request failed') ||
                              reason.includes('google.script.run') ||
                              reason.includes('timeout');

      if (isUserImpacting && window.notifications) {
        window.notifications.warning('通信エラーが発生しました。しばらく待ってから再試行してください。', 6000);
      }

      console.warn('Unhandled promise rejection:', event.reason);
    });

    // Script loading monitoring to detect problematic scripts
    const originalCreateElement = document.createElement;
    document.createElement = function (tagName) {
      const element = originalCreateElement.call(this, tagName);

      if (tagName.toLowerCase() === 'script') {
        const originalSrc = element.src;
        Object.defineProperty(element, 'src', {
          get() {
            return originalSrc;
          },
          set(value) {
            console.log('🔍 Script loading:', value);

            // Monitor specific scripts that might cause syntax errors
            if (value.includes('tailwindcss') || value.includes('cdn.')) {
              element.addEventListener('load', () => {
                console.log('✅ External script loaded successfully:', value);
              });

              element.addEventListener('error', (e) => {
                console.error('❌ External script failed to load:', value, e);
              });
            }

            originalSrc = value;
          },
        });
      }

      return element;
    };
  })();

  // =============================================================================
  // SAFE RESPONSE PROCESSING - Fix response.trim() errors
  // =============================================================================

  /**
   * 安全なレスポンス処理 - response.trim()エラーを防ぐ
   * @param {any} response - サーバーからのレスポンス
   * @returns {string} 安全な文字列レスポンス
   */
  window.safeResponseTrim = function(response) {
    if (response === null || response === undefined) {
      return '';
    }

    // 既に文字列の場合
    if (typeof response === 'string') {
      return response.trim();
    }

    // オブジェクトの場合はJSON文字列化
    if (typeof response === 'object') {
      try {
        return JSON.stringify(response).trim();
      } catch (error) {
        console.warn('safeResponseTrim: JSON stringify failed', error);
        return String(response).trim();
      }
    }

    // その他の型は文字列変換
    return String(response).trim();
  };

  /**
   * 安全なGoogle Apps Scriptレスポンス処理
   * @param {any} response - GASからのレスポンス
   * @returns {Object} パースされたレスポンスオブジェクト
   */
  window.safeParseGASResponse = function(response) {
    try {
      // レスポンスが既にオブジェクトの場合
      if (typeof response === 'object' && response !== null) {
        return response;
      }

      // 文字列の場合はJSONパース
      if (typeof response === 'string') {
        const trimmed = response.trim();
        if (trimmed === '') {
          return { success: false, message: '空のレスポンス' };
        }
        return JSON.parse(trimmed);
      }

      return { success: false, message: '不正なレスポンス形式', raw: response };
    } catch (error) {
      console.warn('safeParseGASResponse: Parse failed', error, response);
      return {
        success: false,
        message: 'レスポンス解析エラー',
        error: error.message,
        raw: response
      };
    }
  };

  // =============================================================================
  // PERFORMANCE UTILITIES
  // =============================================================================

  // Debounce function with key-based tracking
  class DebounceManager {
    constructor() {
      this.timers = new Map();
    }

    debounce(func, key, delay = 1000) {
      // Cancel existing debounce for this key
      if (this.timers.has(key)) {
        this.timers.delete(key);
      }

      // CLAUDE.md V8 compliant: Pure Promise-based delay
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      const debouncePromise = createPromiseDelay(delay).then(() => {
        if (this.timers.get(key) === debouncePromise) {
          func();
          this.timers.delete(key);
        }
      }).catch(() => {
        // Silent cleanup on cancellation
        this.timers.delete(key);
      });

      this.timers.set(key, debouncePromise);
    }

    clear(key) {
      // V8 compliant: Promise cancellation by removal
      this.timers.delete(key);
    }

    clearAll() {
      // V8 compliant: Clear all tracked promises
      this.timers.clear();
    }
  }

  // Throttle function with key-based tracking
  class ThrottleManager {
    constructor() {
      this.timers = new Map();
      this.lastExecution = new Map();
    }

    throttle(func, key, delay = 100) {
      const now = Date.now();
      const lastRun = this.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func();
        this.lastExecution.set(key, now);
      } else if (!this.timers.has(key)) {
        // CLAUDE.md V8 compliant: Promise-based delay for throttle
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        const delayTime = delay - (now - lastRun);
        const throttlePromise = createPromiseDelay(delayTime).then(() => {
          if (this.timers.get(key) === throttlePromise) {
            func();
            this.lastExecution.set(key, Date.now());
            this.timers.delete(key);
          }
        }).catch(() => {
          // Silent cleanup on cancellation
          this.timers.delete(key);
        });

        this.timers.set(key, throttlePromise);
      }
    }

    clear(key) {
      // V8 compliant: Promise cancellation by removal
      this.timers.delete(key);
      this.lastExecution.delete(key);
    }

    clearAll() {
      // V8 compliant: Clear all tracked promises and execution times
      this.timers.clear();
      this.lastExecution.clear();
    }
  }

  // =============================================================================
  // DOM UTILITIES
  // =============================================================================

  // Enhanced DOM utility functions
  class DOMUtilities {
    constructor() {
      this.elementCache = new Map();
    }

    // Safe element creation
    createSafeElement(tag, className, textContent) {
      const element = document.createElement(tag);
      if (className) element.className = className;
      if (textContent) element.textContent = textContent;
      return element;
    }

    // Safe element selection with caching
    getCachedElement(id) {
      if (this.elementCache.has(id)) {
        return this.elementCache.get(id);
      }

      const element = document.getElementById(id);
      if (element) {
        this.elementCache.set(id, element);
      } else {
        console.warn('Element not found:', id);
      }
      return element;
    }

    // Batch cache multiple elements
    cacheElements(elementIds) {
      const cached = {};
      elementIds.forEach((id) => {
        cached[id] = this.getCachedElement(id);
      });
      return cached;
    }

    // Clear element cache
    clearElementCache(id = null) {
      if (id) {
        this.elementCache.delete(id);
      } else {
        this.elementCache.clear();
      }
    }

    // Safe button state management
    setButtonState(button, isDisabled, text) {
      if (!button) return;
      button.disabled = isDisabled;
      if (text) button.textContent = text;
    }

    // Safe text content setting
    setSafeTextContent(element, text) {
      if (!element) return;
      element.textContent = text || '';
    }

    // Safe class toggling
    toggleClass(element, className, condition) {
      if (!element) return;
      if (condition) {
        element.classList.add(className);
      } else {
        element.classList.remove(className);
      }
    }

    // Safe event listener management
    addSafeEventListener(element, event, handler, options = {}) {
      if (!element) return null;
      element.addEventListener(event, handler, options);
      return handler;
    }

    removeSafeEventListener(element, event, handler) {
      if (!element || !handler) return;
      element.removeEventListener(event, handler);
    }
  }

  // =============================================================================
  // CACHE MANAGEMENT
  // =============================================================================

  // Cache manager with TTL and size limits
  class Cache {
    constructor(maxSize = 100, defaultTTL = 300000) {
      // 5 minutes default
      this.cache = new Map();
      this.timestamps = new Map();
      this.ttls = new Map();
      this.maxSize = maxSize;
      this.defaultTTL = defaultTTL;
    }

    set(key, value, ttl = null) {
      const now = Date.now();
      const actualTTL = ttl || this.defaultTTL;

      // If cache is full, remove oldest entry
      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.removeOldest();
      }

      this.cache.set(key, value);
      this.timestamps.set(key, now);
      this.ttls.set(key, actualTTL);
    }

    get(key) {
      if (!this.cache.has(key)) {
        return null;
      }

      const now = Date.now();
      const timestamp = this.timestamps.get(key);
      const ttl = this.ttls.get(key);

      if (now - timestamp > ttl) {
        this.delete(key);
        return null;
      }

      return this.cache.get(key);
    }

    has(key) {
      return this.get(key) !== null;
    }

    delete(key) {
      this.cache.delete(key);
      this.timestamps.delete(key);
      this.ttls.delete(key);
    }

    clear() {
      this.cache.clear();
      this.timestamps.clear();
      this.ttls.clear();
    }

    removeOldest() {
      let oldestKey = null;
      let oldestTime = Infinity;

      for (const [key, timestamp] of this.timestamps) {
        if (timestamp < oldestTime) {
          oldestTime = timestamp;
          oldestKey = key;
        }
      }

      if (oldestKey) {
        this.delete(oldestKey);
      }
    }

    cleanup() {
      const now = Date.now();
      const expiredKeys = [];

      for (const [key, timestamp] of this.timestamps) {
        const ttl = this.ttls.get(key);
        if (now - timestamp > ttl) {
          expiredKeys.push(key);
        }
      }

      expiredKeys.forEach((key) => this.delete(key));
    }

    get size() {
      this.cleanup(); // Clean expired entries before returning size
      return this.cache.size;
    }

    getStats() {
      this.cleanup();
      return {
        size: this.cache.size,
        maxSize: this.maxSize,
        defaultTTL: this.defaultTTL,
      };
    }
  }

  // =============================================================================
  // GAS DATA LOADING API - Phase 2.1 & 2.2 Implementation
  // =============================================================================

  /**
   * 統一データローディングAPI - GAS 2025ベストプラクティス準拠
   * 非同期データローディング、キャッシング、エラーハンドリングを統合
   */
  class UnifiedDataLoader {
    constructor() {
      this.loadingStates = new Map();
      this.cache = new Map();
      this.abortControllers = new Map();
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      this.defaultTimeout = 30000;
    }

    /**
     * データ読み込みの統一エントリーポイント
     * @param {string} functionName - GAS関数名
     * @param {Object} options - 読み込みオプション
     * @param {...any} args - GAS関数への引数
     * @returns {Promise} データ読み込み結果
     */
    async loadData(functionName, options = {}, ...args) {
      const {
        cache = true,
        cacheKey = null,
        cacheTTL = 300000, // 5分
        showLoading = true,
        loadingMessage = 'データを読み込み中...',
        retryOnError = true,
        timeout = this.defaultTimeout
      } = options;

      // CLAUDE.md準拠: 変数存在チェック後のテンプレートリテラル使用
      const funcName = functionName || 'unknown';
      const finalCacheKey = cacheKey || `${funcName}_${JSON.stringify(args || []).substring(0, 50)}`;
      const requestId = `${funcName}_${Date.now()}`;

      try {
        // キャッシュチェック
        if (cache && this.cache.has(finalCacheKey)) {
          const cached = this.cache.get(finalCacheKey);
          if (Date.now() - cached.timestamp < cacheTTL) {
            console.log(`📦 [UnifiedDataLoader] キャッシュから取得: ${funcName}`);
            return cached.data;
          }
          this.cache.delete(finalCacheKey);
        }

        // ローディング表示
        if (showLoading) {
          this.setLoadingState(requestId, true, loadingMessage);
        }

        // データ読み込み実行
        const result = await this.executeGASCall(functionName, timeout, ...args);

        // キャッシュ保存
        if (cache && result) {
          this.cache.set(finalCacheKey, {
            data: result,
            timestamp: Date.now()
          });
        }

        return result;

      } catch (error) {
        console.error(`❌ [UnifiedDataLoader] ${funcName} エラー:`, error);

        if (retryOnError && this.shouldRetry(requestId)) {
          console.log(`🔄 [UnifiedDataLoader] ${funcName} リトライ実行`);
          return this.loadData(functionName, { ...options, retryOnError: false }, ...args);
        }

        throw error;
      } finally {
        if (showLoading) {
          this.setLoadingState(requestId, false);
        }
        this.cleanup(requestId);
      }
    }

    /**
     * バッチデータ読み込み - 複数のGAS関数を並列実行
     * @param {Array} requests - [{functionName, args, options}] の配列
     * @returns {Promise<Array>} 各リクエストの結果配列
     */
    async loadBatchData(requests) {
      console.log(`📦 [UnifiedDataLoader] バッチ読み込み開始: ${(requests && requests.length) || 0}件`);

      const promises = requests.map((request, index) => {
        const { functionName, args = [], options = {} } = request;
        return this.loadData(functionName, {
          ...options,
          showLoading: false, // バッチでは個別ローディングを無効化
        }, ...args).catch(error => {
          console.error(`❌ [UnifiedDataLoader] バッチ${index || 0}: ${functionName || 'unknown'} エラー:`, error);
          return { error: error.message, functionName };
        });
      });

      return Promise.all(promises);
    }

    /**
     * GAS関数の実際の実行
     * @param {string} functionName - 関数名
     * @param {number} timeout - タイムアウト時間
     * @param {...any} args - 引数
     * @returns {Promise} 実行結果
     */
    executeGASCall(functionName, timeout, ...args) {
      return new Promise((resolve, reject) => {
        // GAS環境チェック
        if (typeof google === 'undefined' || !google.script?.run) {
          reject(new Error('Google Apps Script環境が利用できません'));
          return;
        }

        // タイムアウト設定
        // CLAUDE.md V8 compliant: Promise-based timeout
        const createPromiseTimeout = (ms) => new Promise((_, reject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              reject(new Error(`タイムアウト: ${functionName || 'unknown'} (${timeout || 0}ms)`));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(timeout);
        const timeoutId = Symbol('promise-timeout');

        // GAS関数実行
        let completed = false;
        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              console.log(`✅ [UnifiedDataLoader] ${functionName || 'unknown'} 成功`);
              resolve(result);
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              console.error(`❌ [UnifiedDataLoader] ${functionName || 'unknown'} GAS実行エラー:`, error);
              reject(new Error(error.message || error.toString()));
            }
          })
          [functionName](...args);

        // V8 compliant timeout handling
        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    }

    /**
     * ローディング状態管理
     */
    setLoadingState(requestId, isLoading, message = '') {
      if (isLoading) {
        this.loadingStates.set(requestId, { message, startTime: Date.now() });
        if (window.unifiedLoading) {
          window.unifiedLoading.show(message);
        }
      } else {
        this.loadingStates.delete(requestId);
        if (window.unifiedLoading && this.loadingStates.size === 0) {
          window.unifiedLoading.hide();
        }
      }
    }

    /**
     * リトライ判定
     */
    shouldRetry(requestId) {
      const attempts = this.retryAttempts.get(requestId) || 0;
      if (attempts >= this.maxRetries) {
        return false;
      }
      this.retryAttempts.set(requestId, attempts + 1);
      return true;
    }

    /**
     * リクエスト後処理
     */
    cleanup(requestId) {
      this.loadingStates.delete(requestId);
      this.retryAttempts.delete(requestId);
      this.abortControllers.delete(requestId);
    }

    /**
     * キャッシュ管理
     */
    clearCache(pattern = null) {
      if (pattern) {
        for (const key of this.cache.keys()) {
          if (key.includes(pattern)) {
            this.cache.delete(key);
          }
        }
      } else {
        this.cache.clear();
      }
      console.log(`🧹 [UnifiedDataLoader] キャッシュクリア: ${pattern || 'ALL'}`);
    }

    /**
     * 統計情報取得
     */
    getStats() {
      return {
        cacheSize: this.cache.size,
        activeRequests: this.loadingStates.size,
        totalRetries: Array.from(this.retryAttempts.values()).reduce((a, b) => a + b, 0)
      };
    }
  }

  // グローバルインスタンス作成
  window.unifiedDataLoader = new UnifiedDataLoader();

  // 後方互換性のためのヘルパー関数
  window.loadData = (functionName, options, ...args) =>
    window.unifiedDataLoader.loadData(functionName, options, ...args);

  window.loadBatchData = (requests) =>
    window.unifiedDataLoader.loadBatchData(requests);

  console.info('✅ UnifiedDataLoader initialized - GAS 2025 最適化版');

  // =============================================================================
  // ERROR HANDLING UTILITIES
  // =============================================================================

  class ErrorHandler {
    constructor() {
      this.errors = [];
      this.maxErrors = 50;
    }

    logError(error, context = '') {
      try {
        const errorInfo = {
          message: error?.message || error?.toString() || 'Unknown error',
          stack: error?.stack || 'No stack trace available',
          context: context || 'No context provided',
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          errorType: typeof error,
          isObject: typeof error === 'object',
        };

        this.errors.push(errorInfo);

        // Keep only recent errors
        if (this.errors.length > this.maxErrors) {
          this.errors.shift();
        }

        // Better error logging with more details
        console.group('🚨 Error Logged');
        console.log('Message:', errorInfo.message);
        console.log('Type:', errorInfo.errorType);
        console.log('Context:', errorInfo.context);
        console.log('Stack:', errorInfo.stack);
        console.log('Full Error Object:', error);
        console.groupEnd();
      } catch (loggingError) {
        console.error('Error in error logging:', loggingError);
        console.error('Original error:', error);
      }
    }

    getRecentErrors(count = 10) {
      return this.errors.slice(-count);
    }

    clearErrors() {
      this.errors = [];
    }

    setupGlobalErrorHandling() {
      window.addEventListener('error', (event) => {
        this.logError(event.error, 'Global error handler');
      });

      window.addEventListener('unhandledrejection', (event) => {
        this.logError(event.reason, 'Unhandled promise rejection');
      });
    }
  }

  // =============================================================================
  // LOADING STATE MANAGEMENT
  // =============================================================================

  class LoadingManager {
    constructor() {
      this.loadingStates = new Map();
    }

    setLoading(key, isLoading, message = '') {
      this.loadingStates.set(key, { isLoading, message, timestamp: Date.now() });

      // Emit custom event for UI updates
      const event = new CustomEvent('loadingStateChange', {
        detail: { key, isLoading, message },
      });
      document.dispatchEvent(event);
    }

    isLoading(key) {
      const state = this.loadingStates.get(key);
      return state ? state.isLoading : false;
    }

    getLoadingMessage(key) {
      const state = this.loadingStates.get(key);
      return state ? state.message : '';
    }

    clearLoading(key) {
      this.loadingStates.delete(key);
      this.setLoading(key, false);
    }

    clearAllLoading() {
      const keys = Array.from(this.loadingStates.keys());
      keys.forEach((key) => this.clearLoading(key));
    }
  }

  // =============================================================================
  // GAS INTEGRATION UTILITIES
  // =============================================================================

  class GASUtilities {
    constructor() {
      this.callCache = new Cache(50, 1000); // 1 second cache for API calls
    }

    // Cached GAS function call
    callWithCache(functionName, cacheKey, ttl, ...args) {
      const cached = this.callCache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }

      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler((result) => {
            this.callCache.set(cacheKey, result, ttl);
            resolve(result);
          })
          .withFailureHandler(reject)
          [functionName](...args);
      });
    }

    // Simple GAS function call
    call(functionName, ...args) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          [functionName](...args);
      });
    }

    // GAS function call with loading overlay - 重複リクエスト防止版
    callWithLoading(functionName, message = '処理中...', loadingType = 'overlay', ...args) {
      // Support config object as message parameter
      if (typeof message === 'object' && message !== null) {
        const config = message;
        message = config.message || '処理中...';
        loadingType = config.type || loadingType;
      }

      // 重複リクエスト防止: 同じ関数が実行中の場合は既存のPromiseを返す
      const funcName = functionName || 'unknown';
      const requestKey = `${funcName}_${JSON.stringify(args || [])}`;
      if (this.pendingRequests && this.pendingRequests.has(requestKey)) {
        console.log(`🚫 Duplicate request prevented: ${funcName}`);
        return this.pendingRequests.get(requestKey);
      }

      // pendingRequestsがない場合は初期化
      if (!this.pendingRequests) {
        this.pendingRequests = new Map();
      }

      const promise = new Promise((resolve, reject) => {
        // Use appropriate loading method based on type
        if (loadingType === 'transparent') {
          window.unifiedLoading.showTransparent(message);
        } else {
          window.unifiedLoading.show(message);
        }

        google.script.run
          .withSuccessHandler((result) => {
            window.unifiedLoading.hide(); // Hide loading overlay on success
            this.pendingRequests.delete(requestKey); // 完了後にキャッシュから削除
            resolve(result);
          })
          .withFailureHandler((error) => {
            window.unifiedLoading.hide(); // Hide loading overlay on failure
            this.pendingRequests.delete(requestKey); // エラー時にもキャッシュから削除
            // Log the error using the shared error handler
            window.sharedUtilities.errors.logError(error, `GAS call failed: ${funcName}`);
            reject(error);
          })
          [functionName](...args);
      });

      // 実行中リクエストとしてキャッシュ
      this.pendingRequests.set(requestKey, promise);
      return promise;
    }

    // Check if running in GAS environment
    isGASEnvironment() {
      return typeof google !== 'undefined' && google.script && google.script.run;
    }
  }

  // =============================================================================
  // SECURITY UTILITIES
  // =============================================================================

  // Security utilities for XSS prevention and data sanitization
  class SecurityUtilities {
    // Escape HTML characters to prevent XSS attacks
    escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Sanitize HTML content by removing dangerous tags
    sanitizeHtml(html) {
      if (!html) return '';
      const div = document.createElement('div');
      div.innerHTML = html;

      // Remove script tags and other dangerous elements
      const scripts = div.querySelectorAll('script, object, embed, iframe, form');
      scripts.forEach((script) => script.remove());

      return div.innerHTML;
    }

    // Validate email format
    isValidEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
  }

  // =============================================================================
  // INITIALIZATION AND GLOBAL SETUP
  // =============================================================================

  // Initialize global utilities
  // Privacy-aware logging utilities
  class PrivacyLogger {
    // Anonymize sensitive data for logging
    static anonymize(data) {
      if (typeof data === 'string') {
        // Email anonymization
        if (data.includes('@')) {
          const parts = data.split('@');
          const safePart0 = (parts[0] && parts[0].substring) ? parts[0].substring(0, 2) : 'xx';
          const safePart1 = parts[1] || 'unknown';
          return `${safePart0}***@${safePart1}`;
        }
        // Long text anonymization (potential user content)
        if (data.length > 30) {
          const safeDataPrefix = (data && data.substring) ? data.substring(0, 15) : 'unknown';
          const safeDataLength = (data && data.length) || 0;
          return `${safeDataPrefix}...[${safeDataLength} chars]`;
        }
        return data;
      }

      if (typeof data === 'object' && data !== null) {
        const anonymized = {};
        for (const [key, value] of Object.entries(data)) {
          // Skip sensitive keys
          if (['email', 'userEmail', 'reason', 'opinion', 'answer', 'content'].includes(key)) {
            anonymized[key] = this.anonymize(value);
          } else if (key.includes('Id') && typeof value === 'string') {
            // Anonymize IDs partially
            if (value && value.length && value.substring) {
              anonymized[key] = value.length > 8 ? `${value.substring(0, 4)}***` : value;
            } else {
              anonymized[key] = value;
            }
          } else {
            anonymized[key] = value;
          }
        }
        return anonymized;
      }

      return data;
    }

    // Safe console logging with privacy protection
    static log(message, data = null) {
      if (data) {
        console.log(message, this.anonymize(data));
      } else {
        console.log(message);
      }
    }

    static warn(message, data = null) {
      if (data) {
        console.warn(message, this.anonymize(data));
      } else {
        console.warn(message);
      }
    }

    static error(message, data = null) {
      if (data) {
        console.error(message, this.anonymize(data));
      } else {
        console.error(message);
      }
    }
  }

  window.sharedUtilities = {
    debounce: new DebounceManager(),
    throttle: new ThrottleManager(),
    dom: new DOMUtilities(),
    cache: new Cache(),
    errors: new ErrorHandler(),
    loading: new LoadingManager(),
    gas: new GASUtilities(),
    security: new SecurityUtilities(),
    privacy: PrivacyLogger,
  };

  // Setup global error handling
  window.sharedUtilities.errors.setupGlobalErrorHandling();

  // Helper functions for backward compatibility
  window.debounce = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.debounce) {
      window.sharedUtilities.debounce.debounce(func, key, delay);
    } else {
      // CLAUDE.md V8 compliant: Promise-based fallback
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });
      createPromiseDelay(delay).then(func).catch(() => {
        // Silent error handling for fallback
      });
    }
  };

  window.throttle = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.throttle) {
      window.sharedUtilities.throttle.throttle(func, key, delay);
    } else {
      // Simple fallback
      func();
    }
  };

  // Global cache instance for backward compatibility
  if (!window.UnifiedCache) {
    window.UnifiedCache = Cache;
  }

  // DOM ready utility
  window.onDOMReady = function (callback) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', callback);
    } else {
      callback();
    }
  };

  // Debug function for console access
  window.getSharedUtilitiesStats = function () {
    return {
      debounceTimers: window.sharedUtilities.debounce.timers.size,
      throttleTimers: window.sharedUtilities.throttle.timers.size,
      cacheSize: window.sharedUtilities.cache.size,
      cacheStats: window.sharedUtilities.cache.getStats(),
      domCacheSize: window.sharedUtilities.dom.elementCache.size,
      recentErrors: window.sharedUtilities.errors.getRecentErrors(5),
      loadingStates: Object.fromEntries(window.sharedUtilities.loading.loadingStates),
      gasEnvironment: window.sharedUtilities.gas.isGASEnvironment(),
    };
  };

  // Performance monitoring
  window.clearAllSharedUtilities = function () {
    window.sharedUtilities.debounce.clearAll();
    window.sharedUtilities.throttle.clearAll();
    window.sharedUtilities.cache.clear();
    window.sharedUtilities.dom.clearElementCache();
    window.sharedUtilities.errors.clearErrors();
    window.sharedUtilities.loading.clearAllLoading();
    console.log('🧹 All SharedUtilities cleared');
  };

  // Integration test function
  window.testSharedUtilities = function () {
    console.group('🧪 SharedUtilities Integration Test');

    // Test debounce
    let debounceCount = 0;
    const testDebounce = () => debounceCount++;
    window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);
    window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);

    // CLAUDE.md V8 compliant: Promise-based delay for test
    const createPromiseDelay = (ms) => new Promise(resolve => {
      const start = Date.now();
      const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
      check();
    });

    createPromiseDelay(150).then(() => {
      console.log('Debounce test:', debounceCount === 1 ? '✅ PASS' : '❌ FAIL');
    });

    // Test cache
    window.sharedUtilities.cache.set('test', 'value', 1000);
    const cached = window.sharedUtilities.cache.get('test');
    console.log('Cache test:', cached === 'value' ? '✅ PASS' : '❌ FAIL');

    // Test DOM utilities
    const testEl = window.sharedUtilities.dom.createSafeElement('div', 'test-class', 'test');
    console.log('DOM creation test:', testEl.className === 'test-class' ? '✅ PASS' : '❌ FAIL');

    // Test error handling
    window.sharedUtilities.errors.logError(new Error('Test error'), 'Integration test');
    const errors = window.sharedUtilities.errors.getRecentErrors(1);
    console.log('Error handling test:', errors.length > 0 ? '✅ PASS' : '❌ FAIL');

    console.groupEnd();
    return window.getSharedUtilitiesStats();
  };

  // =============================================================================
  // AUTHENTICATION UTILITIES
  // =============================================================================

  // Shared authentication functions for consistent behavior across pages
  window.sharedUtilities.auth = {
    // Account switching functionality shared across pages
    switchToAnotherAccount: function () {
      if (
        confirm(
          '別のGoogleアカウントでログインしますか？現在のセッションからログアウトされ、アカウント選択画面が表示されます。'
        )
      ) {
        try {
          google.script.run
            .withSuccessHandler(function (result) {
              if (result && result.success) {
                const url = new URL(window.location.href);
                url.searchParams.set('force_account_selection', 'true');
                window.location.replace(url.toString());
              } else {
                window.sharedUtilities.auth.showAccountSwitchFallback();
              }
            })
            .withFailureHandler(function (error) {
              console.warn('認証リセットエラー:', error);
              window.sharedUtilities.auth.showAccountSwitchFallback();
            })
            .resetAuth();
        } catch (error) {
          console.warn('アカウント切り替えエラー:', error);
          window.sharedUtilities.auth.showAccountSwitchFallback();
        }
      }
    },

    // Fallback guidance when automatic switch fails
    showAccountSwitchFallback: function () {
      const msg = `
          アカウントを切り替えるには以下の手順をお試しください：

          1. 新しいブラウザタブでGoogle（google.com）にアクセス
          2. 右上のプロフィール画像をクリック
          3. 「別のアカウントを追加」または使用したいアカウントを選択
          4. このページに戻って再度認証を開始

          または、ブラウザのシークレット/プライベートモードで新しいタブを開いてこのページにアクセスしてください。
        `;
      alert(msg);
    },

    // 最適化されたログアウト（openAppSetupパターン採用）
    logout: function () {
      if (confirm('ログアウトしますか？')) {
        console.log('🚪 Logout initiated');

        // 1. フロントエンドキャッシュクリア
        try {
          if (window.sharedUtilities?.cache?.clear) {
            window.sharedUtilities.cache.clear();
          }
          localStorage.removeItem('current_user_info');
          sessionStorage.clear();
          console.log('🗑️ Client cache cleared');
        } catch (e) {
          console.warn('Cache clear partially failed:', e);
        }

        // 2. openAppSetupと同じパターンでWebApp URL取得→遷移
        google.script.run
          .withSuccessHandler(function(webAppUrl) {
            const loginUrl = `${webAppUrl}?mode=login`;
            console.log('🔄 Redirecting to login page:', loginUrl);

            // openAppSetupと同じ手法: window.open(_top)でサンドボックス制限回避
            window.open(loginUrl, '_top');

            // バックグラウンドでセッションクリア（非ブロッキング）- V8準拠
            const createPromiseDelay = (ms) => new Promise(resolve => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            });

            createPromiseDelay(100).then(() => {
              google.script.run
                .withSuccessHandler(function(result) {
                  console.log('✅ Background server session cleared:', result?.message || 'OK');
                })
                .withFailureHandler(function(error) {
                  console.warn('⚠️ Background session clear failed (non-critical):', error);
                })
                .resetAuth();
            }).catch(() => {
              // Silent error handling for background task
            });
          })
          .withFailureHandler(function(error) {
            console.warn('WebApp URL取得失敗、フォールバック実行:', error);

            // フォールバック: openAppSetupと同じパターン
            try {
              const currentUrl = new URL(window.location.href);
              const baseUrl = currentUrl.origin + currentUrl.pathname;
              const loginUrl = `${baseUrl}?mode=login`;
              console.log('🔄 Fallback redirect to:', loginUrl);
              window.open(loginUrl, '_top');
            } catch (fallbackError) {
              console.warn('フォールバック遷移も失敗:', fallbackError);
              window.location.reload();
            }
          })
          .getWebAppUrl();
      }
    },


    // Authentication verification with promise
    verifyAuthentication: function () {
      return new Promise((resolve, reject) => {
        // CLAUDE.md V8 compliant: Promise-based timeout for auth verification
        const createPromiseTimeout = (ms) => new Promise((_, timeoutReject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              timeoutReject(new Error('認証確認がタイムアウトしました'));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(10000);
        let completed = false;

        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              if (result && result.authenticated && result.email) {
                resolve(result);
              } else {
                reject(new Error('認証が必要です'));
              }
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              reject(error);
            }
          })
          .checkUserAuthentication();

        // Handle timeout
        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    },

    // Display authentication info in standardized format
    displayAuthInfo: function (containerId, email, showSwitchOption = true) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Safely escape email with fallback
      const safeEmail =
        window.sharedUtilities && window.sharedUtilities.security
          ? window.sharedUtilities.security.escapeHtml(email)
          : (email || '').replace(/[<>&"']/g, function (match) {
              switch (match) {
                case '<':
                  return '&lt;';
                case '>':
                  return '&gt;';
                case '&':
                  return '&amp;';
                case '"':
                  return '&quot;';
                case "'":
                  return '&#39;';
                default:
                  return match;
              }
            });

      container.innerHTML = `
        <div class="bg-gray-800 rounded-lg p-4 mb-4">
          <p class="text-sm text-gray-400 mb-1">認証済みアカウント:</p>
          <p class="text-white font-semibold">${safeEmail}</p>
        </div>
        ${
          showSwitchOption
            ? `
        <div class="text-right">
          <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
            別のアカウントでログイン
          </button>
        </div>`
            : ''
        }
      `;
    },
  };

  // Global functions for backward compatibility
  window.switchToAnotherAccount = function () {
    window.sharedUtilities.auth.switchToAnotherAccount();
  };

  window.logout = function () {
    window.sharedUtilities.auth.logout();
  };


  // =============================================================================
  // UNIFIED LOADING MANAGER (NEW ENHANCED VERSION)
  // =============================================================================

  class UnifiedLoadingManager {
    constructor() {
      this.overlay = null;
      this.initialized = false;
      this.currentState = null;
      this.variantClasses = ['transparent', 'minimal', 'modal'];
    }

    // Initialize the loading manager with DOM element detection
    init(retries = 5, delay = 100, onSuccess = null) {
      if (this.initialized) {
        console.log('UnifiedLoadingManager: Already initialized.');
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced DOM readiness check
      if (document.readyState === 'loading') {
        console.log('UnifiedLoadingManager: DOM still loading, waiting for DOMContentLoaded...');
        document.addEventListener(
          'DOMContentLoaded',
          () => {
            // CLAUDE.md V8 compliant: requestIdleCallback for DOM-ready retry
            requestIdleCallback(() => this.init(retries, delay, onSuccess), { timeout: 50 });
          },
          { once: true }
        );
        return false;
      }

      this.overlay = document.getElementById('loading-overlay');
      if (this.overlay) {
        if (!window.unifiedLoadingInitialized) {
          window.unifiedLoadingInitialized = true;
          console.log(
            '✅ UnifiedLoadingManager: Initialized successfully with element:',
            this.overlay.className
          );
        }
        this.initialized = true;
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced retry logic
      if (retries > 0) {
        console.warn(
          (() => {
            const safeReadyState = (document && document.readyState) || 'unknown';
            const safeDelay = delay || 0;
            const safeRetries = retries || 0;
            return `⚠️ UnifiedLoadingManager: loading-overlay element not found. DOM state: ${safeReadyState}. Retrying in ${safeDelay}ms (${safeRetries} retries left)...`;
          })()
        );
        // CLAUDE.md V8 compliant: Promise-based delay for loading manager retry
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(delay).then(() => this.init(retries - 1, delay * 1.5, onSuccess));
      } else {
        console.error(
          '❌ UnifiedLoadingManager: Critical failure - loading-overlay element not found after multiple retries.'
        );
        this.createFallbackOverlay();
      }
      return false;
    }

    // Create a fallback overlay if none exists
    createFallbackOverlay() {
      if (document.getElementById('loading-overlay')) {
        this.overlay = document.getElementById('loading-overlay');
        this.initialized = true;
        return true;
      }

      console.warn('⚠️ UnifiedLoadingManager: Creating fallback loading-overlay element');
      const fallbackOverlay = document.createElement('div');
      fallbackOverlay.id = 'loading-overlay';
      fallbackOverlay.className = 'loading-overlay page-specific hidden';

      if (document.body) {
        document.body.insertBefore(fallbackOverlay, document.body.firstChild);
        this.overlay = fallbackOverlay;
        this.initialized = true;
        console.log('✅ UnifiedLoadingManager: Fallback overlay created and initialized');
        return true;
      }
      return false;
    }

    // Main loading function with a unified API and enhanced error handling
    setLoading(isLoading, options = {}) {
      if (!this.initialized) {
        // Silent retry - reduce console noise during initialization
        if (!this.init()) {
          // Initialization failed, but continue silently to avoid spam
          return;
        }
      }

      try {
        if (isLoading) {
          console.log('UnifiedLoadingManager: Showing loading overlay with options:', options);
          this.show(options);
        } else {
          console.log('UnifiedLoadingManager: Hiding loading overlay.');
          this.hide();
        }
      } catch (error) {
        console.error('UnifiedLoadingManager: Error during loading state change:', error);
      }
    }

    // Show loading overlay with options
    show(options = {}) {
      // V8 Runtime 安全性: オプションが文字列の場合はmessageとして扱う
      if (typeof options === 'string') {
        options = { message: options };
      }

      const config = {
        message: options.message || '処理中...',
        type: options.type || 'overlay',
        progress: options.progress || null,
        steps: options.steps || null,
        disableInteraction: options.disableInteraction !== false,
        ...options,
      };

      this.currentState = config;

      // V8 Runtime 安全性: overlay が null の場合の早期リターン
      if (!this.overlay) {
        console.error('UnifiedLoadingManager: Cannot show overlay - element not initialized');
        // フォールバック作成を試行
        if (!this.createFallbackOverlay()) {
          return;
        }
      }

      // Clean up previous variant classes with null safety
      this.variantClasses.forEach((vc) => {
        if (this.overlay && this.overlay.classList) {
          this.overlay.classList.remove(vc);
        }
      });

      // Add the new variant class if it's not the default overlay
      if (config.type !== 'overlay' && this.overlay && this.overlay.classList) {
        this.overlay.classList.add(config.type);
      }

      // Update content and show the overlay
      this.updateContent(config);

      if (this.overlay && this.overlay.classList) {
        this.overlay.classList.remove('hidden');
        this.overlay.style.setProperty('display', 'flex', 'important');
      }

      // Manage user interaction
      if (config.disableInteraction && config.type !== 'transparent' && this.overlay) {
        document.body.style.overflow = 'hidden';
        document.body.style.pointerEvents = 'none';
        this.overlay.style.pointerEvents = 'auto';
      }

      console.log(
        (() => {
          const safeConfigType = (config && config.type) || 'unknown';
          const safeConfigMessage = (config && config.message) || 'No message';
          return `UnifiedLoadingManager: Overlay shown with type '${safeConfigType}' and message '${safeConfigMessage}'`;
        })()
      );
    }

    // Hide loading overlay with cleanup
    hide() {
      if (!this.overlay) return;

      this.overlay.classList.add('hidden');
      this.overlay.style.setProperty('display', 'none', 'important');

      // Clean up variant classes
      this.variantClasses.forEach((vc) => this.overlay.classList.remove(vc));

      // Re-enable user interaction
      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';

      // Clear current state
      this.currentState = null;

      console.log('UnifiedLoadingManager: Overlay hidden');
    }

    // Update the overlay content dynamically
    updateContent(config) {
      if (!this.overlay) return;

      // Use existing content or create default structure
      let messageElement = this.overlay.querySelector('.loading-message');
      if (!messageElement) {
        const safeOverlayMessage = (config && config.message) || 'Loading...';
        this.overlay.innerHTML = `
          <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-message">${safeOverlayMessage}</div>
          </div>
        `;
        messageElement = this.overlay.querySelector('.loading-message');
      } else {
        messageElement.textContent = config.message;
      }

      // Handle progress display if configured
      if (config.progress !== null && config.progress !== undefined) {
        let progressElement = this.overlay.querySelector('.loading-progress');
        if (!progressElement) {
          progressElement = document.createElement('div');
          progressElement.className = 'loading-progress';
          this.overlay.appendChild(progressElement);
        }
        const safeProgress = (config && typeof config.progress === 'number') ? config.progress : 0;
        progressElement.textContent = `${safeProgress}%`;
      }

      // Handle step display if configured
      if (config.steps && Array.isArray(config.steps)) {
        let stepsElement = this.overlay.querySelector('.loading-steps');
        if (!stepsElement) {
          stepsElement = document.createElement('div');
          stepsElement.className = 'loading-steps';
          this.overlay.appendChild(stepsElement);
        }

        stepsElement.innerHTML = config.steps
          .map((step) => {
            const safeStatus = (step && step.status) || 'pending';
            const safeText = (step && step.text) || 'Step';
            return `<div class="loading-step ${safeStatus}">${safeText}</div>`;
          })
          .join('');
      }
    }

    // Convenience methods for different loading types
    showOverlay(message = '処理中...') {
      this.setLoading(true, { message, type: 'overlay' });
    }

    showTransparent(message = '処理中...') {
      this.setLoading(true, { message, type: 'transparent' });
    }

    showWithProgress(message = '処理中...', progress = 0) {
      this.setLoading(true, { message, type: 'overlay', progress });
    }

    // Admin panel specific loading with predefined steps
    showAdminProgress(message = 'システムを準備中...', step = 1, percentage) {
      const options = {
        message,
        type: 'overlay',
        progress: percentage,
      };

      // Define standard admin loading steps
      if (step && step > 0) {
        options.steps = [
          {
            text: 'システム情報を読み込み中...',
            status: step > 1 ? 'completed' : step === 1 ? 'active' : 'pending',
          },
          {
            text: 'ユーザー情報を取得中...',
            status: step > 2 ? 'completed' : step === 2 ? 'active' : 'pending',
          },
          {
            text: 'シート情報と設定を適用中...',
            status: step > 3 ? 'completed' : step === 3 ? 'active' : 'pending',
          },
          {
            text: 'UIを最終調整中...',
            status: step > 4 ? 'completed' : step === 4 ? 'active' : 'pending',
          },
        ];
      }
      this.setLoading(true, options);
    }
  }

  // Create and initialize the global instance once the DOM is ready.
  window.unifiedLoading = new UnifiedLoadingManager();
  document.addEventListener('DOMContentLoaded', () => {
    window.unifiedLoading.init();
  });

  // Backward compatibility wrapper for the global setLoading function.
  window.setLoading = function (isLoading, message, step, percentage) {
    if (!isLoading) {
      window.unifiedLoading.setLoading(false);
      return;
    }

    if (typeof message === 'object') {
      window.unifiedLoading.setLoading(true, message);
    } else if (typeof step === 'number' && step > 0) {
      window.unifiedLoading.showAdminProgress(message, step, percentage);
    } else {
      window.unifiedLoading.showOverlay(message || '処理中...');
    }
  };

  // 🚀 部分ローディング機能（軽量操作用）
  window.setPartialLoading = function (loading, message) {
    if (loading) {
      // 部分ローディング: 通知 + インラインスピナー、画面操作可能
      const safeInfoMessage = message || '処理中...';
      window.showInfo(`🔄 ${safeInfoMessage}`);

      // インライン要素にスピナークラスを追加（あれば）
      const activeElements = document.querySelectorAll('.partial-loading-target');
      activeElements.forEach((el) => {
        el.classList.add('partial-loading');
        if (!el.dataset.originalText) {
          el.dataset.originalText = el.textContent;
        }
        el.textContent = '読み込み中...';
        el.disabled = true;
      });
    } else {
      // 終了時: スピナー除去、元の状態に復元
      const activeElements = document.querySelectorAll('.partial-loading');
      activeElements.forEach((el) => {
        el.classList.remove('partial-loading');
        if (el.dataset.originalText) {
          el.textContent = el.dataset.originalText;
          delete el.dataset.originalText;
        }
        el.disabled = false;
      });
    }
  };

  // =============================================================================
  // GOOGLE APPS SCRIPT ENVIRONMENT WARNING SUPPRESSION
  // =============================================================================

  // Suppress iframe and sandbox-related warnings specific to Google Apps Script
  (function () {
    const isGoogleAppsScript =
      window.location.hostname.includes('script.google.com') ||
      window.location.href.includes('script.googleusercontent.com') ||
      (typeof google !== 'undefined' && google.script);

    if (isGoogleAppsScript) {
      const originalConsoleWarn = console.warn;
      console.warn = function (...args) {
        const message = args.join(' ').toLowerCase();

        // Suppress common iframe/sandbox warnings in GAS environment
        const suppressPatterns = [
          'iframe',
          'sandbox',
          'x-frame-options',
          'frame-ancestors',
          'refused to frame',
          'same-origin policy',
          'cross-origin frame access',
          'document.domain',
          'postmessage',
          'unrecognized feature',
          'gyroscope',
          'accelerometer',
          'magnetometer',
          'camera',
          'microphone',
          'geolocation',
          'allow-scripts',
          'allow-same-origin',
          'feature',
          'permission',
          'permissions policy',
          'feature policy',
          'escape its sandboxing',
          'document.domain setter',
          'an iframe which has both allow-scripts and allow-same-origin',
          'can escape its sandboxing',
          'net state changed from idle to busy',
          'net state changed from busy to idle',
          'warden_bin_i18n_warden',
          'geolocation',
          'microphone',
          'camera',
          'gyroscope',
          'accelerometer',
          'magnetometer',
          'usb',
          'serial',
          'bluetooth',
          'hid',
          'payment',
          'display-capture',
          'screen-wake-lock',
          'web-share',
          'unrecognized feature',
          'usercodepanel',
          'mae_html_user_bin_i18n_mae_html_user',
          '3088782566-warden_bin_i18n_warden__ja.js',
          '2056725483-mae_html_user_bin_i18n_mae_html_user__ja.js',
          'an iframe which has both allow-scripts and allow-same-origin',
          'can escape its sandboxing',
          'usercodepanel',
          'mae_html_user_bin_i18n_mae_html_user',
          '3088782566-warden_bin_i18n_warden__ja.js',
          '2056725483-mae_html_user_bin_i18n_mae_html_user__ja.js',
        ];

        const shouldSuppress = suppressPatterns.some((pattern) => message.includes(pattern));

        if (!shouldSuppress) {
          originalConsoleWarn.apply(console, args);
        }
      };

      // Suppress common iframe-related errors
      const originalConsoleError = console.error;
      console.error = function (...args) {
        const message = args.join(' ').toLowerCase();

        if (
          message.includes('iframe') &&
          (message.includes('refused to frame') ||
            message.includes('x-frame-options') ||
            message.includes('frame-ancestors'))
        ) {
          return;
        }

        originalConsoleError.apply(console, args);
      };

      // Handle iframe-related window errors silently
      window.addEventListener(
        'error',
        function (event) {
          if (event.message && typeof event.message === 'string') {
            const message = event.message.toLowerCase();
            if (
              (message.includes('iframe') || message.includes('frame')) &&
              (message.includes('denied') || message.includes('blocked'))
            ) {
              event.preventDefault();
              return false;
            }
          }
        },
        true
      );
    }
  })();

  // =============================================================================
  // NOTIFICATION TOAST SYSTEM
  // =============================================================================

  class NotificationSystem {
    constructor() {
      this.container = null;
      this.initialized = false;
      this.domContentLoadedAdded = false;
    }

    // Initialize notification container (fixed styling conflicts and event duplication)
    init() {
      // Check container existence first (more reliable than initialized flag)
      this.container = document.getElementById('notification-container');

      if (this.container) {
        this.initialized = true;
        return;
      }

      // Create notification container with unified styling
      this.container = document.createElement('div');
      this.container.id = 'notification-container';

      // Use CSS classes only (remove style.cssText conflict)
      this.container.className = 'fixed top-4 right-4 z-[10000] space-y-2 pointer-events-none';

      // Enhanced DOM insertion with duplication prevention
      this.appendToBody();
      this.initialized = true;
    }

    // Append container to body with event duplication prevention
    appendToBody() {
      if (document.body) {
        document.body.appendChild(this.container);
      } else if (!this.domContentLoadedAdded) {
        this.domContentLoadedAdded = true;
        document.addEventListener('DOMContentLoaded', () => {
          if (this.container && !this.container.parentNode) {
            document.body.appendChild(this.container);
          }
        });
      }
    }

    // Show notification message
    showMessage(message, type = 'info', duration = null) {
      // Standardized durations: success: 4000, error: 7000, warning: 6000, info: 5000
      if (duration === null) {
        const standardDurations = { success: 4000, error: 7000, warning: 6000, info: 5000 };
        duration = standardDurations[type] || 5000;
      }
      // Ensure container is initialized
      this.init();

      if (!this.container) {
        console.error('Notification container could not be initialized');
        // Fallback to alert for critical messages
        if (type === 'error') {
          alert('エラー: ' + message);
        }
        return;
      }

      // Color schemes for different types
      const colors = {
        success: 'border-green-400 bg-green-900/50 text-green-100',
        error: 'border-red-400 bg-red-900/50 text-red-100',
        warning: 'border-yellow-400 bg-yellow-900/50 text-yellow-100',
        info: 'border-blue-400 bg-blue-900/50 text-blue-100',
      };

      // Icons for different types
      const icons = {
        success: '✅',
        error: '❌',
        warning: '⚠️',
        info: 'ℹ️',
      };

      // Create notification element with unified styling approach
      const notification = document.createElement('div');
      const safeTypeColor = colors[type] || colors.info;

      // Use CSS classes for layout, inline styles only for animations and type-specific colors
      notification.className = `notification glass-panel rounded-lg border shadow-lg flex items-center ${safeTypeColor}`;

      // Inline styles only for animation states and essential overrides
      notification.style.cssText = `
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease-out;
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        min-height: 3rem;
        max-height: 5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        line-height: 1.4;
        pointer-events: auto;
      `;

      const safeIcon = icons[type] || icons.info;
      const safeHtmlMessage = this.escapeHtml(message || 'No message');
      notification.innerHTML = `
        <div class="mr-3 text-lg flex-shrink-0 leading-none">${safeIcon}</div>
        <div class="flex-1 text-sm leading-normal">${safeHtmlMessage}</div>
        <button type="button" class="ml-4 text-gray-400 hover:text-white text-lg leading-none flex-shrink-0" style="background: none; border: none; cursor: pointer; line-height: 1;">✕</button>
      `;

      // Add close button handler
      const closeBtn = notification.querySelector('button');
      closeBtn.addEventListener('click', () => this.removeNotification(notification));

      // Append to container
      this.container.appendChild(notification);

      // CLAUDE.md V8 compliant: requestAnimationFrame for smooth animation
      requestAnimationFrame(() => {
        // Ensure DOM insertion is complete before starting animation
        if (notification.parentNode) {
          notification.style.transform = 'translateX(0)';
          notification.style.opacity = '1';

          // Schedule removal after animation completes
          if (duration > 0) {
            // Animation duration (300ms) + safety margin (100ms)
            const animationDelay = 400;
            this.scheduleNotificationRemoval(notification, duration + animationDelay);
          }
        }
      });
    }

    // Simplified and reliable notification removal scheduling
    scheduleNotificationRemoval(notification, delay) {
      // Simple setTimeout for reliable notification removal
      setTimeout(() => {
        this.removeNotification(notification);
      }, delay);
    }

    // Remove notification with animation (simplified and reliable)
    removeNotification(notification) {
      if (!notification || !notification.parentNode) return;

      // Prevent duplicate removal attempts
      if (notification.dataset.removing === 'true') return;
      notification.dataset.removing = 'true';

      // Start exit animation
      notification.style.transform = 'translateX(100%)';
      notification.style.opacity = '0';

      // Simple and reliable removal after animation duration
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 300); // Match CSS transition duration
    }

    // Convenience methods (simplified - use showMessage defaults)
    success(message, duration) {
      this.showMessage(message, 'success', duration);
    }

    error(message, duration) {
      this.showMessage(message, 'error', duration);
    }

    warning(message, duration) {
      this.showMessage(message, 'warning', duration);
    }

    info(message, duration) {
      this.showMessage(message, 'info', duration);
    }

    // Escape HTML to prevent XSS
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // Clear all notifications
    clearAll() {
      if (!this.container) return;

      const notifications = this.container.querySelectorAll('.notification');
      notifications.forEach((notification) => this.removeNotification(notification));
    }
  }

  // Create global notification instance
  window.notifications = new NotificationSystem();

  // Add to shared utilities
  if (window.sharedUtilities) {
    window.sharedUtilities.notifications = window.notifications;
  }

  // Global convenience functions for backward compatibility
  window.showSuccess = function (message, duration) {
    window.notifications.success(message, duration);
  };

  window.showError = function (message, duration) {
    window.notifications.error(message, duration);
  };

  window.showWarning = function (message, duration) {
    window.notifications.warning(message, duration);
  };

  window.showInfo = function (message, duration) {
    window.notifications.info(message, duration);
  };

  // Alias for generic show message
  window.showMessage = function (message, type, duration) {
    window.notifications.showMessage(message, type, duration);
  };

  // Add styles for notification system if not using Tailwind
  if (!document.querySelector('script[src*="tailwindcss"]')) {
    const style = document.createElement('style');
    style.textContent = `
      #notification-container {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 10000;
        pointer-events: none;
      }
      #notification-container .notification {
        pointer-events: auto;
        min-width: 300px;
        max-width: 500px;
      }
    `;
    document.head.appendChild(style);
  }

  // =============================================================================
  // DYNAMIC PERFORMANCE CONSTANTS - Shared across all HTML files
  // =============================================================================

  // Performance level detection
  window.getPerformanceLevel = function() {
    if (typeof navigator === 'undefined') return 'medium';

    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const connection = navigator.connection;

    // High-end device criteria
    if (memory >= 8 && cores >= 8) return 'high';

    // Low-end device criteria
    if (memory <= 2 || cores <= 2) return 'low';

    // Network considerations
    if (connection) {
      const { effectiveType, downlink } = connection;
      if (effectiveType === '2g' || (downlink && downlink < 1)) return 'low';
      if (effectiveType === '4g' && downlink && downlink > 10) return 'high';
    }

    return 'medium';
  };

  window.isLowEndDevice = function() {
    if (typeof navigator === 'undefined') return false;

    const memory = navigator.deviceMemory;
    const cores = navigator.hardwareConcurrency;

    return (memory && memory <= 2) || (cores && cores <= 2);
  };

  // Dynamic performance constants
  window.getPerformanceConstants = function() {
    const perfLevel = window.getPerformanceLevel();
    const isLowEnd = window.isLowEndDevice();

    return {
      BASE_RENDER_BATCH_SIZE: perfLevel === 'high' ? 15 : perfLevel === 'low' ? 5 : 10,
      LOW_PERF_BATCH_SIZE: isLowEnd ? 3 : 5,
      HIGH_PERF_BATCH_SIZE: perfLevel === 'high' ? 25 : 15,
      VIEWPORT_BUFFER: perfLevel === 'high' ? 300 : perfLevel === 'low' ? 100 : 200,
      PERFORMANCE_BUDGET: perfLevel === 'high' ? 12 : perfLevel === 'low' ? 24 : 16,
      CHUNK_SIZE: perfLevel === 'high' ? 8 : perfLevel === 'low' ? 3 : 5,
      IDLE_TIMEOUT: isLowEnd ? 8000 : 5000
    };
  };

  // Getter functions for dynamic constants
  window.getBatchSize = function(type = 'base') {
    const constants = window.getPerformanceConstants();
    const safeType = (type && type.toUpperCase) ? type.toUpperCase() : 'DEFAULT';
    return constants[`${safeType}_BATCH_SIZE`] || constants.BASE_RENDER_BATCH_SIZE;
  };

  window.getViewportBuffer = function() {
    return window.getPerformanceConstants().VIEWPORT_BUFFER;
  };

  window.getPerformanceBudget = function() {
    return window.getPerformanceConstants().PERFORMANCE_BUDGET;
  };

  window.getChunkSize = function() {
    return window.getPerformanceConstants().CHUNK_SIZE;
  };

  window.getIdleTimeout = function() {
    return window.getPerformanceConstants().IDLE_TIMEOUT;
  };

  // Prevent duplicate loading messages
  if (!window.sharedUtilitiesLoaded) {
    window.sharedUtilitiesLoaded = true;
    console.log(
      '✅ SharedUtilities loaded successfully - Version 3.0.0-flat (Zero-Dependency Architecture)'
    );
  }
</script>
