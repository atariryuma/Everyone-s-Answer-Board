<script>
  /* =============================================================================
     ã¿ã‚“ãªã®å›ç­”ãƒœãƒ¼ãƒ‰ - Shared JavaScript Utilities
     GAS Compatible utility functions for all HTML files
     ============================================================================= */

  // âœ… IMMEDIATE WARNING SUPPRESSION - HIGHEST PRIORITY
  (function() {
    const originalWarn = window.console.warn;
    const originalError = window.console.error;

    window.console.warn = function(...args) {
      const message = String(args[0] || '');
      if (message.includes('Unrecognized feature') ||
          message.includes('ambient-light-sensor') ||
          message.includes('speaker') ||
          message.includes('vibrate') ||
          message.includes('vr') ||
          message.includes('iframe') ||
          message.includes('sandboxing') ||
          message.includes('tailwind') ||
          message.includes('net state changed')) {
        return; // Suppress
      }
      originalWarn.apply(console, args);
    };

    window.console.error = function(...args) {
      const message = String(args[0] || '');
      if (message.includes('Unsafe attempt to initiate navigation') ||
          message.includes('sandboxed with the') ||
          message.includes('about:blank')) {
        return; // Suppress
      }
      originalError.apply(console, args);
    };
  })();


  (function () {
    const suppressedErrors = [
      'cdn.tailwindcss.com should not be used in production',
      'cdnjs.cloudflare.com',
      'tailwind',
      'TailwindCSS',
      'iframe which has both allow-scripts and allow-same-origin',
      'can escape its sandboxing',
      'An iframe which has both allow-scripts and allow-same-origin',
    ];

    const criticalSyntaxErrors = [
      'Unexpected end of input',
      'Unexpected token',
      'SyntaxError: Unexpected',
      'Invalid or unexpected token',
    ];

    const originalErrorHandler = window.onerror;
    window.onerror = function (message, source, lineno, colno, error) {
      const errorMessage = message ? message.toString() : '';

      const shouldSuppress = suppressedErrors.some((pattern) => errorMessage.includes(pattern));

      if (shouldSuppress) {
        return true; // Suppress known warnings
      }

      const isCritical = criticalSyntaxErrors.some((pattern) => errorMessage.includes(pattern));
      if (isCritical && window.notifications) {
        window.notifications.error('ãƒšãƒ¼ã‚¸ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å†èª­ã¿è¾¼ã¿ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚', 8000);
      }

      if (originalErrorHandler) {
        return originalErrorHandler.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    const originalWarn = console.warn;
    console.warn = function (...args) {
      const message = args.join(' ');
      const shouldSuppress = suppressedErrors.some((pattern) => message.includes(pattern));

      if (shouldSuppress) {
        return; // Suppress known warnings
      }

      originalWarn.apply(console, args);
    };

    window.addEventListener('unhandledrejection', function (event) {
      const reason = event.reason?.toString() || '';
      const shouldSuppress = suppressedErrors.some((pattern) => reason.includes(pattern));

      if (shouldSuppress) {
        event.preventDefault();
        return;
      }

      const isUserImpacting = reason.includes('Failed to fetch') ||
                              reason.includes('Network request failed') ||
                              reason.includes('google.script.run') ||
                              reason.includes('timeout');

      if (isUserImpacting && window.notifications) {
        window.notifications.warning('é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚', 6000);
      }

      console.warn('Unhandled promise rejection:', event.reason);
    });

    const originalCreateElement = document.createElement;
    document.createElement = function (tagName) {
      const element = originalCreateElement.call(this, tagName);

      if (tagName.toLowerCase() === 'script') {
        const originalSrc = element.src;
        Object.defineProperty(element, 'src', {
          get() {
            return originalSrc;
          },
          set(value) {

            if (value.includes('tailwindcss') || value.includes('cdn.')) {
              element.addEventListener('load', () => {
              });

              element.addEventListener('error', (e) => {
                console.error('âŒ External script failed to load:', value, e);
              });
            }

            originalSrc = value;
          },
        });
      }

      return element;
    };
  })();



  class DebounceManager {
    constructor() {
      this.timers = new Map();
    }

    debounce(func, key, delay = 1000) {
      if (this.timers.has(key)) {
        this.timers.delete(key);
      }

      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      const debouncePromise = createPromiseDelay(delay).then(() => {
        if (this.timers.get(key) === debouncePromise) {
          func();
          this.timers.delete(key);
        }
      }).catch(() => {
        this.timers.delete(key);
      });

      this.timers.set(key, debouncePromise);
    }

    clear(key) {
      this.timers.delete(key);
    }

    clearAll() {
      this.timers.clear();
    }
  }

  class ThrottleManager {
    constructor() {
      this.timers = new Map();
      this.lastExecution = new Map();
    }

    throttle(func, key, delay = 100) {
      const now = Date.now();
      const lastRun = this.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func();
        this.lastExecution.set(key, now);
      } else if (!this.timers.has(key)) {
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        const delayTime = delay - (now - lastRun);
        const throttlePromise = createPromiseDelay(delayTime).then(() => {
          if (this.timers.get(key) === throttlePromise) {
            func();
            this.lastExecution.set(key, Date.now());
            this.timers.delete(key);
          }
        }).catch(() => {
          this.timers.delete(key);
        });

        this.timers.set(key, throttlePromise);
      }
    }

    clear(key) {
      this.timers.delete(key);
      this.lastExecution.delete(key);
    }

    clearAll() {
      this.timers.clear();
      this.lastExecution.clear();
    }
  }



  class Cache {
    constructor(maxSize = 100, defaultTTL = 300000) {
      this.cache = new Map();
      this.timestamps = new Map();
      this.ttls = new Map();
      this.maxSize = maxSize;
      this.defaultTTL = defaultTTL;
    }

    set(key, value, ttl = null) {
      const now = Date.now();
      const actualTTL = ttl || this.defaultTTL;

      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.removeOldest();
      }

      this.cache.set(key, value);
      this.timestamps.set(key, now);
      this.ttls.set(key, actualTTL);
    }

    get(key) {
      if (!this.cache.has(key)) {
        return null;
      }

      const now = Date.now();
      const timestamp = this.timestamps.get(key);
      const ttl = this.ttls.get(key);

      if (now - timestamp > ttl) {
        this.delete(key);
        return null;
      }

      return this.cache.get(key);
    }

    has(key) {
      return this.get(key) !== null;
    }

    delete(key) {
      this.cache.delete(key);
      this.timestamps.delete(key);
      this.ttls.delete(key);
    }

    clear() {
      this.cache.clear();
      this.timestamps.clear();
      this.ttls.clear();
    }

    removeOldest() {
      let oldestKey = null;
      let oldestTime = Infinity;

      for (const [key, timestamp] of this.timestamps) {
        if (timestamp < oldestTime) {
          oldestTime = timestamp;
          oldestKey = key;
        }
      }

      if (oldestKey) {
        this.delete(oldestKey);
      }
    }

    cleanup() {
      const now = Date.now();
      const expiredKeys = [];

      for (const [key, timestamp] of this.timestamps) {
        const ttl = this.ttls.get(key);
        if (now - timestamp > ttl) {
          expiredKeys.push(key);
        }
      }

      expiredKeys.forEach((key) => this.delete(key));
    }

    get size() {
      this.cleanup(); // Clean expired entries before returning size
      return this.cache.size;
    }

    getStats() {
      this.cleanup();
      return {
        size: this.cache.size,
        maxSize: this.maxSize,
        defaultTTL: this.defaultTTL,
      };
    }
  }


  /**
   * çµ±ä¸€ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°API - GAS 2025ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹æº–æ‹ 
   * éåŒæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’çµ±åˆ
   */
  class UnifiedDataLoader {
    constructor() {
      this.loadingStates = new Map();
      this.cache = new Map();
      this.abortControllers = new Map();
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      this.defaultTimeout = 30000;
    }

    /**
     * ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã®çµ±ä¸€ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
     * @param {string} functionName - GASé–¢æ•°å
     * @param {Object} options - èª­ã¿è¾¼ã¿ã‚ªãƒ—ã‚·ãƒ§ãƒ³
     * @param {...any} args - GASé–¢æ•°ã¸ã®å¼•æ•°
     * @returns {Promise} ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿çµæœ
     */
    async loadData(functionName, options = {}, ...args) {
      const {
        cache = true,
        cacheKey = null,
        cacheTTL = 300000, // 5åˆ†
        showLoading = true,
        loadingMessage = 'ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...',
        retryOnError = true,
        timeout = this.defaultTimeout
      } = options;

      const funcName = functionName || 'unknown';
      const finalCacheKey = cacheKey || `${funcName}_${JSON.stringify(args || []).substring(0, 50)}`;
      const requestId = `${funcName}_${Date.now()}`;

      try {
        if (cache && this.cache.has(finalCacheKey)) {
          const cached = this.cache.get(finalCacheKey);
          if (Date.now() - cached.timestamp < cacheTTL) {
            return cached.data;
          }
          this.cache.delete(finalCacheKey);
        }

        if (showLoading) {
          this.setLoadingState(requestId, true, loadingMessage);
        }

        const result = await this.executeGASCall(functionName, timeout, ...args);

        if (cache && result) {
          this.cache.set(finalCacheKey, {
            data: result,
            timestamp: Date.now()
          });
        }

        return result;

      } catch (error) {
        console.error(`âŒ [UnifiedDataLoader] ${funcName} ã‚¨ãƒ©ãƒ¼:`, error);

        if (retryOnError && this.shouldRetry(requestId)) {
          return this.loadData(functionName, { ...options, retryOnError: false }, ...args);
        }

        throw error;
      } finally {
        if (showLoading) {
          this.setLoadingState(requestId, false);
        }
        this.cleanup(requestId);
      }
    }

    /**
     * ãƒãƒƒãƒãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ - è¤‡æ•°ã®GASé–¢æ•°ã‚’ä¸¦åˆ—å®Ÿè¡Œ
     * @param {Array} requests - [{functionName, args, options}] ã®é…åˆ—
     * @returns {Promise<Array>} å„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®çµæœé…åˆ—
     */
    async loadBatchData(requests) {

      const promises = requests.map((request, index) => {
        const { functionName, args = [], options = {} } = request;
        return this.loadData(functionName, {
          ...options,
          showLoading: false, // ãƒãƒƒãƒã§ã¯å€‹åˆ¥ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–
        }, ...args).catch(error => {
          console.error(`âŒ [UnifiedDataLoader] ãƒãƒƒãƒ${index || 0}: ${functionName || 'unknown'} ã‚¨ãƒ©ãƒ¼:`, error);
          return { error: error.message, functionName };
        });
      });

      return Promise.all(promises);
    }

    /**
     * GASé–¢æ•°ã®å®Ÿéš›ã®å®Ÿè¡Œ
     * @param {string} functionName - é–¢æ•°å
     * @param {number} timeout - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“
     * @param {...any} args - å¼•æ•°
     * @returns {Promise} å®Ÿè¡Œçµæœ
     */
    executeGASCall(functionName, timeout, ...args) {
      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script?.run) {
          reject(new Error('Google Apps Scriptç’°å¢ƒãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'));
          return;
        }

        const createPromiseTimeout = (ms) => new Promise((_, reject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              reject(new Error(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${functionName || 'unknown'} (${timeout || 0}ms)`));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(timeout);
        const timeoutId = Symbol('promise-timeout');

        let completed = false;
        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              resolve(result);
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              console.error(`âŒ [UnifiedDataLoader] ${functionName || 'unknown'} GASå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:`, error);
              reject(new Error(error.message || error.toString()));
            }
          })
          [functionName](...args);

        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    }

    /**
     * ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ç®¡ç†
     */
    setLoadingState(requestId, isLoading, message = '') {
      if (isLoading) {
        this.loadingStates.set(requestId, { message, startTime: Date.now() });
        if (window.unifiedLoading) {
          window.unifiedLoading.show(message);
        }
      } else {
        this.loadingStates.delete(requestId);
        if (window.unifiedLoading && this.loadingStates.size === 0) {
          window.unifiedLoading.hide();
        }
      }
    }

    /**
     * ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š
     */
    shouldRetry(requestId) {
      const attempts = this.retryAttempts.get(requestId) || 0;
      if (attempts >= this.maxRetries) {
        return false;
      }
      this.retryAttempts.set(requestId, attempts + 1);
      return true;
    }

    /**
     * ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¾Œå‡¦ç†
     */
    cleanup(requestId) {
      this.loadingStates.delete(requestId);
      this.retryAttempts.delete(requestId);
      this.abortControllers.delete(requestId);
    }

    /**
     * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
     */
    clearCache(pattern = null) {
      if (pattern) {
        for (const key of this.cache.keys()) {
          if (key.includes(pattern)) {
            this.cache.delete(key);
          }
        }
      } else {
        this.cache.clear();
      }
    }

    /**
     * çµ±è¨ˆæƒ…å ±å–å¾—
     */
    getStats() {
      return {
        cacheSize: this.cache.size,
        activeRequests: this.loadingStates.size,
        totalRetries: Array.from(this.retryAttempts.values()).reduce((a, b) => a + b, 0)
      };
    }
  }

  window.unifiedDataLoader = new UnifiedDataLoader();

  window.loadData = (functionName, options, ...args) =>
    window.unifiedDataLoader.loadData(functionName, options, ...args);

  window.loadBatchData = (requests) =>
    window.unifiedDataLoader.loadBatchData(requests);



  class ErrorHandler {
    constructor() {
      this.errors = [];
      this.maxErrors = 50;
    }

    logError(error, context = '') {
      try {
        const errorInfo = {
          message: error?.message || error?.toString() || 'Unknown error',
          stack: error?.stack || 'No stack trace available',
          context: context || 'No context provided',
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          errorType: typeof error,
          isObject: typeof error === 'object',
        };

        this.errors.push(errorInfo);

        if (this.errors.length > this.maxErrors) {
          this.errors.shift();
        }

        console.group('ğŸš¨ Error Logged');
        console.groupEnd();
      } catch (loggingError) {
        console.error('Error in error logging:', loggingError);
        console.error('Original error:', error);
      }
    }

    getRecentErrors(count = 10) {
      return this.errors.slice(-count);
    }

    clearErrors() {
      this.errors = [];
    }

    setupGlobalErrorHandling() {
      window.addEventListener('error', (event) => {
        this.logError(event.error, 'Global error handler');
      });

      window.addEventListener('unhandledrejection', (event) => {
        this.logError(event.reason, 'Unhandled promise rejection');
      });
    }
  }


  class LoadingManager {
    constructor() {
      this.loadingStates = new Map();
    }

    setLoading(key, isLoading, message = '') {
      this.loadingStates.set(key, { isLoading, message, timestamp: Date.now() });

      const event = new CustomEvent('loadingStateChange', {
        detail: { key, isLoading, message },
      });
      document.dispatchEvent(event);
    }

    isLoading(key) {
      const state = this.loadingStates.get(key);
      return state ? state.isLoading : false;
    }

    getLoadingMessage(key) {
      const state = this.loadingStates.get(key);
      return state ? state.message : '';
    }

    clearLoading(key) {
      this.loadingStates.delete(key);
      this.setLoading(key, false);
    }

    clearAllLoading() {
      const keys = Array.from(this.loadingStates.keys());
      keys.forEach((key) => this.clearLoading(key));
    }
  }


  // SECURITY UTILITIES

  class SecurityUtilities {
    escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    sanitizeHtml(html) {
      if (!html) return '';
      const div = document.createElement('div');
      div.innerHTML = html;

      const scripts = div.querySelectorAll('script, object, embed, iframe, form');
      scripts.forEach((script) => script.remove());

      return div.innerHTML;
    }

    isValidEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
  }


  class PrivacyLogger {
    static anonymize(data) {
      if (typeof data === 'string') {
        if (data.includes('@')) {
          const parts = data.split('@');
          const safePart0 = (parts[0] && parts[0].substring) ? parts[0].substring(0, 2) : 'xx';
          const safePart1 = parts[1] || 'unknown';
          return `${safePart0}***@${safePart1}`;
        }
        if (data.length > 30) {
          const safeDataPrefix = (data && data.substring) ? data.substring(0, 15) : 'unknown';
          const safeDataLength = (data && data.length) || 0;
          return `${safeDataPrefix}...[${safeDataLength} chars]`;
        }
        return data;
      }

      if (typeof data === 'object' && data !== null) {
        const anonymized = {};
        for (const [key, value] of Object.entries(data)) {
          if (['email', 'userEmail', 'reason', 'opinion', 'answer', 'content'].includes(key)) {
            anonymized[key] = this.anonymize(value);
          } else if (key.includes('Id') && typeof value === 'string') {
            if (value && value.length && value.substring) {
              anonymized[key] = value.length > 8 ? `${value.substring(0, 4)}***` : value;
            } else {
              anonymized[key] = value;
            }
          } else {
            anonymized[key] = value;
          }
        }
        return anonymized;
      }

      return data;
    }

    static log(message, data = null) {
      if (data) {
      } else {
      }
    }

    static warn(message, data = null) {
      if (data) {
        console.warn(message, this.anonymize(data));
      } else {
        console.warn(message);
      }
    }

    static error(message, data = null) {
      if (data) {
        console.error(message, this.anonymize(data));
      } else {
        console.error(message);
      }
    }
  }

  window.sharedUtilities = {
    debounce: new DebounceManager(),
    throttle: new ThrottleManager(),
    cache: new Cache(),
    errors: new ErrorHandler(),
    loading: new LoadingManager(),
    security: new SecurityUtilities(),
    privacy: PrivacyLogger,
  };

  window.sharedUtilities.errors.setupGlobalErrorHandling();

  window.debounce = (func, delay, key = 'default') => {
    if (window.sharedUtilities && window.sharedUtilities.debounce) {
      window.sharedUtilities.debounce.debounce(func, key, delay);
    } else {
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });
      createPromiseDelay(delay).then(func).catch(() => {
      });
    }
  };

  window.throttle = (func, delay, key = 'default') => {
    if (window.sharedUtilities && window.sharedUtilities.throttle) {
      window.sharedUtilities.throttle.throttle(func, key, delay);
    } else {
      func();
    }
  };

  if (!window.UnifiedCache) {
    window.UnifiedCache = Cache;
  }

  window.onDOMReady = function (callback) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', callback);
    } else {
      callback();
    }
  };




  window.sharedUtilities.auth = {
    switchToAnotherAccount: function () {
      if (
        confirm(
          'åˆ¥ã®Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã•ã‚Œã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé¸æŠç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚'
        )
      ) {
        try {
          google.script.run
            .withSuccessHandler(function (result) {
              if (result && result.success) {
                const url = new URL(window.location.href);
                url.searchParams.set('force_account_selection', 'true');
                window.open(url.toString(), '_top');
              } else {
                window.sharedUtilities.auth.showAccountSwitchFallback();
              }
            })
            .withFailureHandler(function (error) {
              console.warn('èªè¨¼ãƒªã‚»ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', error);
              window.sharedUtilities.auth.showAccountSwitchFallback();
            })
            .resetAuth();
        } catch (error) {
          console.warn('ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼:', error);
          window.sharedUtilities.auth.showAccountSwitchFallback();
        }
      }
    },

    showAccountSwitchFallback: function () {
      const msg = `
          ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ã«ã¯ä»¥ä¸‹ã®æ‰‹é †ã‚’ãŠè©¦ã—ãã ã•ã„ï¼š

          1. æ–°ã—ã„ãƒ–ãƒ©ã‚¦ã‚¶ã‚¿ãƒ–ã§Googleï¼ˆgoogle.comï¼‰ã«ã‚¢ã‚¯ã‚»ã‚¹
          2. å³ä¸Šã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯
          3. ã€Œåˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è¿½åŠ ã€ã¾ãŸã¯ä½¿ç”¨ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠ
          4. ã“ã®ãƒšãƒ¼ã‚¸ã«æˆ»ã£ã¦å†åº¦èªè¨¼ã‚’é–‹å§‹

          ã¾ãŸã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ/ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ã§æ–°ã—ã„ã‚¿ãƒ–ã‚’é–‹ã„ã¦ã“ã®ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚
        `;
      alert(msg);
    },

    logout: function () {
      if (confirm('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {

        try {
          if (window.sharedUtilities?.cache?.clear) {
            window.sharedUtilities.cache.clear();
          }
          localStorage.removeItem('current_user_info');
          sessionStorage.clear();
        } catch (e) {
          console.warn('Cache clear partially failed:', e);
        }

        google.script.run
          .withSuccessHandler(function(webAppUrl) {
            const loginUrl = `${webAppUrl}?mode=login`;

            window.open(loginUrl, '_top');

            const createPromiseDelay = (ms) => new Promise(resolve => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            });

            createPromiseDelay(100).then(() => {
              google.script.run
                .withSuccessHandler(function(result) {
                })
                .withFailureHandler(function(error) {
                  console.warn('âš ï¸ Background session clear failed (non-critical):', error);
                })
                .resetAuth();
            }).catch(() => {
            });
          })
          .withFailureHandler(function(error) {
            console.warn('WebApp URLå–å¾—å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ:', error);

            try {
              const currentUrl = new URL(window.location.href);
              const baseUrl = currentUrl.origin + currentUrl.pathname;
              const loginUrl = `${baseUrl}?mode=login`;
              window.open(loginUrl, '_top');
            } catch (fallbackError) {
              console.warn('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é·ç§»ã‚‚å¤±æ•—:', fallbackError);
              window.open(window.location.href, '_top');
            }
          })
          .getWebAppUrl();
      }
    },


    verifyAuthentication: function () {
      return new Promise((resolve, reject) => {
        const createPromiseTimeout = (ms) => new Promise((_, timeoutReject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              timeoutReject(new Error('èªè¨¼ç¢ºèªãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ'));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(10000);
        let completed = false;

        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              if (result && result.authenticated && result.email) {
                resolve(result);
              } else {
                reject(new Error('èªè¨¼ãŒå¿…è¦ã§ã™'));
              }
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              reject(error);
            }
          })
          .checkUserAuthentication();

        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    },

    displayAuthInfo: function (containerId, email, showSwitchOption = true) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const safeEmail =
        window.sharedUtilities && window.sharedUtilities.security
          ? window.sharedUtilities.security.escapeHtml(email)
          : (email || '').replace(/[<>&"']/g, function (match) {
              switch (match) {
                case '<':
                  return '&lt;';
                case '>':
                  return '&gt;';
                case '&':
                  return '&amp;';
                case '"':
                  return '&quot;';
                case "'":
                  return '&#39;';
                default:
                  return match;
              }
            });

      container.innerHTML = `
        <div class="bg-gray-800 rounded-lg p-4 mb-4">
          <p class="text-sm text-gray-400 mb-1">èªè¨¼æ¸ˆã¿ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ:</p>
          <p class="text-white font-semibold">${safeEmail}</p>
        </div>
        ${
          showSwitchOption
            ? `
        <div class="text-right">
          <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
            åˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³
          </button>
        </div>`
            : ''
        }
      `;
    },
  };

  window.switchToAnotherAccount = function () {
    window.sharedUtilities.auth.switchToAnotherAccount();
  };

  window.logout = function () {
    window.sharedUtilities.auth.logout();
  };


  window.sharedUtilities.page = {
    safeReload: function(options = {}) {

      try {
        if (window.sharedUtilities?.cache?.clear) {
          window.sharedUtilities.cache.clear();
        }
        localStorage.removeItem('current_user_info');
        sessionStorage.clear();
      } catch (e) {
        console.warn('Cache clear partially failed during reload:', e);
      }

      try {
        let targetUrl = window.location.href;

        if (options.cleanParams) {
          const currentUrl = new URL(window.location.href);
          const keepParams = options.keepParams || [];
          const params = new URLSearchParams();
          keepParams.forEach(param => {
            if (currentUrl.searchParams.has(param)) {
              params.set(param, currentUrl.searchParams.get(param));
            }
          });
          currentUrl.search = params.toString();
          targetUrl = currentUrl.toString();
        }

        window.location.href = targetUrl;

      } catch (error) {
        console.error('Page reload failed:', error);
        window.location.reload();
      }
    },

    redirectToLogin: function() {
      window.sharedUtilities.auth.logout();
    }
  };

  window.safeReload = function(options) {
    window.sharedUtilities.page.safeReload(options);
  };

  window.redirectToLogin = function() {
    window.sharedUtilities.page.redirectToLogin();
  };


  class UnifiedLoadingManager {
    constructor() {
      this.overlay = null;
      this.initialized = false;
      this.currentState = null;
      this.variantClasses = ['transparent', 'minimal', 'modal'];
    }

    init(retries = 5, delay = 100, onSuccess = null) {
      if (this.initialized) {
        if (onSuccess) onSuccess();
        return true;
      }

      if (document.readyState === 'loading') {
        document.addEventListener(
          'DOMContentLoaded',
          () => {
            requestIdleCallback(() => this.init(retries, delay, onSuccess), { timeout: 50 });
          },
          { once: true }
        );
        return false;
      }

      this.overlay = document.getElementById('loading-overlay');
      if (this.overlay) {
        if (!window.unifiedLoadingInitialized) {
          window.unifiedLoadingInitialized = true;
            'âœ… UnifiedLoadingManager: Initialized successfully with element:',
            this.overlay.className
          );
        }
        this.initialized = true;
        if (onSuccess) onSuccess();
        return true;
      }

      if (retries > 0) {
        console.warn(
          (() => {
            const safeReadyState = (document && document.readyState) || 'unknown';
            const safeDelay = delay || 0;
            const safeRetries = retries || 0;
            return `âš ï¸ UnifiedLoadingManager: loading-overlay element not found. DOM state: ${safeReadyState}. Retrying in ${safeDelay}ms (${safeRetries} retries left)...`;
          })()
        );
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(delay).then(() => this.init(retries - 1, delay * 1.5, onSuccess));
      } else {
        console.error(
          'âŒ UnifiedLoadingManager: Critical failure - loading-overlay element not found after multiple retries.'
        );
        this.createFallbackOverlay();
      }
      return false;
    }

    createFallbackOverlay() {
      if (document.getElementById('loading-overlay')) {
        this.overlay = document.getElementById('loading-overlay');
        this.initialized = true;
        return true;
      }

      console.warn('âš ï¸ UnifiedLoadingManager: Creating fallback loading-overlay element');
      const fallbackOverlay = document.createElement('div');
      fallbackOverlay.id = 'loading-overlay';
      fallbackOverlay.className = 'loading-overlay page-specific hidden';

      if (document.body) {
        document.body.insertBefore(fallbackOverlay, document.body.firstChild);
        this.overlay = fallbackOverlay;
        this.initialized = true;
        return true;
      }
      return false;
    }

    setLoading(isLoading, options = {}) {
      if (!this.initialized) {
        if (!this.init()) {
          return;
        }
      }

      try {
        if (isLoading) {
          this.show(options);
        } else {
          this.hide();
        }
      } catch (error) {
        console.error('UnifiedLoadingManager: Error during loading state change:', error);
      }
    }

    show(options = {}) {
      if (typeof options === 'string') {
        options = { message: options };
      }

      const config = {
        message: options.message || 'å‡¦ç†ä¸­...',
        type: options.type || 'overlay',
        disableInteraction: options.disableInteraction !== false,
        ...options,
      };

      this.currentState = config;

      if (!this.overlay) {
        console.error('UnifiedLoadingManager: Cannot show overlay - element not initialized');
        if (!this.createFallbackOverlay()) {
          return;
        }
      }

      this.variantClasses.forEach((vc) => {
        if (this.overlay && this.overlay.classList) {
          this.overlay.classList.remove(vc);
        }
      });

      if (config.type !== 'overlay' && this.overlay && this.overlay.classList) {
        this.overlay.classList.add(config.type);
      }

      this.updateContent(config);

      if (this.overlay && this.overlay.classList) {
        this.overlay.classList.remove('hidden');
        this.overlay.style.setProperty('display', 'flex', 'important');
      }

      if (config.disableInteraction && config.type !== 'transparent' && this.overlay) {
        document.body.style.overflow = 'hidden';
        document.body.style.pointerEvents = 'none';
        this.overlay.style.pointerEvents = 'auto';
      }

        (() => {
          const safeConfigType = (config && config.type) || 'unknown';
          const safeConfigMessage = (config && config.message) || 'No message';
          return `UnifiedLoadingManager: Overlay shown with type '${safeConfigType}' and message '${safeConfigMessage}'`;
        })()
      );
    }

    hide() {
      if (!this.overlay) return;

      this.overlay.classList.add('hidden');
      this.overlay.style.setProperty('display', 'none', 'important');

      this.variantClasses.forEach((vc) => this.overlay.classList.remove(vc));

      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';

      this.currentState = null;

    }

    updateContent(config) {
      if (!this.overlay) return;

      let messageElement = this.overlay.querySelector('.loading-message');
      if (!messageElement) {
        const rawMessage = (config && config.message) || 'Loading...';
        const safeOverlayMessage = window.sharedUtilities.security.escapeHtml(rawMessage);
        this.overlay.innerHTML = `
          <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-message">${safeOverlayMessage}</div>
          </div>
        `;
        messageElement = this.overlay.querySelector('.loading-message');
      } else {
        messageElement.textContent = config.message;
      }

      const existingProgress = this.overlay.querySelector('.loading-progress');
      if (existingProgress) {
        existingProgress.remove();
      }

      const existingSteps = this.overlay.querySelector('.loading-steps');
      if (existingSteps) {
        existingSteps.remove();
      }
    }

    showOverlay(message = 'å‡¦ç†ä¸­...') {
      this.setLoading(true, { message, type: 'overlay' });
    }

    showTransparent(message = 'å‡¦ç†ä¸­...') {
      this.setLoading(true, { message, type: 'transparent' });
    }
  }

  window.unifiedLoading = new UnifiedLoadingManager();
  document.addEventListener('DOMContentLoaded', () => {
    window.unifiedLoading.init();
  });

  window.setLoading = function (isLoading, message) {
    if (!isLoading) {
      window.unifiedLoading.setLoading(false);
      return;
    }

    if (typeof message === 'object') {
      window.unifiedLoading.setLoading(true, message);
    } else {
      window.unifiedLoading.showOverlay(message || 'å‡¦ç†ä¸­...');
    }
  };

  window.setPartialLoading = function (loading, message) {
    if (loading) {
      const safeInfoMessage = message || 'å‡¦ç†ä¸­...';
      window.showInfo(safeInfoMessage);

      const activeElements = document.querySelectorAll('.partial-loading-target');
      activeElements.forEach((el) => {
        el.classList.add('partial-loading');
        if (!el.dataset.originalText) {
          el.dataset.originalText = el.textContent;
        }
        el.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
        el.disabled = true;
      });
    } else {
      const activeElements = document.querySelectorAll('.partial-loading');
      activeElements.forEach((el) => {
        el.classList.remove('partial-loading');
        if (el.dataset.originalText) {
          el.textContent = el.dataset.originalText;
          delete el.dataset.originalText;
        }
        el.disabled = false;
      });
    }
  };

  // IMMEDIATE WARNING SUPPRESSION - EMERGENCY FIX

  const originalWarn = console.warn;
  const originalError = console.error;

  console.warn = function(...args) {
    const message = String(args[0] || '');
    if (message.includes('Unrecognized feature: \'ambient-light-sensor\'') ||
        message.includes('Unrecognized feature: \'speaker\'') ||
        message.includes('Unrecognized feature: \'vibrate\'') ||
        message.includes('Unrecognized feature: \'vr\'') ||
        message.includes('iframe which has both allow-scripts and allow-same-origin') ||
        message.includes('can escape its sandboxing') ||
        message.includes('tailwind') ||
        message.includes('cdn.tailwindcss.com') ||
        message.includes('net state changed')) {
      return;
    }
    originalWarn.apply(console, args);
  };

  console.error = function(...args) {
    const message = String(args[0] || '');
    if (message.includes('Unsafe attempt to initiate navigation') ||
        message.includes('sandboxed with the') ||
        message.includes('iframe') ||
        message.includes('about:blank')) {
      return;
    }
    originalError.apply(console, args);
  };


  class NotificationSystem {
    constructor() {
      this.container = null;
    }

    createContainer() {
      if (this.container) return;

      this.container = document.createElement('div');
      this.container.style.cssText = `
        position: fixed;
        top: var(--space-5);
        right: var(--space-5);
        z-index: var(--z-notification);
        pointer-events: none;
      `;

      if (document.body) {
        document.body.appendChild(this.container);
      }
    }

    showMessage(message, type = 'info') {
      if (!message) return;

      this.createContainer();

      const notification = document.createElement('div');
      notification.style.cssText = `
        background: ${this.getColor(type)};
        color: white;
        padding: var(--space-3) var(--space-4);
        border-radius: var(--radius-md);
        margin-bottom: var(--space-2);
        box-shadow: var(--shadow-md);
        pointer-events: auto;
        cursor: pointer;
        font-size: 14px;
        max-width: 350px;
        word-wrap: break-word;
        animation: fadeInFromRight 0.4s ease-out forwards;
        will-change: transform, opacity;
      `;

      notification.textContent = `${this.getIcon(type)} ${message}`;
      notification.onclick = () => this.remove(notification);

      this.container.appendChild(notification);

      const duration = this.getDuration(type);
      const startTime = Date.now();
      const checkRemoval = () => {
        if (Date.now() - startTime >= duration) {
          this.remove(notification);
        } else {
          requestAnimationFrame(checkRemoval);
        }
      };
      requestAnimationFrame(checkRemoval);
    }

    remove(notification) {
      if (notification && notification.parentNode) {
        notification.style.animation = 'fadeOut 0.3s ease-out forwards';
        notification.style.willChange = 'transform, opacity';

        setTimeout(() => {
          if (notification && notification.parentNode) {
            notification.remove();
          }
        }, 300);
      }
    }

    success(message) { this.showMessage(message, 'success'); }
    error(message) { this.showMessage(message, 'error'); }
    warning(message) { this.showMessage(message, 'warning'); }
    info(message) { this.showMessage(message, 'info'); }

    getColor(type) {
      const colors = {
        success: 'var(--status-success)',
        error: 'var(--status-error)',
        warning: 'var(--status-warning)',
        info: 'var(--status-info)'
      };
      return colors[type] || colors.info;
    }

    getIcon(type) {
      const icons = { success: 'âœ…', error: 'âŒ', warning: 'âš ï¸', info: 'â„¹ï¸' };
      return icons[type] || icons.info;
    }

    getDuration(type) {
      const durations = { success: 3000, error: 5000, warning: 4000, info: 3000 };
      return durations[type] || 3000;
    }


  }

  window.notifications = new NotificationSystem();

  window.showMessage = (message, type) => window.notifications.showMessage(message, type);
  window.showSuccess = (message) => window.notifications.showMessage(message, 'success');
  window.showError = (message) => window.notifications.showMessage(message, 'error');
  window.showWarning = (message) => window.notifications.showMessage(message, 'warning');
  window.showInfo = (message) => window.notifications.showMessage(message, 'info');



  window.getPerformanceLevel = function() {
    if (typeof navigator === 'undefined') return 'medium';

    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const connection = navigator.connection;

    if (memory >= 8 && cores >= 8) return 'high';

    if (memory <= 2 || cores <= 2) return 'low';

    if (connection) {
      const { effectiveType, downlink } = connection;
      if (effectiveType === '2g' || (downlink && downlink < 1)) return 'low';
      if (effectiveType === '4g' && downlink && downlink > 10) return 'high';
    }

    return 'medium';
  };

  window.isLowEndDevice = function() {
    if (typeof navigator === 'undefined') return false;

    const memory = navigator.deviceMemory;
    const cores = navigator.hardwareConcurrency;

    return (memory && memory <= 2) || (cores && cores <= 2);
  };

  window.getPerformanceConstants = function() {
    const perfLevel = window.getPerformanceLevel();
    const isLowEnd = window.isLowEndDevice();

    return {
      BASE_RENDER_BATCH_SIZE: perfLevel === 'high' ? 15 : perfLevel === 'low' ? 5 : 10,
      LOW_PERF_BATCH_SIZE: isLowEnd ? 3 : 5,
      HIGH_PERF_BATCH_SIZE: perfLevel === 'high' ? 25 : 15,
      VIEWPORT_BUFFER: perfLevel === 'high' ? 300 : perfLevel === 'low' ? 100 : 200,
      PERFORMANCE_BUDGET: perfLevel === 'high' ? 12 : perfLevel === 'low' ? 24 : 16,
      CHUNK_SIZE: perfLevel === 'high' ? 8 : perfLevel === 'low' ? 3 : 5,
      IDLE_TIMEOUT: isLowEnd ? 8000 : 5000
    };
  };

  window.getBatchSize = function(type = 'base') {
    const constants = window.getPerformanceConstants();
    const safeType = (type && type.toUpperCase) ? type.toUpperCase() : 'DEFAULT';
    return constants[`${safeType}_BATCH_SIZE`] || constants.BASE_RENDER_BATCH_SIZE;
  };

  window.getViewportBuffer = function() {
    return window.getPerformanceConstants().VIEWPORT_BUFFER;
  };

  window.getPerformanceBudget = function() {
    return window.getPerformanceConstants().PERFORMANCE_BUDGET;
  };

  window.getChunkSize = function() {
    return window.getPerformanceConstants().CHUNK_SIZE;
  };

  window.getIdleTimeout = function() {
    return window.getPerformanceConstants().IDLE_TIMEOUT;
  };


  /**
   * çµ±ä¸€UNIFIED_CONFIGæ§‹ç¯‰é–¢æ•° - CLAUDE.mdæº–æ‹ 
   * @param {Object} CONFIG - ãƒ‘ãƒ¼ã‚¹æ¸ˆã¿configJSON
   * @param {Object} legacyVars - ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ•°
   * @param {Object} pageDefaults - ãƒšãƒ¼ã‚¸å›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
   * @returns {Object} çµ±ä¸€è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  window.sharedUtilities.createUnifiedConfig = function(CONFIG, legacyVars = {}, pageDefaults = {}) {
    const safeUserId = (value) => {
      return (typeof value === 'string' && !value.startsWith('<')) ? value : '';
    };

    return {
      userId: CONFIG.userId || safeUserId(legacyVars.__USER_ID__),
      targetUserId: pageDefaults.targetUserId || CONFIG.userId || safeUserId(legacyVars.__USER_ID__),
      userEmail: CONFIG.userEmail || '',
      questionText: CONFIG.questionText || 'å›ç­”ãƒœãƒ¼ãƒ‰',
      isPublished: CONFIG.isPublished || false,
      isEditor: CONFIG.isEditor !== undefined ? CONFIG.isEditor : (pageDefaults.isEditor || false),
      isAdminUser: CONFIG.isAdminUser || (pageDefaults.isAdminUser || false),
      isOwnBoard: CONFIG.isOwnBoard || (pageDefaults.isOwnBoard || false),
      formUrl: CONFIG.formUrl || '',
      formTitle: CONFIG.formTitle || '',
      showDetails: CONFIG.showDetails !== false,
      setupStatus: CONFIG.setupStatus || 'pending',
      displaySettings: CONFIG.displaySettings || { showNames: false, showReactions: false },
      columnMapping: CONFIG.columnMapping || {}
    };
  };


  /**
   * ã‚·ãƒ³ãƒ—ãƒ«ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºé–¢æ•°
   * é–‹ç™ºè€…ãŒå•é¡Œã‚’ç‰¹å®šã§ãã‚‹æœ€å°é™ã®æƒ…å ±ã‚’ä¸­å¤®ãƒ¢ãƒ¼ãƒ€ãƒ«ã§è¡¨ç¤º
   */
  window.showSimpleError = function(message) {
    if (!message) return;

    const existingModal = document.getElementById('simple-error-modal');
    if (existingModal) existingModal.remove();

    const modalHTML = `
      <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" id="simple-error-modal">
        <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 text-white">
          <div class="flex items-center mb-4">
            <span class="text-2xl mr-3">âŒ</span>
            <h3 class="text-lg font-semibold">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h3>
          </div>
          <p class="text-gray-300 mb-6">${message}</p>
          <div class="text-right">
            <button onclick="document.getElementById('simple-error-modal').remove()"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white">
              OK
            </button>
          </div>
        </div>
      </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHTML);
  };


  if (!window.sharedUtilitiesLoaded) {
    window.sharedUtilitiesLoaded = true;
      'âœ… SharedUtilities loaded successfully - Version 3.0.0-flat (Zero-Dependency Architecture)'
    );
  }
</script>
