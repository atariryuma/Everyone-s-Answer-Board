<script>
/* =============================================================================
   StudyQuest - Shared JavaScript Utilities
   GAS Compatible utility functions for all HTML files
   ============================================================================= */

// =============================================================================
// PERFORMANCE UTILITIES
// =============================================================================

// Debounce function with key-based tracking
class DebounceManager {
  constructor() {
    this.timers = new Map();
  }
  
  debounce(func, key, delay = 1000) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }
    const timeoutId = setTimeout(() => {
      func();
      this.timers.delete(key);
    }, delay);
    this.timers.set(key, timeoutId);
  }
  
  clear(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
  }
  
  clearAll() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
  }
}

// Throttle function with key-based tracking
class ThrottleManager {
  constructor() {
    this.timers = new Map();
    this.lastExecution = new Map();
  }
  
  throttle(func, key, delay = 100) {
    const now = Date.now();
    const lastRun = this.lastExecution.get(key) || 0;
    
    if (now - lastRun >= delay) {
      func();
      this.lastExecution.set(key, now);
    } else if (!this.timers.has(key)) {
      const timeoutId = setTimeout(() => {
        func();
        this.lastExecution.set(key, Date.now());
        this.timers.delete(key);
      }, delay - (now - lastRun));
      this.timers.set(key, timeoutId);
    }
  }
  
  clear(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    this.lastExecution.delete(key);
  }
  
  clearAll() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
    this.lastExecution.clear();
  }
}

// =============================================================================
// DOM UTILITIES
// =============================================================================

// Enhanced DOM utility functions
class DOMUtilities {
  constructor() {
    this.elementCache = new Map();
  }
  
  // Safe element creation
  createSafeElement(tag, className, textContent) {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (textContent) element.textContent = textContent;
    return element;
  }
  
  // Safe element selection with caching
  getCachedElement(id) {
    if (this.elementCache.has(id)) {
      return this.elementCache.get(id);
    }
    
    const element = document.getElementById(id);
    if (element) {
      this.elementCache.set(id, element);
    } else {
      console.warn('Element not found:', id);
    }
    return element;
  }
  
  // Batch cache multiple elements
  cacheElements(elementIds) {
    const cached = {};
    elementIds.forEach(id => {
      cached[id] = this.getCachedElement(id);
    });
    return cached;
  }
  
  // Clear element cache
  clearElementCache(id = null) {
    if (id) {
      this.elementCache.delete(id);
    } else {
      this.elementCache.clear();
    }
  }
  
  // Safe button state management
  setButtonState(button, isDisabled, text) {
    if (!button) return;
    button.disabled = isDisabled;
    if (text) button.textContent = text;
  }
  
  // Safe text content setting
  setSafeTextContent(element, text) {
    if (!element) return;
    element.textContent = text || '';
  }
  
  // Safe class toggling
  toggleClass(element, className, condition) {
    if (!element) return;
    if (condition) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }
  
  // Safe event listener management
  addSafeEventListener(element, event, handler, options = {}) {
    if (!element) return null;
    element.addEventListener(event, handler, options);
    return handler;
  }
  
  removeSafeEventListener(element, event, handler) {
    if (!element || !handler) return;
    element.removeEventListener(event, handler);
  }
}

// =============================================================================
// CACHE MANAGEMENT
// =============================================================================

// Enhanced cache manager with TTL and size limits
class EnhancedCache {
  constructor(maxSize = 100, defaultTTL = 300000) { // 5 minutes default
    this.cache = new Map();
    this.timestamps = new Map();
    this.ttls = new Map();
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;
  }
  
  set(key, value, ttl = null) {
    const now = Date.now();
    const actualTTL = ttl || this.defaultTTL;
    
    // If cache is full, remove oldest entry
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.removeOldest();
    }
    
    this.cache.set(key, value);
    this.timestamps.set(key, now);
    this.ttls.set(key, actualTTL);
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return null;
    }
    
    const now = Date.now();
    const timestamp = this.timestamps.get(key);
    const ttl = this.ttls.get(key);
    
    if (now - timestamp > ttl) {
      this.delete(key);
      return null;
    }
    
    return this.cache.get(key);
  }
  
  has(key) {
    return this.get(key) !== null;
  }
  
  delete(key) {
    this.cache.delete(key);
    this.timestamps.delete(key);
    this.ttls.delete(key);
  }
  
  clear() {
    this.cache.clear();
    this.timestamps.clear();
    this.ttls.clear();
  }
  
  removeOldest() {
    let oldestKey = null;
    let oldestTime = Infinity;
    
    for (const [key, timestamp] of this.timestamps) {
      if (timestamp < oldestTime) {
        oldestTime = timestamp;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.delete(oldestKey);
    }
  }
  
  cleanup() {
    const now = Date.now();
    const expiredKeys = [];
    
    for (const [key, timestamp] of this.timestamps) {
      const ttl = this.ttls.get(key);
      if (now - timestamp > ttl) {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.delete(key));
  }
  
  get size() {
    this.cleanup(); // Clean expired entries before returning size
    return this.cache.size;
  }
  
  getStats() {
    this.cleanup();
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      defaultTTL: this.defaultTTL
    };
  }
}

// =============================================================================
// ERROR HANDLING UTILITIES
// =============================================================================

class ErrorHandler {
  constructor() {
    this.errors = [];
    this.maxErrors = 50;
  }
  
  logError(error, context = '') {
    const errorInfo = {
      message: error.message || error,
      stack: error.stack,
      context: context,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent
    };
    
    this.errors.push(errorInfo);
    
    // Keep only recent errors
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    console.error('Error logged:', errorInfo);
  }
  
  getRecentErrors(count = 10) {
    return this.errors.slice(-count);
  }
  
  clearErrors() {
    this.errors = [];
  }
  
  setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      this.logError(event.error, 'Global error handler');
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.logError(event.reason, 'Unhandled promise rejection');
    });
  }
}

// =============================================================================
// LOADING STATE MANAGEMENT
// =============================================================================

class LoadingManager {
  constructor() {
    this.loadingStates = new Map();
  }
  
  setLoading(key, isLoading, message = '') {
    this.loadingStates.set(key, { isLoading, message, timestamp: Date.now() });
    
    // Emit custom event for UI updates
    const event = new CustomEvent('loadingStateChange', {
      detail: { key, isLoading, message }
    });
    document.dispatchEvent(event);
  }
  
  isLoading(key) {
    const state = this.loadingStates.get(key);
    return state ? state.isLoading : false;
  }
  
  getLoadingMessage(key) {
    const state = this.loadingStates.get(key);
    return state ? state.message : '';
  }
  
  clearLoading(key) {
    this.loadingStates.delete(key);
    this.setLoading(key, false);
  }
  
  clearAllLoading() {
    const keys = Array.from(this.loadingStates.keys());
    keys.forEach(key => this.clearLoading(key));
  }
}

// =============================================================================
// GAS INTEGRATION UTILITIES
// =============================================================================

class GASUtilities {
  constructor() {
    this.callCache = new EnhancedCache(50, 1000); // 1 second cache for API calls
  }
  
  // Cached GAS function call
  callWithCache(functionName, cacheKey, ttl, ...args) {
    const cached = this.callCache.get(cacheKey);
    if (cached) {
      return Promise.resolve(cached);
    }
    
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(result => {
          this.callCache.set(cacheKey, result, ttl);
          resolve(result);
        })
        .withFailureHandler(reject)
        [functionName](...args);
    });
  }
  
  // Simple GAS function call
  call(functionName, ...args) {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)
        [functionName](...args);
    });
  }
  
  // Check if running in GAS environment
  isGASEnvironment() {
    return typeof google !== 'undefined' && 
           google.script && 
           google.script.run;
  }
}

// =============================================================================
// INITIALIZATION AND GLOBAL SETUP
// =============================================================================

// Initialize global utilities
window.sharedUtilities = {
  debounce: new DebounceManager(),
  throttle: new ThrottleManager(),
  dom: new DOMUtilities(),
  cache: new EnhancedCache(),
  errors: new ErrorHandler(),
  loading: new LoadingManager(),
  gas: new GASUtilities()
};

// Setup global error handling
window.sharedUtilities.errors.setupGlobalErrorHandling();

// Helper functions for backward compatibility
window.debounce = (func, delay, key = 'default') => {
  window.sharedUtilities.debounce.debounce(func, key, delay);
};

window.throttle = (func, delay, key = 'default') => {
  window.sharedUtilities.throttle.throttle(func, key, delay);
};

// Global cache instance for backward compatibility
if (!window.UnifiedCache) {
  window.UnifiedCache = EnhancedCache;
}

// DOM ready utility
window.onDOMReady = function(callback) {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', callback);
  } else {
    callback();
  }
};

// Debug function for console access
window.getSharedUtilitiesStats = function() {
  return {
    debounceTimers: window.sharedUtilities.debounce.timers.size,
    throttleTimers: window.sharedUtilities.throttle.timers.size,
    cacheSize: window.sharedUtilities.cache.size,
    cacheStats: window.sharedUtilities.cache.getStats(),
    domCacheSize: window.sharedUtilities.dom.elementCache.size,
    recentErrors: window.sharedUtilities.errors.getRecentErrors(5),
    loadingStates: Object.fromEntries(window.sharedUtilities.loading.loadingStates),
    gasEnvironment: window.sharedUtilities.gas.isGASEnvironment()
  };
};

// Performance monitoring
window.clearAllSharedUtilities = function() {
  window.sharedUtilities.debounce.clearAll();
  window.sharedUtilities.throttle.clearAll();
  window.sharedUtilities.cache.clear();
  window.sharedUtilities.dom.clearElementCache();
  window.sharedUtilities.errors.clearErrors();
  window.sharedUtilities.loading.clearAllLoading();
  console.log('🧹 All SharedUtilities cleared');
};

// Integration test function
window.testSharedUtilities = function() {
  console.group('🧪 SharedUtilities Integration Test');
  
  // Test debounce
  let debounceCount = 0;
  const testDebounce = () => debounceCount++;
  window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);
  window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);
  
  setTimeout(() => {
    console.log('Debounce test:', debounceCount === 1 ? '✅ PASS' : '❌ FAIL');
  }, 150);
  
  // Test cache
  window.sharedUtilities.cache.set('test', 'value', 1000);
  const cached = window.sharedUtilities.cache.get('test');
  console.log('Cache test:', cached === 'value' ? '✅ PASS' : '❌ FAIL');
  
  // Test DOM utilities
  const testEl = window.sharedUtilities.dom.createSafeElement('div', 'test-class', 'test');
  console.log('DOM creation test:', testEl.className === 'test-class' ? '✅ PASS' : '❌ FAIL');
  
  // Test error handling
  window.sharedUtilities.errors.logError(new Error('Test error'), 'Integration test');
  const errors = window.sharedUtilities.errors.getRecentErrors(1);
  console.log('Error handling test:', errors.length > 0 ? '✅ PASS' : '❌ FAIL');
  
  console.groupEnd();
  return window.getSharedUtilitiesStats();
};

// =============================================================================
// AUTHENTICATION UTILITIES
// =============================================================================

// Shared authentication functions for consistent behavior across pages
window.sharedUtilities.auth = {
  // Account switching functionality shared across pages
  switchToAnotherAccount: function() {
    if (confirm('別のGoogleアカウントでログインしますか？現在のセッションからログアウトされ、アカウント選択画面が表示されます。')) {
      try {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              const url = new URL(window.location.href);
              url.searchParams.set('force_account_selection', 'true');
              window.location.replace(url.toString());
            } else {
              window.sharedUtilities.auth.showAccountSwitchFallback();
            }
          })
          .withFailureHandler(function(error) {
            console.warn('認証リセットエラー:', error);
            window.sharedUtilities.auth.showAccountSwitchFallback();
          })
          .resetUserAuthentication();
      } catch (error) {
        console.warn('アカウント切り替えエラー:', error);
        window.sharedUtilities.auth.showAccountSwitchFallback();
      }
    }
  },

  // Fallback guidance when automatic switch fails
  showAccountSwitchFallback: function() {
    const msg = `
        アカウントを切り替えるには以下の手順をお試しください：

        1. 新しいブラウザタブでGoogle（google.com）にアクセス
        2. 右上のプロフィール画像をクリック
        3. 「別のアカウントを追加」または使用したいアカウントを選択
        4. このページに戻って再度認証を開始

        または、ブラウザのシークレット/プライベートモードで新しいタブを開いてこのページにアクセスしてください。
      `;
    alert(msg);
  },
  
  // Authentication verification with promise
  verifyAuthentication: function() {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('認証確認がタイムアウトしました'));
      }, 10000);

      google.script.run
        .withSuccessHandler(result => {
          clearTimeout(timeoutId);
          if (result && result.authenticated && result.email) {
            resolve(result);
          } else {
            reject(new Error('認証が必要です'));
          }
        })
        .withFailureHandler(error => {
          clearTimeout(timeoutId);
          reject(error);
        })
        .verifyUserAuthentication();
    });
  },
  
  // Display authentication info in standardized format
  displayAuthInfo: function(containerId, email, showSwitchOption = true) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="bg-gray-800 rounded-lg p-4 mb-4">
        <p class="text-sm text-gray-400 mb-1">認証済みアカウント:</p>
        <p class="text-white font-semibold">${window.sharedUtilities.security.escapeHtml(email)}</p>
      </div>
      ${showSwitchOption ? `
      <div class="text-right">
        <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
          別のアカウントでログイン
        </button>
      </div>` : ''}
    `;
  }
};

// Global function for backward compatibility
window.switchToAnotherAccount = function() {
  window.sharedUtilities.auth.switchToAnotherAccount();
};

// =============================================================================
// SECURITY UTILITIES
// =============================================================================

// Security utilities for safe HTML and URL handling
window.sharedUtilities.security = {
  // HTML escape function for preventing XSS
  escapeHtml: function(text) {
    if (!text) return '';
    return String(text)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  },
  
  // URL validation for safe navigation
  isValidUrl: function(url) {
    try {
      new URL(url);
      return true;
    } catch (e) {
      return false;
    }
  },
  
  // Safe URL construction for relative paths
  buildSafeUrl: function(base, params = {}) {
    try {
      const url = new URL(base);
      Object.keys(params).forEach(key => {
        url.searchParams.set(key, params[key]);
      });
      return url.toString();
    } catch (e) {
      console.warn('Invalid URL construction:', e);
      return base;
    }
  }
};

// =============================================================================
// IFRAME-SAFE NAVIGATION UTILITIES
// =============================================================================

// Navigation utilities for Google Apps Script iframe context
window.sharedUtilities.navigation = {
  
  // Safely navigate to a URL within iframe constraints
  safeNavigate: function(url, options = {}) {
    const {
      delay = 1000,
      fallbackMessage = '画面を移動中...',
      useClose = false,
      method = 'auto'
    } = options;
    
    console.log('safeNavigate:', { url, method, delay, useClose });
    
    // Method selection based on context
    const actualMethod = method === 'auto' ? this.detectBestMethod() : method;

    // Try closing the window first when explicitly requested
    let success = false;
    if (useClose) {
      success = this.navigateWithClose(url, delay);
    }

    // Try other methods in sequence with fallbacks
    
    switch (actualMethod) {
      case 'close':
        if (!success) success = this.navigateWithClose(url, delay);
        if (!success) success = this.navigateWithMessage(url, fallbackMessage);
        if (!success) success = this.navigateWithRedirect(url, delay);
        break;
      case 'message':
        if (!success) success = this.navigateWithMessage(url, fallbackMessage);
        if (!success) success = this.navigateWithRedirect(url, delay);
        break;
      case 'redirect':
        if (!success) success = this.navigateWithRedirect(url, delay);
        break;
      default:
        if (!success) success = this.navigateWithRedirect(url, delay);
    }
    
    // Final fallback if all methods fail
    if (!success) {
      this.navigateWithFallback(url, fallbackMessage);
    }
  },
  
  // Method 1: Use google.script.host.close() if available
  navigateWithClose: function(url, delay = 1000) {
    try {
      if (typeof google !== 'undefined' && 
          google.script && 
          google.script.host &&
          typeof google.script.host.close === 'function') {
        console.log('Using google.script.host.close() method');
        setTimeout(() => {
          try {
            google.script.host.close();
          } catch (closeError) {
            console.warn('google.script.host.close() execution failed:', closeError);
            // Fallback to next method
            this.navigateWithMessage(url, 'アプリを閉じています...');
          }
        }, delay);
        this.showNavigationMessage('アプリを閉じています...', delay);
        return true;
      }
    } catch (e) {
      console.warn('google.script.host.close() failed:', e);
    }
    return false;
  },
  
  // Method 2: Use window messaging to parent
  navigateWithMessage: function(url, message) {
    try {
      console.log('Using parent messaging method');
      if (window.parent && window.parent !== window) {
        // Try multiple messaging approaches
        try {
          window.parent.postMessage({
            type: 'navigate',
            url: url,
            source: 'StudyQuest'
          }, '*');
        } catch (e) {
          console.warn('PostMessage failed, trying alternative method:', e);
        }
        
        // Google Apps Script specific: Try to navigate parent directly
        try {
          setTimeout(() => {
            window.parent.location.href = url;
          }, 1000);
        } catch (e) {
          console.warn('Parent navigation failed:', e);
          // Fall back to redirect method
          return this.navigateWithRedirect(url, 1000);
        }
        
        this.showNavigationMessage(message, 2000);
        return true;
      }
    } catch (e) {
      console.warn('Parent messaging failed:', e);
    }
    return false;
  },
  
  // Method 3: Direct redirect (for same-origin)
  navigateWithRedirect: function(url, delay = 1000) {
    try {
      console.log('Using direct redirect method');
      setTimeout(() => {
        window.location.href = url;
      }, delay);
      this.showNavigationMessage('ページを移動中...', delay);
      return true;
    } catch (e) {
      console.warn('Direct redirect failed:', e);
    }
    return false;
  },
  
  // Method 4: User-triggered fallback
  navigateWithFallback: function(url, message) {
    console.log('Using manual fallback method');
    this.showManualNavigationDialog(url, message);
  },
  
  // Detect the best navigation method for current context
  detectBestMethod: function() {
    // Check if we're in an iframe
    const isIframe = window !== window.top;
    
    // Check if google.script.host.close is available
    const hasGoogleScriptHostClose = typeof google !== 'undefined' && 
                                     google.script && 
                                     google.script.host &&
                                     typeof google.script.host.close === 'function';
    
    // Check if google.script.run is available (for server-side navigation)
    const hasGoogleScriptRun = typeof google !== 'undefined' && 
                               google.script && 
                               google.script.run;
    
    // Check current URL origin vs target
    const currentOrigin = window.location.origin;
    
    console.log('Navigation context:', {
      isIframe,
      hasGoogleScriptHostClose,
      hasGoogleScriptRun,
      currentOrigin
    });
    
    // For iframe environments, prefer direct redirect
    if (isIframe) {
      return 'redirect';
    } else if (hasGoogleScriptHostClose) {
      return 'close';
    } else {
      return 'redirect';
    }
  },
  
  // Show navigation message to user
  showNavigationMessage: function(message, duration = 2000) {
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 20px 30px;
      border-radius: 10px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 10000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 16px;
      /* Backdrop blur handled by unified CSS classes */
      border: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
    `;
    messageDiv.textContent = message;
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
      if (messageDiv.parentNode) {
        messageDiv.parentNode.removeChild(messageDiv);
      }
    }, duration);
  },
  
  // Show manual navigation dialog when automatic methods fail
  showManualNavigationDialog: function(url, message) {
    const dialog = document.createElement('div');
    dialog.style.cssText = `
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(15, 23, 42, 0.9);
      /* Backdrop blur handled by unified CSS classes */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    
    dialog.innerHTML = `
      <div style="
        background: rgba(30, 41, 59, 0.95);
        border: 1px solid rgba(6, 182, 212, 0.3);
        border-radius: 16px;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        width: 100%; max-width: 500px;
        padding: 32px;
        margin: 20px;
        color: white;
        text-align: center;
      ">
        <div style="
          width: 48px; height: 48px;
          background: linear-gradient(135deg, #06b6d4 0%, #a855f7 100%);
          border-radius: 50%;
          margin: 0 auto 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 24px;
        ">✓</div>
        <h3 style="margin: 0 0 16px 0; font-size: 22px; font-weight: 600; color: #06b6d4;">
          ${message}
        </h3>
        <p style="margin: 0 0 24px 0; color: rgba(255, 255, 255, 0.8); line-height: 1.5; font-size: 16px;">
          続行するには下のボタンをクリックしてください。
        </p>
        <button onclick="
          try { 
            window.parent.location.href='${url}'; 
          } catch(e) { 
            window.open('${url}', '_top'); 
          }
          this.parentElement.parentElement.remove();
        " style="
          background: linear-gradient(135deg, #06b6d4 0%, #a855f7 100%);
          border: none;
          border-radius: 8px;
          color: white;
          padding: 14px 28px;
          font-size: 16px;
          font-weight: 600;
          cursor: pointer;
          margin-right: 12px;
          transition: transform 0.2s ease;
          box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(6, 182, 212, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)'">
          管理パネルを開く
        </button>
        <button onclick="window.open('${url}', '_blank'); this.parentElement.parentElement.remove();" style="
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 8px;
          color: white;
          padding: 14px 28px;
          font-size: 16px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        " onmouseover="this.style.background='rgba(255, 255, 255, 0.15)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'">
          新しいタブで開く
        </button>
      </div>
    `;
    
    document.body.appendChild(dialog);
    
    // Auto-close after 10 seconds
    setTimeout(() => {
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    }, 10000);
  },
  
  // Server-side navigation for iframe environments
  navigateWithServer: function(url, message = '移動中...') {
    try {
      console.log('Using server-side navigation method');
      
      // Show immediate feedback
      this.showNavigationMessage(message, 5000);
      
      // Call server-side navigation function
      google.script.run
        .withSuccessHandler(result => {
          if (result && result.success && result.redirectUrl) {
            // Server provided a redirect URL, try to navigate
            console.log('Server navigation success, redirecting to:', result.redirectUrl);
            
            // For iframe environments, try different approaches
            if (window !== window.top) {
              console.log('Iframe detected, using alternative navigation');
              
              // Method 1: Try to replace the entire parent window
              try {
                if (window.parent && window.parent.location) {
                  window.parent.location.replace(result.redirectUrl);
                  return;
                }
              } catch (e) {
                console.warn('Parent location.replace failed:', e);
              }
              
              // Method 2: Use window.open with _top target
              try {
                window.open(result.redirectUrl, '_top');
                return;
              } catch (e) {
                console.warn('window.open _top failed:', e);
              }
              
              // Method 3: Manual dialog as final fallback
              this.showManualNavigationDialog(result.redirectUrl, result.message || message);
            } else {
              // Non-iframe environment
              setTimeout(() => {
                try {
                  window.location.href = result.redirectUrl;
                } catch (e) {
                  console.warn('Direct navigation failed, showing manual dialog');
                  this.showManualNavigationDialog(result.redirectUrl, result.message || message);
                }
              }, 1000);
            }
          } else {
            console.warn('Server navigation failed:', result);
            this.showManualNavigationDialog(url, 'サーバー側の移動処理に失敗しました');
          }
        })
        .withFailureHandler(error => {
          console.error('Server navigation error:', error);
          this.showManualNavigationDialog(url, 'ナビゲーション処理でエラーが発生しました');
        })
        .performServerSideNavigation(url, message);
      
      return true;
    } catch (e) {
      console.warn('Server-side navigation failed:', e);
      return false;
    }
  },
  
  // Quick navigation to admin panel (commonly used)
  goToAdminPanel: function(adminUrl, delay = 2000) {
    // Try server-side navigation first for iframe environments
    if (window !== window.top) {
      this.navigateWithServer(adminUrl, '管理パネルに移動中...');
    } else {
      this.safeNavigate(adminUrl, {
        delay: delay,
        fallbackMessage: '管理パネルに移動中...',
        method: 'auto'
      });
    }
  },
  
  // Quick navigation with success message
  navigateWithSuccess: function(url, successMessage = '処理が完了しました', delay = 3000) {
    this.showNavigationMessage(successMessage, delay);
    setTimeout(() => {
      // Use server-side navigation for iframe environments
      if (window !== window.top) {
        this.navigateWithServer(url, successMessage);
      } else {
        this.safeNavigate(url, {
          delay: 1000,
          method: 'auto'
        });
      }
    }, delay - 1000);
  }
};

// Global convenience functions
window.safeNavigate = function(url, options) {
  window.sharedUtilities.navigation.safeNavigate(url, options);
};

window.goToAdminPanel = function(adminUrl, delay) {
  window.sharedUtilities.navigation.goToAdminPanel(adminUrl, delay);
};

console.log('✅ SharedUtilities loaded successfully - Version 1.2.0 (iframe navigation fixed)');
</script>
