<script>
  /* =============================================================================
     StudyQuest - Shared JavaScript Utilities
     GAS Compatible utility functions for all HTML files
     ============================================================================= */

  // =============================================================================
  // ENHANCED ERROR HANDLING FOR ASYNC/AWAIT ISSUES
  // =============================================================================

  // Global error handling for Google Apps Script compatibility issues
  (function () {
    // Simplified error suppression - safe for GAS template processing
    const suppressedErrors = [
      'cdn.tailwindcss.com should not be used in production',
      'cdnjs.cloudflare.com',
      'tailwind',
      'TailwindCSS',
      'iframe which has both allow-scripts and allow-same-origin',
      'can escape its sandboxing',
      // ‚úÖ „Éñ„É©„Ç¶„Ç∂„Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„ÇπË≠¶ÂëäÊäëÂà∂
      'An iframe which has both allow-scripts and allow-same-origin',
    ];

    // Syntax errors that need special logging (not suppressed)
    const criticalSyntaxErrors = [
      'Unexpected end of input',
      'Unexpected token',
      'SyntaxError: Unexpected',
      'Invalid or unexpected token',
    ];

    // Simplified and safe error handling for GAS template processing
    const originalErrorHandler = window.onerror;
    window.onerror = function (message, source, lineno, colno, error) {
      const errorMessage = message ? message.toString() : '';

      // Only suppress specific known warnings that interfere with GAS
      const shouldSuppress = suppressedErrors.some((pattern) => errorMessage.includes(pattern));

      if (shouldSuppress) {
        return true; // Suppress known warnings
      }

      // Show critical errors as notifications
      const isCritical = criticalSyntaxErrors.some((pattern) => errorMessage.includes(pattern));
      if (isCritical && window.notifications) {
        window.notifications.error('„Éö„Éº„Ç∏„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂÜçË™≠„ÅøËæº„Åø„Çí„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ', 8000);
      }

      // Let all other errors (including syntax errors) pass through to original handler
      if (originalErrorHandler) {
        return originalErrorHandler.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    // Console.warn suppression for Permissions Policy warnings
    const originalWarn = console.warn;
    console.warn = function (...args) {
      const message = args.join(' ');
      const shouldSuppress = suppressedErrors.some((pattern) => message.includes(pattern));

      if (shouldSuppress) {
        return; // Suppress known warnings
      }

      originalWarn.apply(console, args);
    };

    // Enhanced promise rejection handling
    window.addEventListener('unhandledrejection', function (event) {
      const reason = event.reason?.toString() || '';
      const shouldSuppress = suppressedErrors.some((pattern) => reason.includes(pattern));

      if (shouldSuppress) {
        console.log('Suppressed internal promise rejection:', reason);
        event.preventDefault();
        return;
      }

      // Show user-impacting promise rejections as notifications
      const isUserImpacting = reason.includes('Failed to fetch') ||
                              reason.includes('Network request failed') ||
                              reason.includes('google.script.run') ||
                              reason.includes('timeout');

      if (isUserImpacting && window.notifications) {
        window.notifications.warning('ÈÄö‰ø°„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 6000);
      }

      console.warn('Unhandled promise rejection:', event.reason);
    });

    // Script loading monitoring to detect problematic scripts
    const originalCreateElement = document.createElement;
    document.createElement = function (tagName) {
      const element = originalCreateElement.call(this, tagName);

      if (tagName.toLowerCase() === 'script') {
        const originalSrc = element.src;
        Object.defineProperty(element, 'src', {
          get() {
            return originalSrc;
          },
          set(value) {
            console.log('üîç Script loading:', value);

            // Monitor specific scripts that might cause syntax errors
            if (value.includes('tailwindcss') || value.includes('cdn.')) {
              element.addEventListener('load', () => {
                console.log('‚úÖ External script loaded successfully:', value);
              });

              element.addEventListener('error', (e) => {
                console.error('‚ùå External script failed to load:', value, e);
              });
            }

            originalSrc = value;
          },
        });
      }

      return element;
    };
  })();


  // =============================================================================
  // PERFORMANCE UTILITIES
  // =============================================================================

  // Debounce function with key-based tracking
  class DebounceManager {
    constructor() {
      this.timers = new Map();
    }

    debounce(func, key, delay = 1000) {
      // Cancel existing debounce for this key
      if (this.timers.has(key)) {
        this.timers.delete(key);
      }

      // CLAUDE.md V8 compliant: Pure Promise-based delay
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      const debouncePromise = createPromiseDelay(delay).then(() => {
        if (this.timers.get(key) === debouncePromise) {
          func();
          this.timers.delete(key);
        }
      }).catch(() => {
        // Silent cleanup on cancellation
        this.timers.delete(key);
      });

      this.timers.set(key, debouncePromise);
    }

    clear(key) {
      // V8 compliant: Promise cancellation by removal
      this.timers.delete(key);
    }

    clearAll() {
      // V8 compliant: Clear all tracked promises
      this.timers.clear();
    }
  }

  // Throttle function with key-based tracking
  class ThrottleManager {
    constructor() {
      this.timers = new Map();
      this.lastExecution = new Map();
    }

    throttle(func, key, delay = 100) {
      const now = Date.now();
      const lastRun = this.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func();
        this.lastExecution.set(key, now);
      } else if (!this.timers.has(key)) {
        // CLAUDE.md V8 compliant: Promise-based delay for throttle
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        const delayTime = delay - (now - lastRun);
        const throttlePromise = createPromiseDelay(delayTime).then(() => {
          if (this.timers.get(key) === throttlePromise) {
            func();
            this.lastExecution.set(key, Date.now());
            this.timers.delete(key);
          }
        }).catch(() => {
          // Silent cleanup on cancellation
          this.timers.delete(key);
        });

        this.timers.set(key, throttlePromise);
      }
    }

    clear(key) {
      // V8 compliant: Promise cancellation by removal
      this.timers.delete(key);
      this.lastExecution.delete(key);
    }

    clearAll() {
      // V8 compliant: Clear all tracked promises and execution times
      this.timers.clear();
      this.lastExecution.clear();
    }
  }

  // DOM utilities removed - unused throughout codebase

  // =============================================================================
  // CACHE MANAGEMENT
  // =============================================================================

  // Cache manager with TTL and size limits
  class Cache {
    constructor(maxSize = 100, defaultTTL = 300000) {
      // 5 minutes default
      this.cache = new Map();
      this.timestamps = new Map();
      this.ttls = new Map();
      this.maxSize = maxSize;
      this.defaultTTL = defaultTTL;
    }

    set(key, value, ttl = null) {
      const now = Date.now();
      const actualTTL = ttl || this.defaultTTL;

      // If cache is full, remove oldest entry
      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.removeOldest();
      }

      this.cache.set(key, value);
      this.timestamps.set(key, now);
      this.ttls.set(key, actualTTL);
    }

    get(key) {
      if (!this.cache.has(key)) {
        return null;
      }

      const now = Date.now();
      const timestamp = this.timestamps.get(key);
      const ttl = this.ttls.get(key);

      if (now - timestamp > ttl) {
        this.delete(key);
        return null;
      }

      return this.cache.get(key);
    }

    has(key) {
      return this.get(key) !== null;
    }

    delete(key) {
      this.cache.delete(key);
      this.timestamps.delete(key);
      this.ttls.delete(key);
    }

    clear() {
      this.cache.clear();
      this.timestamps.clear();
      this.ttls.clear();
    }

    removeOldest() {
      let oldestKey = null;
      let oldestTime = Infinity;

      for (const [key, timestamp] of this.timestamps) {
        if (timestamp < oldestTime) {
          oldestTime = timestamp;
          oldestKey = key;
        }
      }

      if (oldestKey) {
        this.delete(oldestKey);
      }
    }

    cleanup() {
      const now = Date.now();
      const expiredKeys = [];

      for (const [key, timestamp] of this.timestamps) {
        const ttl = this.ttls.get(key);
        if (now - timestamp > ttl) {
          expiredKeys.push(key);
        }
      }

      expiredKeys.forEach((key) => this.delete(key));
    }

    get size() {
      this.cleanup(); // Clean expired entries before returning size
      return this.cache.size;
    }

    getStats() {
      this.cleanup();
      return {
        size: this.cache.size,
        maxSize: this.maxSize,
        defaultTTL: this.defaultTTL,
      };
    }
  }

  // =============================================================================
  // GAS DATA LOADING API - Phase 2.1 & 2.2 Implementation
  // =============================================================================

  /**
   * Áµ±‰∏Ä„Éá„Éº„Çø„É≠„Éº„Éá„Ç£„É≥„Ç∞API - GAS 2025„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„ÇπÊ∫ñÊã†
   * ÈùûÂêåÊúü„Éá„Éº„Çø„É≠„Éº„Éá„Ç£„É≥„Ç∞„ÄÅ„Ç≠„É£„ÉÉ„Ç∑„É≥„Ç∞„ÄÅ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇíÁµ±Âêà
   */
  class UnifiedDataLoader {
    constructor() {
      this.loadingStates = new Map();
      this.cache = new Map();
      this.abortControllers = new Map();
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      this.defaultTimeout = 30000;
    }

    /**
     * „Éá„Éº„ÇøË™≠„ÅøËæº„Åø„ÅÆÁµ±‰∏Ä„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
     * @param {string} functionName - GASÈñ¢Êï∞Âêç
     * @param {Object} options - Ë™≠„ÅøËæº„Åø„Ç™„Éó„Ç∑„Éß„É≥
     * @param {...any} args - GASÈñ¢Êï∞„Å∏„ÅÆÂºïÊï∞
     * @returns {Promise} „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÁµêÊûú
     */
    async loadData(functionName, options = {}, ...args) {
      const {
        cache = true,
        cacheKey = null,
        cacheTTL = 300000, // 5ÂàÜ
        showLoading = true,
        loadingMessage = '„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...',
        retryOnError = true,
        timeout = this.defaultTimeout
      } = options;

      // CLAUDE.mdÊ∫ñÊã†: Â§âÊï∞Â≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØÂæå„ÅÆ„ÉÜ„É≥„Éó„É¨„Éº„Éà„É™„ÉÜ„É©„É´‰ΩøÁî®
      const funcName = functionName || 'unknown';
      const finalCacheKey = cacheKey || `${funcName}_${JSON.stringify(args || []).substring(0, 50)}`;
      const requestId = `${funcName}_${Date.now()}`;

      try {
        // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
        if (cache && this.cache.has(finalCacheKey)) {
          const cached = this.cache.get(finalCacheKey);
          if (Date.now() - cached.timestamp < cacheTTL) {
            console.log(`üì¶ [UnifiedDataLoader] „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÂèñÂæó: ${funcName}`);
            return cached.data;
          }
          this.cache.delete(finalCacheKey);
        }

        // „É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫
        if (showLoading) {
          this.setLoadingState(requestId, true, loadingMessage);
        }

        // „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂÆüË°å
        const result = await this.executeGASCall(functionName, timeout, ...args);

        // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò
        if (cache && result) {
          this.cache.set(finalCacheKey, {
            data: result,
            timestamp: Date.now()
          });
        }

        return result;

      } catch (error) {
        console.error(`‚ùå [UnifiedDataLoader] ${funcName} „Ç®„É©„Éº:`, error);

        if (retryOnError && this.shouldRetry(requestId)) {
          console.log(`üîÑ [UnifiedDataLoader] ${funcName} „É™„Éà„É©„Ç§ÂÆüË°å`);
          return this.loadData(functionName, { ...options, retryOnError: false }, ...args);
        }

        throw error;
      } finally {
        if (showLoading) {
          this.setLoadingState(requestId, false);
        }
        this.cleanup(requestId);
      }
    }

    /**
     * „Éê„ÉÉ„ÉÅ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø - Ë§áÊï∞„ÅÆGASÈñ¢Êï∞„Çí‰∏¶ÂàóÂÆüË°å
     * @param {Array} requests - [{functionName, args, options}] „ÅÆÈÖçÂàó
     * @returns {Promise<Array>} ÂêÑ„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÁµêÊûúÈÖçÂàó
     */
    async loadBatchData(requests) {
      console.log(`üì¶ [UnifiedDataLoader] „Éê„ÉÉ„ÉÅË™≠„ÅøËæº„ÅøÈñãÂßã: ${(requests && requests.length) || 0}‰ª∂`);

      const promises = requests.map((request, index) => {
        const { functionName, args = [], options = {} } = request;
        return this.loadData(functionName, {
          ...options,
          showLoading: false, // „Éê„ÉÉ„ÉÅ„Åß„ÅØÂÄãÂà•„É≠„Éº„Éá„Ç£„É≥„Ç∞„ÇíÁÑ°ÂäπÂåñ
        }, ...args).catch(error => {
          console.error(`‚ùå [UnifiedDataLoader] „Éê„ÉÉ„ÉÅ${index || 0}: ${functionName || 'unknown'} „Ç®„É©„Éº:`, error);
          return { error: error.message, functionName };
        });
      });

      return Promise.all(promises);
    }

    /**
     * GASÈñ¢Êï∞„ÅÆÂÆüÈöõ„ÅÆÂÆüË°å
     * @param {string} functionName - Èñ¢Êï∞Âêç
     * @param {number} timeout - „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇÈñì
     * @param {...any} args - ÂºïÊï∞
     * @returns {Promise} ÂÆüË°åÁµêÊûú
     */
    executeGASCall(functionName, timeout, ...args) {
      return new Promise((resolve, reject) => {
        // GASÁí∞Â¢É„ÉÅ„Çß„ÉÉ„ÇØ
        if (typeof google === 'undefined' || !google.script?.run) {
          reject(new Error('Google Apps ScriptÁí∞Â¢É„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì'));
          return;
        }

        // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàË®≠ÂÆö
        // CLAUDE.md V8 compliant: Promise-based timeout
        const createPromiseTimeout = (ms) => new Promise((_, reject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              reject(new Error(`„Çø„Ç§„É†„Ç¢„Ç¶„Éà: ${functionName || 'unknown'} (${timeout || 0}ms)`));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(timeout);
        const timeoutId = Symbol('promise-timeout');

        // GASÈñ¢Êï∞ÂÆüË°å
        let completed = false;
        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              console.log(`‚úÖ [UnifiedDataLoader] ${functionName || 'unknown'} ÊàêÂäü`);
              resolve(result);
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              console.error(`‚ùå [UnifiedDataLoader] ${functionName || 'unknown'} GASÂÆüË°å„Ç®„É©„Éº:`, error);
              reject(new Error(error.message || error.toString()));
            }
          })
          [functionName](...args);

        // V8 compliant timeout handling
        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    }

    /**
     * „É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖãÁÆ°ÁêÜ
     */
    setLoadingState(requestId, isLoading, message = '') {
      if (isLoading) {
        this.loadingStates.set(requestId, { message, startTime: Date.now() });
        if (window.unifiedLoading) {
          window.unifiedLoading.show(message);
        }
      } else {
        this.loadingStates.delete(requestId);
        if (window.unifiedLoading && this.loadingStates.size === 0) {
          window.unifiedLoading.hide();
        }
      }
    }

    /**
     * „É™„Éà„É©„Ç§Âà§ÂÆö
     */
    shouldRetry(requestId) {
      const attempts = this.retryAttempts.get(requestId) || 0;
      if (attempts >= this.maxRetries) {
        return false;
      }
      this.retryAttempts.set(requestId, attempts + 1);
      return true;
    }

    /**
     * „É™„ÇØ„Ç®„Çπ„ÉàÂæåÂá¶ÁêÜ
     */
    cleanup(requestId) {
      this.loadingStates.delete(requestId);
      this.retryAttempts.delete(requestId);
      this.abortControllers.delete(requestId);
    }

    /**
     * „Ç≠„É£„ÉÉ„Ç∑„É•ÁÆ°ÁêÜ
     */
    clearCache(pattern = null) {
      if (pattern) {
        for (const key of this.cache.keys()) {
          if (key.includes(pattern)) {
            this.cache.delete(key);
          }
        }
      } else {
        this.cache.clear();
      }
      console.log(`üßπ [UnifiedDataLoader] „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢: ${pattern || 'ALL'}`);
    }

    /**
     * Áµ±Ë®àÊÉÖÂ†±ÂèñÂæó
     */
    getStats() {
      return {
        cacheSize: this.cache.size,
        activeRequests: this.loadingStates.size,
        totalRetries: Array.from(this.retryAttempts.values()).reduce((a, b) => a + b, 0)
      };
    }
  }

  // „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàê
  window.unifiedDataLoader = new UnifiedDataLoader();

  // ÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
  window.loadData = (functionName, options, ...args) =>
    window.unifiedDataLoader.loadData(functionName, options, ...args);

  window.loadBatchData = (requests) =>
    window.unifiedDataLoader.loadBatchData(requests);

  console.info('‚úÖ UnifiedDataLoader initialized - GAS 2025 ÊúÄÈÅ©ÂåñÁâà');

  // =============================================================================
  // ERROR HANDLING UTILITIES
  // =============================================================================

  class ErrorHandler {
    constructor() {
      this.errors = [];
      this.maxErrors = 50;
    }

    logError(error, context = '') {
      try {
        const errorInfo = {
          message: error?.message || error?.toString() || 'Unknown error',
          stack: error?.stack || 'No stack trace available',
          context: context || 'No context provided',
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          errorType: typeof error,
          isObject: typeof error === 'object',
        };

        this.errors.push(errorInfo);

        // Keep only recent errors
        if (this.errors.length > this.maxErrors) {
          this.errors.shift();
        }

        // Better error logging with more details
        console.group('üö® Error Logged');
        console.log('Message:', errorInfo.message);
        console.log('Type:', errorInfo.errorType);
        console.log('Context:', errorInfo.context);
        console.log('Stack:', errorInfo.stack);
        console.log('Full Error Object:', error);
        console.groupEnd();
      } catch (loggingError) {
        console.error('Error in error logging:', loggingError);
        console.error('Original error:', error);
      }
    }

    getRecentErrors(count = 10) {
      return this.errors.slice(-count);
    }

    clearErrors() {
      this.errors = [];
    }

    setupGlobalErrorHandling() {
      window.addEventListener('error', (event) => {
        this.logError(event.error, 'Global error handler');
      });

      window.addEventListener('unhandledrejection', (event) => {
        this.logError(event.reason, 'Unhandled promise rejection');
      });
    }
  }

  // =============================================================================
  // LOADING STATE MANAGEMENT
  // =============================================================================

  class LoadingManager {
    constructor() {
      this.loadingStates = new Map();
    }

    setLoading(key, isLoading, message = '') {
      this.loadingStates.set(key, { isLoading, message, timestamp: Date.now() });

      // Emit custom event for UI updates
      const event = new CustomEvent('loadingStateChange', {
        detail: { key, isLoading, message },
      });
      document.dispatchEvent(event);
    }

    isLoading(key) {
      const state = this.loadingStates.get(key);
      return state ? state.isLoading : false;
    }

    getLoadingMessage(key) {
      const state = this.loadingStates.get(key);
      return state ? state.message : '';
    }

    clearLoading(key) {
      this.loadingStates.delete(key);
      this.setLoading(key, false);
    }

    clearAllLoading() {
      const keys = Array.from(this.loadingStates.keys());
      keys.forEach((key) => this.clearLoading(key));
    }
  }

  // GAS integration utilities removed - unused throughout codebase

  // =============================================================================
  // SECURITY UTILITIES
  // =============================================================================

  // Security utilities for XSS prevention and data sanitization
  class SecurityUtilities {
    // Escape HTML characters to prevent XSS attacks
    escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Sanitize HTML content by removing dangerous tags
    sanitizeHtml(html) {
      if (!html) return '';
      const div = document.createElement('div');
      div.innerHTML = html;

      // Remove script tags and other dangerous elements
      const scripts = div.querySelectorAll('script, object, embed, iframe, form');
      scripts.forEach((script) => script.remove());

      return div.innerHTML;
    }

    // Validate email format
    isValidEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
  }

  // =============================================================================
  // INITIALIZATION AND GLOBAL SETUP
  // =============================================================================

  // Initialize global utilities
  // Privacy-aware logging utilities
  class PrivacyLogger {
    // Anonymize sensitive data for logging
    static anonymize(data) {
      if (typeof data === 'string') {
        // Email anonymization
        if (data.includes('@')) {
          const parts = data.split('@');
          const safePart0 = (parts[0] && parts[0].substring) ? parts[0].substring(0, 2) : 'xx';
          const safePart1 = parts[1] || 'unknown';
          return `${safePart0}***@${safePart1}`;
        }
        // Long text anonymization (potential user content)
        if (data.length > 30) {
          const safeDataPrefix = (data && data.substring) ? data.substring(0, 15) : 'unknown';
          const safeDataLength = (data && data.length) || 0;
          return `${safeDataPrefix}...[${safeDataLength} chars]`;
        }
        return data;
      }

      if (typeof data === 'object' && data !== null) {
        const anonymized = {};
        for (const [key, value] of Object.entries(data)) {
          // Skip sensitive keys
          if (['email', 'userEmail', 'reason', 'opinion', 'answer', 'content'].includes(key)) {
            anonymized[key] = this.anonymize(value);
          } else if (key.includes('Id') && typeof value === 'string') {
            // Anonymize IDs partially
            if (value && value.length && value.substring) {
              anonymized[key] = value.length > 8 ? `${value.substring(0, 4)}***` : value;
            } else {
              anonymized[key] = value;
            }
          } else {
            anonymized[key] = value;
          }
        }
        return anonymized;
      }

      return data;
    }

    // Safe console logging with privacy protection
    static log(message, data = null) {
      if (data) {
        console.log(message, this.anonymize(data));
      } else {
        console.log(message);
      }
    }

    static warn(message, data = null) {
      if (data) {
        console.warn(message, this.anonymize(data));
      } else {
        console.warn(message);
      }
    }

    static error(message, data = null) {
      if (data) {
        console.error(message, this.anonymize(data));
      } else {
        console.error(message);
      }
    }
  }

  window.sharedUtilities = {
    debounce: new DebounceManager(),
    throttle: new ThrottleManager(),
    cache: new Cache(),
    errors: new ErrorHandler(),
    loading: new LoadingManager(),
    security: new SecurityUtilities(),
    privacy: PrivacyLogger,
  };

  // Setup global error handling
  window.sharedUtilities.errors.setupGlobalErrorHandling();

  // Helper functions for backward compatibility
  window.debounce = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.debounce) {
      window.sharedUtilities.debounce.debounce(func, key, delay);
    } else {
      // CLAUDE.md V8 compliant: Promise-based fallback
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });
      createPromiseDelay(delay).then(func).catch(() => {
        // Silent error handling for fallback
      });
    }
  };

  window.throttle = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.throttle) {
      window.sharedUtilities.throttle.throttle(func, key, delay);
    } else {
      // Simple fallback
      func();
    }
  };

  // Global cache instance for backward compatibility
  if (!window.UnifiedCache) {
    window.UnifiedCache = Cache;
  }

  // DOM ready utility
  window.onDOMReady = function (callback) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', callback);
    } else {
      callback();
    }
  };



  // =============================================================================
  // AUTHENTICATION UTILITIES
  // =============================================================================

  // Shared authentication functions for consistent behavior across pages
  window.sharedUtilities.auth = {
    // Account switching functionality shared across pages
    switchToAnotherAccount: function () {
      if (
        confirm(
          'Âà•„ÅÆGoogle„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„É≠„Ç∞„Ç§„É≥„Åó„Åæ„Åô„ÅãÔºüÁèæÂú®„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„Çâ„É≠„Ç∞„Ç¢„Ç¶„Éà„Åï„Çå„ÄÅ„Ç¢„Ç´„Ç¶„É≥„ÉàÈÅ∏ÊäûÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ'
        )
      ) {
        try {
          google.script.run
            .withSuccessHandler(function (result) {
              if (result && result.success) {
                const url = new URL(window.location.href);
                url.searchParams.set('force_account_selection', 'true');
                window.location.replace(url.toString());
              } else {
                window.sharedUtilities.auth.showAccountSwitchFallback();
              }
            })
            .withFailureHandler(function (error) {
              console.warn('Ë™çË®º„É™„Çª„ÉÉ„Éà„Ç®„É©„Éº:', error);
              window.sharedUtilities.auth.showAccountSwitchFallback();
            })
            .resetAuth();
        } catch (error) {
          console.warn('„Ç¢„Ç´„Ç¶„É≥„ÉàÂàá„ÇäÊõø„Åà„Ç®„É©„Éº:', error);
          window.sharedUtilities.auth.showAccountSwitchFallback();
        }
      }
    },

    // Fallback guidance when automatic switch fails
    showAccountSwitchFallback: function () {
      const msg = `
          „Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÂàá„ÇäÊõø„Åà„Çã„Å´„ÅØ‰ª•‰∏ã„ÅÆÊâãÈ†Ü„Çí„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑÔºö

          1. Êñ∞„Åó„ÅÑ„Éñ„É©„Ç¶„Ç∂„Çø„Éñ„ÅßGoogleÔºàgoogle.comÔºâ„Å´„Ç¢„ÇØ„Çª„Çπ
          2. Âè≥‰∏ä„ÅÆ„Éó„É≠„Éï„Ç£„Éº„É´ÁîªÂÉè„Çí„ÇØ„É™„ÉÉ„ÇØ
          3. „ÄåÂà•„ÅÆ„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíËøΩÂä†„Äç„Åæ„Åü„ÅØ‰ΩøÁî®„Åó„Åü„ÅÑ„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÈÅ∏Êäû
          4. „Åì„ÅÆ„Éö„Éº„Ç∏„Å´Êàª„Å£„Å¶ÂÜçÂ∫¶Ë™çË®º„ÇíÈñãÂßã

          „Åæ„Åü„ÅØ„ÄÅ„Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç∑„Éº„ÇØ„É¨„ÉÉ„Éà/„Éó„É©„Ç§„Éô„Éº„Éà„É¢„Éº„Éâ„ÅßÊñ∞„Åó„ÅÑ„Çø„Éñ„ÇíÈñã„ÅÑ„Å¶„Åì„ÅÆ„Éö„Éº„Ç∏„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
        `;
      alert(msg);
    },

    // ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„É≠„Ç∞„Ç¢„Ç¶„ÉàÔºàopenAppSetup„Éë„Çø„Éº„É≥Êé°Áî®Ôºâ
    logout: function () {
      if (confirm('„É≠„Ç∞„Ç¢„Ç¶„Éà„Åó„Åæ„Åô„ÅãÔºü')) {
        console.log('üö™ Logout initiated');

        // 1. „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
        try {
          if (window.sharedUtilities?.cache?.clear) {
            window.sharedUtilities.cache.clear();
          }
          localStorage.removeItem('current_user_info');
          sessionStorage.clear();
          console.log('üóëÔ∏è Client cache cleared');
        } catch (e) {
          console.warn('Cache clear partially failed:', e);
        }

        // 2. openAppSetup„Å®Âêå„Åò„Éë„Çø„Éº„É≥„ÅßWebApp URLÂèñÂæó‚ÜíÈÅ∑Áßª
        google.script.run
          .withSuccessHandler(function(webAppUrl) {
            const loginUrl = `${webAppUrl}?mode=login`;
            console.log('üîÑ Redirecting to login page:', loginUrl);

            // openAppSetup„Å®Âêå„ÅòÊâãÊ≥ï: window.open(_top)„Åß„Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„ÇπÂà∂ÈôêÂõûÈÅø
            window.open(loginUrl, '_top');

            // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„Çª„ÉÉ„Ç∑„Éß„É≥„ÇØ„É™„Ç¢ÔºàÈùû„Éñ„É≠„ÉÉ„Ç≠„É≥„Ç∞Ôºâ- V8Ê∫ñÊã†
            const createPromiseDelay = (ms) => new Promise(resolve => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            });

            createPromiseDelay(100).then(() => {
              google.script.run
                .withSuccessHandler(function(result) {
                  console.log('‚úÖ Background server session cleared:', result?.message || 'OK');
                })
                .withFailureHandler(function(error) {
                  console.warn('‚ö†Ô∏è Background session clear failed (non-critical):', error);
                })
                .resetAuth();
            }).catch(() => {
              // Silent error handling for background task
            });
          })
          .withFailureHandler(function(error) {
            console.warn('WebApp URLÂèñÂæóÂ§±Êïó„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÆüË°å:', error);

            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: openAppSetup„Å®Âêå„Åò„Éë„Çø„Éº„É≥
            try {
              const currentUrl = new URL(window.location.href);
              const baseUrl = currentUrl.origin + currentUrl.pathname;
              const loginUrl = `${baseUrl}?mode=login`;
              console.log('üîÑ Fallback redirect to:', loginUrl);
              window.open(loginUrl, '_top');
            } catch (fallbackError) {
              console.warn('„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÈÅ∑Áßª„ÇÇÂ§±Êïó:', fallbackError);
              window.location.reload();
            }
          })
          .getWebAppUrl();
      }
    },


    // Authentication verification with promise
    verifyAuthentication: function () {
      return new Promise((resolve, reject) => {
        // CLAUDE.md V8 compliant: Promise-based timeout for auth verification
        const createPromiseTimeout = (ms) => new Promise((_, timeoutReject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              timeoutReject(new Error('Ë™çË®ºÁ¢∫Ë™ç„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü'));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(10000);
        let completed = false;

        google.script.run
          .withSuccessHandler((result) => {
            if (!completed) {
              completed = true;
              if (result && result.authenticated && result.email) {
                resolve(result);
              } else {
                reject(new Error('Ë™çË®º„ÅåÂøÖË¶Å„Åß„Åô'));
              }
            }
          })
          .withFailureHandler((error) => {
            if (!completed) {
              completed = true;
              reject(error);
            }
          })
          .checkUserAuthentication();

        // Handle timeout
        timeoutPromise.catch((timeoutError) => {
          if (!completed) {
            completed = true;
            reject(timeoutError);
          }
        });
      });
    },

    // Display authentication info in standardized format
    displayAuthInfo: function (containerId, email, showSwitchOption = true) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Safely escape email with fallback
      const safeEmail =
        window.sharedUtilities && window.sharedUtilities.security
          ? window.sharedUtilities.security.escapeHtml(email)
          : (email || '').replace(/[<>&"']/g, function (match) {
              switch (match) {
                case '<':
                  return '&lt;';
                case '>':
                  return '&gt;';
                case '&':
                  return '&amp;';
                case '"':
                  return '&quot;';
                case "'":
                  return '&#39;';
                default:
                  return match;
              }
            });

      container.innerHTML = `
        <div class="bg-gray-800 rounded-lg p-4 mb-4">
          <p class="text-sm text-gray-400 mb-1">Ë™çË®ºÊ∏à„Åø„Ç¢„Ç´„Ç¶„É≥„Éà:</p>
          <p class="text-white font-semibold">${safeEmail}</p>
        </div>
        ${
          showSwitchOption
            ? `
        <div class="text-right">
          <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
            Âà•„ÅÆ„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„É≠„Ç∞„Ç§„É≥
          </button>
        </div>`
            : ''
        }
      `;
    },
  };

  // Global functions for backward compatibility
  window.switchToAnotherAccount = function () {
    window.sharedUtilities.auth.switchToAnotherAccount();
  };

  window.logout = function () {
    window.sharedUtilities.auth.logout();
  };


  // =============================================================================
  // UNIFIED LOADING MANAGER (NEW ENHANCED VERSION)
  // =============================================================================

  class UnifiedLoadingManager {
    constructor() {
      this.overlay = null;
      this.initialized = false;
      this.currentState = null;
      this.variantClasses = ['transparent', 'minimal', 'modal'];
    }

    // Initialize the loading manager with DOM element detection
    init(retries = 5, delay = 100, onSuccess = null) {
      if (this.initialized) {
        console.log('UnifiedLoadingManager: Already initialized.');
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced DOM readiness check
      if (document.readyState === 'loading') {
        console.log('UnifiedLoadingManager: DOM still loading, waiting for DOMContentLoaded...');
        document.addEventListener(
          'DOMContentLoaded',
          () => {
            // CLAUDE.md V8 compliant: requestIdleCallback for DOM-ready retry
            requestIdleCallback(() => this.init(retries, delay, onSuccess), { timeout: 50 });
          },
          { once: true }
        );
        return false;
      }

      this.overlay = document.getElementById('loading-overlay');
      if (this.overlay) {
        if (!window.unifiedLoadingInitialized) {
          window.unifiedLoadingInitialized = true;
          console.log(
            '‚úÖ UnifiedLoadingManager: Initialized successfully with element:',
            this.overlay.className
          );
        }
        this.initialized = true;
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced retry logic
      if (retries > 0) {
        console.warn(
          (() => {
            const safeReadyState = (document && document.readyState) || 'unknown';
            const safeDelay = delay || 0;
            const safeRetries = retries || 0;
            return `‚ö†Ô∏è UnifiedLoadingManager: loading-overlay element not found. DOM state: ${safeReadyState}. Retrying in ${safeDelay}ms (${safeRetries} retries left)...`;
          })()
        );
        // CLAUDE.md V8 compliant: Promise-based delay for loading manager retry
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(delay).then(() => this.init(retries - 1, delay * 1.5, onSuccess));
      } else {
        console.error(
          '‚ùå UnifiedLoadingManager: Critical failure - loading-overlay element not found after multiple retries.'
        );
        this.createFallbackOverlay();
      }
      return false;
    }

    // Create a fallback overlay if none exists
    createFallbackOverlay() {
      if (document.getElementById('loading-overlay')) {
        this.overlay = document.getElementById('loading-overlay');
        this.initialized = true;
        return true;
      }

      console.warn('‚ö†Ô∏è UnifiedLoadingManager: Creating fallback loading-overlay element');
      const fallbackOverlay = document.createElement('div');
      fallbackOverlay.id = 'loading-overlay';
      fallbackOverlay.className = 'loading-overlay page-specific hidden';

      if (document.body) {
        document.body.insertBefore(fallbackOverlay, document.body.firstChild);
        this.overlay = fallbackOverlay;
        this.initialized = true;
        console.log('‚úÖ UnifiedLoadingManager: Fallback overlay created and initialized');
        return true;
      }
      return false;
    }

    // Main loading function with a unified API and enhanced error handling
    setLoading(isLoading, options = {}) {
      if (!this.initialized) {
        // Silent retry - reduce console noise during initialization
        if (!this.init()) {
          // Initialization failed, but continue silently to avoid spam
          return;
        }
      }

      try {
        if (isLoading) {
          console.log('UnifiedLoadingManager: Showing loading overlay with options:', options);
          this.show(options);
        } else {
          console.log('UnifiedLoadingManager: Hiding loading overlay.');
          this.hide();
        }
      } catch (error) {
        console.error('UnifiedLoadingManager: Error during loading state change:', error);
      }
    }

    // Show loading overlay with options
    show(options = {}) {
      // V8 Runtime ÂÆâÂÖ®ÊÄß: „Ç™„Éó„Ç∑„Éß„É≥„ÅåÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØmessage„Å®„Åó„Å¶Êâ±„ÅÜ
      if (typeof options === 'string') {
        options = { message: options };
      }

      const config = {
        message: options.message || 'Âá¶ÁêÜ‰∏≠...',
        type: options.type || 'overlay',
        disableInteraction: options.disableInteraction !== false,
        ...options,
      };

      this.currentState = config;

      // V8 Runtime ÂÆâÂÖ®ÊÄß: overlay „Åå null „ÅÆÂ†¥Âêà„ÅÆÊó©Êúü„É™„Çø„Éº„É≥
      if (!this.overlay) {
        console.error('UnifiedLoadingManager: Cannot show overlay - element not initialized');
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ΩúÊàê„ÇíË©¶Ë°å
        if (!this.createFallbackOverlay()) {
          return;
        }
      }

      // Clean up previous variant classes with null safety
      this.variantClasses.forEach((vc) => {
        if (this.overlay && this.overlay.classList) {
          this.overlay.classList.remove(vc);
        }
      });

      // Add the new variant class if it's not the default overlay
      if (config.type !== 'overlay' && this.overlay && this.overlay.classList) {
        this.overlay.classList.add(config.type);
      }

      // Update content and show the overlay
      this.updateContent(config);

      if (this.overlay && this.overlay.classList) {
        this.overlay.classList.remove('hidden');
        this.overlay.style.setProperty('display', 'flex', 'important');
      }

      // Manage user interaction
      if (config.disableInteraction && config.type !== 'transparent' && this.overlay) {
        document.body.style.overflow = 'hidden';
        document.body.style.pointerEvents = 'none';
        this.overlay.style.pointerEvents = 'auto';
      }

      console.log(
        (() => {
          const safeConfigType = (config && config.type) || 'unknown';
          const safeConfigMessage = (config && config.message) || 'No message';
          return `UnifiedLoadingManager: Overlay shown with type '${safeConfigType}' and message '${safeConfigMessage}'`;
        })()
      );
    }

    // Hide loading overlay with cleanup
    hide() {
      if (!this.overlay) return;

      this.overlay.classList.add('hidden');
      this.overlay.style.setProperty('display', 'none', 'important');

      // Clean up variant classes
      this.variantClasses.forEach((vc) => this.overlay.classList.remove(vc));

      // Re-enable user interaction
      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';

      // Clear current state
      this.currentState = null;

      console.log('UnifiedLoadingManager: Overlay hidden');
    }

    // Update the overlay content dynamically
    updateContent(config) {
      if (!this.overlay) return;

      // Use existing content or create default structure
      let messageElement = this.overlay.querySelector('.loading-message');
      if (!messageElement) {
        const safeOverlayMessage = (config && config.message) || 'Loading...';
        this.overlay.innerHTML = `
          <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-message">${safeOverlayMessage}</div>
          </div>
        `;
        messageElement = this.overlay.querySelector('.loading-message');
      } else {
        messageElement.textContent = config.message;
      }

      // Remove any existing progress elements for clean display
      const existingProgress = this.overlay.querySelector('.loading-progress');
      if (existingProgress) {
        existingProgress.remove();
      }

      const existingSteps = this.overlay.querySelector('.loading-steps');
      if (existingSteps) {
        existingSteps.remove();
      }
    }

    // Convenience methods for different loading types
    showOverlay(message = 'Âá¶ÁêÜ‰∏≠...') {
      this.setLoading(true, { message, type: 'overlay' });
    }

    showTransparent(message = 'Âá¶ÁêÜ‰∏≠...') {
      this.setLoading(true, { message, type: 'transparent' });
    }
  }

  // Create and initialize the global instance once the DOM is ready.
  window.unifiedLoading = new UnifiedLoadingManager();
  document.addEventListener('DOMContentLoaded', () => {
    window.unifiedLoading.init();
  });

  // Backward compatibility wrapper for the global setLoading function.
  window.setLoading = function (isLoading, message) {
    if (!isLoading) {
      window.unifiedLoading.setLoading(false);
      return;
    }

    if (typeof message === 'object') {
      window.unifiedLoading.setLoading(true, message);
    } else {
      window.unifiedLoading.showOverlay(message || 'Âá¶ÁêÜ‰∏≠...');
    }
  };

  // üöÄ ÈÉ®ÂàÜ„É≠„Éº„Éá„Ç£„É≥„Ç∞Ê©üËÉΩÔºàËªΩÈáèÊìç‰ΩúÁî®Ôºâ
  window.setPartialLoading = function (loading, message) {
    if (loading) {
      // ÈÉ®ÂàÜ„É≠„Éº„Éá„Ç£„É≥„Ç∞: ÈÄöÁü• + „Ç§„É≥„É©„Ç§„É≥„Çπ„Éî„Éä„Éº„ÄÅÁîªÈù¢Êìç‰ΩúÂèØËÉΩ
      const safeInfoMessage = message || 'Âá¶ÁêÜ‰∏≠...';
      window.showInfo(safeInfoMessage);

      // „Ç§„É≥„É©„Ç§„É≥Ë¶ÅÁ¥†„Å´„Çπ„Éî„Éä„Éº„ÇØ„É©„Çπ„ÇíËøΩÂä†Ôºà„ÅÇ„Çå„Å∞Ôºâ
      const activeElements = document.querySelectorAll('.partial-loading-target');
      activeElements.forEach((el) => {
        el.classList.add('partial-loading');
        if (!el.dataset.originalText) {
          el.dataset.originalText = el.textContent;
        }
        el.textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
        el.disabled = true;
      });
    } else {
      // ÁµÇ‰∫ÜÊôÇ: „Çπ„Éî„Éä„ÉºÈô§Âéª„ÄÅÂÖÉ„ÅÆÁä∂ÊÖã„Å´Âæ©ÂÖÉ
      const activeElements = document.querySelectorAll('.partial-loading');
      activeElements.forEach((el) => {
        el.classList.remove('partial-loading');
        if (el.dataset.originalText) {
          el.textContent = el.dataset.originalText;
          delete el.dataset.originalText;
        }
        el.disabled = false;
      });
    }
  };

  // =============================================================================
  // SIMPLE & EFFECTIVE WARNING SUPPRESSION FOR GAS
  // =============================================================================

  // ‚úÖ Immediate and simple warning suppression
  const originalWarn = console.warn;
  const originalError = console.error;

  console.warn = function(...args) {
    const msg = args.join(' ');
    // Simple pattern matching for known GAS warnings
    if (msg.includes('Unrecognized feature') ||
        msg.includes('ambient-light-sensor') ||
        msg.includes('speaker') ||
        msg.includes('vibrate') ||
        msg.includes('vr') ||
        msg.includes('iframe') ||
        msg.includes('sandbox') ||
        msg.includes('navigation') ||
        msg.includes('net state changed') ||
        msg.includes('warden_bin')) {
      return; // Suppress these warnings
    }
    originalWarn.apply(console, args);
  };

  console.error = function(...args) {
    const msg = args.join(' ');
    // Simple pattern matching for known GAS errors
    if (msg.includes('Unsafe attempt to initiate navigation') ||
        msg.includes('sandboxed with the') ||
        msg.includes('iframe') ||
        msg.includes('about:blank') ||
        msg.includes('can escape its sandboxing')) {
      return; // Suppress these errors
    }
    originalError.apply(console, args);
  };

  // =============================================================================
  // NOTIFICATION TOAST SYSTEM
  // =============================================================================

  class NotificationSystem {
    constructor() {
      this.container = null;
      this.initialized = false;
      this.notificationQueue = [];
      this.maxConcurrentNotifications = 5;
      this.isLowEndDevice = window.isLowEndDevice ? window.isLowEndDevice() : false;
      this.performanceConstants = window.getPerformanceConstants ? window.getPerformanceConstants() : {
        BASE_RENDER_BATCH_SIZE: 10,
        VIEWPORT_BUFFER: 200,
        PERFORMANCE_BUDGET: 16
      };
    }

    // Initialize notification container with enhanced resilience
    init() {
      try {
        // ‚úÖ Enhanced DOM readiness check
        if (!document.body) {
          // Try again after a short delay if DOM not ready
          if (!this.initRetryCount) this.initRetryCount = 0;
          if (this.initRetryCount < 3) {
            this.initRetryCount++;
            setTimeout(() => this.init(), 50);
            return false;
          }
          console.warn('NotificationSystem: DOM not ready after retries, skipping initialization');
          return false;
        }

        this.container = document.getElementById('notification-container');

        if (this.container) {
          this.initialized = true;
          return true;
        }

        // ‚úÖ Create notification container with enhanced error handling
        try {
          this.container = document.createElement('div');
          this.container.id = 'notification-container';
          this.container.className = 'fixed top-4 right-4 z-50 space-y-2 pointer-events-none';

          document.body.appendChild(this.container);
          this.initialized = true;
          return true;
        } catch (domError) {
          console.warn('NotificationSystem: Failed to create container:', domError.message);
          // Fallback: try to use document.head if body fails
          try {
            this.container = document.createElement('div');
            this.container.id = 'notification-container-fallback';
            this.container.className = 'fixed top-4 right-4 z-50 space-y-2 pointer-events-none';
            document.head.appendChild(this.container);
            this.initialized = true;
            return true;
          } catch (fallbackError) {
            console.error('NotificationSystem: Complete initialization failure:', fallbackError.message);
            return false;
          }
        }
      } catch (error) {
        console.error('NotificationSystem: Unexpected initialization error:', error.message);
        return false;
      }
    }

    // Show notification message with enhanced resilience and performance optimization
    showMessage(message, type = 'info', duration = null) {
      try {
        // ‚úÖ Input validation and sanitization
        if (!message || typeof message !== 'string') {
          console.warn('NotificationSystem: Invalid message provided:', message);
          return;
        }

        // Standardized durations: success: 4000, error: 7000, warning: 6000, info: 5000
        if (duration === null) {
          const standardDurations = { success: 4000, error: 7000, warning: 6000, info: 5000 };
          duration = standardDurations[type] || 5000;
        }

        // Performance optimization: Queue notifications on low-end devices
        if (this.isLowEndDevice && this.getActiveNotificationCount() >= 3) {
          this.queueNotification({ message, type, duration });
          return;
        }

        // ‚úÖ Enhanced initialization with retry mechanism
        let initSuccess = this.init();
        if (!initSuccess) {
          // Retry initialization once more after small delay
          setTimeout(() => {
            if (this.init()) {
              this.showMessage(message, type, duration);
            } else {
              this.fallbackNotification(message, type);
            }
          }, 100);
          return;
        }
      } catch (error) {
        console.error('NotificationSystem: Error in showMessage:', error.message);
        this.fallbackNotification(message, type);
        return;
      }

      if (!this.container) {
        console.error('Notification container could not be initialized');
        if (type === 'error') {
          alert('„Ç®„É©„Éº: ' + message);
        }
        return;
      }

      // Color schemes for different types
      const colors = {
        success: 'border-green-400 bg-green-900/50 text-green-100',
        error: 'border-red-400 bg-red-900/50 text-red-100',
        warning: 'border-yellow-400 bg-yellow-900/50 text-yellow-100',
        info: 'border-blue-400 bg-blue-900/50 text-blue-100',
      };

      // Icons for different types
      const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        warning: '‚ö†Ô∏è',
        info: '‚ÑπÔ∏è',
      };

      // Create notification element
      const notification = document.createElement('div');
      const safeTypeColor = colors[type] || colors.info;

      notification.className = `notification glass-panel rounded-lg border shadow-lg flex items-center ${safeTypeColor}`;

      notification.style.cssText = `
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease-out;
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        min-height: 3rem;
        max-height: 5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        line-height: 1.4;
        pointer-events: auto;
      `;

      const safeIcon = icons[type] || icons.info;
      const safeHtmlMessage = this.escapeHtml(message || 'No message');
      notification.innerHTML = `
        <div class="mr-3 text-lg flex-shrink-0 leading-none">${safeIcon}</div>
        <div class="flex-1 text-sm leading-normal">${safeHtmlMessage}</div>
        <button type="button" class="ml-4 text-gray-400 hover:text-white text-lg leading-none flex-shrink-0" style="background: none; border: none; cursor: pointer; line-height: 1;">‚úï</button>
      `;

      // Add close button handler
      const closeBtn = notification.querySelector('button');
      closeBtn.addEventListener('click', () => this.removeNotification(notification));

      // Append to container
      this.container.appendChild(notification);

      // Animate in
      requestAnimationFrame(() => {
        if (notification.parentNode) {
          notification.style.transform = 'translateX(0)';
          notification.style.opacity = '1';

          // Schedule removal - V8 compliant Promise-based delay
          if (duration > 0) {
            const createPromiseDelay = (ms) => new Promise(resolve => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            });

            createPromiseDelay(duration + 400).then(() => {
              this.removeNotification(notification);
            }).catch(() => {
              // Silent cleanup on cancellation
            });
          }
        }
      });
    }

    // Remove notification with animation
    removeNotification(notification) {
      if (!notification || !notification.parentNode) return;

      if (notification.dataset.removing === 'true') return;
      notification.dataset.removing = 'true';

      // Start exit animation
      notification.style.transform = 'translateX(100%)';
      notification.style.opacity = '0';

      // Remove after animation - V8 compliant Promise-based delay
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      createPromiseDelay(300).then(() => {
        if (notification && notification.parentNode) {
          notification.remove();
        }
        // Trigger performance cleanup and queue processing
        this.performCleanup();
      }).catch(() => {
        // Silent cleanup on cancellation
      });
    }

    // Convenience methods (simplified - use showMessage defaults)
    success(message, duration) {
      this.showMessage(message, 'success', duration);
    }

    error(message, duration) {
      this.showMessage(message, 'error', duration);
    }

    warning(message, duration) {
      this.showMessage(message, 'warning', duration);
    }

    info(message, duration) {
      this.showMessage(message, 'info', duration);
    }

    // Escape HTML to prevent XSS
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // Clear all notifications
    clearAll() {
      if (!this.container) return;

      const notifications = this.container.querySelectorAll('.notification');
      notifications.forEach((notification) => this.removeNotification(notification));
    }

    // ‚úÖ Fallback notification system for critical failures
    fallbackNotification(message, type) {
      try {
        // Primary fallback: Use browser alert/console for critical messages
        if (type === 'error') {
          alert(`„Ç®„É©„Éº: ${message}`);
        } else if (type === 'warning') {
          console.warn(`[Ë≠¶Âëä] ${message}`);
        } else {
          console.log(`[${type}] ${message}`);
        }
      } catch (fallbackError) {
        // Ultimate fallback: Basic console output
        console.log(`NotificationSystem fallback: [${type}] ${message}`);
      }
    }

    // Performance optimization helper methods
    getActiveNotificationCount() {
      if (!this.container) return 0;
      return this.container.querySelectorAll('.notification').length;
    }

    queueNotification(notificationData) {
      // Limit queue size to prevent memory leaks
      if (this.notificationQueue.length >= 10) {
        this.notificationQueue.shift(); // Remove oldest queued notification
      }

      this.notificationQueue.push(notificationData);
      this.processQueuedNotifications();
    }

    processQueuedNotifications() {
      if (this.notificationQueue.length === 0) return;
      if (this.getActiveNotificationCount() >= this.maxConcurrentNotifications) return;

      const nextNotification = this.notificationQueue.shift();
      if (nextNotification) {
        // V8 compliant: Promise-based delayed processing
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(100).then(() => {
          this.showMessage(nextNotification.message, nextNotification.type, nextNotification.duration);
        }).catch(() => {
          // Silent error handling
        });
      }
    }

    // Performance-aware batch cleanup
    performCleanup() {
      if (!this.container) return;

      const notifications = this.container.querySelectorAll('.notification[data-removing="true"]');
      // Batch DOM operations for better performance
      const fragment = document.createDocumentFragment();

      notifications.forEach(notification => {
        if (notification.parentNode) {
          notification.remove();
        }
      });

      // Process any queued notifications after cleanup
      this.processQueuedNotifications();
    }
  }

  // Create global notification instance (prevent duplicates)
  if (!window.notifications) {
    window.notifications = new NotificationSystem();
    // Force immediate initialization
    window.notifications.init();
  }

  // Add to shared utilities
  if (window.sharedUtilities) {
    window.sharedUtilities.notifications = window.notifications;
  }

  // Global convenience functions for backward compatibility (prevent duplicates)
  if (!window.showSuccess) {
    window.showSuccess = function (message, duration) {
      if (window.notifications && window.notifications.success) {
        window.notifications.success(message, duration);
      } else {
        console.log('[SUCCESS] ' + message);
      }
    };
  }

  if (!window.showError) {
    window.showError = function (message, duration) {
      if (window.notifications && window.notifications.error) {
        window.notifications.error(message, duration);
      } else {
        alert('„Ç®„É©„Éº: ' + message);
      }
    };
  }

  if (!window.showWarning) {
    window.showWarning = function (message, duration) {
      if (window.notifications && window.notifications.warning) {
        window.notifications.warning(message, duration);
      } else {
        console.warn('[WARNING] ' + message);
      }
    };
  }

  if (!window.showInfo) {
    window.showInfo = function (message, duration) {
      if (window.notifications && window.notifications.info) {
        window.notifications.info(message, duration);
      } else {
        console.log('[INFO] ' + message);
      }
    };
  }

  // Alias for generic show message (prevent duplicates)
  if (!window.showMessage) {
    window.showMessage = function (message, type, duration) {
      if (window.notifications && window.notifications.showMessage) {
        window.notifications.showMessage(message, type, duration);
      } else {
        // Fallback based on type
        if (type === 'error') {
          alert('„Ç®„É©„Éº: ' + message);
        } else {
          console.log(`[${type.toUpperCase()}] ${message}`);
        }
      }
    };
  }

  // Add styles for notification system if not using Tailwind (prevent duplicates)
  if (!document.querySelector('script[src*="tailwindcss"]') && !document.querySelector('#notification-fallback-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-fallback-styles';
    style.textContent = `
      #notification-container {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 10000;
        pointer-events: none;
      }
      #notification-container .notification {
        pointer-events: auto;
        min-width: 300px;
        max-width: 500px;
      }
    `;
    document.head.appendChild(style);
  }

  // ‚úÖ Simple test function for notifications - immediately available
  function testNotifications() {
    console.log('üß™ Testing notification system...');

    // Check if notification system is available
    if (!window.notifications) {
      console.error('‚ùå NotificationSystem not available');
      return false;
    }

    // Ensure it's initialized
    try {
      window.notifications.init();
    } catch (e) {
      console.warn('Notification init warning:', e.message);
    }

    // Test all notification types
    try {
      window.notifications.info('üß™ Info test - z-index fixed', 2000);
      window.notifications.success('‚úÖ Success test', 2000);
      window.notifications.warning('‚ö†Ô∏è Warning test', 2000);
      window.notifications.error('‚ùå Error test', 2000);

      console.log('‚úÖ All notification types sent successfully');

      // Log container info for debugging
      if (window.notifications.container) {
        const styles = window.getComputedStyle(window.notifications.container);
        console.log(`üìç Container z-index: ${styles.zIndex}`);
        console.log(`üìç Container position: ${styles.position}`);
        console.log(`üìç Container classes: ${window.notifications.container.className}`);
      }

      return true;
    } catch (error) {
      console.error('‚ùå Notification test failed:', error.message);
      return false;
    }
  }

  // Make function globally available
  window.testNotifications = testNotifications;

  // Also make it available as a global function (multiple ways for reliability)
  if (typeof globalThis !== 'undefined') {
    globalThis.testNotifications = testNotifications;
  }

  console.log('üîß testNotifications() is now globally available');

  // ‚úÖ Immediate system status check
  console.log('üìä Notification System Status:', {
    notificationsAvailable: !!window.notifications,
    testFunctionAvailable: !!window.testNotifications,
    showMessageAvailable: !!window.showMessage
  });

  // =============================================================================
  // DYNAMIC PERFORMANCE CONSTANTS - Shared across all HTML files
  // =============================================================================

  // Performance level detection
  window.getPerformanceLevel = function() {
    if (typeof navigator === 'undefined') return 'medium';

    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const connection = navigator.connection;

    // High-end device criteria
    if (memory >= 8 && cores >= 8) return 'high';

    // Low-end device criteria
    if (memory <= 2 || cores <= 2) return 'low';

    // Network considerations
    if (connection) {
      const { effectiveType, downlink } = connection;
      if (effectiveType === '2g' || (downlink && downlink < 1)) return 'low';
      if (effectiveType === '4g' && downlink && downlink > 10) return 'high';
    }

    return 'medium';
  };

  window.isLowEndDevice = function() {
    if (typeof navigator === 'undefined') return false;

    const memory = navigator.deviceMemory;
    const cores = navigator.hardwareConcurrency;

    return (memory && memory <= 2) || (cores && cores <= 2);
  };

  // Dynamic performance constants
  window.getPerformanceConstants = function() {
    const perfLevel = window.getPerformanceLevel();
    const isLowEnd = window.isLowEndDevice();

    return {
      BASE_RENDER_BATCH_SIZE: perfLevel === 'high' ? 15 : perfLevel === 'low' ? 5 : 10,
      LOW_PERF_BATCH_SIZE: isLowEnd ? 3 : 5,
      HIGH_PERF_BATCH_SIZE: perfLevel === 'high' ? 25 : 15,
      VIEWPORT_BUFFER: perfLevel === 'high' ? 300 : perfLevel === 'low' ? 100 : 200,
      PERFORMANCE_BUDGET: perfLevel === 'high' ? 12 : perfLevel === 'low' ? 24 : 16,
      CHUNK_SIZE: perfLevel === 'high' ? 8 : perfLevel === 'low' ? 3 : 5,
      IDLE_TIMEOUT: isLowEnd ? 8000 : 5000
    };
  };

  // Getter functions for dynamic constants
  window.getBatchSize = function(type = 'base') {
    const constants = window.getPerformanceConstants();
    const safeType = (type && type.toUpperCase) ? type.toUpperCase() : 'DEFAULT';
    return constants[`${safeType}_BATCH_SIZE`] || constants.BASE_RENDER_BATCH_SIZE;
  };

  window.getViewportBuffer = function() {
    return window.getPerformanceConstants().VIEWPORT_BUFFER;
  };

  window.getPerformanceBudget = function() {
    return window.getPerformanceConstants().PERFORMANCE_BUDGET;
  };

  window.getChunkSize = function() {
    return window.getPerformanceConstants().CHUNK_SIZE;
  };

  window.getIdleTimeout = function() {
    return window.getPerformanceConstants().IDLE_TIMEOUT;
  };

  // Prevent duplicate loading messages
  if (!window.sharedUtilitiesLoaded) {
    window.sharedUtilitiesLoaded = true;
    console.log(
      '‚úÖ SharedUtilities loaded successfully - Version 3.0.0-flat (Zero-Dependency Architecture)'
    );
  }
</script>
