<script>
  /* =============================================================================
     StudyQuest - Shared JavaScript Utilities
     GAS Compatible utility functions for all HTML files
     ============================================================================= */

  // =============================================================================
  // ENHANCED ERROR HANDLING FOR ASYNC/AWAIT ISSUES
  // =============================================================================

  // Global error handling for Google Apps Script compatibility issues
  (function () {
    // Simplified error suppression - safe for GAS template processing
    const suppressedErrors = [
      'cdn.tailwindcss.com should not be used in production',
      'cdnjs.cloudflare.com',
      'tailwind',
      'TailwindCSS',
      'iframe which has both allow-scripts and allow-same-origin',
      'can escape its sandboxing',
    ];

    // Syntax errors that need special logging (not suppressed)
    const criticalSyntaxErrors = [
      'Unexpected end of input',
      'Unexpected token',
      'SyntaxError: Unexpected',
      'Invalid or unexpected token',
    ];

    // Simplified and safe error handling for GAS template processing
    const originalErrorHandler = window.onerror;
    window.onerror = function (message, source, lineno, colno, error) {
      const errorMessage = message ? message.toString() : '';

      // Only suppress specific known warnings that interfere with GAS
      const shouldSuppress = suppressedErrors.some((pattern) => errorMessage.includes(pattern));

      if (shouldSuppress) {
        return true; // Suppress known warnings
      }

      // Let all other errors (including syntax errors) pass through to original handler
      if (originalErrorHandler) {
        return originalErrorHandler.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    // Console.warn suppression for Permissions Policy warnings
    const originalWarn = console.warn;
    console.warn = function (...args) {
      const message = args.join(' ');
      const shouldSuppress = suppressedErrors.some((pattern) => message.includes(pattern));

      if (shouldSuppress) {
        return; // Suppress known warnings
      }

      originalWarn.apply(console, args);
    };

    // Enhanced promise rejection handling
    window.addEventListener('unhandledrejection', function (event) {
      const reason = event.reason?.toString() || '';
      const shouldSuppress = suppressedErrors.some((pattern) => reason.includes(pattern));

      if (shouldSuppress) {
        console.debug('Suppressed internal promise rejection:', reason);
        event.preventDefault();
        return;
      }

      console.warn('Unhandled promise rejection:', event.reason);
    });

    // Script loading monitoring to detect problematic scripts
    const originalCreateElement = document.createElement;
    document.createElement = function (tagName) {
      const element = originalCreateElement.call(this, tagName);

      if (tagName.toLowerCase() === 'script') {
        const originalSrc = element.src;
        Object.defineProperty(element, 'src', {
          get() {
            return originalSrc;
          },
          set(value) {
            console.log('ğŸ” Script loading:', value);

            // Monitor specific scripts that might cause syntax errors
            if (value.includes('tailwindcss') || value.includes('cdn.')) {
              element.addEventListener('load', () => {
                console.log('âœ… External script loaded successfully:', value);
              });

              element.addEventListener('error', (e) => {
                console.error('âŒ External script failed to load:', value, e);
              });
            }

            originalSrc = value;
          },
        });
      }

      return element;
    };
  })();

  // =============================================================================
  // SAFE RESPONSE PROCESSING - Fix response.trim() errors
  // =============================================================================

  /**
   * å®‰å…¨ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç† - response.trim()ã‚¨ãƒ©ãƒ¼ã‚’é˜²ã
   * @param {any} response - ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   * @returns {string} å®‰å…¨ãªæ–‡å­—åˆ—ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   */
  window.safeResponseTrim = function(response) {
    if (response === null || response === undefined) {
      return '';
    }

    // æ—¢ã«æ–‡å­—åˆ—ã®å ´åˆ
    if (typeof response === 'string') {
      return response.trim();
    }

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¯JSONæ–‡å­—åˆ—åŒ–
    if (typeof response === 'object') {
      try {
        return JSON.stringify(response).trim();
      } catch (error) {
        console.warn('safeResponseTrim: JSON stringify failed', error);
        return String(response).trim();
      }
    }

    // ãã®ä»–ã®å‹ã¯æ–‡å­—åˆ—å¤‰æ›
    return String(response).trim();
  };

  /**
   * å®‰å…¨ãªGoogle Apps Scriptãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†
   * @param {any} response - GASã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   * @returns {Object} ãƒ‘ãƒ¼ã‚¹ã•ã‚ŒãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  window.safeParseGASResponse = function(response) {
    try {
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒæ—¢ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
      if (typeof response === 'object' && response !== null) {
        return response;
      }

      // æ–‡å­—åˆ—ã®å ´åˆã¯JSONãƒ‘ãƒ¼ã‚¹
      if (typeof response === 'string') {
        const trimmed = response.trim();
        if (trimmed === '') {
          return { success: false, message: 'ç©ºã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹' };
        }
        return JSON.parse(trimmed);
      }

      return { success: false, message: 'ä¸æ­£ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼', raw: response };
    } catch (error) {
      console.warn('safeParseGASResponse: Parse failed', error, response);
      return {
        success: false,
        message: 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹è§£æã‚¨ãƒ©ãƒ¼',
        error: error.message,
        raw: response
      };
    }
  };

  // =============================================================================
  // PERFORMANCE UTILITIES
  // =============================================================================

  // Debounce function with key-based tracking
  class DebounceManager {
    constructor() {
      this.timers = new Map();
    }

    debounce(func, key, delay = 1000) {
      if (this.timers.has(key)) {
        clearTimeout(this.timers.get(key));
      }
      // CLAUDE.md V8 compliant: Promise-based delay instead of setTimeout
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      const promise = createPromiseDelay(delay).then(() => {
        func();
        this.timers.delete(key);
      });
      const timeoutId = Symbol('promise-delay');
      this.timers.set(key, timeoutId);
    }

    clear(key) {
      if (this.timers.has(key)) {
        clearTimeout(this.timers.get(key));
        this.timers.delete(key);
      }
    }

    clearAll() {
      this.timers.forEach((timer) => clearTimeout(timer));
      this.timers.clear();
    }
  }

  // Throttle function with key-based tracking
  class ThrottleManager {
    constructor() {
      this.timers = new Map();
      this.lastExecution = new Map();
    }

    throttle(func, key, delay = 100) {
      const now = Date.now();
      const lastRun = this.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func();
        this.lastExecution.set(key, now);
      } else if (!this.timers.has(key)) {
        // CLAUDE.md V8 compliant: Promise-based delay for throttle
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        const delayTime = delay - (now - lastRun);
        const promise = createPromiseDelay(delayTime).then(() => {
          func();
          this.lastExecution.set(key, Date.now());
          this.timers.delete(key);
        });
        const timeoutId = Symbol('promise-delay');
        this.timers.set(key, timeoutId);
      }
    }

    clear(key) {
      if (this.timers.has(key)) {
        clearTimeout(this.timers.get(key));
        this.timers.delete(key);
      }
      this.lastExecution.delete(key);
    }

    clearAll() {
      this.timers.forEach((timer) => clearTimeout(timer));
      this.timers.clear();
      this.lastExecution.clear();
    }
  }

  // =============================================================================
  // DOM UTILITIES
  // =============================================================================

  // Enhanced DOM utility functions
  class DOMUtilities {
    constructor() {
      this.elementCache = new Map();
    }

    // Safe element creation
    createSafeElement(tag, className, textContent) {
      const element = document.createElement(tag);
      if (className) element.className = className;
      if (textContent) element.textContent = textContent;
      return element;
    }

    // Safe element selection with caching
    getCachedElement(id) {
      if (this.elementCache.has(id)) {
        return this.elementCache.get(id);
      }

      const element = document.getElementById(id);
      if (element) {
        this.elementCache.set(id, element);
      } else {
        console.warn('Element not found:', id);
      }
      return element;
    }

    // Batch cache multiple elements
    cacheElements(elementIds) {
      const cached = {};
      elementIds.forEach((id) => {
        cached[id] = this.getCachedElement(id);
      });
      return cached;
    }

    // Clear element cache
    clearElementCache(id = null) {
      if (id) {
        this.elementCache.delete(id);
      } else {
        this.elementCache.clear();
      }
    }

    // Safe button state management
    setButtonState(button, isDisabled, text) {
      if (!button) return;
      button.disabled = isDisabled;
      if (text) button.textContent = text;
    }

    // Safe text content setting
    setSafeTextContent(element, text) {
      if (!element) return;
      element.textContent = text || '';
    }

    // Safe class toggling
    toggleClass(element, className, condition) {
      if (!element) return;
      if (condition) {
        element.classList.add(className);
      } else {
        element.classList.remove(className);
      }
    }

    // Safe event listener management
    addSafeEventListener(element, event, handler, options = {}) {
      if (!element) return null;
      element.addEventListener(event, handler, options);
      return handler;
    }

    removeSafeEventListener(element, event, handler) {
      if (!element || !handler) return;
      element.removeEventListener(event, handler);
    }
  }

  // =============================================================================
  // CACHE MANAGEMENT
  // =============================================================================

  // Cache manager with TTL and size limits
  class Cache {
    constructor(maxSize = 100, defaultTTL = 300000) {
      // 5 minutes default
      this.cache = new Map();
      this.timestamps = new Map();
      this.ttls = new Map();
      this.maxSize = maxSize;
      this.defaultTTL = defaultTTL;
    }

    set(key, value, ttl = null) {
      const now = Date.now();
      const actualTTL = ttl || this.defaultTTL;

      // If cache is full, remove oldest entry
      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.removeOldest();
      }

      this.cache.set(key, value);
      this.timestamps.set(key, now);
      this.ttls.set(key, actualTTL);
    }

    get(key) {
      if (!this.cache.has(key)) {
        return null;
      }

      const now = Date.now();
      const timestamp = this.timestamps.get(key);
      const ttl = this.ttls.get(key);

      if (now - timestamp > ttl) {
        this.delete(key);
        return null;
      }

      return this.cache.get(key);
    }

    has(key) {
      return this.get(key) !== null;
    }

    delete(key) {
      this.cache.delete(key);
      this.timestamps.delete(key);
      this.ttls.delete(key);
    }

    clear() {
      this.cache.clear();
      this.timestamps.clear();
      this.ttls.clear();
    }

    removeOldest() {
      let oldestKey = null;
      let oldestTime = Infinity;

      for (const [key, timestamp] of this.timestamps) {
        if (timestamp < oldestTime) {
          oldestTime = timestamp;
          oldestKey = key;
        }
      }

      if (oldestKey) {
        this.delete(oldestKey);
      }
    }

    cleanup() {
      const now = Date.now();
      const expiredKeys = [];

      for (const [key, timestamp] of this.timestamps) {
        const ttl = this.ttls.get(key);
        if (now - timestamp > ttl) {
          expiredKeys.push(key);
        }
      }

      expiredKeys.forEach((key) => this.delete(key));
    }

    get size() {
      this.cleanup(); // Clean expired entries before returning size
      return this.cache.size;
    }

    getStats() {
      this.cleanup();
      return {
        size: this.cache.size,
        maxSize: this.maxSize,
        defaultTTL: this.defaultTTL,
      };
    }
  }

  // =============================================================================
  // GAS DATA LOADING API - Phase 2.1 & 2.2 Implementation
  // =============================================================================

  /**
   * çµ±ä¸€ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°API - GAS 2025ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹æº–æ‹ 
   * éåŒæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’çµ±åˆ
   */
  class UnifiedDataLoader {
    constructor() {
      this.loadingStates = new Map();
      this.cache = new Map();
      this.abortControllers = new Map();
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      this.defaultTimeout = 30000;
    }

    /**
     * ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã®çµ±ä¸€ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
     * @param {string} functionName - GASé–¢æ•°å
     * @param {Object} options - èª­ã¿è¾¼ã¿ã‚ªãƒ—ã‚·ãƒ§ãƒ³
     * @param {...any} args - GASé–¢æ•°ã¸ã®å¼•æ•°
     * @returns {Promise} ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿çµæœ
     */
    async loadData(functionName, options = {}, ...args) {
      const {
        cache = true,
        cacheKey = null,
        cacheTTL = 300000, // 5åˆ†
        showLoading = true,
        loadingMessage = 'ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...',
        retryOnError = true,
        timeout = this.defaultTimeout
      } = options;

      const finalCacheKey = cacheKey || `${functionName}_${JSON.stringify(args).substring(0, 50)}`;
      const requestId = `${functionName}_${Date.now()}`;

      try {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        if (cache && this.cache.has(finalCacheKey)) {
          const cached = this.cache.get(finalCacheKey);
          if (Date.now() - cached.timestamp < cacheTTL) {
            console.log(`ğŸ“¦ [UnifiedDataLoader] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—: ${functionName}`);
            return cached.data;
          }
          this.cache.delete(finalCacheKey);
        }

        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
        if (showLoading) {
          this.setLoadingState(requestId, true, loadingMessage);
        }

        // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Ÿè¡Œ
        const result = await this.executeGASCall(functionName, timeout, ...args);

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
        if (cache && result) {
          this.cache.set(finalCacheKey, {
            data: result,
            timestamp: Date.now()
          });
        }

        return result;

      } catch (error) {
        console.error(`âŒ [UnifiedDataLoader] ${functionName} ã‚¨ãƒ©ãƒ¼:`, error);

        if (retryOnError && this.shouldRetry(requestId)) {
          console.log(`ğŸ”„ [UnifiedDataLoader] ${functionName} ãƒªãƒˆãƒ©ã‚¤å®Ÿè¡Œ`);
          return this.loadData(functionName, { ...options, retryOnError: false }, ...args);
        }

        throw error;
      } finally {
        if (showLoading) {
          this.setLoadingState(requestId, false);
        }
        this.cleanup(requestId);
      }
    }

    /**
     * ãƒãƒƒãƒãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ - è¤‡æ•°ã®GASé–¢æ•°ã‚’ä¸¦åˆ—å®Ÿè¡Œ
     * @param {Array} requests - [{functionName, args, options}] ã®é…åˆ—
     * @returns {Promise<Array>} å„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®çµæœé…åˆ—
     */
    async loadBatchData(requests) {
      console.log(`ğŸ“¦ [UnifiedDataLoader] ãƒãƒƒãƒèª­ã¿è¾¼ã¿é–‹å§‹: ${requests.length}ä»¶`);

      const promises = requests.map((request, index) => {
        const { functionName, args = [], options = {} } = request;
        return this.loadData(functionName, {
          ...options,
          showLoading: false, // ãƒãƒƒãƒã§ã¯å€‹åˆ¥ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–
        }, ...args).catch(error => {
          console.error(`âŒ [UnifiedDataLoader] ãƒãƒƒãƒ${index}: ${functionName} ã‚¨ãƒ©ãƒ¼:`, error);
          return { error: error.message, functionName };
        });
      });

      return Promise.all(promises);
    }

    /**
     * GASé–¢æ•°ã®å®Ÿéš›ã®å®Ÿè¡Œ
     * @param {string} functionName - é–¢æ•°å
     * @param {number} timeout - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“
     * @param {...any} args - å¼•æ•°
     * @returns {Promise} å®Ÿè¡Œçµæœ
     */
    executeGASCall(functionName, timeout, ...args) {
      return new Promise((resolve, reject) => {
        // GASç’°å¢ƒãƒã‚§ãƒƒã‚¯
        if (typeof google === 'undefined' || !google.script?.run) {
          reject(new Error('Google Apps Scriptç’°å¢ƒãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'));
          return;
        }

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
        // CLAUDE.md V8 compliant: Promise-based timeout
        const createPromiseTimeout = (ms) => new Promise((_, reject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              reject(new Error(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${functionName} (${timeout}ms)`));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(timeout);
        const timeoutId = Symbol('promise-timeout');

        // GASé–¢æ•°å®Ÿè¡Œ
        google.script.run
          .withSuccessHandler((result) => {
            clearTimeout(timeoutId);
            console.log(`âœ… [UnifiedDataLoader] ${functionName} æˆåŠŸ`);
            resolve(result);
          })
          .withFailureHandler((error) => {
            clearTimeout(timeoutId);
            console.error(`âŒ [UnifiedDataLoader] ${functionName} GASå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:`, error);
            reject(new Error(error.message || error.toString()));
          })
          [functionName](...args);
      });
    }

    /**
     * ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ç®¡ç†
     */
    setLoadingState(requestId, isLoading, message = '') {
      if (isLoading) {
        this.loadingStates.set(requestId, { message, startTime: Date.now() });
        if (window.unifiedLoading) {
          window.unifiedLoading.show(message);
        }
      } else {
        this.loadingStates.delete(requestId);
        if (window.unifiedLoading && this.loadingStates.size === 0) {
          window.unifiedLoading.hide();
        }
      }
    }

    /**
     * ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š
     */
    shouldRetry(requestId) {
      const attempts = this.retryAttempts.get(requestId) || 0;
      if (attempts >= this.maxRetries) {
        return false;
      }
      this.retryAttempts.set(requestId, attempts + 1);
      return true;
    }

    /**
     * ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¾Œå‡¦ç†
     */
    cleanup(requestId) {
      this.loadingStates.delete(requestId);
      this.retryAttempts.delete(requestId);
      this.abortControllers.delete(requestId);
    }

    /**
     * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
     */
    clearCache(pattern = null) {
      if (pattern) {
        for (const key of this.cache.keys()) {
          if (key.includes(pattern)) {
            this.cache.delete(key);
          }
        }
      } else {
        this.cache.clear();
      }
      console.log(`ğŸ§¹ [UnifiedDataLoader] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢: ${pattern || 'ALL'}`);
    }

    /**
     * çµ±è¨ˆæƒ…å ±å–å¾—
     */
    getStats() {
      return {
        cacheSize: this.cache.size,
        activeRequests: this.loadingStates.size,
        totalRetries: Array.from(this.retryAttempts.values()).reduce((a, b) => a + b, 0)
      };
    }
  }

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
  window.unifiedDataLoader = new UnifiedDataLoader();

  // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  window.loadData = (functionName, options, ...args) =>
    window.unifiedDataLoader.loadData(functionName, options, ...args);

  window.loadBatchData = (requests) =>
    window.unifiedDataLoader.loadBatchData(requests);

  console.info('âœ… UnifiedDataLoader initialized - GAS 2025 æœ€é©åŒ–ç‰ˆ');

  // =============================================================================
  // ERROR HANDLING UTILITIES
  // =============================================================================

  class ErrorHandler {
    constructor() {
      this.errors = [];
      this.maxErrors = 50;
    }

    logError(error, context = '') {
      try {
        const errorInfo = {
          message: error?.message || error?.toString() || 'Unknown error',
          stack: error?.stack || 'No stack trace available',
          context: context || 'No context provided',
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          errorType: typeof error,
          isObject: typeof error === 'object',
        };

        this.errors.push(errorInfo);

        // Keep only recent errors
        if (this.errors.length > this.maxErrors) {
          this.errors.shift();
        }

        // Better error logging with more details
        console.group('ğŸš¨ Error Logged');
        console.log('Message:', errorInfo.message);
        console.log('Type:', errorInfo.errorType);
        console.log('Context:', errorInfo.context);
        console.log('Stack:', errorInfo.stack);
        console.log('Full Error Object:', error);
        console.groupEnd();
      } catch (loggingError) {
        console.error('Error in error logging:', loggingError);
        console.error('Original error:', error);
      }
    }

    getRecentErrors(count = 10) {
      return this.errors.slice(-count);
    }

    clearErrors() {
      this.errors = [];
    }

    setupGlobalErrorHandling() {
      window.addEventListener('error', (event) => {
        this.logError(event.error, 'Global error handler');
      });

      window.addEventListener('unhandledrejection', (event) => {
        this.logError(event.reason, 'Unhandled promise rejection');
      });
    }
  }

  // =============================================================================
  // LOADING STATE MANAGEMENT
  // =============================================================================

  class LoadingManager {
    constructor() {
      this.loadingStates = new Map();
    }

    setLoading(key, isLoading, message = '') {
      this.loadingStates.set(key, { isLoading, message, timestamp: Date.now() });

      // Emit custom event for UI updates
      const event = new CustomEvent('loadingStateChange', {
        detail: { key, isLoading, message },
      });
      document.dispatchEvent(event);
    }

    isLoading(key) {
      const state = this.loadingStates.get(key);
      return state ? state.isLoading : false;
    }

    getLoadingMessage(key) {
      const state = this.loadingStates.get(key);
      return state ? state.message : '';
    }

    clearLoading(key) {
      this.loadingStates.delete(key);
      this.setLoading(key, false);
    }

    clearAllLoading() {
      const keys = Array.from(this.loadingStates.keys());
      keys.forEach((key) => this.clearLoading(key));
    }
  }

  // =============================================================================
  // GAS INTEGRATION UTILITIES
  // =============================================================================

  class GASUtilities {
    constructor() {
      this.callCache = new Cache(50, 1000); // 1 second cache for API calls
    }

    // Cached GAS function call
    callWithCache(functionName, cacheKey, ttl, ...args) {
      const cached = this.callCache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }

      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler((result) => {
            this.callCache.set(cacheKey, result, ttl);
            resolve(result);
          })
          .withFailureHandler(reject)
          [functionName](...args);
      });
    }

    // Simple GAS function call
    call(functionName, ...args) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          [functionName](...args);
      });
    }

    // GAS function call with loading overlay - é‡è¤‡ãƒªã‚¯ã‚¨ã‚¹ãƒˆé˜²æ­¢ç‰ˆ
    callWithLoading(functionName, message = 'å‡¦ç†ä¸­...', loadingType = 'overlay', ...args) {
      // Support config object as message parameter
      if (typeof message === 'object' && message !== null) {
        const config = message;
        message = config.message || 'å‡¦ç†ä¸­...';
        loadingType = config.type || loadingType;
      }

      // é‡è¤‡ãƒªã‚¯ã‚¨ã‚¹ãƒˆé˜²æ­¢: åŒã˜é–¢æ•°ãŒå®Ÿè¡Œä¸­ã®å ´åˆã¯æ—¢å­˜ã®Promiseã‚’è¿”ã™
      const requestKey = `${functionName}_${JSON.stringify(args)}`;
      if (this.pendingRequests && this.pendingRequests.has(requestKey)) {
        console.log(`ğŸš« Duplicate request prevented: ${functionName}`);
        return this.pendingRequests.get(requestKey);
      }

      // pendingRequestsãŒãªã„å ´åˆã¯åˆæœŸåŒ–
      if (!this.pendingRequests) {
        this.pendingRequests = new Map();
      }

      const promise = new Promise((resolve, reject) => {
        // Use appropriate loading method based on type
        if (loadingType === 'transparent') {
          window.unifiedLoading.showTransparent(message);
        } else {
          window.unifiedLoading.show(message);
        }

        google.script.run
          .withSuccessHandler((result) => {
            window.unifiedLoading.hide(); // Hide loading overlay on success
            this.pendingRequests.delete(requestKey); // å®Œäº†å¾Œã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‰Šé™¤
            resolve(result);
          })
          .withFailureHandler((error) => {
            window.unifiedLoading.hide(); // Hide loading overlay on failure
            this.pendingRequests.delete(requestKey); // ã‚¨ãƒ©ãƒ¼æ™‚ã«ã‚‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‰Šé™¤
            // Log the error using the shared error handler
            window.sharedUtilities.errors.logError(error, `GAS call failed: ${functionName}`);
            reject(error);
          })
          [functionName](...args);
      });

      // å®Ÿè¡Œä¸­ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¨ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      this.pendingRequests.set(requestKey, promise);
      return promise;
    }

    // Check if running in GAS environment
    isGASEnvironment() {
      return typeof google !== 'undefined' && google.script && google.script.run;
    }
  }

  // =============================================================================
  // SECURITY UTILITIES
  // =============================================================================

  // Security utilities for XSS prevention and data sanitization
  class SecurityUtilities {
    // Escape HTML characters to prevent XSS attacks
    escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Sanitize HTML content by removing dangerous tags
    sanitizeHtml(html) {
      if (!html) return '';
      const div = document.createElement('div');
      div.innerHTML = html;

      // Remove script tags and other dangerous elements
      const scripts = div.querySelectorAll('script, object, embed, iframe, form');
      scripts.forEach((script) => script.remove());

      return div.innerHTML;
    }

    // Validate email format
    isValidEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
  }

  // =============================================================================
  // INITIALIZATION AND GLOBAL SETUP
  // =============================================================================

  // Initialize global utilities
  // Privacy-aware logging utilities
  class PrivacyLogger {
    // Anonymize sensitive data for logging
    static anonymize(data) {
      if (typeof data === 'string') {
        // Email anonymization
        if (data.includes('@')) {
          const parts = data.split('@');
          return `${parts[0].substring(0, 2)}***@${parts[1]}`;
        }
        // Long text anonymization (potential user content)
        if (data.length > 30) {
          return `${data.substring(0, 15)}...[${data.length} chars]`;
        }
        return data;
      }

      if (typeof data === 'object' && data !== null) {
        const anonymized = {};
        for (const [key, value] of Object.entries(data)) {
          // Skip sensitive keys
          if (['email', 'userEmail', 'reason', 'opinion', 'answer', 'content'].includes(key)) {
            anonymized[key] = this.anonymize(value);
          } else if (key.includes('Id') && typeof value === 'string') {
            // Anonymize IDs partially
            anonymized[key] = value.length > 8 ? `${value.substring(0, 4)}***` : value;
          } else {
            anonymized[key] = value;
          }
        }
        return anonymized;
      }

      return data;
    }

    // Safe console logging with privacy protection
    static log(message, data = null) {
      if (data) {
        console.log(message, this.anonymize(data));
      } else {
        console.log(message);
      }
    }

    static warn(message, data = null) {
      if (data) {
        console.warn(message, this.anonymize(data));
      } else {
        console.warn(message);
      }
    }

    static error(message, data = null) {
      if (data) {
        console.error(message, this.anonymize(data));
      } else {
        console.error(message);
      }
    }
  }

  window.sharedUtilities = {
    debounce: new DebounceManager(),
    throttle: new ThrottleManager(),
    dom: new DOMUtilities(),
    cache: new Cache(),
    errors: new ErrorHandler(),
    loading: new LoadingManager(),
    gas: new GASUtilities(),
    security: new SecurityUtilities(),
    privacy: PrivacyLogger,
  };

  // Setup global error handling
  window.sharedUtilities.errors.setupGlobalErrorHandling();

  // Helper functions for backward compatibility
  window.debounce = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.debounce) {
      window.sharedUtilities.debounce.debounce(func, key, delay);
    } else {
      // CLAUDE.md V8 compliant: requestIdleCallback fallback
      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(() => func(), { timeout: delay });
      } else {
        // Promise-based delay as final fallback
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });
        createPromiseDelay(delay).then(func);
      }
    }
  };

  window.throttle = (func, delay, key = 'default') => {
    // Check if sharedUtilities exists before using
    if (window.sharedUtilities && window.sharedUtilities.throttle) {
      window.sharedUtilities.throttle.throttle(func, key, delay);
    } else {
      // Simple fallback
      func();
    }
  };

  // Global cache instance for backward compatibility
  if (!window.UnifiedCache) {
    window.UnifiedCache = Cache;
  }

  // DOM ready utility
  window.onDOMReady = function (callback) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', callback);
    } else {
      callback();
    }
  };

  // Debug function for console access
  window.getSharedUtilitiesStats = function () {
    return {
      debounceTimers: window.sharedUtilities.debounce.timers.size,
      throttleTimers: window.sharedUtilities.throttle.timers.size,
      cacheSize: window.sharedUtilities.cache.size,
      cacheStats: window.sharedUtilities.cache.getStats(),
      domCacheSize: window.sharedUtilities.dom.elementCache.size,
      recentErrors: window.sharedUtilities.errors.getRecentErrors(5),
      loadingStates: Object.fromEntries(window.sharedUtilities.loading.loadingStates),
      gasEnvironment: window.sharedUtilities.gas.isGASEnvironment(),
    };
  };

  // Performance monitoring
  window.clearAllSharedUtilities = function () {
    window.sharedUtilities.debounce.clearAll();
    window.sharedUtilities.throttle.clearAll();
    window.sharedUtilities.cache.clear();
    window.sharedUtilities.dom.clearElementCache();
    window.sharedUtilities.errors.clearErrors();
    window.sharedUtilities.loading.clearAllLoading();
    console.log('ğŸ§¹ All SharedUtilities cleared');
  };

  // Integration test function
  window.testSharedUtilities = function () {
    console.group('ğŸ§ª SharedUtilities Integration Test');

    // Test debounce
    let debounceCount = 0;
    const testDebounce = () => debounceCount++;
    window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);
    window.sharedUtilities.debounce.debounce(testDebounce, 'test', 100);

    // CLAUDE.md V8 compliant: Promise-based delay for test
    const createPromiseDelay = (ms) => new Promise(resolve => {
      const start = Date.now();
      const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
      check();
    });

    createPromiseDelay(150).then(() => {
      console.log('Debounce test:', debounceCount === 1 ? 'âœ… PASS' : 'âŒ FAIL');
    });

    // Test cache
    window.sharedUtilities.cache.set('test', 'value', 1000);
    const cached = window.sharedUtilities.cache.get('test');
    console.log('Cache test:', cached === 'value' ? 'âœ… PASS' : 'âŒ FAIL');

    // Test DOM utilities
    const testEl = window.sharedUtilities.dom.createSafeElement('div', 'test-class', 'test');
    console.log('DOM creation test:', testEl.className === 'test-class' ? 'âœ… PASS' : 'âŒ FAIL');

    // Test error handling
    window.sharedUtilities.errors.logError(new Error('Test error'), 'Integration test');
    const errors = window.sharedUtilities.errors.getRecentErrors(1);
    console.log('Error handling test:', errors.length > 0 ? 'âœ… PASS' : 'âŒ FAIL');

    console.groupEnd();
    return window.getSharedUtilitiesStats();
  };

  // =============================================================================
  // AUTHENTICATION UTILITIES
  // =============================================================================

  // Shared authentication functions for consistent behavior across pages
  window.sharedUtilities.auth = {
    // Account switching functionality shared across pages
    switchToAnotherAccount: function () {
      if (
        confirm(
          'åˆ¥ã®Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã•ã‚Œã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé¸æŠç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚'
        )
      ) {
        try {
          google.script.run
            .withSuccessHandler(function (result) {
              if (result && result.success) {
                const url = new URL(window.location.href);
                url.searchParams.set('force_account_selection', 'true');
                window.location.replace(url.toString());
              } else {
                window.sharedUtilities.auth.showAccountSwitchFallback();
              }
            })
            .withFailureHandler(function (error) {
              console.warn('èªè¨¼ãƒªã‚»ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', error);
              window.sharedUtilities.auth.showAccountSwitchFallback();
            })
            .resetAuth();
        } catch (error) {
          console.warn('ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼:', error);
          window.sharedUtilities.auth.showAccountSwitchFallback();
        }
      }
    },

    // Fallback guidance when automatic switch fails
    showAccountSwitchFallback: function () {
      const msg = `
          ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ã«ã¯ä»¥ä¸‹ã®æ‰‹é †ã‚’ãŠè©¦ã—ãã ã•ã„ï¼š

          1. æ–°ã—ã„ãƒ–ãƒ©ã‚¦ã‚¶ã‚¿ãƒ–ã§Googleï¼ˆgoogle.comï¼‰ã«ã‚¢ã‚¯ã‚»ã‚¹
          2. å³ä¸Šã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯
          3. ã€Œåˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è¿½åŠ ã€ã¾ãŸã¯ä½¿ç”¨ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠ
          4. ã“ã®ãƒšãƒ¼ã‚¸ã«æˆ»ã£ã¦å†åº¦èªè¨¼ã‚’é–‹å§‹

          ã¾ãŸã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ/ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ã§æ–°ã—ã„ã‚¿ãƒ–ã‚’é–‹ã„ã¦ã“ã®ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚
        `;
      alert(msg);
    },

    // Authentication verification with promise
    verifyAuthentication: function () {
      return new Promise((resolve, reject) => {
        // CLAUDE.md V8 compliant: Promise-based timeout for auth verification
        const createPromiseTimeout = (ms) => new Promise((_, timeoutReject) => {
          const start = Date.now();
          const check = () => {
            if (Date.now() - start >= ms) {
              timeoutReject(new Error('èªè¨¼ç¢ºèªãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ'));
            } else {
              Promise.resolve().then(check);
            }
          };
          check();
        });

        const timeoutPromise = createPromiseTimeout(10000);
        const timeoutId = Symbol('auth-timeout');

        google.script.run
          .withSuccessHandler((result) => {
            clearTimeout(timeoutId);
            if (result && result.authenticated && result.email) {
              resolve(result);
            } else {
              reject(new Error('èªè¨¼ãŒå¿…è¦ã§ã™'));
            }
          })
          .withFailureHandler((error) => {
            clearTimeout(timeoutId);
            reject(error);
          })
          .verifyUserAuthentication();
      });
    },

    // Display authentication info in standardized format
    displayAuthInfo: function (containerId, email, showSwitchOption = true) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Safely escape email with fallback
      const safeEmail =
        window.sharedUtilities && window.sharedUtilities.security
          ? window.sharedUtilities.security.escapeHtml(email)
          : (email || '').replace(/[<>&"']/g, function (match) {
              switch (match) {
                case '<':
                  return '&lt;';
                case '>':
                  return '&gt;';
                case '&':
                  return '&amp;';
                case '"':
                  return '&quot;';
                case "'":
                  return '&#39;';
                default:
                  return match;
              }
            });

      container.innerHTML = `
        <div class="bg-gray-800 rounded-lg p-4 mb-4">
          <p class="text-sm text-gray-400 mb-1">èªè¨¼æ¸ˆã¿ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ:</p>
          <p class="text-white font-semibold">${safeEmail}</p>
        </div>
        ${
          showSwitchOption
            ? `
        <div class="text-right">
          <button type="button" onclick="window.sharedUtilities.auth.switchToAnotherAccount()" class="text-cyan-400 hover:text-cyan-300 hover:underline text-sm">
            åˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³
          </button>
        </div>`
            : ''
        }
      `;
    },
  };

  // Global function for backward compatibility
  window.switchToAnotherAccount = function () {
    window.sharedUtilities.auth.switchToAnotherAccount();
  };

  // =============================================================================
  // SIMPLE LOADING MANAGER - Minimal loading overlay management
  // =============================================================================

  // Basic loading manager
  window.basicLoading = {
    overlay: null,

    init: function () {
      this.overlay = document.getElementById('loading-overlay');
      if (!this.overlay) {
        // Create simple overlay if it doesn't exist
        this.overlay = document.createElement('div');
        this.overlay.id = 'loading-overlay';
        this.overlay.style.cssText = `
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background: rgba(0,0,0,0.5); display: none; z-index: 9999;
          justify-content: center; align-items: center; color: white;
        `;
        this.overlay.innerHTML = '<div>èª­ã¿è¾¼ã¿ä¸­...</div>';
        (document.body || document.documentElement).appendChild(this.overlay);
      }
    },

    show: function () {
      if (!this.overlay) this.init();
      if (this.overlay) this.overlay.style.display = 'flex';
    },

    hide: function () {
      if (!this.overlay) this.init();
      if (this.overlay) this.overlay.style.display = 'none';
    },
  };

  // Initialize when DOM is ready and provide backward compatibility
  document.addEventListener('DOMContentLoaded', () => {
    window.basicLoading.init();
  });

  // Backward compatibility wrapper for existing code
  window.unifiedLoading = window.basicLoading;
  window.setLoading = function (isLoading, message) {
    if (isLoading) {
      window.basicLoading.show();
    } else {
      window.basicLoading.hide();
    }
  };

  // =============================================================================
  // UNIFIED LOADING MANAGER (NEW ENHANCED VERSION)
  // =============================================================================

  class UnifiedLoadingManager {
    constructor() {
      this.overlay = null;
      this.initialized = false;
      this.currentState = null;
      this.variantClasses = ['transparent', 'minimal', 'modal'];
    }

    // Initialize the loading manager with DOM element detection
    init(retries = 5, delay = 100, onSuccess = null) {
      if (this.initialized) {
        console.log('UnifiedLoadingManager: Already initialized.');
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced DOM readiness check
      if (document.readyState === 'loading') {
        console.log('UnifiedLoadingManager: DOM still loading, waiting for DOMContentLoaded...');
        document.addEventListener(
          'DOMContentLoaded',
          () => {
            // CLAUDE.md V8 compliant: requestIdleCallback for DOM-ready retry
            requestIdleCallback(() => this.init(retries, delay, onSuccess), { timeout: 50 });
          },
          { once: true }
        );
        return false;
      }

      this.overlay = document.getElementById('loading-overlay');
      if (this.overlay) {
        if (!window.unifiedLoadingInitialized) {
          window.unifiedLoadingInitialized = true;
          console.log(
            'âœ… UnifiedLoadingManager: Initialized successfully with element:',
            this.overlay.className
          );
        }
        this.initialized = true;
        if (onSuccess) onSuccess();
        return true;
      }

      // Enhanced retry logic
      if (retries > 0) {
        console.warn(
          `âš ï¸ UnifiedLoadingManager: loading-overlay element not found. DOM state: ${document.readyState}. Retrying in ${delay}ms (${retries} retries left)...`
        );
        // CLAUDE.md V8 compliant: Promise-based delay for loading manager retry
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(delay).then(() => this.init(retries - 1, delay * 1.5, onSuccess));
      } else {
        console.error(
          'âŒ UnifiedLoadingManager: Critical failure - loading-overlay element not found after multiple retries.'
        );
        this.createFallbackOverlay();
      }
      return false;
    }

    // Create a fallback overlay if none exists
    createFallbackOverlay() {
      if (document.getElementById('loading-overlay')) return;

      console.warn('âš ï¸ UnifiedLoadingManager: Creating fallback loading-overlay element');
      const fallbackOverlay = document.createElement('div');
      fallbackOverlay.id = 'loading-overlay';
      fallbackOverlay.className = 'loading-overlay page-specific hidden';

      if (document.body) {
        document.body.insertBefore(fallbackOverlay, document.body.firstChild);
        this.overlay = fallbackOverlay;
        this.initialized = true;
        console.log('âœ… UnifiedLoadingManager: Fallback overlay created and initialized');
        return true;
      }
      return false;
    }

    // Main loading function with a unified API and enhanced error handling
    setLoading(isLoading, options = {}) {
      if (!this.initialized) {
        console.warn('UnifiedLoadingManager: Not initialized, attempting initialization...');
        if (!this.init()) {
          console.error(
            'UnifiedLoadingManager: Cannot manage loading state - initialization failed.'
          );
          return;
        }
      }

      try {
        if (isLoading) {
          console.log('UnifiedLoadingManager: Showing loading overlay with options:', options);
          this.show(options);
        } else {
          console.log('UnifiedLoadingManager: Hiding loading overlay.');
          this.hide();
        }
      } catch (error) {
        console.error('UnifiedLoadingManager: Error during loading state change:', error);
      }
    }

    // Show loading overlay with options
    show(options = {}) {
      const config = {
        message: options.message || 'å‡¦ç†ä¸­...',
        type: options.type || 'overlay',
        progress: options.progress || null,
        steps: options.steps || null,
        disableInteraction: options.disableInteraction !== false,
        ...options,
      };

      this.currentState = config;

      // Clean up previous variant classes
      this.variantClasses.forEach((vc) => this.overlay.classList.remove(vc));

      // Add the new variant class if it's not the default overlay
      if (config.type !== 'overlay') {
        this.overlay.classList.add(config.type);
      }

      // Update content and show the overlay
      this.updateContent(config);
      this.overlay.classList.remove('hidden');
      this.overlay.style.setProperty('display', 'flex', 'important');

      // Manage user interaction
      if (config.disableInteraction && config.type !== 'transparent') {
        document.body.style.overflow = 'hidden';
        document.body.style.pointerEvents = 'none';
        this.overlay.style.pointerEvents = 'auto';
      }

      console.log(
        `UnifiedLoadingManager: Overlay shown with type '${config.type}' and message '${config.message}'`
      );
    }

    // Hide loading overlay with cleanup
    hide() {
      if (!this.overlay) return;

      this.overlay.classList.add('hidden');
      this.overlay.style.setProperty('display', 'none', 'important');

      // Clean up variant classes
      this.variantClasses.forEach((vc) => this.overlay.classList.remove(vc));

      // Re-enable user interaction
      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';

      // Clear current state
      this.currentState = null;

      console.log('UnifiedLoadingManager: Overlay hidden');
    }

    // Update the overlay content dynamically
    updateContent(config) {
      if (!this.overlay) return;

      // Use existing content or create default structure
      let messageElement = this.overlay.querySelector('.loading-message');
      if (!messageElement) {
        this.overlay.innerHTML = `
          <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-message">${config.message}</div>
          </div>
        `;
        messageElement = this.overlay.querySelector('.loading-message');
      } else {
        messageElement.textContent = config.message;
      }

      // Handle progress display if configured
      if (config.progress !== null && config.progress !== undefined) {
        let progressElement = this.overlay.querySelector('.loading-progress');
        if (!progressElement) {
          progressElement = document.createElement('div');
          progressElement.className = 'loading-progress';
          this.overlay.appendChild(progressElement);
        }
        progressElement.textContent = `${config.progress}%`;
      }

      // Handle step display if configured
      if (config.steps && Array.isArray(config.steps)) {
        let stepsElement = this.overlay.querySelector('.loading-steps');
        if (!stepsElement) {
          stepsElement = document.createElement('div');
          stepsElement.className = 'loading-steps';
          this.overlay.appendChild(stepsElement);
        }

        stepsElement.innerHTML = config.steps
          .map((step) => `<div class="loading-step ${step.status}">${step.text}</div>`)
          .join('');
      }
    }

    // Convenience methods for different loading types
    showOverlay(message = 'å‡¦ç†ä¸­...') {
      this.setLoading(true, { message, type: 'overlay' });
    }

    showTransparent(message = 'å‡¦ç†ä¸­...') {
      this.setLoading(true, { message, type: 'transparent' });
    }

    showWithProgress(message = 'å‡¦ç†ä¸­...', progress = 0) {
      this.setLoading(true, { message, type: 'overlay', progress });
    }

    // Admin panel specific loading with predefined steps
    showAdminProgress(message = 'ã‚·ã‚¹ãƒ†ãƒ ã‚’æº–å‚™ä¸­...', step = 1, percentage) {
      const options = {
        message,
        type: 'overlay',
        progress: percentage,
      };

      // Define standard admin loading steps
      if (step && step > 0) {
        options.steps = [
          {
            text: 'ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ä¸­...',
            status: step > 1 ? 'completed' : step === 1 ? 'active' : 'pending',
          },
          {
            text: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ä¸­...',
            status: step > 2 ? 'completed' : step === 2 ? 'active' : 'pending',
          },
          {
            text: 'ã‚·ãƒ¼ãƒˆæƒ…å ±ã¨è¨­å®šã‚’é©ç”¨ä¸­...',
            status: step > 3 ? 'completed' : step === 3 ? 'active' : 'pending',
          },
          {
            text: 'UIã‚’æœ€çµ‚èª¿æ•´ä¸­...',
            status: step > 4 ? 'completed' : step === 4 ? 'active' : 'pending',
          },
        ];
      }
      this.setLoading(true, options);
    }
  }

  // Create and initialize the global instance once the DOM is ready.
  window.unifiedLoading = new UnifiedLoadingManager();
  document.addEventListener('DOMContentLoaded', () => {
    window.unifiedLoading.init();
  });

  // Backward compatibility wrapper for the global setLoading function.
  window.setLoading = function (isLoading, message, step, percentage) {
    if (!isLoading) {
      window.unifiedLoading.setLoading(false);
      return;
    }

    if (typeof message === 'object') {
      window.unifiedLoading.setLoading(true, message);
    } else if (typeof step === 'number' && step > 0) {
      window.unifiedLoading.showAdminProgress(message, step, percentage);
    } else {
      window.unifiedLoading.showOverlay(message || 'å‡¦ç†ä¸­...');
    }
  };

  // ğŸš€ éƒ¨åˆ†ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ©Ÿèƒ½ï¼ˆè»½é‡æ“ä½œç”¨ï¼‰
  window.setPartialLoading = function (loading, message) {
    if (loading) {
      // éƒ¨åˆ†ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°: é€šçŸ¥ + ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ãƒ”ãƒŠãƒ¼ã€ç”»é¢æ“ä½œå¯èƒ½
      window.showInfo(`ğŸ”„ ${message || 'å‡¦ç†ä¸­...'}`);

      // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¦ç´ ã«ã‚¹ãƒ”ãƒŠãƒ¼ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ï¼ˆã‚ã‚Œã°ï¼‰
      const activeElements = document.querySelectorAll('.partial-loading-target');
      activeElements.forEach((el) => {
        el.classList.add('partial-loading');
        if (!el.dataset.originalText) {
          el.dataset.originalText = el.textContent;
        }
        el.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
        el.disabled = true;
      });
    } else {
      // çµ‚äº†æ™‚: ã‚¹ãƒ”ãƒŠãƒ¼é™¤å»ã€å…ƒã®çŠ¶æ…‹ã«å¾©å…ƒ
      const activeElements = document.querySelectorAll('.partial-loading');
      activeElements.forEach((el) => {
        el.classList.remove('partial-loading');
        if (el.dataset.originalText) {
          el.textContent = el.dataset.originalText;
          delete el.dataset.originalText;
        }
        el.disabled = false;
      });
    }
  };

  // =============================================================================
  // GOOGLE APPS SCRIPT ENVIRONMENT WARNING SUPPRESSION
  // =============================================================================

  // Suppress iframe and sandbox-related warnings specific to Google Apps Script
  (function () {
    const isGoogleAppsScript =
      window.location.hostname.includes('script.google.com') ||
      window.location.href.includes('script.googleusercontent.com') ||
      (typeof google !== 'undefined' && google.script);

    if (isGoogleAppsScript) {
      const originalConsoleWarn = console.warn;
      console.warn = function (...args) {
        const message = args.join(' ').toLowerCase();

        // Suppress common iframe/sandbox warnings in GAS environment
        const suppressPatterns = [
          'iframe',
          'sandbox',
          'x-frame-options',
          'frame-ancestors',
          'refused to frame',
          'same-origin policy',
          'cross-origin frame access',
          'document.domain',
          'postmessage',
          'unrecognized feature',
          'gyroscope',
          'accelerometer',
          'magnetometer',
          'camera',
          'microphone',
          'geolocation',
          'allow-scripts',
          'allow-same-origin',
          'feature',
          'permission',
          'permissions policy',
          'feature policy',
          'escape its sandboxing',
          'document.domain setter',
          'an iframe which has both allow-scripts and allow-same-origin',
          'can escape its sandboxing',
          'net state changed from idle to busy',
          'net state changed from busy to idle',
          'warden_bin_i18n_warden',
          'geolocation',
          'microphone',
          'camera',
          'gyroscope',
          'accelerometer',
          'magnetometer',
          'usb',
          'serial',
          'bluetooth',
          'hid',
          'payment',
          'display-capture',
          'screen-wake-lock',
          'web-share',
          'unrecognized feature',
          'usercodepanel',
          'mae_html_user_bin_i18n_mae_html_user',
          '3088782566-warden_bin_i18n_warden__ja.js',
          '2056725483-mae_html_user_bin_i18n_mae_html_user__ja.js',
          'an iframe which has both allow-scripts and allow-same-origin',
          'can escape its sandboxing',
          'usercodepanel',
          'mae_html_user_bin_i18n_mae_html_user',
          '3088782566-warden_bin_i18n_warden__ja.js',
          '2056725483-mae_html_user_bin_i18n_mae_html_user__ja.js',
        ];

        const shouldSuppress = suppressPatterns.some((pattern) => message.includes(pattern));

        if (!shouldSuppress) {
          originalConsoleWarn.apply(console, args);
        }
      };

      // Suppress common iframe-related errors
      const originalConsoleError = console.error;
      console.error = function (...args) {
        const message = args.join(' ').toLowerCase();

        if (
          message.includes('iframe') &&
          (message.includes('refused to frame') ||
            message.includes('x-frame-options') ||
            message.includes('frame-ancestors'))
        ) {
          return;
        }

        originalConsoleError.apply(console, args);
      };

      // Handle iframe-related window errors silently
      window.addEventListener(
        'error',
        function (event) {
          if (event.message && typeof event.message === 'string') {
            const message = event.message.toLowerCase();
            if (
              (message.includes('iframe') || message.includes('frame')) &&
              (message.includes('denied') || message.includes('blocked'))
            ) {
              event.preventDefault();
              return false;
            }
          }
        },
        true
      );
    }
  })();

  // =============================================================================
  // NOTIFICATION TOAST SYSTEM
  // =============================================================================

  class NotificationSystem {
    constructor() {
      this.container = null;
      this.initialized = false;
    }

    // Initialize notification container
    init() {
      if (this.initialized) return;

      // Check if container already exists
      this.container = document.getElementById('notification-container');

      if (!this.container) {
        // Create notification container
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.className = 'fixed top-4 right-4 z-[10000] space-y-2';
        this.container.style.cssText = 'position: fixed; top: 1rem; right: 1rem; z-index: 10000;';

        // Append to body when DOM is ready
        if (document.body) {
          document.body.appendChild(this.container);
        } else {
          document.addEventListener('DOMContentLoaded', () => {
            document.body.appendChild(this.container);
          });
        }
      }

      this.initialized = true;
    }

    // Show notification message
    showMessage(message, type = 'info', duration = 5000) {
      // Ensure container is initialized
      this.init();

      if (!this.container) {
        console.error('Notification container could not be initialized');
        // Fallback to alert for critical messages
        if (type === 'error') {
          alert('ã‚¨ãƒ©ãƒ¼: ' + message);
        }
        return;
      }

      // Color schemes for different types
      const colors = {
        success: 'border-green-400 bg-green-900/50 text-green-100',
        error: 'border-red-400 bg-red-900/50 text-red-100',
        warning: 'border-yellow-400 bg-yellow-900/50 text-yellow-100',
        info: 'border-blue-400 bg-blue-900/50 text-blue-100',
      };

      // Icons for different types
      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        warning: 'âš ï¸',
        info: 'â„¹ï¸',
      };

      // Create notification element
      const notification = document.createElement('div');
      notification.className = `notification glass-panel rounded-lg p-4 border shadow-lg flex items-center transition-all duration-300 ease-out transform translate-x-full opacity-0 ${colors[type]}`;

      // Add inline styles for better compatibility
      notification.style.cssText = `
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease-out;
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        min-height: 3rem;
        max-height: 5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid;
        line-height: 1.4;
      `;

      notification.innerHTML = `
        <div class="mr-3 text-lg flex-shrink-0 leading-none">${icons[type]}</div>
        <div class="flex-1 text-sm leading-normal">${this.escapeHtml(message)}</div>
        <button type="button" class="ml-4 text-gray-400 hover:text-white text-lg leading-none flex-shrink-0" style="background: none; border: none; cursor: pointer; line-height: 1;">âœ•</button>
      `;

      // Add close button handler
      const closeBtn = notification.querySelector('button');
      closeBtn.addEventListener('click', () => this.removeNotification(notification));

      // Append to container
      this.container.appendChild(notification);

      // CLAUDE.md V8 compliant: requestIdleCallback for notification animation
      requestIdleCallback(() => {
        notification.style.transform = 'translateX(0)';
        notification.style.opacity = '1';
      }, { timeout: 10 });

      // CLAUDE.md V8 compliant: Promise-based delay for notification auto-removal
      if (duration > 0) {
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        createPromiseDelay(duration).then(() => {
          this.removeNotification(notification);
        });
      }
    }

    // Remove notification with animation
    removeNotification(notification) {
      if (!notification) return;

      notification.style.transform = 'translateX(100%)';
      notification.style.opacity = '0';

      notification.addEventListener(
        'transitionend',
        () => {
          if (notification.parentNode) {
            notification.remove();
          }
        },
        { once: true }
      );
    }

    // Convenience methods
    success(message, duration = 5000) {
      this.showMessage(message, 'success', duration);
    }

    error(message, duration = 7000) {
      this.showMessage(message, 'error', duration);
    }

    warning(message, duration = 6000) {
      this.showMessage(message, 'warning', duration);
    }

    info(message, duration = 5000) {
      this.showMessage(message, 'info', duration);
    }

    // Escape HTML to prevent XSS
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // Clear all notifications
    clearAll() {
      if (!this.container) return;

      const notifications = this.container.querySelectorAll('.notification');
      notifications.forEach((notification) => this.removeNotification(notification));
    }
  }

  // Create global notification instance
  window.notifications = new NotificationSystem();

  // Add to shared utilities
  if (window.sharedUtilities) {
    window.sharedUtilities.notifications = window.notifications;
  }

  // Global convenience functions for backward compatibility
  window.showSuccess = function (message, duration) {
    window.notifications.success(message, duration);
  };

  window.showError = function (message, duration) {
    window.notifications.error(message, duration);
  };

  window.showWarning = function (message, duration) {
    window.notifications.warning(message, duration);
  };

  window.showInfo = function (message, duration) {
    window.notifications.info(message, duration);
  };

  // Alias for generic show message
  window.showMessage = function (message, type, duration) {
    window.notifications.showMessage(message, type, duration);
  };

  // Add styles for notification system if not using Tailwind
  if (!document.querySelector('script[src*="tailwindcss"]')) {
    const style = document.createElement('style');
    style.textContent = `
      #notification-container {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 10000;
        pointer-events: none;
      }
      #notification-container .notification {
        pointer-events: auto;
        min-width: 300px;
        max-width: 500px;
      }
    `;
    document.head.appendChild(style);
  }

  // =============================================================================
  // DYNAMIC PERFORMANCE CONSTANTS - Shared across all HTML files
  // =============================================================================

  // Performance level detection
  window.getPerformanceLevel = function() {
    if (typeof navigator === 'undefined') return 'medium';

    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const connection = navigator.connection;

    // High-end device criteria
    if (memory >= 8 && cores >= 8) return 'high';

    // Low-end device criteria
    if (memory <= 2 || cores <= 2) return 'low';

    // Network considerations
    if (connection) {
      const { effectiveType, downlink } = connection;
      if (effectiveType === '2g' || (downlink && downlink < 1)) return 'low';
      if (effectiveType === '4g' && downlink && downlink > 10) return 'high';
    }

    return 'medium';
  };

  window.isLowEndDevice = function() {
    if (typeof navigator === 'undefined') return false;

    const memory = navigator.deviceMemory;
    const cores = navigator.hardwareConcurrency;

    return (memory && memory <= 2) || (cores && cores <= 2);
  };

  // Dynamic performance constants
  window.getPerformanceConstants = function() {
    const perfLevel = window.getPerformanceLevel();
    const isLowEnd = window.isLowEndDevice();

    return {
      BASE_RENDER_BATCH_SIZE: perfLevel === 'high' ? 15 : perfLevel === 'low' ? 5 : 10,
      LOW_PERF_BATCH_SIZE: isLowEnd ? 3 : 5,
      HIGH_PERF_BATCH_SIZE: perfLevel === 'high' ? 25 : 15,
      VIEWPORT_BUFFER: perfLevel === 'high' ? 300 : perfLevel === 'low' ? 100 : 200,
      PERFORMANCE_BUDGET: perfLevel === 'high' ? 12 : perfLevel === 'low' ? 24 : 16,
      CHUNK_SIZE: perfLevel === 'high' ? 8 : perfLevel === 'low' ? 3 : 5,
      IDLE_TIMEOUT: isLowEnd ? 8000 : 5000
    };
  };

  // Getter functions for dynamic constants
  window.getBatchSize = function(type = 'base') {
    const constants = window.getPerformanceConstants();
    return constants[`${type.toUpperCase()}_BATCH_SIZE`] || constants.BASE_RENDER_BATCH_SIZE;
  };

  window.getViewportBuffer = function() {
    return window.getPerformanceConstants().VIEWPORT_BUFFER;
  };

  window.getPerformanceBudget = function() {
    return window.getPerformanceConstants().PERFORMANCE_BUDGET;
  };

  window.getChunkSize = function() {
    return window.getPerformanceConstants().CHUNK_SIZE;
  };

  window.getIdleTimeout = function() {
    return window.getPerformanceConstants().IDLE_TIMEOUT;
  };

  // Prevent duplicate loading messages
  if (!window.sharedUtilitiesLoaded) {
    window.sharedUtilitiesLoaded = true;
    console.log(
      'âœ… SharedUtilities loaded successfully - Version 1.4.0 (with Performance Constants)'
    );
  }
</script>
