/**
 * @fileoverview ServiceFactory - Áµ±‰∏Ä„Çµ„Éº„Éì„Çπ„Ç¢„ÇØ„Çª„ÇπÂ±§
 *
 * üéØ Ë≤¨‰ªªÁØÑÂõ≤:
 * - GAS Platform APIsÁµ±‰∏Ä„Ç¢„ÇØ„Çª„Çπ
 * - Zero-Dependency ArchitectureÂÆüË£Ö
 * - Service LayerÊäΩË±°Âåñ
 * - Cross-ServiceÁµ±Âêà
 *
 * üîÑ GAS Best PracticesÊ∫ñÊã†:
 * - Áõ¥Êé•ÁöÑ„Å™Èñ¢Êï∞„Ç®„ÇØ„Çπ„Éù„Éº„Éà
 * - „Éï„É©„ÉÉ„ÉàÈñ¢Êï∞ÊßãÈÄ†
 * - „Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†APIÁµ±Âêà
 */

/* global DatabaseOperations, getUserSheetData, dsAddReaction, dsToggleHighlight, getUserConfig, saveUserConfig, validateUserData, validateSession, getServiceAccountToken, connectToSheetInternal */

// ===========================================
// üîß Session Management
// ===========================================

function getSession() {
  try {
    const email = Session.getActiveUser().getEmail();
    return {
      isValid: Boolean(email),
      email: email || null
    };
  } catch (error) {
    console.warn('ServiceFactory.getSession: Session access error:', error.message);
    return {
      isValid: false,
      email: null
    };
  }
}

// ===========================================
// üìä Properties Management
// ===========================================

function getProperties() {
  try {
    const scriptProps = PropertiesService.getScriptProperties();

    return {
      getDatabaseSpreadsheetId() {
        return scriptProps.getProperty('DATABASE_SPREADSHEET_ID');
      },

      getAdminEmail() {
        return scriptProps.getProperty('ADMIN_EMAIL');
      },

      getProperty(key) {
        return scriptProps.getProperty(key);
      },

      setProperty(key, value) {
        return scriptProps.setProperty(key, value);
      },

      setProperties(properties) {
        return scriptProps.setProperties(properties);
      }
    };
  } catch (error) {
    console.error('ServiceFactory.getProperties: Properties access error:', error.message);
    return null;
  }
}

// ===========================================
// üíæ Cache Management
// ===========================================

function getCache() {
  try {
    const cache = CacheService.getScriptCache();

    return {
      get(key) {
        try {
          const value = cache.get(key);
          return value ? JSON.parse(value) : null;
        } catch (parseError) {
          console.warn('ServiceFactory.getCache.get: Parse error for key:', key);
          return null;
        }
      },

      put(key, value, expirationInSeconds = 3600) {
        try {
          return cache.put(key, JSON.stringify(value), expirationInSeconds);
        } catch (error) {
          console.warn('ServiceFactory.getCache.put: Cache put error:', error.message);
          return false;
        }
      },

      remove(key) {
        try {
          return cache.remove(key);
        } catch (error) {
          console.warn('ServiceFactory.getCache.remove: Cache remove error:', error.message);
          return false;
        }
      },

      removeAll(keys) {
        try {
          // GAS Cache.removeAll requires an array of keys; no API for clearing entire cache.
          if (Array.isArray(keys) && keys.length > 0) {
            cache.removeAll(keys);
            return true;
          }
          // No keys provided: perform a no-op to avoid API signature error.
          console.warn('ServiceFactory.getCache.removeAll: No keys provided; skipping clear');
          return false;
        } catch (error) {
          console.warn('ServiceFactory.getCache.removeAll: Cache clear error:', error.message);
          return false;
        }
      }
    };
  } catch (error) {
    console.error('ServiceFactory.getCache: Cache service error:', error.message);
    return null;
  }
}

// ===========================================
// üóÑÔ∏è Database Access
// ===========================================

function getDB() {
  try {
    const root = (typeof globalThis !== 'undefined') ? globalThis : (typeof global !== 'undefined' ? global : this);
    // Prefer globally exposed DB instance
    if (root && root.DB) {
      return root.DB;
    }
    // Fallback to DatabaseOperations symbol if present
    if (typeof DatabaseOperations !== 'undefined') {
      // Cache to global root for subsequent calls
      try { root.DB = DatabaseOperations; } catch (_) { void 0; }
      return DatabaseOperations;
    }

    console.warn('ServiceFactory.getDB: DatabaseOperations not available');
    return null;
  } catch (error) {
    console.error('ServiceFactory.getDB: Database access error:', error.message);
    return null;
  }
}

// ===========================================
// üìã Spreadsheet Operations
// ===========================================

function getSpreadsheet() {
  return {
    openById(id) {
      try {
        return SpreadsheetApp.openById(id);
      } catch (error) {
        console.error('ServiceFactory.getSpreadsheet.openById: Error opening spreadsheet:', error.message);
        return null;
      }
    },

    create(name) {
      try {
        return SpreadsheetApp.create(name);
      } catch (error) {
        console.error('ServiceFactory.getSpreadsheet.create: Error creating spreadsheet:', error.message);
        return null;
      }
    }
  };
}

// ===========================================
// üîß Utility Functions
// ===========================================

function getUtils() {
  return {
    generateId() {
      return Utilities.getUuid();
    },

    initService(serviceName) {
      try {
        if (typeof ServiceFactory === 'undefined') {
          console.warn(`init${serviceName}: ServiceFactory not available`);
          return false;
        }
        console.log(`‚úÖ ${serviceName} (Zero-Dependency) initialized successfully`);
        return true;
      } catch (error) {
        console.error(`init${serviceName} failed:`, error.message);
        return false;
      }
    },

    formatDate(date, format = 'yyyy-MM-dd HH:mm:ss') {
      try {
        return Utilities.formatDate(date, Session.getScriptTimeZone(), format);
      } catch (error) {
        console.warn('ServiceFactory.getUtils.formatDate: Format error:', error.message);
        return date.toISOString();
      }
    },

    getTimeZone() {
      try {
        return Session.getScriptTimeZone();
      } catch (error) {
        console.warn('ServiceFactory.getUtils.getTimeZone: Timezone error:', error.message);
        return 'UTC';
      }
    },

    getWebAppUrl() {
      try {
        return ScriptApp.getService().getUrl();
      } catch (error) {
        console.warn('ServiceFactory.getUtils.getWebAppUrl: WebApp URL error:', error.message);
        return '';
      }
    }
  };
}

// ===========================================
// üë§ User Service Accessor
// ===========================================

function getUserService() {
  try {
    const root = (typeof globalThis !== 'undefined') ? globalThis : this;
    if (root.UserService && typeof root.UserService.isSystemAdmin === 'function') {
      return root.UserService;
    }
    // Fallback: wrap global isSystemAdmin function if available
    if (typeof global.isSystemAdmin === 'function') {
      return { isSystemAdmin: global.isSystemAdmin };
    }
    // Safe default stub
    return {
      isSystemAdmin: () => false
    };
  } catch (error) {
    console.warn('ServiceFactory.getUserService: Access error:', error.message);
    return { isSystemAdmin: () => false };
  }
}

// ===========================================
// üìä Data Service Accessor
// ===========================================

function getDataService() {
  try {
    const root = (typeof globalThis !== 'undefined') ? globalThis : this;
    if (root.DataService) return root.DataService;

    // Build a minimal shim from available globals (best-effort)
    const shim = {};
    if (typeof getUserSheetData === 'function') {
      shim.getUserSheetData = getUserSheetData;
    }
    if (typeof dsAddReaction === 'function') {
      shim.addReaction = dsAddReaction;
    }
    if (typeof dsToggleHighlight === 'function') {
      shim.toggleHighlight = dsToggleHighlight;
    }
    if (typeof connectToSheetInternal === 'function') {
      shim.connectToSheetInternal = connectToSheetInternal;
    }
    if (Object.keys(shim).length > 0) return shim;

    console.warn('ServiceFactory.getDataService: DataService not available');
    return null;
  } catch (error) {
    console.error('ServiceFactory.getDataService: Access error:', error.message);
    return null;
  }
}

// ===========================================
// ‚öôÔ∏è Config Service Accessor
// ===========================================

function getConfigService() {
  try {
    const root = (typeof globalThis !== 'undefined') ? globalThis : this;
    if (root.ConfigService) return root.ConfigService;

    // Build minimal shim from available globals
    const shim = {};
    if (typeof getUserConfig === 'function') shim.getUserConfig = getUserConfig;
    if (typeof saveUserConfig === 'function') shim.saveUserConfig = saveUserConfig;
    if (Object.keys(shim).length > 0) return shim;

    console.warn('ServiceFactory.getConfigService: ConfigService not available');
    return null;
  } catch (error) {
    console.error('ServiceFactory.getConfigService: Access error:', error.message);
    return null;
  }
}
// ===========================================
// üîç Diagnostics
// ===========================================

function diagnose() {
  const results = {
    service: 'ServiceFactory',
    timestamp: new Date().toISOString(),
    checks: []
  };

  // Session check
  try {
    const session = getSession();
    results.checks.push({
      name: 'Session Service',
      status: session.isValid ? '‚úÖ' : '‚ö†Ô∏è',
      details: session.isValid ? `User: ${session.email}` : 'No active session'
    });
  } catch (error) {
    results.checks.push({
      name: 'Session Service',
      status: '‚ùå',
      details: error.message
    });
  }

  // Properties check
  try {
    const props = getProperties();
    results.checks.push({
      name: 'Properties Service',
      status: props ? '‚úÖ' : '‚ùå',
      details: props ? 'Properties service accessible' : 'Properties service failed'
    });
  } catch (error) {
    results.checks.push({
      name: 'Properties Service',
      status: '‚ùå',
      details: error.message
    });
  }

  // Cache check
  try {
    const cache = getCache();
    results.checks.push({
      name: 'Cache Service',
      status: cache ? '‚úÖ' : '‚ùå',
      details: cache ? 'Cache service accessible' : 'Cache service failed'
    });
  } catch (error) {
    results.checks.push({
      name: 'Cache Service',
      status: '‚ùå',
      details: error.message
    });
  }

  // Database check
  try {
    const db = getDB();
    results.checks.push({
      name: 'Database Service',
      status: db ? '‚úÖ' : '‚ö†Ô∏è',
      details: db ? 'Database operations available' : 'DatabaseOperations not found'
    });
  } catch (error) {
    results.checks.push({
      name: 'Database Service',
      status: '‚ùå',
      details: error.message
    });
  }

  results.overall = results.checks.every(check => check.status === '‚úÖ') ? '‚úÖ' : '‚ö†Ô∏è';
  return results;
}

// ===========================================
// üåç Global ServiceFactory Object
// ===========================================

/**
 * ServiceFactoryÁµ±‰∏Ä„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
 * Zero-Dependency ArchitectureÁµ±ÂêàÂ±§
 */
const __rootSF = (typeof globalThis !== 'undefined') ? globalThis : (typeof global !== 'undefined' ? global : this);
__rootSF.ServiceFactory = {
  getSession,
  getProperties,
  getCache,
  getDB,
  getSpreadsheet,
  getUtils,
  getUserService,
  getDataService,
  getConfigService,
  // Lazy accessor for SecurityService (optional usage sites)
  getSecurityService: (function () {
    return function getSecurityService() {
      try {
        const root = (typeof globalThis !== 'undefined') ? globalThis : this;
        if (root.SecurityService) return root.SecurityService;
        const shim = {};
        if (typeof validateUserData === 'function') shim.validateUserData = validateUserData;
        if (typeof validateSession === 'function') shim.validateSession = validateSession;
        if (typeof getServiceAccountToken === 'function') shim.getServiceAccountToken = getServiceAccountToken;
        if (Object.keys(shim).length > 0) return shim;
        console.warn('ServiceFactory.getSecurityService: SecurityService not available');
        return null;
      } catch (e) {
        console.error('ServiceFactory.getSecurityService: Access error:', e.message);
        return null;
      }
    };
  })(),
  diagnose
};
