<script>
// Dynamic performance-based batch sizing
const BASE_RENDER_BATCH_SIZE = 10; // Base batch size for normal performance
const LOW_PERF_BATCH_SIZE = 5; // Reduced batch size for low performance devices
const HIGH_PERF_BATCH_SIZE = 15; // Increased batch size for high performance devices
const VIEWPORT_BUFFER = 200; // Viewport buffer for virtual scrolling
const PERFORMANCE_BUDGET = 16; // Maximum ms per frame (60fps)
const CHUNK_SIZE = 5; // DOM operations per chunk
const IDLE_TIMEOUT = 5000; // Idle timeout for cleanup

// Dynamic batch size calculation based on device performance
function getDynamicBatchSize(performanceMetrics = {}) {
  const memory = navigator.deviceMemory || 4;
  const cores = navigator.hardwareConcurrency || 4;
  const frameTime = performanceMetrics.frameTime || 16;
  
  // High performance: plenty of memory, many cores, fast frame time
  if (memory >= 8 && cores >= 8 && frameTime < 12) {
    return HIGH_PERF_BATCH_SIZE;
  }
  
  // Low performance: limited memory, few cores, slow frame time
  if (memory <= 2 || cores <= 2 || frameTime > 20) {
    return LOW_PERF_BATCH_SIZE;
  }
  
  // Normal performance
  return BASE_RENDER_BATCH_SIZE;
}

// Get optimal batch size for current device
const RENDER_BATCH_SIZE = getDynamicBatchSize();
const ICONS = {
  'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
  'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
  'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
  'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
  'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
  'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
  'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star-solid': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
  'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
};

class UnifiedCache {
  constructor() {
    this.data = new Map();
    this.timestamps = new Map();
  }
  
  set(key, value, ttl = 300000) { // 5åˆ†ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆTTL
    this.data.set(key, value);
    this.timestamps.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (!this.data.has(key)) return undefined;
    
    const expiry = this.timestamps.get(key);
    if (expiry && Date.now() > expiry) {
      this.delete(key);
      return undefined;
    }
    
    return this.data.get(key);
  }
  
  has(key) {
    return this.get(key) !== undefined;
  }
  
  delete(key) {
    this.data.delete(key);
    this.timestamps.delete(key);
  }
  
  clear() {
    this.data.clear();
    this.timestamps.clear();
  }
  
  cleanup() {
    const now = Date.now();
    for (const [key, expiry] of this.timestamps.entries()) {
      if (now > expiry) {
        this.delete(key);
      }
    }
  }
  
  get size() {
    return this.data.size;
  }
}

class StudyQuestApp {
  // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®šæ•°
  static CONSTANTS = {
    REACTION_RATE_LIMIT_MS: 500,
    HIGHLIGHT_RATE_LIMIT_MS: 500,
    CACHE_TTL_MS: 1000,
    RETRY_DELAY_MS: 2000,
    POLLING_INTERVAL_MS: 5000,
    INIT_TIMEOUT_MS: 30000
  };

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’æ¤œè¨¼ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤ã‚’æä¾›
   * @param {string} userId - æ¤œè¨¼ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @returns {string} æœ‰åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼IDã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
   */
  validateUserId(userId) {
    // åŸºæœ¬çš„ãªæ¤œè¨¼
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      console.warn('âš ï¸ StudyQuestApp: Invalid or empty userId provided:', userId);
      
      // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰userIdã‚’å–å¾—ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const fallbackUserId = urlParams.get('userId');
        
        if (fallbackUserId) {
          console.log('âœ… StudyQuestApp: Using fallback userId from URL parameters:', fallbackUserId);
          return fallbackUserId;
        }
      } catch (error) {
        console.warn('âš ï¸ StudyQuestApp: Failed to get userId from URL parameters:', error.message);
      }
      
      // æœ€å¾Œã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      console.error('âŒ StudyQuestApp: No valid userId available. Data loading may fail.');
      return '';
    }
    
    // UUIDå½¢å¼ã®åŸºæœ¬çš„ãªå½¢å¼ãƒã‚§ãƒƒã‚¯ï¼ˆ36æ–‡å­—ã€ãƒã‚¤ãƒ•ãƒ³ä»˜ãï¼‰
    if (userId.length === 36 && userId.includes('-')) {
      console.log('âœ… StudyQuestApp: Valid userId format detected:', userId.substring(0, 8) + '...');
      return userId;
    }
    
    // ãã®ä»–ã®å½¢å¼ã‚‚è¨±å¯ã™ã‚‹ãŒè­¦å‘Šã‚’å‡ºã™
    console.warn('âš ï¸ StudyQuestApp: Unusual userId format, but proceeding:', userId.substring(0, 8) + '...');
    return userId;
  }

  constructor() {
    this.cache = new UnifiedCache();
    this.weakCache = new WeakMap(); // For DOM element caching
    this.performanceMetrics = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;
    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      newContentBanner: document.getElementById('newContentBanner'),
      newContentText: document.getElementById('newContentText'),
      refreshContentBtn: document.getElementById('refreshContentBtn'),
      dismissBannerBtn: document.getElementById('dismissBannerBtn'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter'),
      loadingOverlay: document.getElementById('loading-overlay')
    };
    this.state = {
      currentAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      isStudentMode: window.isStudentMode,
      isAdminUser: window.isAdminUser,
      showCounts: window.showCounts,
      showAdminFeatures: false, // åˆæœŸçŠ¶æ…‹ã¯å¸¸ã«é–²è¦§ãƒ¢ãƒ¼ãƒ‰
      showHighlightToggle: window.isAdminUser, // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
      showScoreSort: window.showScoreSort,
      displayMode: window.displayMode,
      sheetName: SHEET_NAME,
      userId: this.validateUserId(USER_ID), // Validate and add userId to state
      hasNewContent: false,
      newContentCount: 0,
      lastSeenCount: this.loadLastSeenCount(), // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒ
      pollingFailureCount: 0,
      startTime: Date.now() // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ç”¨
    };
    
    // æ–°ç€ãƒã‚§ãƒƒã‚¯ç”¨ã®åˆæœŸåŒ–
    this.lastViewKey = null;
    this.initialDataLoaded = false;
    this.hadInitialDataLoadFailure = false; // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°
    
    // Initial state setup complete
    this.serverShowCounts = window.showCounts;
    this.serverDisplayMode = window.displayMode;
    this.pollingInterval = null;
    this.handlers = {};
    this.adminModeVerified = false; // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®æ¨©é™ç¢ºèªãƒ•ãƒ©ã‚°
    this.reactionDebounce = new Map(); // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ç”¨
    this.highlightDebounce = new Map(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ç”¨
    this.pendingReactions = new Set(); // å‡¦ç†ä¸­ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    this.reactionQueue = new Map(); // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œã‚­ãƒ¥ãƒ¼
    this.reactionEventListeners = new Map(); // å‡¦ç†å®Œäº†é€šçŸ¥ç”¨
    this.isProcessingReactionQueue = false; // ã‚­ãƒ¥ãƒ¼å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°
    
    // ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ã—ãªã„è¿½åŠ æ©Ÿèƒ½ï¼‰
    this.enableBatchProcessing = true; // ãƒãƒƒãƒå‡¦ç†æœ‰åŠ¹ãƒ•ãƒ©ã‚°ï¼ˆç°¡å˜ã«ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
    this.reactionBatchQueue = new Map(); // rowIndex -> reactions[] ã®ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼
    this.batchTimer = null; // ãƒãƒƒãƒå‡¦ç†ã‚¿ã‚¤ãƒãƒ¼
    this.BATCH_TIMEOUT = 500; // 500msä»¥å†…ã®æ“ä½œã‚’ãƒãƒƒãƒåŒ–
    this.BATCH_SIZE_LIMIT = 5; // æœ€å¤§ãƒãƒƒãƒã‚µã‚¤ã‚ºï¼ˆæ§ãˆã‚ã«è¨­å®šï¼‰
    this.batchProcessingActive = false; // ãƒãƒƒãƒå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼é‡è¤‡ç™»éŒ²é˜²æ­¢ãƒ•ãƒ©ã‚°
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];
    
    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¿å­˜ç”¨ã®ã‚­ãƒ¼
    this.reactionStorageKey = `reactions_${USER_ID}_${SHEET_NAME}`;
    this.gas = {
      getPublishedSheetData: (classFilter, sort, adminMode, bypassCache) => this.runGas('getPublishedSheetData', this.state.userId, classFilter, sort, adminMode, bypassCache),
      getIncrementalSheetData: (classFilter, sort, adminMode, sinceRowCount) => this.runGas('getIncrementalSheetData', this.state.userId, classFilter, sort, adminMode, sinceRowCount),
      getAvailableSheets: () => this.runGas('getAvailableSheets', this.state.userId),
      addReactionBatch: (batchOperations) => this.runGas('addReactionBatch', this.state.userId, batchOperations), // æ–°ã—ã„ãƒãƒƒãƒAPI
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('addReaction', this.state.userId, rowIndex, reaction, sheetName),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('toggleHighlight', this.state.userId, rowIndex, sheetName),
      checkAdmin: () => this.runGas('checkAdmin', this.state.userId),
      clearCache: () => this.runGas('refreshBoardData', this.state.userId),
      getDataCount: (classFilter, sortOrder, adminMode) => this.runGas('getDataCount', this.state.userId, classFilter, sortOrder, adminMode)
    };
    
    // Polling settings
    this.pollingSettings = {
      enabled: true,
      interval: 30000, // 30ç§’é–“éš”
      maxRetries: 3,
      currentRetries: 0
    };
    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
      this.elements.sizeSlider.value = savedCols;
      this.elements.sliderValue.textContent = savedCols;
    }
    this.init().catch(error => {
      console.error('âŒ StudyQuestApp: Fatal initialization error:', error);
      this.displayInitializationError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
    });
  }
  async init() {
      try {
        // åˆæœŸãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’è¡¨ç¤º
        this.showLoadingOverlay();
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ15ç§’ï¼‰
        this.initTimeoutId = setTimeout(() => {
          this.hideLoadingOverlay();
          console.warn('ãƒšãƒ¼ã‚¸ã®åˆæœŸåŒ–ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™ã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');
        }, 15000);
        
        // Critical path only - non-blocking
        this.setupCriticalElements();
        this.showMinimalSkeleton();
        
        // Apply default low performance tweaks
        this.optimizeForLowPerformance();
        
        // Immediate async loading for data with proper await
        await this.loadDataImmediate();
        
        // Clear timeout on successful completion
        if (this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }
        
      } catch (error) {
        console.error('âŒ StudyQuestApp: Critical error in init():', error);
        this.displayInitializationError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
        
        // Clear timeout on error
        if (this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }
        
        // Hide loading overlay on error
        this.hideLoadingOverlay();
        return; // Exit early on initialization failure
      }
      
      // Defer all non-critical operations
      requestIdleCallback(() => {
        this.setupNonCriticalEventListeners();
        this.renderIcons();
        this.adjustLayout();
        this.updateSortOptions();
        this.setupObservers();
        // Initial admin state setup - ç®¡ç†è€…æ¨©é™ãŒã‚ã£ã¦ã‚‚æœ€åˆã¯é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
        if (window.hasAdminCapability && window.isAdminUser) {
          this.state.isAdminUser = true;
          this.state.showAdminFeatures = false; // åˆæœŸã¯é–²è¦§ãƒ¢ãƒ¼ãƒ‰
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.style.display = ''; // è¡¨ç¤ºã‚’ç¢ºå®Ÿã«
            this.elements.adminToggleBtn.textContent = 'ç®¡ç†ãƒ¢ãƒ¼ãƒ‰';
          }
        } else {
          // éç®¡ç†è€…ã®å ´åˆã¯ç®¡ç†æ©Ÿèƒ½ã‚’å®Œå…¨ã«ç„¡åŠ¹åŒ–
          this.state.isAdminUser = false;
          this.state.showAdminFeatures = false;
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.add('hidden');
            this.elements.adminToggleBtn.setAttribute('hidden', '');
            this.elements.adminToggleBtn.style.display = 'none'; // ç¢ºå®Ÿã«éè¡¨ç¤º
          }
        }
        
        // Start polling for new answers
        this.startNewAnswerPolling();
        
        // Start sync monitoring
        this.startSyncMonitoring();
      }, { timeout: 50 });

      // AdminPanelã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒªãƒƒã‚¹ãƒ³
      window.addEventListener('message', async (event) => {
        if (event.data && event.data.type === 'REFRESH_BOARD_DATA') {
          // Refresh board data message received
          try {
            await this.loadSheetData({ bypassCache: true });
            // Show info modal on board refresh
            this.showInfoModal();
          } catch (error) {
            console.error('ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
          }
        } else if (event.data && event.data.type === 'BOARD_PUBLISHED') {
          // æ–°ã—ã„ãƒœãƒ¼ãƒ‰ãŒå…¬é–‹ã•ã‚ŒãŸæ™‚ã®å³åº§æ›´æ–°
          console.log('æ–°ã—ã„ãƒœãƒ¼ãƒ‰ãŒå…¬é–‹ã•ã‚Œã¾ã—ãŸ:', event.data.sheetName);
          try {
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ‘ã‚¹ã§æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
            await this.checkForNewContentLight(true);
            // å¿…è¦ã«å¿œã˜ã¦ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
            await this.loadSheetData({ bypassCache: true });
            // Show info modal when new board is published
            this.showInfoModal();
          } catch (error) {
            console.warn('æ–°ã—ã„ãƒœãƒ¼ãƒ‰ã®å³åº§æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
            // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’å®Ÿè¡Œ
            try {
              await this.loadSheetData({ bypassCache: true });
            } catch (loadError) {
              console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èª­ã¿è¾¼ã¿ã‚‚ã‚¨ãƒ©ãƒ¼:', loadError);
            }
            // Show info modal even on error
            this.showInfoModal();
          }
        }
      });
      
      // BroadcastChannelã§ä»–ã®ã‚¿ãƒ–ã‹ã‚‰ã®æ›´æ–°é€šçŸ¥ã‚‚å—ä¿¡
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.addEventListener('message', async (event) => {
          if (event.data && event.data.type === 'BOARD_PUBLISHED') {
            console.log('BroadcastChannelã‹ã‚‰æ–°ã—ã„ãƒœãƒ¼ãƒ‰å…¬é–‹ã‚’å—ä¿¡:', event.data.sheetName);
            try {
              await this.checkForNewContentLight(true);
              await this.loadSheetData({ bypassCache: true });
              // Show info modal when board is updated via BroadcastChannel
              this.showInfoModal();
            } catch (error) {
              console.warn('BroadcastChannelçµŒç”±ã®æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
              try {
                await this.loadSheetData({ bypassCache: true });
              } catch (loadError) {
                console.error('BroadcastChannel ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èª­ã¿è¾¼ã¿ã‚‚ã‚¨ãƒ©ãƒ¼:', loadError);
              }
              // Show info modal even on error
              this.showInfoModal();
            }
          }
        });
      }
    }
  setupCriticalElements() {
    if (this.elements.headingLabel) {
      // å•é¡Œæ–‡ã‚’å¸¸ã«è¡¨ç¤ºï¼ˆèª­ã¿è¾¼ã¿ä¸­ã¯è¡¨ç¤ºã—ãªã„ï¼‰
      const opinionHeader = __OPINION_HEADER__.startsWith('<') || __OPINION_HEADER__.includes('èª­ã¿è¾¼ã¿')
        ? 'ãŠé¡Œ'  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ã‚­ã‚¹ãƒˆ
        : this.escapeHtml(__OPINION_HEADER__);
      this.elements.headingLabel.textContent = opinionHeader;
    }

    // Only setup absolutely critical event listeners
    this.setupEventDelegation();
    this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    // Size slider for immediate response with throttling
    const debouncedRender = this.debounce(() => this.renderBoard(true, false), 200);
    this.handlers.onSizeSliderInput = this.throttle((e) => {
      localStorage.setItem('boardColumns', e.target.value);
      debouncedRender();
    }, 100); // Throttle to 100ms
    
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, { passive: true });
    }
  }
  
  setupNonCriticalEventListeners() {
    // é‡è¤‡ç™»éŒ²é˜²æ­¢
    if (this.nonCriticalListenersSetup) {
      // Non-critical event listeners already set up
      return;
    }
    
    // answersContainer ã®ã‚¯ãƒªãƒƒã‚¯ãƒªã‚¹ãƒŠãƒ¼ã¯ setupEventDelegation() ã§ç™»éŒ²æ¸ˆã¿
    
    // Modal handlers
    this.handlers.onAnswerModalContainerClick = (e) => {
      if (e.target === e.currentTarget) {
        this.hideAnswerModal();
      }
    };
    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn) {
      this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
      this.elements.infoModalConfirmBtn.addEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    this.handlers.onModalReactionClick = (e) => {
      const btn = e.target.closest('.reaction-btn');
      const highlightBtn = e.target.closest('.highlight-btn');
      
      if (highlightBtn) {
        const id = highlightBtn.dataset.rowIndex;
        if (id) {
          this.handleHighlight(id);
        }
      } else if (btn) {
        const id = btn.dataset.rowIndex;
        const reaction = btn.dataset.reaction;
        if (id && reaction) {
          this.handleReaction(id, reaction);
        }
      }
    };
    if (this.elements.modalReactionContainer) {
      this.elements.modalReactionContainer.addEventListener('click', this.handlers.onModalReactionClick);
    }
    this.handlers.onClassFilterChange = async () => {
      this.dismissNewContentBanner(); // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã¯æ—¢å­˜ã®é€šçŸ¥ã‚’æ¶ˆå»
      try {
        await this.loadSheetData({ bypassCache: true });
        this.updateLastSeenCount(this.state.currentAnswers.length); // æ–°ã—ã„ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è¨­å®š
      } catch (error) {
        console.error('ã‚¯ãƒ©ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
    };
    this.handlers.onSortOrderChange = async () => {
      this.dismissNewContentBanner(); // ã‚½ãƒ¼ãƒˆå¤‰æ›´æ™‚ã¯æ—¢å­˜ã®é€šçŸ¥ã‚’æ¶ˆå»
      try {
        await this.loadSheetData({ bypassCache: true });
        this.updateLastSeenCount(this.state.currentAnswers.length); // æ–°ã—ã„ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è¨­å®š
      } catch (error) {
        console.error('ã‚½ãƒ¼ãƒˆé †å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
    };
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.endPublicationBtn) {
      this.handlers.onEndPublicationClick = () => this.endPublication();
      this.elements.endPublicationBtn.addEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.adminToggleBtn) {
      this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
      this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
    }
    
    // æ–°ç€é€šçŸ¥ãƒãƒŠãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    if (this.elements.refreshContentBtn) {
      this.handlers.onRefreshContentClick = async () => {
        try {
          await this.refreshContent();
        } catch (error) {
          console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
        }
      };
      this.elements.refreshContentBtn.addEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn) {
      this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
      this.elements.dismissBannerBtn.addEventListener('click', this.handlers.onDismissBannerClick);
    }
    this.handlers.onDocumentKeydown = (e) => {
      if (e.key === 'Escape') {
        this.hideAnswerModal();
      }
    };
    document.addEventListener('keydown', this.handlers.onDocumentKeydown);
    this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
    window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
    this.handlers.onVisibilityChange = () => {
      if (document.hidden) {
        this.stopPolling();
        // Cleanup when page is hidden
        this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
      } else {
        this.startPolling();
      }
    };
    document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, { passive: true });
    
    this.nonCriticalListenersSetup = true;
    // Non-critical event listener setup complete
  }
  /**
 * ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ã®è¨­å®šï¼ˆå®‰å®šç‰ˆã®å …ç‰¢ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æ¡ç”¨ï¼‰
 * ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãŒä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã¨ç«¶åˆã—ãªããªã‚Šã¾ã™ã€‚
 */
  setupEventDelegation() {
    // é‡è¤‡ç™»éŒ²é˜²æ­¢
    if (this.eventDelegationSetup) {
        // Event delegation already set up
        return;
    }
    
    this.handlers.onAnswersContainerClick = (e) => {
        const answerCard = e.target.closest('.answer-card');

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
            return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
            return;
        }

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†
        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
            e.stopPropagation(); // â˜…é‡è¦: ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’æ­¢ã‚ã€ã‚«ãƒ¼ãƒ‰æœ¬ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã¨åˆ†é›¢
            if (!reactionBtn.disabled) {
                this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
            }
            return;
        }

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†
        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
            e.stopPropagation(); // â˜…é‡è¦: åŒæ§˜ã«ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
            if (!highlightBtn.disabled) {
                this.handleHighlight(rowIndex);
            }
            return;
        }

        // ä¸Šè¨˜ä»¥å¤–ã®å ´åˆã¯ã€ã‚«ãƒ¼ãƒ‰æœ¬ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã¨ã—ã¦ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        this.showAnswerModal(rowIndex);
    };

    if (this.elements.answersContainer) {
        // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰è¿½åŠ 
        this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
        this.elements.answersContainer.addEventListener('click', this.handlers.onAnswersContainerClick);
        this.eventDelegationSetup = true;
    } else {
        console.error('No answers container found for event delegation');
    }
}
  
  // Debug helper functions removed for production
  adjustLayout() {
    if (this.baseBodyPadding === undefined) {
      this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
    }
    const footerHeight = this.elements.footer.offsetHeight;
    this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
  }
  runGas(funcName, ...args) {
    // Simple request deduplication for identical calls (except for state-changing operations)
    const cacheKey = funcName + JSON.stringify(args);
    const isStateChanging = ['toggleHighlight', 'addReaction', 'endPublication'].includes(funcName);
    
    if (!isStateChanging) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }
    }
    
    // GAS API call processing
    
    return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        const userId = USER_ID || '';
        google.script.run
          .withSuccessHandler((result) => {
            if (!isStateChanging) {
              this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
            }
            resolve(result);
          })
          .withFailureHandler((error) => {
            console.error('GAS APIã‚¨ãƒ©ãƒ¼å—ä¿¡:', { funcName, args, error, success: false });
            reject(error);
          })
          .withUserObject({ userId: userId })
          [funcName](...args);
      } else {
        console.warn('Google Apps Script environment not detected.');
        this.getMockData(funcName, ...args).then((result) => {
          if (!isStateChanging) {
            this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
          }
          resolve(result);
        }).catch(reject);
      }
    });
  }
  async verifyAdminAsync() {
    // Use server-provided flag first (fast)
    if (window.isAdminUser) {
      this.state.isAdminUser = true;
      this.state.showHighlightToggle = true; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
      // Admin permissions verified
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      return;
    }
    
    // Fallback API call (slower)
    let prevState;
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (isAdmin) {
        window.isAdminUser = true;
        this.state.isAdminUser = true;
        this.state.showHighlightToggle = true; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
        // API admin permissions verified
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
      }
    } catch (e) {
      console.error('Admin check failed', e);
    }
  }
  
  // ç®¡ç†è€…UIæ›´æ–°ã®å…±é€šãƒ¡ã‚½ãƒƒãƒ‰
  updateAdminButtonUI() {
    // Only show admin toggle button for administrators, never for viewers
    if (this.elements.adminToggleBtn && this.state.isAdminUser) {
      // Show button for admin users only
      this.elements.adminToggleBtn.classList.remove('hidden');
      this.elements.adminToggleBtn.removeAttribute('hidden');
      
      // Always show "ç®¡ç†ãƒ¢ãƒ¼ãƒ‰" text, never show "é–²è¦§ãƒ¢ãƒ¼ãƒ‰" to avoid confusion
      this.elements.adminToggleBtn.textContent = 'ç®¡ç†ãƒ¢ãƒ¼ãƒ‰';
      
      // Apply styling based on current admin mode state
      if (this.state.showAdminFeatures) {
        // Active admin mode: highlighted styling
        this.elements.adminToggleBtn.classList.remove('text-gray-500', 'opacity-60');
        this.elements.adminToggleBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
      } else {
        // Inactive admin mode: subtle gray styling
        this.elements.adminToggleBtn.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
        this.elements.adminToggleBtn.classList.add('text-gray-500', 'opacity-60');
      }
    } else {
      // Hide button for non-admin users
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.add('hidden');
        this.elements.adminToggleBtn.setAttribute('hidden', '');
      }
    }
  }
  
  updateEndPublicationButtonUI() {
    if (this.elements.endPublicationBtn) {
      if (this.state.showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', '');
      }
    }
  }
  
  // ã‚µãƒ¼ãƒãƒ¼ç®¡ç†è€…æ¨©é™ç¢ºèªã®å…±é€šãƒ¡ã‚½ãƒƒãƒ‰
  async checkServerAdminPermission() {
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (!isAdmin) {
        throw new Error('ã‚µãƒ¼ãƒãƒ¼å´ã§ç®¡ç†è€…æ¨©é™ãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ');
      }
      return true;
    } catch (error) {
      console.error('ç®¡ç†è€…æ¨©é™ç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
      throw error;
    }
  }
  
  async checkForNewContentLight(bypassCache = false) {
    // ãƒãƒ¼ãƒªãƒ³ã‚°å®Ÿè¡Œä¸­ã®å ´åˆã¯é‡è¤‡å®Ÿè¡Œã‚’é˜²ã
    if (this.contentCheckInProgress) {
      console.log('Content check already in progress, skipping...');
      return;
    }
    
    try {
      this.contentCheckInProgress = true;
      
      // åŸºæœ¬çŠ¶æ…‹ã®æ¤œè¨¼
      if (!this.validateContentCheckPrerequisites()) {
        return;
      }
      
      // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æº–å‚™
      const { selectedClass, sortOrder } = this.prepareContentCheckParams();
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦ãªå ´åˆï¼‰
      if (bypassCache) {
        await this.clearCacheForContentCheck();
      }
      
      // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ä»¶æ•°ã‚’å–å¾—
      const countData = await this.fetchContentCount(selectedClass, sortOrder);
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‡¦ç†
      await this.processContentCountResponse(countData, selectedClass, sortOrder);
      
    } catch (error) {
      await this.handleContentCheckError(error);
    } finally {
      this.contentCheckInProgress = false;
    }
  }
  
  validateContentCheckPrerequisites() {
    // å¿…è¦ãªè¦ç´ ã®å­˜åœ¨ç¢ºèª
    if (!this.elements.classFilter || !this.elements.sortOrder) {
      console.warn('Required UI elements not available for content check');
      return false;
    }
    
    // åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
    if (!this.state.userId) {
      console.warn('User ID not available for content check');
      return false;
    }
    
    return true;
  }
  
  prepareContentCheckParams() {
    let selectedClass = this.elements.classFilter.value || 'ã™ã¹ã¦';
    if (!selectedClass.trim()) {
      selectedClass = 'ã™ã¹ã¦';
    }
    
    const sortOrder = this.elements.sortOrder.value || 'newest';
    
    return { selectedClass, sortOrder };
  }
  
  async clearCacheForContentCheck() {
    try {
      await this.gas.clearCache();
      console.log('âœ… Cache cleared for content check');
    } catch (error) {
      console.warn('âš ï¸ Failed to clear cache:', error.message);
      // Continue without cache clearing
    }
  }
  
  async fetchContentCount(selectedClass, sortOrder) {
    const countData = await this.gas.getDataCount(
      selectedClass, 
      sortOrder, 
      this.state.showAdminFeatures
    );
    
    if (!countData) {
      throw new Error('No response from server for content count');
    }
    
    return countData;
  }
  
  async processContentCountResponse(countData, selectedClass, sortOrder) {
    const newCount = countData.count || 0;
    
    console.log('ğŸ“Š Content count check:', {
      newCount,
      currentCount: this.state.currentAnswers?.length || 0,
      lastSeenCount: this.state.lastSeenCount,
      selectedClass,
      sortOrder,
      hadInitialFailure: this.hadInitialDataLoadFailure
    });
    
    // ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã®ãƒãƒ¼ã‚¯
    this.state.pollingFailureCount = 0;
    
    // ç¾åœ¨ã®ãƒ“ãƒ¥ãƒ¼ã‚­ãƒ¼
    const currentViewKey = `${selectedClass}-${sortOrder}`;
    
    // åˆå›ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å®Œäº†ã®å‡¦ç†
    if (!this.initialDataLoaded) {
      await this.handleInitialContentLoad(currentViewKey, newCount);
      return;
    }
    
    // ãƒ“ãƒ¥ãƒ¼è¨­å®šå¤‰æ›´ã®å‡¦ç†
    if (this.lastViewKey !== currentViewKey) {
      await this.handleViewChange(currentViewKey, newCount);
      return;
    }
    
    // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ¤œå‡º
    await this.checkForNewItems(newCount);
  }
  
  async handleInitialContentLoad(currentViewKey, newCount) {
    this.lastViewKey = currentViewKey;
    
    // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®åˆå›æˆåŠŸãƒãƒ¼ãƒªãƒ³ã‚°æ™‚ã®ç‰¹åˆ¥å‡¦ç†
    if (this.hadInitialDataLoadFailure && newCount > this.state.lastSeenCount) {
      console.log('ğŸ”„ åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®æ–°ç€æ¤œå‡º:', {
        newCount,
        lastSeenCount: this.state.lastSeenCount,
        difference: newCount - this.state.lastSeenCount
      });
      
      // å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.hadInitialDataLoadFailure = false;
      
      // æ–°ç€é€šçŸ¥ã‚’å…ˆã«è¡¨ç¤º
      await this.checkForNewItems(newCount);
    }
    
    this.updateLastSeenCount(newCount);
    this.initialDataLoaded = true;
    
    console.log('âœ… Initial content load completed:', {
      viewKey: currentViewKey,
      count: newCount,
      hadPreviousFailure: this.hadInitialDataLoadFailure
    });
  }
  
  async handleViewChange(currentViewKey, newCount) {
    console.log('ğŸ”„ View settings changed:', {
      from: this.lastViewKey,
      to: currentViewKey,
      newCount
    });
    
    this.lastViewKey = currentViewKey;
    this.updateLastSeenCount(newCount);
    this.dismissNewContentBanner();
  }
  
  async checkForNewItems(newCount) {
    if (newCount > this.state.lastSeenCount) {
      const newItems = newCount - this.state.lastSeenCount;
      
      console.log('ğŸ“¢ New content detected:', {
        newCount,
        lastSeen: this.state.lastSeenCount,
        newItems
      });
      
      // æ–°ç€é€šçŸ¥ãƒãƒŠãƒ¼ã‚’è¡¨ç¤º
      this.showNewContentBanner(newItems);
    }
  }
  
  // è‡ªå‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ– - æ–°ç€æ™‚ã¯å¸¸ã«é€šçŸ¥ãƒãƒŠãƒ¼è¡¨ç¤º
  shouldAutoRefresh(newItems) {
    return false;
  }
  
  async handleContentCheckError(error) {
    this.state.pollingFailureCount++;
    
    console.warn('âŒ Content check failed:', {
      error: error.message,
      failureCount: this.state.pollingFailureCount
    });
    
    // é€£ç¶šå¤±æ•—æ™‚ã®å¯¾å‡¦
    if (this.state.pollingFailureCount >= 3) {
      console.log('â³ Too many polling failures, extending interval...');
      await this.handlePollingFailures();
    }
  }
  
  async handlePollingFailures() {
    this.stopPolling();
    
    // 5ç§’å¾Œã«ãƒãƒ¼ãƒªãƒ³ã‚°å†é–‹
    setTimeout(() => {
      this.startPolling();
      this.state.pollingFailureCount = 0;
      console.log('âœ… Polling restarted after failure recovery');
    }, 5000);
  }
  
  // æ–°ç€é€šçŸ¥ãƒãƒŠãƒ¼ã‚’è¡¨ç¤º
  showNewContentBanner(newItems) {
    if (!this.elements.newContentBanner) return;
    
    // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼šçŸ­æ™‚é–“å†…ã®é€£ç¶šé€šçŸ¥ã‚’é˜²ã
    const now = Date.now();
    if (this.lastNotificationTime && (now - this.lastNotificationTime) < 2000) {
      console.log('ğŸš« é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹: çŸ­æ™‚é–“å†…ã®é€£ç¶šé€šçŸ¥ã‚’ã‚¹ã‚­ãƒƒãƒ—');
      return;
    }
    this.lastNotificationTime = now;
    
    // æ—¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æ–°ã—ã„æ•°ã§ä¸Šæ›¸ãï¼ˆç´¯ç©ã—ãªã„ï¼‰
    if (!this.elements.newContentBanner.classList.contains('hidden')) {
      console.log('ğŸ“± é€šçŸ¥æ›´æ–°: æ—¢å­˜ãƒãƒŠãƒ¼ã‚’æ–°ã—ã„æ•°ã§æ›´æ–°', {
        oldCount: this.state.newContentCount,
        newCount: newItems
      });
      this.state.newContentCount = newItems; // ç´¯ç©ã›ãšä¸Šæ›¸ã
    } else {
      this.state.newContentCount = newItems;
    }
    
    this.state.hasNewContent = true;
    
    const message = this.state.newContentCount === 1 ? 
      'æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ' : 
      `${this.state.newContentCount}ä»¶ã®æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ`;
    this.elements.newContentText.textContent = message;
    
    this.elements.newContentBanner.classList.remove('hidden');
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰é©ç”¨
    this.elements.newContentBanner.style.animation = '';
    
    // 3ç§’å¾Œã«ãƒã‚¦ãƒ³ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    setTimeout(() => {
      if (!this.elements.newContentBanner.classList.contains('hidden')) {
        this.elements.newContentBanner.style.animation = 'bounce 1s ease-in-out';
      }
    }, 3000);
    
    console.log('ğŸ“¢ æ–°ç€é€šçŸ¥è¡¨ç¤º:', {
      count: this.state.newContentCount,
      message: message
    });
  }
  
  // æ–°ç€ãƒãƒŠãƒ¼ã‚’é–‰ã˜ã‚‹
  dismissNewContentBanner() {
    if (!this.elements.newContentBanner) return;
    
    this.elements.newContentBanner.classList.add('hidden');
    this.elements.newContentBanner.style.animation = '';
    this.state.hasNewContent = false;
    this.state.newContentCount = 0;
  }
  
  // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆé€šçŸ¥ãƒãƒŠãƒ¼ã‹ã‚‰ã®å‘¼ã³å‡ºã—ï¼‰
  async refreshContent() {
    try {
      // ã¾ãšå¢—åˆ†æ›´æ–°ã‚’è©¦è¡Œ
      await this.refreshContentIncremental();
    } catch (error) {
      console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      // å¢—åˆ†æ›´æ–°ãŒå¤±æ•—ã—ãŸå ´åˆã¯ãƒ•ãƒ«æ›´æ–°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…¨ä½“æ›´æ–°ã‚’å®Ÿè¡Œ');
      await this.refreshContentFull();
    }
  }
  
  // å¢—åˆ†ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆæ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã®ã¿å–å¾—ãƒ»è¿½åŠ ï¼‰
  async refreshContentIncremental() {
    this.dismissNewContentBanner();
    
    try {
      const originalText = this.elements.refreshContentBtn ? this.elements.refreshContentBtn.textContent : '';
      if (this.elements.refreshContentBtn) {
        this.elements.refreshContentBtn.textContent = 'æ›´æ–°ä¸­...';
        this.elements.refreshContentBtn.disabled = true;
      }
      
      console.log('ğŸ”„ å¢—åˆ†ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹ - åŸºæº–è¡Œæ•°:', this.state.lastSeenCount || 0);
      
      // ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿è¨­å®šã‚’å–å¾—
      const classFilter = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
      const adminMode = this.state.showAdminFeatures;
      
      // å¢—åˆ†ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const incrementalData = await this.gas.getIncrementalSheetData(
        classFilter, 
        sortOrder, 
        adminMode, 
        this.state.lastSeenCount || 0
      );
      
      if (incrementalData.status === 'error') {
        throw new Error(incrementalData.message);
      }
      
      console.log('ğŸ“¥ å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœ:', {
        newCount: incrementalData.newCount,
        totalCount: incrementalData.totalCount,
        hasNewData: incrementalData.newCount > 0,
        currentCardsCount: this.state.currentAnswers.length,
        lastSeenCount: this.state.lastSeenCount
      });
      
      // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ï¼šè¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ãƒ‰æ•°ã¨æœŸå¾…å€¤ãŒä¸ä¸€è‡´ã®å ´åˆ
      const expectedCardCount = this.state.lastSeenCount || 0;
      const actualCardCount = this.state.currentAnswers.length;
      
      if (actualCardCount < expectedCardCount || (incrementalData.totalCount > 0 && actualCardCount === 0)) {
        console.warn('ğŸš¨ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡º - ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’å®Ÿè¡Œ:', {
          expected: expectedCardCount,
          actual: actualCardCount,
          serverTotal: incrementalData.totalCount
        });
        
        // ä¸æ•´åˆã®å ´åˆã¯ç›´æ¥ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’å®Ÿè¡Œ
        await this.refreshContentFull();
        return;
      }
      
      // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ
      if (incrementalData.newCount === 0) {
        this.provideFeedback('æœ€æ–°ã®çŠ¶æ…‹ã§ã™', 'info');
        this.updateLastSeenCount(incrementalData.totalCount);
        return;
      }
      
      // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã«è¿½åŠ 
      await this.appendNewCards(incrementalData.data, sortOrder);

      // çŠ¶æ…‹ã‚’æ›´æ–°
      if (sortOrder === 'newest') {
        this.state.currentAnswers = incrementalData.data.concat(this.state.currentAnswers);
      } else {
        this.state.currentAnswers = this.state.currentAnswers.concat(incrementalData.data);
      }

      // ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦ä»–ã®ã‚½ãƒ¼ãƒˆé †ã§ã‚‚æ–°ç€ãŒåæ˜ ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
      this.gas.clearCache().catch(err => console.warn('Cache clear failed', err));
      this.updateLastSeenCount(incrementalData.totalCount);
      
      console.log('âœ… å¢—åˆ†ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†:', {
        addedCards: incrementalData.newCount,
        totalCards: this.state.currentAnswers.length,
        newBaseline: this.state.lastSeenCount
      });
      
      this.provideFeedback(`${incrementalData.newCount}ä»¶ã®æ–°ã—ã„æŠ•ç¨¿ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, 'success');
      
    } catch (error) {
      console.error('å¢—åˆ†ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã«å¤±æ•—:', error);
      
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®å…¨ä½“æ›´æ–°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…¨ä½“æ›´æ–°ã‚’å®Ÿè¡Œ');
      await this.refreshContentFull();
      
    } finally {
      // ãƒœã‚¿ãƒ³ã‚’å…ƒã«æˆ»ã™
      if (this.elements.refreshContentBtn) {
        this.elements.refreshContentBtn.textContent = this.elements.refreshContentBtn.textContent.includes('æ›´æ–°ä¸­') ? 
          (originalText || 'æ›´æ–°ã—ã¦è¡¨ç¤º') : this.elements.refreshContentBtn.textContent;
        this.elements.refreshContentBtn.disabled = false;
      }
    }
  }
  
  // å…¨ä½“ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆå¾“æ¥ã®æ–¹æ³•ï¼‰
  async refreshContentFull() {
    try {
      // å¾“æ¥ã®æ‰‹å‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      this.cache.clear();
      console.log('ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹ - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å®Œäº†');
      
      await this.loadSheetData({ bypassCache: true });
      
      // æ‰‹å‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã¯æ–°ç€ãƒã‚§ãƒƒã‚¯åŸºæº–ã‚’æ›´æ–°ï¼ˆåˆæœŸåŒ–ãƒ•ãƒ©ã‚°ã¯ç¶­æŒï¼‰
      this.updateLastSeenCount(this.state.currentAnswers.length);
      console.log('ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€æ–°ç€åŸºæº–æ›´æ–°:', {
        newLastSeenCount: this.state.lastSeenCount,
        maintainInitialFlag: this.initialDataLoaded,
        currentAnswersLength: this.state.currentAnswers.length,
        visibleCards: document.querySelectorAll('.answer-card').length
      });
      
      this.provideFeedback('æ›´æ–°å®Œäº†ï¼', 'success');
      
    } catch (error) {
      console.error('å…¨ä½“ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã«å¤±æ•—:', error);
      this.provideFeedback('æ›´æ–°å¤±æ•—', 'error');
      throw error;
    }
  }

  // æ–°ç€å›ç­”ã®ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹
  startNewAnswerPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }

    this.pollingInterval = setInterval(async () => {
      if (!this.pollingSettings.enabled) return;

      try {
        await this.checkForNewAnswers();
        this.pollingSettings.currentRetries = 0; // æˆåŠŸæ™‚ã¯ãƒªãƒˆãƒ©ã‚¤ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
      } catch (error) {
        this.pollingSettings.currentRetries++;
        console.warn(`ãƒãƒ¼ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ (${this.pollingSettings.currentRetries}/${this.pollingSettings.maxRetries}):`, error);
        
        if (this.pollingSettings.currentRetries >= this.pollingSettings.maxRetries) {
          console.error('ãƒãƒ¼ãƒªãƒ³ã‚°æœ€å¤§ãƒªãƒˆãƒ©ã‚¤æ•°ã«é”ã—ãŸãŸã‚åœæ­¢');
          this.stopNewAnswerPolling();
        }
      }
    }, this.pollingSettings.interval);

    console.log('ğŸ”„ æ–°ç€å›ç­”ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹:', {
      interval: this.pollingSettings.interval,
      enabled: this.pollingSettings.enabled
    });
  }

  // æ–°ç€å›ç­”ã®ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
  stopNewAnswerPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
      console.log('â¹ï¸ æ–°ç€å›ç­”ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢');
    }
  }

  // æ–°ç€å›ç­”ã®ç¢ºèª
  async checkForNewAnswers() {
    if (this.state.isLoading) return; // æ—¢ã«ãƒ­ãƒ¼ãƒ‰ä¸­ã®å ´åˆã¯è·³ã°ã™

    try {
      const classFilter = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
      const adminMode = this.state.showAdminFeatures;
      
      const incrementalData = await this.gas.getIncrementalSheetData(
        classFilter, 
        sortOrder, 
        adminMode, 
        this.state.lastSeenCount || 0
      );
      
      if (incrementalData.status === 'error') {
        throw new Error(incrementalData.message);
      }
      
      // æ–°ç€ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆ
      if (incrementalData.newCount > 0) {
        console.log('ğŸ†• æ–°ç€å›ç­”æ¤œå‡º:', {
          newCount: incrementalData.newCount,
          totalCount: incrementalData.totalCount
        });
        
        this.state.hasNewContent = true;
        this.state.newContentCount = incrementalData.newCount;
        this.showNewContentBanner(incrementalData.newCount);
      }
      
    } catch (error) {
      console.error('æ–°ç€ç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
      throw error;
    }
  }
  
  // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ›´æ–°ï¼ˆæ‰‹å‹•ï¼‰ - å¢—åˆ†æ›´æ–°ã‚’å„ªå…ˆ
  async refreshContent() {
    // å¢—åˆ†æ›´æ–°ã‚’è©¦è¡Œã€å¤±æ•—æ™‚ã¯å…¨ä½“æ›´æ–°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    await this.refreshContentIncremental();
  }
  
  // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
  async appendNewCards(newData, sortOrder = 'newest') {
    if (!newData || newData.length === 0) return;
    
    console.log('ğŸ“Œ æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ :', newData.length + 'ä»¶');
    debugLog('DEBUG: appendNewCards called. newData length:', newData.length);
    
    const container = this.elements.answersContainer;
    if (!container) return;
    
    // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
    const fragment = document.createDocumentFragment();
    const addedCardIds = [];
    
    for (const data of newData) {
      const cardElement = this.createAnswerCard(data);
      if (cardElement) {
        // å·®åˆ†è¿½åŠ ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ãƒãƒ¼ã‚¯
        cardElement.setAttribute('data-differential-card', 'true');
        cardElement.setAttribute('data-added-timestamp', Date.now().toString());
        
        // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        cardElement.style.opacity = '0';
        cardElement.style.transform = 'translateY(20px)';
        fragment.appendChild(cardElement);
        
        // è¿½åŠ ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®IDã‚’è¨˜éŒ²
        if (data.rowIndex !== undefined) {
          addedCardIds.push(data.rowIndex);
        }
      }
    }
    
    // å·®åˆ†è¿½åŠ ã‚«ãƒ¼ãƒ‰ã®IDã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
    if (addedCardIds.length > 0) {
      this.saveDifferentialCards(addedCardIds);
    }
    
    if (sortOrder === 'newest') {
      container.prepend(fragment);
      debugLog('DEBUG: appendNewCards - Fragment prepended. answersContainer children count:', container.children.length);
    } else {
      container.appendChild(fragment);
      debugLog('DEBUG: appendNewCards - Fragment appended. answersContainer children count:', container.children.length);
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
    await new Promise(resolve => {
      requestAnimationFrame(() => {
        const newCards = container.querySelectorAll('.answer-card[style*="opacity: 0"]');
        newCards.forEach((card, index) => {
          setTimeout(() => {
            card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, index * 100); // 100msãšã¤é…å»¶ã—ã¦é †æ¬¡è¡¨ç¤º
        });
        
        // å…¨ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿ
        setTimeout(resolve, newCards.length * 100 + 300);
      });
    });
  }
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º
  provideFeedback(message, type = 'info') {
    if (!this.elements.refreshContentBtn) return;
    
    const originalText = this.elements.refreshContentBtn.textContent;
    const originalBackground = this.elements.refreshContentBtn.style.background;
    
    this.elements.refreshContentBtn.textContent = message;
    
    switch (type) {
      case 'success':
        this.elements.refreshContentBtn.style.background = 'rgba(16, 185, 129, 0.3)';
        break;
      case 'error':
        this.elements.refreshContentBtn.style.background = 'rgba(239, 68, 68, 0.3)';
        break;
      case 'info':
        this.elements.refreshContentBtn.style.background = 'rgba(59, 130, 246, 0.3)';
        break;
    }
    
    setTimeout(() => {
      this.elements.refreshContentBtn.textContent = originalText;
      this.elements.refreshContentBtn.style.background = originalBackground;
    }, 2000);
  }
  
  getMockData(funcName, ...args) {
    return new Promise((resolve) => {
      setTimeout(() => {
        if (funcName === 'getPublishedSheetData') {
          const currentDisplayMode = window.displayMode || this.state.displayMode;
          const studentName1 = currentDisplayMode === 'named' ? 'ç”°ä¸­å¤ªéƒ' : '';
          const studentName2 = currentDisplayMode === 'named' ? 'ä½è—¤èŠ±å­' : '';
          resolve({
            header: 'ãƒ†ã‚¹ãƒˆå•é¡Œ',
            sheetName: 'ãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒˆ',
            data: [
              {
                rowIndex: 1,
                name: studentName1,
                class: '3å¹´Açµ„',
                opinion: 'ã“ã‚Œã¯ç´ æ™´ã‚‰ã—ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã ã¨æ€ã„ã¾ã™ã€‚',
                reason: 'ç†ç”±ã¯ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ãã€å®Ÿç¾å¯èƒ½æ€§ãŒé«˜ã„ã‹ã‚‰ã§ã™ã€‚',
                reactions: {
                  UNDERSTAND: { count: 5, reacted: false },
                  LIKE: { count: 2, reacted: false },
                  CURIOUS: { count: 1, reacted: false }
                },
                highlight: false
              },
              {
                rowIndex: 2,
                name: studentName2,
                class: '3å¹´Bçµ„',
                opinion: 'å°‘ã—æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚‹ã¨è€ƒãˆã¾ã™ã€‚',
                reason: 'ã‚ˆã‚Šå¤šãã®äººã®æ„è¦‹ã‚’èãå¿…è¦ãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚',
                reactions: {
                  UNDERSTAND: { count: 3, reacted: true },
                  LIKE: { count: 0, reacted: false },
                  CURIOUS: { count: 0, reacted: false }
                },
                highlight: true
              }
            ]
          });
        } else if (funcName === 'addReaction') {
          resolve({
            status: 'ok',
            reactions: {
              UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
            }
          });
        } else if (funcName === 'toggleHighlight') {
          const currentHighlight = args[2] === undefined ? false : !args[2];
          resolve({
            status: 'ok',
            highlight: currentHighlight
          });
        } else if (funcName === 'checkAdmin') {
          resolve(true);
        }
      }, 300);
    });
  }
  startPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    
    // Adaptive polling: start with normal interval, adjust based on success/failure
    this.pollSuccessCount = 0;
    this.pollFailureCount = 0;
    this.currentPollInterval = this.isLowPerformanceMode ? 30000 : 15000;
    
    const adaptivePoll = async () => {
      console.log('â° ãƒãƒ¼ãƒªãƒ³ã‚°å®Ÿè¡Œ:', {
        currentInterval: this.currentPollInterval,
        successCount: this.pollSuccessCount,
        failureCount: this.pollFailureCount,
        timestamp: new Date().toLocaleTimeString()
      });
      
      try {
        await this.checkForNewContentLight();
        this.pollSuccessCount++;
        this.pollFailureCount = 0;
        
        // Reduce interval on consistent success (but not below minimum)
        if (this.pollSuccessCount > 3 && this.currentPollInterval > 10000) {
          this.currentPollInterval = Math.max(10000, this.currentPollInterval * 0.9);
        }
        
        console.log('âœ… ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸ:', {
          successCount: this.pollSuccessCount,
          nextInterval: this.currentPollInterval
        });
      } catch (error) {
        this.pollFailureCount++;
        this.pollSuccessCount = 0;
        
        // Increase interval on failures (exponential backoff)
        if (this.pollFailureCount > 2) {
          this.currentPollInterval = Math.min(60000, this.currentPollInterval * 1.5);
        }
        console.warn('âŒ ãƒãƒ¼ãƒªãƒ³ã‚°å¤±æ•—:', error, {
          failureCount: this.pollFailureCount,
          newInterval: this.currentPollInterval
        });
      }
      
      // Schedule next poll with current interval
      this.pollingTimeout = setTimeout(adaptivePoll, this.currentPollInterval);
    };
    
    // Start first poll
    this.pollingTimeout = setTimeout(adaptivePoll, this.currentPollInterval);
    
    // Start automatic cleanup for memory management
    // å®šæœŸçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã¨ãƒ¡ãƒ¢ãƒªç®¡ç†
    this.cleanupInterval = setInterval(() => {
      this.performMemoryCleanup();
    }, 5 * 60 * 1000); // Cleanup every 5 minutes
    
    // é•·æ™‚é–“å®Ÿè¡Œç›£è¦–ï¼ˆ1æ™‚é–“ã”ã¨ï¼‰
    this.longRunningCheckInterval = setInterval(() => {
      this.checkLongRunningPerformance();
    }, 60 * 60 * 1000); // Check every hour
  }
  stopPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    if (this.pollingTimeout) {
      clearTimeout(this.pollingTimeout);
      this.pollingTimeout = null;
    }
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    
    if (this.longRunningCheckInterval) {
      clearInterval(this.longRunningCheckInterval);
      this.longRunningCheckInterval = null;
    }
  }
  
  // ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  performMemoryCleanup() {
    try {
      console.log('ğŸ§¹ Performing memory cleanup...');
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      if (this.cache) {
        const cacheSize = this.cache.size();
        this.cache.cleanup();
        console.log('ğŸ—‘ï¸ Cache cleanup completed', {cacheSize});
      }
      
      // å¤ã„DOMè¦ç´ ã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
      this.cleanupDOMReferences();
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®æ•´ç†
      this.cleanupEventListeners();
      
      // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã®æœ€é©åŒ–
      this.optimizeVirtualScrollState();
      
      console.log('âœ… Memory cleanup completed');
    } catch (error) {
      console.warn('âš ï¸ Memory cleanup failed:', error);
    }
  }
  
  cleanupDOMReferences() {
    // å‰Šé™¤ã•ã‚ŒãŸDOMè¦ç´ ã¸ã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
    const elementsToCheck = ['answersContainer', 'loadingOverlay', 'newContentBanner'];
    elementsToCheck.forEach(key => {
      const element = this.elements[key];
      if (element && !document.contains(element)) {
        console.log(`ğŸ§¹ Removing stale DOM reference: ${key}`);
        delete this.elements[key];
      }
    });
  }
  
  cleanupEventListeners() {
    // é‡è¤‡ã—ãŸã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç¢ºèªã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    if (this.handlers) {
      Object.keys(this.handlers).forEach(key => {
        if (typeof this.handlers[key] !== 'function') {
          console.log(`ğŸ§¹ Removing invalid handler: ${key}`);
          delete this.handlers[key];
        }
      });
    }
  }
  
  optimizeVirtualScrollState() {
    // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã®æœ€é©åŒ–
    if (this.virtualScrollState && this.virtualScrollState.renderedRowIndexes) {
      const size = this.virtualScrollState.renderedRowIndexes.size;
      if (size > 1000) { // å¤§é‡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒè“„ç©ã•ã‚Œã¦ã„ã‚‹å ´åˆ
        console.log(`ğŸ§¹ Optimizing virtual scroll state (${size} items)`);
        this.virtualScrollState.renderedRowIndexes.clear();
        this.virtualScrollState.renderedItems = 0;
      }
    }
  }
  
  checkLongRunningPerformance() {
    try {
      const uptime = Date.now() - this.state.startTime;
      const uptimeHours = Math.floor(uptime / (1000 * 60 * 60));
      
      console.log(`â° Long-running check: ${uptimeHours}h uptime`);
      
      // 2æ™‚é–“ä»¥ä¸Šå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹å ´åˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å¯¾ç­–
      if (uptimeHours >= 2) {
        console.log('ğŸ”§ Applying long-running optimizations...');
        
        // ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã‚’å»¶é•·ï¼ˆè² è·è»½æ¸›ï¼‰
        if (this.currentPollInterval < 60000) { // 1åˆ†æœªæº€ã®å ´åˆ
          this.currentPollInterval = Math.min(60000, this.currentPollInterval * 1.5);
          console.log(`ğŸ“‰ Polling interval extended to ${this.currentPollInterval}ms`);
        }
        
        // å¼·åˆ¶çš„ãªãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        this.performMemoryCleanup();
        
        // å¯èƒ½ã§ã‚ã‚Œã°ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¿ƒã™
        if (window.gc && typeof window.gc === 'function') {
          window.gc();
          console.log('ğŸ—‘ï¸ Manual garbage collection triggered');
        }
      }
      
      // 6æ™‚é–“ä»¥ä¸Šã®å ´åˆã¯è­¦å‘Š
      if (uptimeHours >= 6) {
        console.warn('âš ï¸ Application has been running for over 6 hours. Consider refreshing the page.');
        this.showWarningMessage('é•·æ™‚é–“ã®å®Ÿè¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ã€ãƒšãƒ¼ã‚¸ã®å†èª­ã¿è¾¼ã¿ã‚’æ¨å¥¨ã—ã¾ã™ã€‚');
      }
      
    } catch (error) {
      console.warn('âš ï¸ Long-running performance check failed:', error);
    }
  }
  
  showWarningMessage(message) {
    // è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆæ—¢å­˜ã®showErrorMessageã‚’å‚è€ƒã«ï¼‰
    const warningDiv = document.createElement('div');
    warningDiv.className = 'fixed top-4 right-4 z-50 bg-yellow-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md border-l-4 border-yellow-400';
    warningDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13 4c-.77-.833-1.964-.833-2.732 0L3 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
        </svg>
        <span class="text-sm">${this.escapeHtml(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 hover:bg-yellow-700 rounded p-1">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    `;
    
    document.body.appendChild(warningDiv);
    
    // 10ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
    setTimeout(() => {
      if (warningDiv.parentNode) {
        warningDiv.parentNode.removeChild(warningDiv);
      }
    }, 10000);
  }

  destroy() {
    this.stopPolling();
    this.cleanup();
    if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
      this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
    }
    if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
      this.elements.answerModalCloseBtn.removeEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
      this.elements.answerModalContainer.removeEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
      this.elements.infoModalConfirmBtn.removeEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
      this.elements.modalReactionContainer.removeEventListener('click', this.handlers.onModalReactionClick);
    }
    if (this.elements.classFilter && this.handlers.onClassFilterChange) {
      this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
      this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
      this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
    }
    if (this.handlers.onDocumentKeydown) {
      document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
    }
    if (this.handlers.onWindowResize) {
      window.removeEventListener('resize', this.handlers.onWindowResize);
    }
    if (this.handlers.onVisibilityChange) {
      document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
    }
    if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
      this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
    }
    if (this.handlers.onDocumentClick) {
      document.removeEventListener('click', this.handlers.onDocumentClick);
    }
    // Cleanup observers
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    // Cancel any pending callbacks
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    // æ¼ã‚Œã¦ã„ãŸã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
    if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
      this.elements.refreshContentBtn.removeEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
      this.elements.dismissBannerBtn.removeEventListener('click', this.handlers.onDismissBannerClick);
    }
    if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
      this.elements.endPublicationBtn.removeEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.sheetSelector && this.handlers.onSheetSelectorChange) {
      this.elements.sheetSelector.removeEventListener('change', this.handlers.onSheetSelectorChange);
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šãƒ•ãƒ©ã‚°ã®ãƒªã‚»ãƒƒãƒˆ
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    
    // Clear caches
    this.cache.clear();
    this.deferredUpdates.clear();
    this.domFragmentPool.length = 0;
    
    debugLog('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
  }
  async loadDataImmediate() {
    try {
      console.log('ğŸš€ StudyQuestApp: Starting immediate data loading...');
      
      // 1. Validate essential prerequisites
      if (!this.validatePrerequisites()) {
        console.error('âŒ StudyQuestApp: Prerequisites validation failed, aborting initialization');
        this.displayInitializationError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¿…è¦ãªæ¡ä»¶ãŒæº€ãŸã•ã‚Œã¦ã„ã¾ã›ã‚“');
        return;
      }
      
      // 2. Verify admin status to ensure proper initialization
      console.log('ğŸ” StudyQuestApp: Verifying admin status...');
      await this.verifyAdminAsync().catch(error => {
        console.warn('âš ï¸ StudyQuestApp: Admin verification failed, continuing with default permissions:', error.message);
      });
      
      // 3. Start loading immediately without waiting
      console.log('ğŸ“Š StudyQuestApp: Starting sheet data loading...');
      try {
        await this.loadSheetData({ showLoading: false, isInitialLoad: true, bypassCache: true });
        console.log('âœ… StudyQuestApp: Sheet data loaded, restoring differential cards...');
        
        // å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å¾©å…ƒ
        this.restoreDifferentialCards();
        
        console.log('âœ… StudyQuestApp: Starting polling...');
        this.startPolling();
      } catch (error) {
        console.error('âŒ StudyQuestApp: Sheet data loading failed:', error);
        this.displayDataLoadError(error.message || 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
      
      // 4. Load sheets in background only for administrators
      if (this.state.isAdminUser) {
        console.log('ğŸ‘‘ StudyQuestApp: Loading available sheets for admin user...');
        try {
          await this.loadAvailableSheets();
        } catch (error) {
          console.warn('âš ï¸ StudyQuestApp: Available sheets loading failed:', error.message);
        }
      }
      
      // Show info modal during loading (after data is loaded but before completion)
      console.log('ğŸ“‹ StudyQuestApp: Showing info modal during initialization...');
      this.showInfoModal();
      
      console.log('ğŸ¯ StudyQuestApp: Immediate loading initialization completed');
      
    } catch (error) {
      console.error('âŒ StudyQuestApp: Critical error in loadDataImmediate:', error);
      this.displayInitializationError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
    }
  }

  /**
   * Validate essential prerequisites for app initialization
   * @returns {boolean} true if all prerequisites are met
   */
  validatePrerequisites() {
    const checks = [
      { name: 'userId', value: this.state.userId, required: true },
      { name: 'answersContainer', value: this.elements.answersContainer, required: true },
      { name: 'sheetName', value: this.state.sheetName, required: false },
      { name: 'google.script.run', value: typeof google !== 'undefined' && google.script && google.script.run, required: true }
    ];
    
    let allValid = true;
    console.log('ğŸ” StudyQuestApp: Validating prerequisites:');
    
    checks.forEach(check => {
      const isValid = check.required ? !!check.value : true;
      const status = isValid ? 'âœ…' : 'âŒ';
      console.log(`  ${status} ${check.name}: ${check.required ? 'required' : 'optional'} - ${isValid ? 'OK' : 'MISSING'}`);
      
      if (check.required && !isValid) {
        allValid = false;
      }
    });
    
    return allValid;
  }

  /**
   * Display initialization error to user
   * @param {string} message - Error message to display
   */
  displayInitializationError(message) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${this.escapeHtml(message)}</p>
        <div class="mt-6">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Display data loading error to user
   * @param {string} message - Error message to display
   */
  displayDataLoadError(message) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-yellow-400">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${this.escapeHtml(message)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
          <button 
            onclick="window.studyQuestApp && window.studyQuestApp.loadSheetData({ bypassCache: true, isInitialLoad: true })" 
            class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
          >
            å†è©¦è¡Œ
          </button>
        </div>
      </div>
    `;
  }
  
  showErrorMessage(message, isTemporary = true) {
    // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆãƒˆãƒ¼ã‚¹ãƒˆé¢¨ï¼‰
    const errorDiv = document.createElement('div');
    errorDiv.className = 'fixed top-4 right-4 z-50 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md';
    errorDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span class="text-sm">${this.escapeHtml(message)}</span>
      </div>
    `;
    
    document.body.appendChild(errorDiv);
    
    if (isTemporary) {
      // 5ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
      setTimeout(() => {
        if (errorDiv.parentNode) {
          errorDiv.parentNode.removeChild(errorDiv);
        }
      }, 5000);
    }
    
    return errorDiv;
  }
  
  showMinimalSkeleton() {
    // Show only 3 skeletons for immediate visual feedback
    const count = 3;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      frag.appendChild(this.createSkeletonCard());
    }
    this.elements.answersContainer.appendChild(frag);
  }

  displayEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-white">ã¾ã å›ç­”ãŒã‚ã‚Šã¾ã›ã‚“</h3>
        <p class="mt-1 text-sm text-gray-400">æœ€åˆã®å›ç­”è€…ã«ãªã‚Šã¾ã—ã‚‡ã†ï¼</p>
      </div>
    `;
  }
  
  safeDisplayEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const existingCards = container.querySelectorAll('.answer-card');
    if (existingCards.length > 0) {
      console.log('safeDisplayEmptyState: æ—¢å­˜ã‚«ãƒ¼ãƒ‰ãŒ', existingCards.length, 'å€‹ã‚ã‚‹ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“');
      return; // ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ãªã„
    }
    
    // currentAnswersã‚‚ãƒã‚§ãƒƒã‚¯
    if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
      console.log('safeDisplayEmptyState: currentAnswersã«', this.state.currentAnswers.length, 'å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“');
      return; // ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã‚‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ãªã„
    }
    
    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯è¡¨ç¤ºã—ãªã„
    if (this.state.isLoading) {
      console.log('safeDisplayEmptyState: ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“');
      return;
    }
    
    console.log('safeDisplayEmptyState: æ¡ä»¶ã‚’æº€ãŸã—ãŸãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã™');
    this.displayEmptyState();
  }
  
  clearAllCardsForEmptyData() {
    // çœŸã®åˆå›åˆ¤å®š: localStorageçŠ¶æ…‹ + DOMçŠ¶æ…‹ã‚’ç¢ºèª
    const isFirstTime = this.isFirstTimeBoardAccess();
    
    if (isFirstTime) {
      console.log('ğŸ¯ åˆå›ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹: åˆæœŸåŒ–å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™');
    } else {
      console.log('ğŸ—‘ï¸ clearAllCardsForEmptyData: ç©ºãƒ‡ãƒ¼ã‚¿å—ä¿¡ã®ãŸã‚å…¨ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™');
    }
    
    // currentAnswersã‚’ç©ºã«ãƒªã‚»ãƒƒãƒˆ
    this.state.currentAnswers = [];
    
    // DOMå†…ã®å…¨ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
    const container = this.elements.answersContainer;
    if (container) {
      const existingCards = container.querySelectorAll('.answer-card');
      
      if (existingCards.length > 0) {
        if (isFirstTime) {
          console.log('åˆå›ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–: DOMå†…ã®', existingCards.length, 'å€‹ã®è¦ç´ ã‚’åˆæœŸåŒ–ã—ã¾ã™');
        } else {
          console.log('clearAllCardsForEmptyData: DOMã‹ã‚‰', existingCards.length, 'å€‹ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™');
        }
        
        // ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’è§£é™¤
        existingCards.forEach(card => {
          if (this.visibilityObserver) {
            this.visibilityObserver.unobserve(card);
          }
          if (this.scrollObserver) {
            this.scrollObserver.unobserve(card);
          }
        });
        
        // DOMã‚’ã‚¯ãƒªã‚¢
        container.innerHTML = '';
      }
    }
    
    // ãƒãƒ¼ãƒãƒ£ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
    console.log('âœ…', isFirstTime ? 'åˆå›åˆæœŸåŒ–å®Œäº†' : 'clearAllCardsForEmptyData: ã‚¯ãƒªã‚¢å®Œäº†');
  }
  
  validatePostLoadState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const domCards = container.querySelectorAll('.answer-card');
    const dataLength = this.state.currentAnswers ? this.state.currentAnswers.length : 0;
    
    console.log('ğŸ” validatePostLoadState: DOMã‚«ãƒ¼ãƒ‰æ•°:', domCards.length, 'currentAnswersæ•°:', dataLength);
    
    // ç©ºãƒ‡ãƒ¼ã‚¿ãªã®ã«DOMã«ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ
    if (dataLength === 0 && domCards.length > 0) {
      console.warn('âš ï¸ çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: ç©ºãƒ‡ãƒ¼ã‚¿ãªã®ã«DOMã«', domCards.length, 'å€‹ã®ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã¾ã™');
      
      // ç©ºãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
      this.clearAllCardsForEmptyData();
      
      // ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
      this.displayEmptyState();
      
      console.log('âœ… çŠ¶æ…‹ä¸æ•´åˆã‚’ä¿®æ­£ã—ã¾ã—ãŸ');
      
    } else if (dataLength !== domCards.length) { // æ•°ã®ä¸ä¸€è‡´ã‚‚ä¸æ•´åˆã¨ã¿ãªã™
      console.warn('âš ï¸ çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: DOMã‚«ãƒ¼ãƒ‰æ•°ã¨ãƒ‡ãƒ¼ã‚¿æ•°ãŒä¸€è‡´ã—ã¾ã›ã‚“ã€‚DOM:', domCards.length, 'ãƒ‡ãƒ¼ã‚¿:', dataLength);

      // ä¸æ•´åˆãŒã‚ã‚‹å ´åˆã¯å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      console.log('å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’å®Ÿè¡Œã—ã¾ã™...');
      this.renderBoard(false, false);
      
    } else {
      console.log('âœ… çŠ¶æ…‹æ¤œè¨¼: DOMã¨ãƒ‡ãƒ¼ã‚¿ã®çŠ¶æ…‹ãŒä¸€è‡´ã—ã¦ã„ã¾ã™');
    }
    
    // è¿½åŠ : è¨­å®šã¨è¡¨ç¤ºå†…å®¹ã®ä¸€è‡´æ€§ã‚’æ¤œè¨¼
    this.validateConfigConsistency();
  }
  
  validateConfigConsistency() {
    // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®è¡¨ç¤ºã—ã¦ã„ã‚‹è³ªå•æ–‡ã‚’å–å¾—
    const displayedHeader = this.elements.headingLabel ? this.elements.headingLabel.textContent : '';
    
    // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ•°ã¨ãƒãƒ¼ãƒªãƒ³ã‚°ã§å–å¾—ã—ãŸã‚«ã‚¦ãƒ³ãƒˆã‚’æ¯”è¼ƒ
    const currentDataCount = this.state.currentAnswers ? this.state.currentAnswers.length : 0;
    
    console.log('ğŸ” è¨­å®šä¸€è‡´æ€§æ¤œè¨¼:', {
      'è¡¨ç¤ºä¸­ã®è³ªå•æ–‡': displayedHeader,
      'ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ•°': currentDataCount,
      'æœ€æ–°ãƒãƒ¼ãƒªãƒ³ã‚°çµæœ': this.lastPollingResult || 'æœªå®Ÿè¡Œ'
    });
    
    // ãƒãƒ¼ãƒªãƒ³ã‚°çµæœã¨ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ•°ã®ä¸ä¸€è‡´ã‚’æ¤œå‡º
    if (this.lastPollingResult && this.lastPollingResult.newCount !== currentDataCount) {
      console.warn('âš ï¸ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡º:', {
        'ãƒãƒ¼ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆ': this.lastPollingResult.newCount,
        'è¡¨ç¤ºãƒ‡ãƒ¼ã‚¿æ•°': currentDataCount,
        'å·®åˆ†': this.lastPollingResult.newCount - currentDataCount
      });
      
      // ä¸æ•´åˆãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã®å¯¾å¿œ
      this.handleDataInconsistency();
    }
  }
  
  async handleDataInconsistency() {
    console.log('ğŸ”„ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã‚’è§£æ±ºã™ã‚‹ãŸã‚è©³ç´°åˆ†æã‚’é–‹å§‹ã—ã¾ã™...');
    
    try {
      // 1. ç¾åœ¨ã®çŠ¶æ…‹ã‚’è©³ç´°ã«åˆ†æ
      const currentState = await this.analyzeCurrentDataState();
      
      // 2. ä¸æ•´åˆã®ç¨®é¡ã‚’ç‰¹å®š
      const inconsistencyType = this.classifyInconsistency(currentState);
      
      // 3. ä¸æ•´åˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸä¿®å¾©æˆ¦ç•¥ã‚’å®Ÿè¡Œ
      await this.executeRepairStrategy(inconsistencyType, currentState);
      
    } catch (error) {
      console.error('âš ï¸ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆä¿®å¾©ã§ã‚¨ãƒ©ãƒ¼:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
      this.forceDataRefresh().catch(fallbackError => {
        console.error('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚‚ã‚¨ãƒ©ãƒ¼:', fallbackError);
      });
    }
  }

  async analyzeCurrentDataState() {
    const container = this.elements.answersContainer;
    const domCards = container ? container.querySelectorAll('.answer-card') : [];
    
    return {
      domCardCount: domCards.length,
      stateDataCount: this.state.currentAnswers ? this.state.currentAnswers.length : 0,
      lastSeenCount: this.state.lastSeenCount || 0,
      pollingResult: this.lastPollingResult,
      hasLocalStorage: this.hasRelevantLocalStorage(),
      isInitialLoad: !this.initialDataLoaded,
      timestamp: new Date().toISOString()
    };
  }

  classifyInconsistency(state) {
    if (state.isInitialLoad && state.domCardCount > 0) {
      return 'phantom_cards_on_init';
    } else if (state.stateDataCount === 0 && state.pollingResult?.newCount > 0) {
      return 'empty_state_with_server_data';
    } else if (state.domCardCount !== state.stateDataCount) {
      return 'dom_state_mismatch';
    } else if (state.lastSeenCount > state.stateDataCount) {
      return 'seen_count_ahead';
    } else {
      return 'general_inconsistency';
    }
  }

  async executeRepairStrategy(type, state) {
    console.log('ğŸ”§ ä¸æ•´åˆä¿®å¾©æˆ¦ç•¥:', type, state);
    
    switch (type) {
      case 'phantom_cards_on_init':
        console.log('ğŸ‘» åˆå›èª­ã¿è¾¼ã¿æ™‚ã®å¹½éœŠã‚«ãƒ¼ãƒ‰ã‚’ä¿®å¾©');
        this.clearAllCardsForEmptyData();
        await this.loadSheetData({ bypassCache: true });
        break;
        
      case 'empty_state_with_server_data':
        console.log('ğŸ“¡ ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿å­˜åœ¨æ™‚ã®ç©ºçŠ¶æ…‹ã‚’ä¿®å¾©');
        await this.performServerDataSync();
        break;
        
      case 'dom_state_mismatch':
        console.log('ğŸ”„ DOM-Stateä¸æ•´åˆã‚’ä¿®å¾©');
        await this.resyncDOMWithState();
        break;
        
      case 'seen_count_ahead':
        console.log('ğŸ“Š lastSeenCountå…ˆè¡Œå•é¡Œã‚’ä¿®å¾©');
        this.updateLastSeenCount(state.stateDataCount);
        break;
        
      default:
        console.log('ğŸ”„ ä¸€èˆ¬çš„ãªä¸æ•´åˆä¿®å¾©');
        await this.forceDataRefresh();
    }
  }

  hasRelevantLocalStorage() {
    const userId = this.state?.userId || USER_ID;
    const sheetName = SHEET_NAME;
    
    return {
      hasLastSeen: localStorage.getItem(`lastSeenCount_${userId}_${sheetName}`) !== null,
      hasDiffCards: localStorage.getItem(`differentialCards_${userId}_${sheetName}`) !== null
    };
  }

  async performServerDataSync() {
    console.log('ğŸ”„ ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿åŒæœŸé–‹å§‹');
    
    // è»½é‡ãƒã‚§ãƒƒã‚¯ã§æœ€æ–°ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
    const classFilter = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
    const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);
    
    console.log('ğŸ“Š ã‚µãƒ¼ãƒãƒ¼ã‚«ã‚¦ãƒ³ãƒˆç¢ºèª:', countData);
    
    if (countData && countData.count > 0) {
      // ã‚µãƒ¼ãƒãƒ¼ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯å¼·åˆ¶å†èª­ã¿è¾¼ã¿
      await this.loadSheetData({ bypassCache: true });
    } else {
      // ã‚µãƒ¼ãƒãƒ¼ã«ã‚‚ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
      this.displayEmptyState();
    }
  }

  async resyncDOMWithState() {
    console.log('ğŸ”„ DOM-Stateå†åŒæœŸé–‹å§‹');
    
    // ç¾åœ¨ã®stateãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦DOMã‚’å†æ§‹ç¯‰
    if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
      this.renderBoard(this.state.currentAnswers, []);
    } else {
      this.clearAllCardsForEmptyData();
      this.displayEmptyState();
    }
  }
  
  async forceDataRefresh() {
    console.log('ğŸ—‘ï¸ å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹...');
    
    // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
    if (this.cache) {
      this.cache.clear();
      console.log('âœ… ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢');
    }
    
    // ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
    try {
      await new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .clearCache();
      });
      console.log('âœ… ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢');
    } catch (error) {
      console.warn('âš ï¸ ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã§ã‚¨ãƒ©ãƒ¼:', error);
    }
    
    // å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿å†èª­ã¿è¾¼ã¿
    await this.loadSheetData({ bypassCache: true });
    
    console.log('âœ… å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†');
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœã®æœ‰åŠ¹æ€§ã‚’åˆ¤å®š
   * @param {object} result - ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”
   * @returns {boolean} æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹
   */
  isValidDataResult(result) {
    try {
      // åŸºæœ¬æ§‹é€ ã®ç¢ºèª
      if (!result || typeof result !== 'object') {
        console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: çµæœãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„');
        return false;
      }
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ã®è©³ç´°ãƒ­ã‚°
      console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ç¢ºèª', {
        hasStatus: 'status' in result,
        status: result.status,
        hasData: 'data' in result,
        dataType: Array.isArray(result.data) ? 'array' : typeof result.data,
        dataLength: Array.isArray(result.data) ? result.data.length : 'N/A',
        hasHeader: 'header' in result,
        hasSheetName: 'sheetName' in result,
        keys: Object.keys(result)
      });
      
      // 2ã¤ã®å¯èƒ½ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã«å¯¾å¿œ
      // 1. æ–°å½¢å¼: { status: 'success', data: [...], header: '...', sheetName: '...' }
      // 2. æ—§å½¢å¼: { data: [...], header: '...', sheetName: '...' } (statusãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã—)
      
      const hasStatusField = 'status' in result;
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèªï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
      if (hasStatusField && result.status !== 'success') {
        console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæˆåŠŸã§ã¯ãªã„ -', result.status);
        return false;
      }
      
      // ãƒ‡ãƒ¼ã‚¿é…åˆ—ã®å­˜åœ¨ç¢ºèª
      if (!Array.isArray(result.data)) {
        console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: dataãŒé…åˆ—ã§ã¯ãªã„', typeof result.data);
        return false;
      }
      
      // ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®ç¢ºèªï¼ˆä»»æ„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
      if (result.header && typeof result.header !== 'string') {
        console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®å‹ãŒä¸æ­£', typeof result.header);
        return false;
      }
      
      // ã‚·ãƒ¼ãƒˆåã®ç¢ºèªï¼ˆä»»æ„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
      if (result.sheetName && typeof result.sheetName !== 'string') {
        console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ã‚·ãƒ¼ãƒˆåã®å‹ãŒä¸æ­£', typeof result.sheetName);
        return false;
      }
      
      console.log('âœ… ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿æ§‹é€  -', {
        status: result.status || '(no status field)',
        dataLength: result.data.length,
        hasHeader: !!result.header,
        sheetName: result.sheetName
      });
      
      return true;
    } catch (error) {
      console.warn('âš ï¸ ãƒ‡ãƒ¼ã‚¿åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
      return false;
    }
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼å¤±æ•—ã®ç†ç”±ã‚’å–å¾—
   * @param {object} result - æ¤œè¨¼å¯¾è±¡ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   * @returns {string} å¤±æ•—ç†ç”±
   */
  getValidationFailureReason(result) {
    if (!result) {
      return 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒnull/undefined';
    }
    if (typeof result !== 'object') {
      return `ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„ (${typeof result})`;
    }
    
    const hasStatusField = 'status' in result;
    if (hasStatusField && result.status !== 'success') {
      return `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæˆåŠŸã§ã¯ãªã„ (${result.status})`;
    }
    
    if (!('data' in result)) {
      return 'dataãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ãªã„';
    }
    if (!Array.isArray(result.data)) {
      return `dataãŒé…åˆ—ã§ã¯ãªã„ (${typeof result.data})`;
    }
    
    if (result.header && typeof result.header !== 'string') {
      return `ãƒ˜ãƒƒãƒ€ãƒ¼ã®å‹ãŒä¸æ­£ (${typeof result.header})`;
    }
    if (result.sheetName && typeof result.sheetName !== 'string') {
      return `ã‚·ãƒ¼ãƒˆåã®å‹ãŒä¸æ­£ (${typeof result.sheetName})`;
    }
    
    return 'ä¸æ˜ãªæ¤œè¨¼å¤±æ•—';
  }

  /**
   * ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ããƒ‡ãƒ¼ã‚¿å–å¾—
   * @param {object} fetchParams - ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
   * @param {boolean} isInitialLoad - åˆæœŸãƒ­ãƒ¼ãƒ‰ã‹ã©ã†ã‹
   * @returns {Promise} ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœ
   */
  async performDataFetchWithRetry(fetchParams, isInitialLoad) {
    // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰æ™‚ã¯é«˜é€Ÿãƒªãƒˆãƒ©ã‚¤ã€é€šå¸¸æ™‚ã¯å¾“æ¥é€šã‚Š
    const MAX_ATTEMPTS = isInitialLoad ? 2 : 3;
    const retryDelays = isInitialLoad ? [500, 1000] : [1000, 2000, 3000]; // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã¯é«˜é€ŸåŒ–

    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
      try {
        console.log(`ğŸ“¡ ãƒ‡ãƒ¼ã‚¿å–å¾—è©¦è¡Œ ${attempt + 1}/${MAX_ATTEMPTS}:`, fetchParams);
        
        // ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’ Promise ã§å®Ÿè¡Œ
        const result = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('ãƒ‡ãƒ¼ã‚¿å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ'));
          }, attempt === 0 ? 15000 : 10000); // åˆå›ã¯15ç§’ã€ä»¥é™ã¯10ç§’
          
          google.script.run
            .withSuccessHandler(response => {
              clearTimeout(timeout);
              resolve(response);
            })
            .withFailureHandler(error => {
              clearTimeout(timeout);
              reject(error);
            })
            .getPublishedSheetData(
              fetchParams.userId,
              fetchParams.classFilter,
              fetchParams.sortOrder,
              fetchParams.showAdminFeatures,
              fetchParams.requestedSheetName
            );
        });
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è©³ç´°ãƒ­ã‚°
        console.log(`ğŸ” ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ¬ã‚¹ãƒãƒ³ã‚¹ (è©¦è¡Œ ${attempt + 1}):`, {
          hasResult: !!result,
          resultType: typeof result,
          resultKeys: result ? Object.keys(result) : [],
          hasData: result && 'data' in result,
          dataType: result && result.data ? (Array.isArray(result.data) ? 'array' : typeof result.data) : 'undefined',
          dataLength: result && Array.isArray(result.data) ? result.data.length : 'N/A'
        });
        
        // æˆåŠŸã—ãŸå ´åˆã¯çµæœã‚’è¿”ã™ - æ”¹å–„ã•ã‚ŒãŸåˆ¤å®šæ¡ä»¶
        if (result && this.isValidDataResult(result)) {
          console.log(`âœ… ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ (è©¦è¡Œ ${attempt + 1}):`, result.data ? result.data.length : 0, 'ä»¶');
          return result;
        }
        
        // ãƒ‡ãƒ¼ã‚¿ãŒç©ºã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
        if (result && result.status === 'error') {
          const isUserNotFoundError = result.message && result.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          
          if (isUserNotFoundError && attempt < MAX_ATTEMPTS - 1) {
            console.warn(`âš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã€ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (è©¦è¡Œ ${attempt + 1}):`, result.message);
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯è¨ºæ–­ãƒ»ä¿®å¾©ã‚’è©¦è¡Œ
            try {
              console.log('ğŸ”§ ã‚µãƒ¼ãƒãƒ¼å´è¨ºæ–­ãƒ»ä¿®å¾©ã‚’è¦æ±‚ä¸­...');
              await new Promise((resolve, reject) => {
                google.script.run
                  .withSuccessHandler(resolve)
                  .withFailureHandler(reject)
                  .performAutoRepair(fetchParams.userId);
              });
              console.log('âœ… ã‚µãƒ¼ãƒãƒ¼å´ä¿®å¾©å®Œäº†ã€æ¬¡ã®è©¦è¡Œã«é€²ã¿ã¾ã™');
            } catch (repairError) {
              console.warn('âš ï¸ ã‚µãƒ¼ãƒãƒ¼å´ä¿®å¾©å¤±æ•—:', repairError);
            }
          } else {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ä»¥å¤–ã€ã¾ãŸã¯æœ€å¾Œã®è©¦è¡Œ
            throw new Error(result.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼');
          }
        }
        
        // ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã®å ´åˆï¼ˆè©³ç´°ãªç†ç”±ã‚’è¨˜éŒ²ï¼‰
        const validationReason = this.getValidationFailureReason(result);
        if (attempt < MAX_ATTEMPTS - 1) {
          console.warn(`âš ï¸ ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã€ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (è©¦è¡Œ ${attempt + 1}): ${validationReason}`);
        } else {
          console.warn(`âŒ æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ã¾ã—ãŸã€æœ€å¾Œã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™: ${validationReason}`);
          // æœ‰åŠ¹ã§ãªã„ãƒ‡ãƒ¼ã‚¿ã§ã‚‚ã€ä½•ã‚‰ã‹ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ã‚Œã°è¿”ã™
          return result || { status: 'error', message: 'ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', data: [] };
        }
        
      } catch (error) {
        console.error(`âŒ ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${attempt + 1}):`, error.message);
        
        // æœ€å¾Œã®è©¦è¡Œã§å¤±æ•—ã—ãŸå ´åˆ
        if (attempt >= MAX_ATTEMPTS - 1) {
          throw error;
        }
        
        // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒªãƒˆãƒ©ã‚¤
        const isTemporaryError = 
          error.message.includes('timeout') ||
          error.message.includes('network') ||
          error.message.includes('script runtime') ||
          error.message.includes('temporarily unavailable');
          
        if (!isTemporaryError && error.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
          // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã¯ç‰¹åˆ¥æ‰±ã„ï¼ˆä¸Šè¨˜ã®å‡¦ç†ã«å§”ã­ã‚‹ï¼‰
          throw error;
        }
        
        if (isTemporaryError || attempt < MAX_ATTEMPTS - 1) {
          const delay = retryDelays[attempt] || 3000;
          console.log(`â³ ${delay}ms å¾…æ©Ÿå¾Œã«ãƒªãƒˆãƒ©ã‚¤...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          throw error;
        }
      }
    }
    
    // ã“ã“ã«åˆ°é”ã™ã‚‹ã“ã¨ã¯ãªã„ã¯ãšã§ã™ãŒã€å®‰å…¨ã®ãŸã‚
    throw new Error('äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: ãƒªãƒˆãƒ©ã‚¤ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã¾ã—ãŸ');
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ç”»é¢ã‚’è¡¨ç¤º
   * @param {string} errorMessage - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   */
  displayUserNotFoundError(errorMessage) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const isUserNotFoundError = errorMessage && (
      errorMessage.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“') || 
      errorMessage.includes('ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    );
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">${isUserNotFoundError ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : 'ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼'}</h3>
        <p class="mt-1 text-sm text-gray-400">${isUserNotFoundError ? 
          'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã¯å­˜åœ¨ã—ãªã„ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒä¸æ­£ã§ã™' : 
          'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“'}</p>
        ${isUserNotFoundError ? `
        <div class="mt-4 p-4 bg-blue-900/20 border border-blue-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-blue-400 mb-2">ğŸ” è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ URLã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œ</li>
            <li>â€¢ ãƒœãƒ¼ãƒ‰ãŒå‰Šé™¤ã•ã‚ŒãŸã‹éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã•ã‚ŒãŸ</li>
            <li>â€¢ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«ä¸€æ™‚çš„ãªå•é¡Œ</li>
            <li>â€¢ ã‚µãƒ¼ãƒãƒ¼å´ã®æ¨©é™è¨­å®šã«å•é¡Œ</li>
            <li>â€¢ ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ãŒç ´æ</li>
          </ul>
        </div>
        <div class="mt-4 p-4 bg-green-900/20 border border-green-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-green-400 mb-2">ğŸ’¡ è§£æ±ºæ–¹æ³•ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ ã¾ãšãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ­£ã—ã„ãƒœãƒ¼ãƒ‰URLã‚’ç®¡ç†è€…ã«ç¢ºèª</li>
            <li>â€¢ 5-10åˆ†å¾…ã£ã¦ã‹ã‚‰å†åº¦ã‚¢ã‚¯ã‚»ã‚¹</li>
            <li>â€¢ åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§è©¦ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ–°ã—ã„å›ç­”ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹</li>
          </ul>
        </div>
        <div class="mt-4 p-3 bg-yellow-900/20 border border-yellow-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-yellow-400 mb-2">ğŸ› ï¸ è‡ªå‹•ä¿®å¾©ï¼š</h4>
          <p class="text-xs text-gray-400">ã‚·ã‚¹ãƒ†ãƒ ã¯è‡ªå‹•çš„ã«å•é¡Œã®ä¿®å¾©ã‚’è©¦è¡Œã—ã¦ã„ã¾ã™ã€‚æ•°åˆ†å¾Œã«å†åº¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨è§£æ±ºã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
        </div>` : ''}
        <p class="mt-2 text-xs text-gray-500">ã‚¨ãƒ©ãƒ¼è©³ç´°: ${this.escapeHtml(errorMessage)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800"
          >
            <svg class="-ml-1 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
    
  }

  // Add these two methods
  showLoadingOverlay(message = '') {
    if (window.unifiedLoading) {
      window.unifiedLoading.setLoading(true, { 
        message: '', // No message for transparent overlay
        type: 'transparent',
        disableInteraction: true 
      });
    }
    
    // Add loading-active class to body and container to disable render optimizations
    // This prevents stacking context issues with the loading overlay
    document.body.classList.add('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.add('loading-active');
      // Replace render-optimized with loading-safe temporarily
      if (this.elements.answersContainer.classList.contains('render-optimized')) {
        this.elements.answersContainer.classList.add('loading-safe');
      }
    }
  }

  hideLoadingOverlay() {
    if (window.unifiedLoading) {
      window.unifiedLoading.setLoading(false);
    }
    
    // Remove loading-active classes to restore render optimizations
    document.body.classList.remove('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.remove('loading-active');
      // Remove loading-safe class to restore normal render optimization
      this.elements.answersContainer.classList.remove('loading-safe');
    }
  }

  async loadSheetData(options = {}) {
    // Normalize options with defaults
    const config = {
      showLoading: options.showLoading !== false, // default true
      bypassCache: options.bypassCache || false,
      isInitialLoad: options.isInitialLoad || false,
      requestedSheetName: options.requestedSheetName || null,
      ...options
    };

    if (config.isInitialLoad) {
      config.bypassCache = true;
    }
    
    // Prevent concurrent loading
    if (this.state.isLoading && config.showLoading) {
      console.log('loadSheetData: Already loading, skipping...');
      return;
    }
    
    try {
      this.state.isLoading = true;
      if (config.showLoading) {
        this.showLoadingOverlay();
      }
      
      console.log('ğŸ” loadSheetData started:', config);
      const oldAnswers = [...this.state.currentAnswers];
      
      // Clear caches if needed
      if (config.bypassCache || this.shouldClearCache(config)) {
        await this.clearDataCaches();
      }
      
      // Load data with simplified parameters
      await this.performDataLoad(config, oldAnswers);
      
    } catch (error) {
      console.error('âŒ loadSheetData error:', error);
      this.handleLoadError(error);
    } finally {
      this.state.isLoading = false;
      this.hideLoadingOverlay();
    }
  }
  
  shouldClearCache(config) {
    // Clear cache on sheet switching or explicit refresh
    return (config.requestedSheetName && config.requestedSheetName !== this.state.currentActiveSheet) ||
           (config.showLoading && !config.isInitialLoad);
  }
  
  async clearDataCaches() {
    console.log('ğŸ§¹ Clearing data caches...');
    
    // Clear frontend cache
    if (this.cache) {
      this.cache.clear();
    }
    
    // Clear server cache
    try {
      await this.gas.clearCache();
      console.log('âœ… Server cache cleared');
    } catch (error) {
      console.warn('âš ï¸ Failed to clear server cache:', error);
    }
  }
  
  async performDataLoad(config, oldAnswers) {
    // Get current filter and sort settings
    const isInitialLoad = config.isInitialLoad;
    const requestedSheetName = config.requestedSheetName;
    const selectedClass = isInitialLoad ? 'ã™ã¹ã¦' :
                         (this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦');
    const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
    
    // Show skeleton cards during loading
    if (config.showLoading && !config.isInitialLoad) {
      const count = Math.min(parseInt(this.elements.sizeSlider.value, 10) * 2, 8); // Cap at 8
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      const container = this.elements.answersContainer;
      container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      container.innerHTML = '';
      container.appendChild(frag);
    }
    try {
      const classFilter = selectedClass;
      
      // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è©³ç´°ãƒ­ã‚°
      const fetchParams = {
        userId: this.state.userId,
        classFilter,
        sortOrder,
        showAdminFeatures: this.state.showAdminFeatures,
        requestedSheetName
      };
      console.log('ğŸ“¡ Starting data fetch with parameters:', fetchParams);
      
      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆã®ãƒ‡ãƒ¼ã‚¿å–å¾—
      await this.performDataFetchWithRetry(fetchParams, isInitialLoad)
        .then(async result => {
          try {
            // åˆæœŸãƒ­ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
            if (isInitialLoad && this.initTimeoutId) {
              clearTimeout(this.initTimeoutId);
              this.initTimeoutId = null;
            }
            
            if (!result || !result.data || result.data.length === 0) {
              // è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°å‡ºåŠ›
              if (result && result.status === 'error') {
                console.error('âŒ StudyQuestApp: Data fetch failed with error:', result.message);
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã®ç‰¹åˆ¥ãªå‡¦ç†
                if (result.message && result.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
                  console.error('âŒ StudyQuestApp: User not found. Current userId:', this.state.userId);
                  console.error('âŒ StudyQuestApp: URL parameters:', window.location.href);
                  console.error('âŒ StudyQuestApp: This may indicate:');
                  console.error('  1. Invalid userId parameter in URL');
                  console.error('  2. User not registered in the system');
                  console.error('  3. Database connectivity issues');
                  console.error('  4. Session expired or corrupted');
                  console.error('âŒ StudyQuestApp: Possible solutions:');
                  console.error('  - Check if the URL parameters are correct');
                  console.error('  - Try refreshing the page');
                  console.error('  - Contact administrator if the issue persists');
                  
                  // UIã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                  this.displayUserNotFoundError(result.message);
                  return;
                }
              } else {
                // ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆãƒã‚§ãƒƒã‚¯: è»½é‡ãƒã‚§ãƒƒã‚¯ã§ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’ç¢ºèª
                console.warn('âš ï¸ StudyQuestApp: Received empty or invalid data:', result);
                debugLog('Data consistency check:', { currentAnswers: this.state.currentAnswers.length, resultData: result.data ? result.data.length : 0 });
                
                try {
                  // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰æ™‚ã¯é«˜é€Ÿå¾©æ—§æˆ¦ç•¥ã‚’æ¡ç”¨
                  if (isInitialLoad) {
                    console.log('ğŸš€ åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•— - é«˜é€Ÿå¾©æ—§æˆ¦ç•¥ã‚’å®Ÿè¡Œ');
                    
                    // è»½é‡ãƒã‚§ãƒƒã‚¯ã§ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ã‚’ç¢ºèª
                    const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);
                    
                    if (countData && countData.count > 0) {
                      console.log(`âš¡ è»½é‡ãƒã‚§ãƒƒã‚¯ã§${countData.count}ä»¶æ¤œå‡º - å¾Œç¶šãƒãƒ¼ãƒªãƒ³ã‚°ã§å¾©æ—§äºˆå®š`);
                      // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¦ãƒãƒ¼ãƒªãƒ³ã‚°ã«å§”ã­ã‚‹
                      this.hadInitialDataLoadFailure = true;
                      this.state.lastSeenCount = 0;
                    }
                  } else {
                    // é€šå¸¸æ™‚ã¯å¾“æ¥ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰
                    const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);
                    console.log('ğŸ” Data consistency check:', {
                      fullDataEmpty: !result?.data || result.data.length === 0,
                      lightCheckCount: countData?.count || 0,
                      requestedSheet: requestedSheetName,
                      currentSheet: this.state.currentActiveSheet
                    });
                    
                    if (countData && countData.count > 0) {
                      console.warn('âš ï¸ Data inconsistency detected! Light check shows', countData.count, 'items but full fetch returned empty');
                      console.log('ğŸ”„ Attempting simplified fallback...');
                      
                      // ç°¡ç´ åŒ–ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆå¾…æ©Ÿæ™‚é–“çŸ­ç¸®ï¼‰
                      await new Promise(resolve => setTimeout(resolve, 500));
                      
                      const retryResult = await new Promise((resolve, reject) => {
                        google.script.run
                          .withSuccessHandler(resolve)
                          .withFailureHandler(reject)
                          .getPublishedSheetData(
                            this.state.userId,
                            classFilter,
                            this.elements.sortOrder ? this.elements.sortOrder.value : 'newest',
                            this.state.showAdminFeatures,
                            true
                          );
                      });
                      
                      if (retryResult && retryResult.data && retryResult.data.length > 0) {
                        console.log('âœ… Fallback retry successful! Got', retryResult.data.length, 'items');
                        result = retryResult; // æˆåŠŸã—ãŸçµæœã‚’ä½¿ç”¨
                      } else {
                        console.warn('âŒ Fallback retry also returned empty data');
                      }
                    }
                  }
                } catch (fallbackError) {
                  console.warn('âš ï¸ Fallback data consistency check failed:', fallbackError);
                }
              }
              
              // å†ãƒã‚§ãƒƒã‚¯å¾Œã‚‚ãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆã®ã¿ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
              if (!result || !result.data || result.data.length === 0) {
                // ç©ºãƒ‡ãƒ¼ã‚¿å—ä¿¡æ™‚ã¯å¤ã„ã‚«ãƒ¼ãƒ‰ã‚’å¼·åˆ¶çš„ã«ã‚¯ãƒªã‚¢
                this.clearAllCardsForEmptyData();
                
                // ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
                this.displayEmptyState();
                if (isInitialLoad) {
                  this.state.lastSeenCount = 0;
                  // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                  this.hadInitialDataLoadFailure = true;
                  console.log('ğŸš¨ åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã‚’ãƒãƒ¼ã‚¯ï¼ˆå¾Œç¶šãƒãƒ¼ãƒªãƒ³ã‚°ã§é€šçŸ¥ã‚’æœ‰åŠ¹åŒ–ï¼‰');
                }
                return;
              }
            }

            console.log('Received data:', result.data);
            
            // ğŸ”¥ CRITICAL FIX: Set currentAnswers with received data
            this.state.currentAnswers = result.data || [];
            this.updateLastSeenCount(this.state.currentAnswers.length);
            console.log('âœ… StudyQuestApp: Set currentAnswers with', this.state.currentAnswers.length, 'items');
            
            // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®è³ªå•æ–‡ã¨ç¾åœ¨è¡¨ç¤ºã®ä¸€è‡´æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if (result.header) {
              const currentDisplayed = this.elements.headingLabel ? this.elements.headingLabel.textContent : '';
              if (currentDisplayed && currentDisplayed !== result.header) {
                console.warn('âš ï¸ è³ªå•æ–‡ä¸ä¸€è‡´æ¤œå‡º:', {
                  'ç¾åœ¨è¡¨ç¤º': currentDisplayed,
                  'ã‚µãƒ¼ãƒãƒ¼è¨­å®š': result.header,
                  'ã‚·ãƒ¼ãƒˆå': result.sheetName
                });
                
                // è³ªå•æ–‡ã‚’æ–°ã—ã„ã‚‚ã®ã«æ›´æ–°
                console.log('ğŸ”„ è³ªå•æ–‡ã‚’ã‚µãƒ¼ãƒãƒ¼è¨­å®šã«åˆã‚ã›ã¾ã™');
              }
            }
            
            // Apply saved reaction states to restore user's previous reactions
            this.applyReactionState(result.data);
            
            // Populate class filter with available classes and make it visible
            this.populateClassFilter(result.data);
            
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°ã§ä½¿ç”¨ï¼‰
            this.state.activeSheetInfo = {
              sheetName: result.sheetName || 'ãƒ•ã‚©ãƒ¼ãƒ ã®å›ç­” 1',
              opinionHeader: result.header || 'ãŠé¡Œ',
              lastUpdated: Date.now()
            };
            console.log('ğŸ“„ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’æ›´æ–°:', this.state.activeSheetInfo);

            this.lastDataLoadTime = Date.now();
            
            if (isInitialLoad) {
              // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å®Œäº†ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
              this.initialDataLoaded = true;
              const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
              const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
              this.lastViewKey = `${selectedClass}-${sortOrder}`;
              // Initial data load completed
            }

            // Update heading with the actual question text from server (only if valid)
            if (result.header && this.elements.headingLabel && 
                result.header !== 'èª­ã¿è¾¼ã¿ä¸­...' && 
                !result.header.includes('èª­ã¿è¾¼ã¿') &&
                result.header.trim() !== '') {
              this.elements.headingLabel.textContent = result.header;
            }

            requestAnimationFrame(() => {
              this.renderBoard(false, isInitialLoad);
              // ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã®çŠ¶æ…‹æ¤œè¨¼ã‚’renderBoardã®å®Ÿè¡Œå¾Œã«ç§»å‹•
              this.validatePostLoadState();
            });
            
          } finally {
            // æˆåŠŸæ™‚ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
            this.state.isLoading = false;
            this.hideLoadingOverlay();
          }
        })
        .catch(error => {
          try {
            // åˆæœŸãƒ­ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
            if (isInitialLoad && this.initTimeoutId) {
              clearTimeout(this.initTimeoutId);
              this.initTimeoutId = null;
            }
            
            console.error('âŒ StudyQuestApp: All retry attempts failed:', error);
            
            // Check if the error indicates the board has been unpublished
            const errorStr = error.message || error.toString();
            if (errorStr.includes('ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“') || 
                errorStr.includes('å…¬é–‹ã•ã‚Œã¦ã„ã¾ã›ã‚“') ||
                errorStr.includes('unpublished') ||
                errorStr.includes('not found')) {
              // Board has been unpublished, redirect to Unpublished.html
              console.log('Board appears to be unpublished, redirecting...');
              this.redirectToUnpublishedPage();
              return;
            }
            
            this.safeDisplayEmptyState();
          } finally {
            // ã‚¨ãƒ©ãƒ¼æ™‚ã«ã‚‚ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
            this.state.isLoading = false;
            this.hideLoadingOverlay();
          }
        })
        ;
      
      
      // Post-processing after successful data load
      this.adjustLayout();
      
      if (!this.state.isAdminUser || !window.hasAdminCapability) {
        this.state.showAdminFeatures = false;
        this.state.showHighlightToggle = false;
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’ç¢ºå®Ÿã«éè¡¨ç¤º
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.add('hidden');
          this.elements.adminToggleBtn.setAttribute('hidden', '');
          this.elements.adminToggleBtn.style.display = 'none';
        }
      } else {
        this.state.showHighlightToggle = true;
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.remove('hidden');
          this.elements.adminToggleBtn.removeAttribute('hidden');
          this.elements.adminToggleBtn.style.display = '';
        }
        // Admin settings updated
        this.cache.clear();
        // Cache cleared due to admin highlight settings
      }
      
      if (isInitialLoad) {
        this.elements.answersContainer.classList.add('render-optimized');
        // If loading is active, also add loading-safe class to prevent stacking context issues
        if (document.body.classList.contains('loading-active') || 
            this.elements.answersContainer.classList.contains('loading-active')) {
          this.elements.answersContainer.classList.add('loading-safe');
        }
      }
    } catch (error) {
      console.error('Error loading sheet data:', error);
      const errorMessage = this.escapeHtml(error.message || 'Unknown error');
      this.elements.answersContainer.querySelectorAll('.skeleton').forEach(el => el.remove());
      this.elements.answersContainer.innerHTML = '<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">' + '<p class="font-bold">ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>' + '<p class="text-sm mt-2">' + errorMessage + '</p>' + '<button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">å†è©¦è¡Œ</button>' + '</div>';
      // åŒæœŸã‚¨ãƒ©ãƒ¼ã®å ´åˆã«ã‚‚ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
      this.state.isLoading = false;
      this.hideLoadingOverlay();
    }
  }
  async loadAvailableSheets() {
    try {
      const sheetsData = await this.gas.getAvailableSheets();
      this.populateSheetSelector(sheetsData);
    } catch (error) {
      console.error('Failed to load available sheets:', error);
      if (this.elements.sheetSelector) {
        this.elements.sheetSelector.innerHTML = '<option value="">ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆèª­ã¿è¾¼ã¿å¤±æ•—</option>';
      }
    }
  }
  populateSheetSelector(sheets) {
    const selector = this.elements.sheetSelector;
    
    if (!selector) return;

    if (!sheets || sheets.length === 0) {
      selector.innerHTML = '<option value="">åˆ©ç”¨å¯èƒ½ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</option>';
      selector.disabled = true;
      return;
    }
    
    // ã‚·ãƒ¼ãƒˆé¸æŠè‚¢ã‚’æ§‹ç¯‰
    if (!Array.isArray(sheets)) {
      console.error('Invalid sheets data:', sheets);
      selector.innerHTML = '<option>ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</option>';
      selector.disabled = true;
      return;
    }
    
    const options = sheets.map(sheet => {
      const selected = sheet.name === this.state.sheetName ? 'selected' : ''; // Use sheet.name for comparison
      const activeLabel = sheet.name === this.state.sheetName ? ' (ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ)' : '';
      return `<option value="${this.escapeHtml(sheet.name)}" ${selected}>${this.escapeHtml(sheet.name)}${activeLabel}</option>`;
    }).join('');
    
    selector.innerHTML = options;
    selector.disabled = false;
    
    // ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã‚’è¨˜éŒ²
    // this.state.currentActiveSheet is already set by loadSheetData
  }
  async switchSheet() {
    const selectedSheet = this.elements.sheetSelector.value;
    
    // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³: ç„¡åŠ¹ãªé¸æŠã¾ãŸã¯åŒã˜ã‚·ãƒ¼ãƒˆ
    if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
      console.log('Sheet switch skipped - same sheet or invalid selection');
      return;
    }
    
    // ç¾åœ¨åˆ‡ã‚Šæ›¿ãˆä¸­ã®å ´åˆã¯å‡¦ç†ã‚’æ‹’å¦
    if (this.sheetSwitchInProgress) {
      console.log('Sheet switch already in progress - ignoring request');
      return;
    }
    
    console.log('ğŸ”„ Starting sheet switch:', {
      from: this.state.currentActiveSheet,
      to: selectedSheet,
      userId: this.state.userId
    });
    
    try {
      this.sheetSwitchInProgress = true;
      
      // å‰å‡¦ç†: çŠ¶æ…‹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await this.prepareForSheetSwitch(selectedSheet);
      
      // ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹: ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
      await this.performSheetSwitch(selectedSheet);
      
      // å¾Œå‡¦ç†: çŠ¶æ…‹ã®ç¢ºå®š
      await this.finalizeSheetSwitch(selectedSheet);
      
      console.log('âœ… Sheet switch completed:', {
        newSheet: selectedSheet,
        dataCount: this.state.currentAnswers?.length || 0
      });
      
    } catch (error) {
      console.error('âŒ Sheet switch failed:', error);
      await this.handleSheetSwitchError(error, selectedSheet);
    } finally {
      this.sheetSwitchInProgress = false;
    }
  }
  
  async prepareForSheetSwitch(targetSheet) {
    // å¿…è¦ãªå‰ææ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
    if (!this.state.userId) {
      throw new Error('User ID is missing - cannot switch sheet');
    }
    
    // UIçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    this.dismissNewContentBanner();
    
    // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
    this.clearVirtualScrollingState();
    
    // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’ä¸€æ™‚åœæ­¢
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    console.log('Sheet switch preparation completed');
  }
  
  async performSheetSwitch(targetSheet) {
    const maxRetries = 3;
    let lastError = null;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`ğŸ”„ Loading sheet data (attempt ${attempt}/${maxRetries}):`, targetSheet);
        
        await this.loadSheetData({ 
          bypassCache: true, 
          requestedSheetName: targetSheet,
          showLoading: true
        });
        
        console.log('âœ… Sheet data loaded successfully on attempt', attempt);
        return; // æˆåŠŸæ™‚ã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
        
      } catch (error) {
        lastError = error;
        console.warn(`âš ï¸ Sheet load attempt ${attempt} failed:`, error.message);
        
        if (attempt < maxRetries) {
          const delay = attempt * 1000; // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
          console.log(`â³ Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    // ã™ã¹ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ãŸå ´åˆ
    throw new Error(`Failed to load sheet after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);
  }
  
  async finalizeSheetSwitch(targetSheet) {
    // çŠ¶æ…‹ã®ç¢ºå®š
    this.state.currentActiveSheet = targetSheet;
    this.state.sheetName = targetSheet;
    
    // æ–°ç€é€šçŸ¥ã®åŸºæº–ã‚’ãƒªã‚»ãƒƒãƒˆ
    this.state.lastSeenCount = this.state.currentAnswers?.length || 0;
    
    // UIã®æ›´æ–°
    this.updateSheetSelectorLabels();
    this.updateSheetDisplayName(targetSheet);
    
    // ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†é–‹
    this.startPolling();
    
    console.log('Sheet switch finalization completed');
  }
  
  async handleSheetSwitchError(error, targetSheet) {
    console.error('Sheet switch error details:', {
      error: error.message,
      targetSheet,
      currentSheet: this.state.currentActiveSheet,
      userId: this.state.userId
    });
    
    // å…ƒã®ã‚·ãƒ¼ãƒˆã®é¸æŠã«æˆ»ã™
    if (this.elements.sheetSelector) {
      this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
    }
    
    // ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†é–‹ï¼ˆå…ƒã®ã‚·ãƒ¼ãƒˆã§ï¼‰
    this.startPolling();
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’é€šçŸ¥
    if (window.messageManager) {
      window.messageManager.show(
        `ãƒœãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`,
        'error',
        5000
      );
    }
    
    // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã§UIæ›´æ–°ã‚’è©¦è¡Œ
    try {
      this.renderBoard(false, false);
    } catch (renderError) {
      console.error('Failed to render board after sheet switch error:', renderError);
    }
  }
  
  updateSheetDisplayName(sheetName) {
    if (this.elements.sheetNameText && sheetName) {
      const sheetIcon = this.getIcon('users', 'w-3 h-3 inline-block mr-1');
      this.elements.sheetNameText.innerHTML = sheetIcon + this.escapeHtml(sheetName);
    }
  }
  
  clearVirtualScrollingState() {
    // ãƒãƒ¼ãƒãƒ£ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
    // æ—¢å­˜ã®ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‚’åˆ‡æ–­
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
      this.scrollObserver = null;
    }
    
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
      // visibilityObserver ã¯ setupObservers() ã§å†ä½œæˆã•ã‚Œã‚‹ã®ã§ null ã«ã—ãªã„
    }
    
    
    
    
    
    debugLog('clearVirtualScrollingState: Virtual scrolling state cleared for sheet switch');
  }
  
  updateSheetSelectorLabels() {
    const selector = this.elements.sheetSelector;
    const options = Array.from(selector.options);
    
    options.forEach(option => {
      const sheetName = option.value;
      const isActive = sheetName === this.state.currentActiveSheet;
      const cleanName = sheetName.replace(/ \(ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ\)$/, '');
      
      if (isActive) {
        option.textContent = `${cleanName} (ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ)`;
      } else {
        option.textContent = cleanName;
      }
    });
  }
  
  populateClassFilter(rows) {
    const classFilter = this.elements.classFilter;
    // Ensure rows is an array before mapping
    const uniqueClasses = ['ã™ã¹ã¦', ...new Set(Array.isArray(rows) ? rows.map(r => r.class).filter(Boolean) : [])];
    classFilter.innerHTML = uniqueClasses.map(c => '<option value="' + this.escapeHtml(c) + '">' + this.escapeHtml(c) + '</option>').join('');
    classFilter.value = 'ã™ã¹ã¦';
    classFilter.classList.remove('hidden');
  }
  
  applyReactionStyles(element, data) {
    if (!element || !data || !(element instanceof HTMLElement)) return;
    
    // æ—¢å­˜ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–¢é€£ã‚¯ãƒ©ã‚¹ã‚’ã‚¯ãƒªã‚¢
    const reactionClasses = [
      'reaction-bg-like', 'reaction-bg-understand', 'reaction-bg-curious',
      'reaction-bg-like-understand', 'reaction-bg-like-curious', 'reaction-bg-understand-curious',
      'reaction-bg-like-understand-curious', 'reaction-border-1', 'reaction-border-2', 'reaction-border-3',
      'highlighted'
    ];
    reactionClasses.forEach(cls => element.classList.remove(cls));
    
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’é©ç”¨ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾ã‚ˆã‚Šå„ªå…ˆï¼‰
    if (data.highlight) {
      element.classList.add('highlighted');
      // Highlight decoration applied
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ™‚ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾ã‚’ã‚¹ã‚­ãƒƒãƒ—
      return;
    } else {
      // No highlight decoration
    }
    
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç‰¹å®š
    const active = this.reactionTypes.filter(rt => 
      data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
    ).map(rt => rt.key);
    
    // èƒŒæ™¯è‰²ã‚¯ãƒ©ã‚¹ã‚’é©ç”¨
    if (active.length === 1) {
      if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
      else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
      else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
    } else if (active.length === 2) {
      const sorted = active.sort();
      if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE') element.classList.add('reaction-bg-like-curious');
      else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-like-understand');
      else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-understand-curious');
    } else if (active.length === 3) {
      element.classList.add('reaction-bg-like-understand-curious');
    }
    
    // ãƒœãƒ¼ãƒ€ãƒ¼å¹…ã‚’é©ç”¨
    const totalReactions = this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
    if (totalReactions >= 10) {
      element.classList.add('reaction-border-3');
    } else if (totalReactions >= 5) {
      element.classList.add('reaction-border-2');
    } else if (totalReactions > 0) {
      element.classList.add('reaction-border-1');
    }
  }
  renderBoard(isLayoutChange = false, isInitialLoad = false, oldRows = []) {
    try {
      // Define newRows first to avoid TDZ error
      const newRows = this.state.currentAnswers;
      debugLog('DEBUG: renderBoard called. newRows.length:', newRows.length);
      
      // ç©ºãƒ‡ãƒ¼ã‚¿ã®å ´åˆã®æ—©æœŸå‡¦ç†
      if (!newRows || newRows.length === 0) {
        console.log('renderBoard: ç©ºãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã€DOMã‚’ã‚¯ãƒªã‚¢ã—ã¦ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã™');
        this.renderEmptyState();
        return;
      }
      
      // ç®¡ç†è€…ãƒã‚¤ãƒ©ã‚¤ãƒˆè¨­å®šã®åˆæœŸåŒ–
      this.initializeAdminSettings();
      
      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‰ã®çŠ¶æ…‹æº–å‚™
      this.prepareRenderingState(newRows);
      
      // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç†
      this.performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad);
      
      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¾Œã®çŠ¶æ…‹æ›´æ–°
      this.finalizeRenderingState();
      this.validatePostLoadState();
      
    } catch (error) {
      console.error('âŒ renderBoard: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
      this.handleRenderingError(error);
    }
  }
  
  renderEmptyState() {
    this.clearAllCardsForEmptyData();
    this.displayEmptyState();
  }
  
  initializeAdminSettings() {
    // ç®¡ç†è€…ã®å ´åˆã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒˆã‚°ãƒ«ã‚’ç¢ºå®Ÿã«æœ‰åŠ¹åŒ–
    if (this.state.isAdminUser && !this.state.showHighlightToggle) {
      this.state.showHighlightToggle = true;
      this.cache.clear();
    }
  }
  
  prepareRenderingState(newRows) {
    const container = this.elements.answersContainer;
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    debugLog('DEBUG: Skeletons removed. answersContainer children count:', container.children.length);
    
    this.updateLayoutControls(newRows);
  }
  
  updateLayoutControls(newRows) {
    // Batch DOM updates using performance-aware batching
    const updates = [];
    if (this.elements.sliderValue && this.elements.sizeSlider && 
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value) {
      updates.push(() => this.elements.sliderValue.textContent = this.elements.sizeSlider.value);
    }
    if (this.elements.sizeSlider) {
      const container = this.elements.answersContainer;
      const newClassName = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      if (container.className !== newClassName) {
        updates.push(() => container.className = newClassName);
      }
    }
    if (this.elements.answerCount) {
      const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
      const countHtml = userIcon + '<span>' + newRows.length + 'ä»¶</span>';
      if (this.elements.answerCount.innerHTML !== countHtml) {
        updates.push(() => this.elements.answerCount.innerHTML = countHtml);
      }
    }
    
    // Apply updates using performance-aware batching
    this.batchDOMUpdates(updates);
  }
  
  performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad) {
    const container = this.elements.answersContainer;
    container.innerHTML = ''; // ã“ã“ã§ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
    
    // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã®ãƒãƒƒãƒ—ã‚’ä½œæˆï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰
    const existingMap = new Map();
    container.querySelectorAll('.answer-card').forEach(card => {
      existingMap.set(card.dataset.rowIndex, card);
    });
    
    // ä¸è¦ãªã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
    existingMap.forEach((card, id) => {
      if (!newRows.some(r => String(r.rowIndex) === id)) {
        card.remove();
        existingMap.delete(id);
      }
    });
    
    // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç†
    if (newRows.length > RENDER_BATCH_SIZE) {
      this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad);
    } else {
      this.renderDirectly(newRows, oldRows, container, existingMap);
    }
  }
  
  renderDirectly(newRows, oldRows, container, existingMap) {
    const fragment = this.getReusableFragment();
    
    newRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);
      
      if (!card) {
        // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’å«ã‚€ï¼‰
        card = this.createAnswerCard(row);
        if (card) {
          card.classList.add('new-card');
          fragment.appendChild(card);
        } else {
          console.warn('renderBoard: Failed to create card for row:', row.rowIndex);
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰
        this.updateAnswerCard(card, row, oldData);
      }
    });
    
    if (fragment.children.length > 0) {
      container.appendChild(fragment);
      debugLog('DEBUG: renderBoard - Fragment appended. answersContainer children count:', container.children.length);
    }
  }
  
  calculateVisibleRange(totalItems) {
    const container = this.elements.answersContainer;
    if (!container) {
      console.warn('calculateVisibleRange: answersContainer not found.');
      return { startIndex: 0, endIndex: 0 };
    }

    const scrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    const cardHeight = 150; // ä»®ã®ã‚«ãƒ¼ãƒ‰ã®é«˜ã•ã€‚å®Ÿéš›ã®CSSã«åŸºã¥ã„ã¦èª¿æ•´ãŒå¿…è¦ã€‚

    let startIndex = 0;
    let endIndex = totalItems;

    if (containerHeight > 0) {
      startIndex = Math.floor(scrollTop / cardHeight);
      endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight));
    } else {
      console.warn('calculateVisibleRange: containerHeight is 0, rendering all items as fallback.');
    }

    debugLog('Virtual scroll range:', { startIndex, endIndex, visibleCount: endIndex - startIndex, totalItems });

    return { startIndex, endIndex };
  }

  renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad) {
    debugLog('DEBUG: renderBoard - Using virtual scrolling for', newRows.length, 'items (initial load:', isInitialLoad, ')');

    if (isInitialLoad || this.state.currentAnswers.length === 0) {
      this.clearVirtualScrollingState();
    }

    // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ã‚‚æ—¢å­˜ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒ
    const fragment = this.getReusableFragment();
    const visibleRange = this.calculateVisibleRange(newRows.length);
    const visibleRows = newRows.slice(visibleRange.startIndex, visibleRange.endIndex);
    debugLog('Virtual scroll rendering:', { visibleRows: visibleRows.length });

    visibleRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

      if (!card) {
        card = this.createAnswerCard(row);
        if (card) {
          fragment.appendChild(card);
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰
        this.updateAnswerCard(card, row, oldData);
      }
    });

    debugLog('Virtual scroll completed:', { renderedCards: fragment.children.length });
    if (fragment.children.length > 0) {
      container.appendChild(fragment);
    }
  }
  
  shouldUpdateCard(newData, oldData) {
    if (!oldData) return true;
    
    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã®å¤‰æ›´ã‚’ãƒã‚§ãƒƒã‚¯
    const newReactionCount = this.reactionTypes.reduce((sum, rt) => 
      sum + (newData.reactions?.[rt.key]?.count || 0), 0);
    const oldReactionCount = this.reactionTypes.reduce((sum, rt) => 
      sum + (oldData.reactions?.[rt.key]?.count || 0), 0);
    
    return newReactionCount !== oldReactionCount || 
           newData.isHighlighted !== oldData.isHighlighted ||
           newData.content !== oldData.content;
  }
  
  finalizeRenderingState() {
    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº†å¾Œã®çŠ¶æ…‹æ›´æ–°
    this.updateAnswerCount();
    this.applyAnimations();
  }

  updateAnswerCount() {
    if (!this.elements.answerCount) return;

    const count = Array.isArray(this.state.currentAnswers)
      ? this.state.currentAnswers.length
      : 0;
    const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
    this.elements.answerCount.innerHTML =
      userIcon + '<span>' + count + 'ä»¶</span>';
  }

  applyAnimations() {
    if (!this.elements.answersContainer) return;

    const newCards =
      this.elements.answersContainer.querySelectorAll('.new-card');
    newCards.forEach(card => {
      requestAnimationFrame(() => {
        card.classList.remove('new-card');
      });
    });
  }
  
  handleRenderingError(error) {
    console.error('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', error);
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å°é™ã®è¡¨ç¤ºã‚’è©¦è¡Œ
    try {
      const container = this.elements.answersContainer;
      container.innerHTML = `
        <div class="text-center py-8 col-span-full">
          <p class="text-red-400">è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>
          <button onclick="location.reload()" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded">
            å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      `;
    } catch (fallbackError) {
      console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºã‚‚å¤±æ•—:', fallbackError);
    }
  }
  
  updateAnswerCard(card, newData, oldData) {
    if (!card || !newData) return;
    
    try {
      // Update text content if changed
      if (!oldData || oldData.content !== newData.content) {
        const contentElement = card.querySelector('.answer-preview p');
        if (contentElement) {
          contentElement.textContent = newData.content || newData.reason || '';
        }
      }
      
      // Update student name if changed
      if (!oldData || oldData.name !== newData.name) {
        const nameElement = card.querySelector('.font-bold');
        if (nameElement) {
          nameElement.textContent = newData.name || '';
        }
      }
      
      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒã—ã¤ã¤æ›´æ–°
      this.updateCardReactions(card, newData);
      
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’æ›´æ–°
      this.updateCardHighlight(card, newData);
      
    } catch (error) {
      console.error('updateAnswerCard error:', error);
    }
  }
  
  updateCardReactions(card, data) {
    const reactionContainer = card.querySelector('.reaction-container');
    if (!reactionContainer) return;

    // DOMæ“ä½œã‚’ãƒãƒƒãƒåŒ–
    const updates = [];
    
    this.reactionTypes.forEach(reactionType => {
      const newCount = data.reactions?.[reactionType.key]?.count || 0;
      const reacted = data.reactions?.[reactionType.key]?.reacted || false;

      // ãƒãƒƒãƒæ›´æ–°ç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©
      updates.push({
        rowIndex: data.rowIndex,
        reaction: reactionType.key,
        count: newCount,
        reacted,
        shouldDisplay: newCount > 0
      });
    });

    // ãƒãƒƒãƒã§DOMæ›´æ–°ã‚’å®Ÿè¡Œ
    this.batchUpdateReactionButtons(updates);
    this.updateCardReactionBackground(card, data);
  }

  // ãƒãƒƒãƒå‡¦ç†ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
  batchUpdateReactionButtons(updates, options = {}) {
    const { onComplete, immediate = false } = options;
    const fragment = document.createDocumentFragment();
    const updatedElements = new Map();
    
    const executeUpdate = () => {
      try {
        updates.forEach(update => {
          const buttons = document.querySelectorAll(`[data-row-index="${update.rowIndex}"][data-reaction="${update.reaction}"]`);
          
          buttons.forEach(btn => {
            if (!updatedElements.has(btn)) {
              // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºæ›´æ–°
              const countEl = btn.querySelector('.reaction-count');
              if (countEl && this.state.showCounts) {
                countEl.textContent = update.count;
              }
              
              // ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
              const rt = this.reactionTypes.find(r => r.key === update.reaction);
              const svgEl = btn.querySelector('svg');
              if (svgEl && rt) {
                svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', update.reacted);
              }
              
              // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
              const colorClass = update.reaction === 'LIKE' ? 'text-red-500' : 
                               update.reaction === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
              btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
              btn.classList.add(colorClass);
              btn.classList.toggle('liked', update.reacted);
              btn.setAttribute('aria-pressed', update.reacted.toString());
              
              // è¡¨ç¤º/éè¡¨ç¤º
              btn.style.display = update.shouldDisplay ? 'flex' : 'none';
              
              // aria-labelæ›´æ–°
              const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
              const reactionName = reactionNames[update.reaction] || update.reaction;
              const ariaLabel = `${reactionName}${update.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${update.count}ä»¶)` : ''}`;
              btn.setAttribute('aria-label', ariaLabel);
              
              updatedElements.set(btn, true);
            }
          });
        });
        
        // å®Œäº†ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
        if (onComplete) {
          onComplete(updatedElements);
        }
        
      } catch (error) {
        console.error('batchUpdateReactionButtons error:', error);
        if (onComplete) {
          onComplete(updatedElements, error);
        }
      }
    };
    
    // å³åº§å®Ÿè¡Œ or requestAnimationFrame
    if (immediate) {
      executeUpdate();
    } else {
      requestAnimationFrame(executeUpdate);
    }
  }
  
  updateCardReactionBackground(card, data) {
    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯ã¨ãƒœãƒ¼ãƒ€ãƒ¼ã‚’æ›´æ–°
    this.applyReactionStyles(card, data);
  }
  
  updateCardHighlight(card, data) {
    const isHighlighted = data.isHighlighted || data.highlight;
    
    if (isHighlighted) {
      card.classList.add('highlighted-card');
    } else {
      card.classList.remove('highlighted-card');
    }
    
    // Update highlight button if present
    const highlightBtn = card.querySelector('.highlight-btn');
    if (highlightBtn) {
      highlightBtn.classList.toggle('active', isHighlighted);
    }
  }
  
  updateExistingCard(card, row, oldData, changedItems) {
    if (oldData) {
      let hasChanges = false;
      
      if (oldData.opinion !== row.opinion) {
        const t = card.querySelector('.opinion-text');
        if (t) {
          t.textContent = row.opinion;
          hasChanges = true;
        }
      }
      
      if (oldData.reason !== row.reason) {
        const p = card.querySelector('.answer-preview p');
        if (p) {
          p.textContent = row.reason;
          hasChanges = true;
        }
      }
      
      if (oldData.name !== row.name) {
        const n = card.querySelector('.font-bold');
        if (n) {
          n.textContent = row.name;
          hasChanges = true;
        }
      }
      
      if (JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) || 
          oldData.highlight !== row.highlight) {
        hasChanges = true;
      }
      
      if (hasChanges) {
        changedItems.push(row);
      }
    }
  }
  createAnswerCard(data) {
    try {
      // Data validation and sanitization
      if (!data || typeof data !== 'object') {
        console.warn('createAnswerCard: Invalid data provided:', data);
        return null;
      }
      
      // Ensure required properties exist with safe defaults
      const safeData = {
        rowIndex: data.rowIndex || 0,
        opinion: data.opinion || '',
        reason: data.reason || '',
        name: data.name || '',
        email: data.email || '',
        reactions: data.reactions || {},
        highlight: Boolean(data.highlight)
      };
      
      // Optimized cache key generation (faster than JSON.stringify)
      const cacheKey = `${safeData.rowIndex}-${safeData.opinion.slice(0,50)}-${safeData.reason.slice(0,30)}-${safeData.name}-${JSON.stringify(safeData.reactions)}-${safeData.highlight}-${this.state.showCounts}-${this.state.displayMode}-${this.state.showHighlightToggle}`;
      
      // Answer card cache check
      const cachedCard = this.cache.get(`render-${cacheKey}`);
      if (cachedCard) {
        try {
          const clonedCard = cachedCard.cloneNode(true);
          // Ensure cloned card has proper data-row-index
          clonedCard.dataset.rowIndex = safeData.rowIndex;
          
          // Optimized: Only update elements that need row index (avoid querySelectorAll)
          const reactionButtons = clonedCard.querySelectorAll('.reaction-btn');
          reactionButtons.forEach(btn => {
            btn.dataset.rowIndex = safeData.rowIndex;
          });
          
          return clonedCard;
        } catch (cacheError) {
          console.warn('createAnswerCard: Cache clone error, creating new card:', cacheError);
          // Continue to create new card if cache fails
        }
      }
    
      const card = document.createElement('div');
      const highlightClass = safeData.highlight ? ' highlighted' : '';
      card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' + highlightClass;
      card.dataset.rowIndex = safeData.rowIndex;
      card.setAttribute('role', 'article');
      card.setAttribute('tabindex', '0');
      card.setAttribute('aria-label', 'å›ç­”ã‚«ãƒ¼ãƒ‰: ' + safeData.opinion.substring(0, 50) + (safeData.opinion.length > 50 ? '...' : ''));
    
      // Answer card created
      let highlightBtnHtml = '';
      // Highlight button condition check
      if (this.state.showHighlightToggle) {
        const cls = safeData.highlight ? 'liked' : '';
        const highlightAriaLabel = safeData.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
        highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + safeData.highlight + '" data-row-index="' + safeData.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', safeData.highlight) + '</button>';
      }
      const showName = this.state.displayMode === 'named';
      let displayName = '';
      
      if (showName) {
        // åå‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°emailã‹ã‚‰ç”Ÿæˆ
        if (safeData.name) {
          displayName = safeData.name;
        } else if (safeData.email) {
          try {
            displayName = safeData.email.split('@')[0];
          } catch (emailError) {
            console.warn('createAnswerCard: Email parsing error:', emailError);
            displayName = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
          }
        }
      }
      
      const nameHtml = showName && displayName ? '<div class="name-display flex-shrink-0 mr-2"><span class="font-bold text-sm text-cyan-300 bg-gray-800/50 px-2 py-1 rounded border border-cyan-400">' + this.escapeHtml(displayName) + '</span></div>' : '';
      const containerClass = nameHtml ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex flex-col sm:flex-row justify-between items-start sm:items-center gap-y-1 min-h-[2rem]' : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';
    
      // Name display configuration complete
      const reactionButtonsHtml = this.reactionTypes.map(rt => {
        try {
          const info = safeData.reactions && safeData.reactions[rt.key] ? safeData.reactions[rt.key] : { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
          const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' + (info.count || 0) + '</span>' : '';
          const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
          const reactionName = reactionNames[rt.key] || rt.key;
          const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count || 0}ä»¶)` : ''}`;
          return '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' + colorClass + ' ' + cls + '" data-row-index="' + safeData.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + ariaLabel + '" aria-pressed="' + info.reacted + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
        } catch (reactionError) {
          console.warn('createAnswerCard: Reaction button creation error:', reactionError);
          return ''; // Skip problematic reaction button
        }
      }).join('');
      // Optimized: Use DocumentFragment instead of innerHTML for better performance
      const fragment = document.createDocumentFragment();
      
      // Create main content div
      const contentDiv = document.createElement('div');
      contentDiv.className = 'relative flex-grow mb-3 answer-preview';
      
      const opinionTitle = document.createElement('h3');
      opinionTitle.className = 'opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight';
      opinionTitle.textContent = safeData.opinion;
      
      const reasonText = document.createElement('p');
      reasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
      reasonText.textContent = safeData.reason;
      
      contentDiv.appendChild(opinionTitle);
      
      // ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿è¿½åŠ 
      if (safeData.reason && safeData.reason.trim()) {
        contentDiv.appendChild(reasonText);
      }
    
      // Create footer div
      const footerDiv = document.createElement('div');
      footerDiv.className = containerClass;
      
      // åå‰è¡¨ç¤ºéƒ¨åˆ†ã‚’è¿½åŠ 
      if (nameHtml) {
        try {
          const nameContainer = document.createElement('div');
          nameContainer.className = 'name-container flex-shrink-0';
          nameContainer.innerHTML = nameHtml;
          footerDiv.appendChild(nameContainer);
        } catch (nameError) {
          console.warn('createAnswerCard: Name container creation error:', nameError);
        }
      }
      
      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³éƒ¨åˆ†ã‚’è¿½åŠ 
      try {
        const reactionsDiv = document.createElement('div');
        reactionsDiv.className = 'flex items-center gap-1 flex-shrink-0';
        reactionsDiv.setAttribute('role', 'group');
        reactionsDiv.setAttribute('aria-label', 'å›ç­”ã¸ã®åå¿œ');
        reactionsDiv.innerHTML = reactionButtonsHtml + highlightBtnHtml;
        
        footerDiv.appendChild(reactionsDiv);
      } catch (reactionError) {
        console.warn('createAnswerCard: Reactions div creation error:', reactionError);
      }
      
      fragment.appendChild(contentDiv);
      fragment.appendChild(footerDiv);
      card.appendChild(fragment);
      
      if (safeData.highlight) {
        try {
          const badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } catch (badgeError) {
          console.warn('createAnswerCard: Highlight badge creation error:', badgeError);
        }
      }
      
      // çµ±ä¸€ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
      try {
        this.applyReactionStyles(card, safeData);
      } catch (styleError) {
        console.warn('createAnswerCard: Reaction styles application error:', styleError);
      }
      
      // Cache the card for reuse (limit cache size)
      try {
        if (this.cache.size > 100) {
          this.cache.cleanup();
        }
        this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
      } catch (cacheError) {
        console.warn('createAnswerCard: Cache storage error:', cacheError);
      }
      
      return card;
      
    } catch (error) {
      console.error('createAnswerCard: Critical error creating card:', error, 'Data:', data);
      
      // Return a minimal error card instead of null
      try {
        const errorCard = document.createElement('div');
        errorCard.className = 'answer-card glass-panel rounded-xl p-4 border-2 border-red-400/50 bg-red-900/20';
        errorCard.innerHTML = `
          <div class="text-red-300 text-center">
            <div class="mb-2">âš ï¸ ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒ©ãƒ¼</div>
            <div class="text-xs text-red-400">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ</div>
          </div>
        `;
        return errorCard;
      } catch (fallbackError) {
        console.error('createAnswerCard: Fallback card creation also failed:', fallbackError);
        return null;
      }
    }
  }
  
  createSkeletonCard() {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
    // Simplified skeleton for faster rendering
    card.innerHTML = '<div class="h-20 w-full rounded bg-gray-500/30 mb-4"></div><div class="h-6 w-full rounded bg-gray-500/20"></div>';
    return card;
  }

  /**
   * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ï¼ˆæ—¢å­˜ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼‹ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãƒãƒƒãƒå‡¦ç†ï¼‰
   */
  async handleReaction(rowIndex, reaction) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;

    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: çŸ­æ™‚é–“ã§ã®é‡è¤‡æ“ä½œã‚’é˜²ã
    const now = Date.now();
    const lastOperation = this.lastReactionTimes?.get(reactionKey);
    if (lastOperation && (now - lastOperation) < 1000) { // 1ç§’ä»¥å†…ã®é‡è¤‡æ“ä½œã‚’é˜²ã
      console.log(`âš¡ é‡è¤‡æ“ä½œã‚¹ã‚­ãƒƒãƒ—: ${reactionKey}`);
      return;
    }

    // æ—¢å­˜ã®å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå¸¸ã«ç¶­æŒï¼‰
    this.reactionQueue.set(reactionKey, {
      rowIndex: numericRowIndex,
      reaction,
      timestamp: now
    });

    // æœ€å¾Œã®æ“ä½œæ™‚åˆ»ã‚’è¨˜éŒ²
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(reactionKey, now);

    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³: ãƒãƒƒãƒå‡¦ç†ã‚‚ä¸¦è¡Œå®Ÿè¡Œï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ãªã—ï¼‰
    if (this.enableBatchProcessing && !this.batchProcessingActive) {
      this.addToBatchQueue(numericRowIndex, reaction);
    }

    // æ—¢å­˜ã®ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚’é–‹å§‹ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã‚’ä¿æŒï¼‰
    this.processReactionQueue();
  }

  async processReactionQueue() {
    if (this.isProcessingReactionQueue) return;
    this.isProcessingReactionQueue = true;

    try {
      // ãƒãƒƒãƒå‡¦ç†ãŒæœ‰åŠ¹ã§ã€ã‚­ãƒ¥ãƒ¼ã«è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹å ´åˆã¯ãƒãƒƒãƒå‡¦ç†ã‚’è©¦è¡Œ
      if (this.enableBatchProcessing && this.reactionQueue.size > 1 && !this.batchProcessingActive) {
        const canBatch = await this.tryBatchProcessing();
        if (canBatch) {
          // ãƒãƒƒãƒå‡¦ç†æˆåŠŸæ™‚ã¯å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
          this.reactionQueue.clear();
          return;
        }
        // ãƒãƒƒãƒå‡¦ç†å¤±æ•—æ™‚ã¯æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      }

      // æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Œå…¨ã«ä¿æŒï¼‰
      while (this.reactionQueue.size > 0) {
        const [reactionKey, operation] = this.reactionQueue.entries().next().value;
        this.reactionQueue.delete(reactionKey);

        await this.executeReactionOperation(operation, reactionKey);
      }
    } catch (error) {
      console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
    } finally {
      this.isProcessingReactionQueue = false;
    }
  }

  async executeReactionOperation(operation, reactionKey) {
    const { rowIndex, reaction } = operation;

    try {
        this.pendingReactions.add(reactionKey);

        const btns = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
        this.setReactionButtonsLoading(btns, true);

        const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
        if (!item) {
            throw new Error(`Item not found for rowIndex: ${rowIndex}`);
        }

        console.log('ğŸ“¡ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ (Server-first):', { rowIndex, reaction, sheetName: this.state.sheetName });

        // Server-first approach: ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã—ã¦ã‹ã‚‰çµæœã‚’é©ç”¨
        const response = await this.sendReactionToServer(rowIndex, reaction);
        await this.processReactionResponse(item, response, reaction);

        // UIæ›´æ–°ï¼ˆã‚µãƒ¼ãƒãƒ¼å¿œç­”å¾Œã®ã¿ï¼‰
        await this.updateReactionUI(item, false);

        console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†:', reactionKey);
        
        // å‡¦ç†å®Œäº†ã‚’é€šçŸ¥
        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: true });
    } catch (error) {
        console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        await this.handleReactionError(error, rowIndex, reaction);
        
        // ã‚¨ãƒ©ãƒ¼å®Œäº†ã‚’é€šçŸ¥
        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: false, error: error.message });
    } finally {
        this.pendingReactions.delete(reactionKey);

        const btns = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
        this.setReactionButtonsLoading(btns, false);
    }
  }

  // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
  notifyReactionComplete(reactionKey, result) {
    const listeners = this.reactionEventListeners.get(reactionKey);
    if (listeners && listeners.length > 0) {
      listeners.forEach(listener => {
        try {
          listener(result);
        } catch (error) {
          console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ãƒªã‚¹ãƒŠãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
        }
      });
      // ä¸€åº¦å®Ÿè¡Œã—ãŸã‚‰å‰Šé™¤
      this.reactionEventListeners.delete(reactionKey);
    }
  }

  // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿ
  waitForReactionComplete(reactionKey, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.reactionEventListeners.delete(reactionKey);
        reject(new Error(`Reaction timeout: ${reactionKey}`));
      }, timeout);

      const listener = (result) => {
        clearTimeout(timeoutId);
        resolve(result);
      };

      if (!this.reactionEventListeners.has(reactionKey)) {
        this.reactionEventListeners.set(reactionKey, []);
      }
      this.reactionEventListeners.get(reactionKey).push(listener);
    });
  }

  // å‹•çš„çŠ¶æ…‹å¤‰åŒ–å¾…æ©Ÿã‚·ã‚¹ãƒ†ãƒ 
  async waitForReactionStateChange(rowIndex, reaction, initialState, timeoutMs = 3000, pollIntervalMs = 50) {
    const startTime = Date.now();
    
    const getReactionButtonState = () => {
      const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
      if (buttons.length === 0) return null;
      
      const btn = buttons[0];
      return {
        reacted: btn.getAttribute('aria-pressed') === 'true',
        count: parseInt(btn.querySelector('.count')?.textContent || '0'),
        disabled: btn.disabled,
        classes: btn.className,
        timestamp: Date.now()
      };
    };
    
    const hasStateChanged = (current, initial) => {
      if (!current || !initial) return false;
      return current.reacted !== initial.reacted || 
             current.count !== initial.count ||
             current.disabled !== initial.disabled;
    };
    
    return new Promise((resolve, reject) => {
      const poll = () => {
        const currentTime = Date.now();
        if (currentTime - startTime >= timeoutMs) {
          reject(new Error(`State change timeout after ${timeoutMs}ms`));
          return;
        }
        
        const currentState = getReactionButtonState();
        if (hasStateChanged(currentState, initialState)) {
          resolve({
            initialState,
            currentState,
            changeDetectedAt: currentTime - startTime,
            stateChanged: true
          });
          return;
        }
        
        setTimeout(poll, pollIntervalMs);
      };
      
      poll();
    });
  }

  // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ç›£è¦–ï¼ˆé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ä¸­å¿ƒï¼‰
  async waitForReactionUpdate(rowIndex, reaction, expectedChange = null, maxWaitMs = 3000) {
    const reactionKey = `${rowIndex}-${reaction}`;
    
    try {
      // å®Œäº†é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®ã¿ã‚’ä½¿ç”¨ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã§ä¿¡é ¼æ€§ãŒé«˜ã„ï¼‰
      const result = await this.waitForReactionComplete(reactionKey, maxWaitMs);
      return result || { timeout: false, success: true };
    } catch (error) {
      console.warn(`âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${reactionKey}`, error.message);
      return { 
        error: error.message, 
        timeout: true,
        success: false
      };
    }
  }

  // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³çŠ¶æ…‹å–å¾—ãƒ˜ãƒ«ãƒ‘ãƒ¼
  getReactionButtonState(rowIndex, reaction) {
    const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
    if (buttons.length === 0) return null;
    
    const btn = buttons[0];
    return {
      reacted: btn.getAttribute('aria-pressed') === 'true',
      count: parseInt(btn.querySelector('.count')?.textContent || '0'),
      disabled: btn.disabled,
      classes: btn.className,
      visible: btn.style.display !== 'none',
      computedStyle: getComputedStyle(btn),
      timestamp: Date.now()
    };
  }

  // ãƒãƒƒãƒå‡¦ç†é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ã—ãªã„è¿½åŠ æ©Ÿèƒ½ï¼‰
  
  addToBatchQueue(rowIndex, reaction) {
    try {
      if (!this.reactionBatchQueue.has(rowIndex)) {
        this.reactionBatchQueue.set(rowIndex, []);
      }
      
      const batchForRow = this.reactionBatchQueue.get(rowIndex);
      const existingIndex = batchForRow.findIndex(r => r.reaction === reaction);
      
      if (existingIndex >= 0) {
        // æ—¢å­˜ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æ›´æ–°
        batchForRow[existingIndex].timestamp = Date.now();
      } else {
        // æ–°ã—ã„ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        batchForRow.push({
          reaction,
          timestamp: Date.now()
        });
      }
      
      // ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶é™ãƒã‚§ãƒƒã‚¯
      const totalBatchSize = Array.from(this.reactionBatchQueue.values())
        .reduce((sum, reactions) => sum + reactions.length, 0);
      
      if (totalBatchSize >= this.BATCH_SIZE_LIMIT) {
        console.log('ğŸ“¦ ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶é™åˆ°é”ã€å³åº§å‡¦ç†å®Ÿè¡Œ');
        this.processBatchQueue();
      }
    } catch (error) {
      console.warn('ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼ï¼ˆå€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰:', error);
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ä½•ã‚‚ã—ãªã„ï¼ˆæ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ãŒå‹•ä½œï¼‰
    }
  }

  async tryBatchProcessing() {
    try {
      if (this.batchProcessingActive || this.reactionQueue.size === 0) {
        return false;
      }

      this.batchProcessingActive = true;
      console.log('ğŸ”„ ãƒãƒƒãƒå‡¦ç†è©¦è¡Œé–‹å§‹');

      // ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ãƒãƒƒãƒæ“ä½œã‚’æº–å‚™
      const batchOperations = Array.from(this.reactionQueue.values());
      
      if (batchOperations.length === 1) {
        // å˜ä¸€æ“ä½œã®å ´åˆã¯ãƒãƒƒãƒå‡¦ç†ã—ãªã„
        this.batchProcessingActive = false;
        return false;
      }

      // ãƒãƒƒãƒã§ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ï¼ˆæ–°ã—ã„APIé–¢æ•°ãŒå¿…è¦ï¼‰
      const result = await this.gas.addReactionBatch(batchOperations);
      
      if (result && result.success) {
        console.log('âœ… ãƒãƒƒãƒå‡¦ç†æˆåŠŸ:', batchOperations.length + 'ä»¶');
        
        // ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
        this.processBatchReactionResponse(result.data, batchOperations);
        
        // å®Œäº†é€šçŸ¥
        batchOperations.forEach(op => {
          const reactionKey = `${op.rowIndex}-${op.reaction}`;
          this.notifyReactionComplete(reactionKey, { success: true, batch: true });
        });
        
        return true;
      } else {
        console.warn('ãƒãƒƒãƒå‡¦ç†å¤±æ•—ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
        return false;
      }
    } catch (error) {
      console.warn('ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯:', error);
      return false;
    } finally {
      this.batchProcessingActive = false;
    }
  }

  processBatchReactionResponse(responseData, originalOperations) {
    try {
      if (!responseData || !Array.isArray(responseData)) {
        console.warn('ç„¡åŠ¹ãªãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€å€‹åˆ¥å‡¦ç†ã§ç¶šè¡Œ');
        return;
      }
      
      // å„è¡Œã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†ï¼ˆæ—¢å­˜ã®ä»•çµ„ã¿ã‚’å†åˆ©ç”¨ï¼‰
      responseData.forEach(rowData => {
        const item = this.state.currentAnswers.find(i => i.rowIndex == rowData.rowIndex);
        if (item) {
          // æ—¢å­˜ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨
          this.processReactionResponse(rowData, item);
        }
      });
      
      console.log('âœ… ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†å®Œäº†');
    } catch (error) {
      console.error('ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ãŒå‡¦ç†ã™ã‚‹
    }
  }

  setReactionButtonsLoading(buttons, isLoading) {
    buttons.forEach(btn => {
        btn.disabled = isLoading;
        if (isLoading) {
            btn.classList.add('loading');
        } else {
            btn.classList.remove('loading');
        }
    });
  }

  async sendReactionToServer(rowIndex, reaction) {
    const response = await this.gas.addReaction(rowIndex, reaction, this.state.sheetName);
    
    if (!response) {
        throw new Error('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“');
    }
    
    if (response.status !== 'ok') {
        throw new Error(response.message || 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    return response;
}

  async processReactionResponse(item, response, reaction) {
    console.log('ğŸ”„ ã‚µãƒ¼ãƒãƒ¼å¿œç­”å‡¦ç†é–‹å§‹:', { rowIndex: item.rowIndex, reaction, response });
    
    // ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’çµ¶å¯¾çš„ã«é©ç”¨ï¼ˆæ¥½è¦³çš„æ›´æ–°ãªã—ï¼‰
    if (response.reactions && typeof response.reactions === 'object') {
        // ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã§å®Œå…¨ã«ä¸Šæ›¸ã
        const serverState = response.reactions;
        item.reactions = JSON.parse(JSON.stringify(serverState));
        
        console.log('âœ… ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹é©ç”¨å®Œäº†:', {
          rowIndex: item.rowIndex,
          reaction,
          serverState: item.reactions
        });
        
    } else {
        console.warn('âš ï¸ æœŸå¾…ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“:', response);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆã‚µãƒ¼ãƒãƒ¼å¿œç­”ãŒä¸æ­£ãªå ´åˆã®ã¿ï¼‰
        this.applyFallbackReactionUpdate(item, reaction);
        console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Ÿè¡Œ:', item.reactions);
    }
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ï¼ˆã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’ä¿å­˜ï¼‰
    this.saveReactionState(item.rowIndex, item.reactions);
    
    console.log('ğŸ¯ ã‚µãƒ¼ãƒãƒ¼å¿œç­”å‡¦ç†å®Œäº†:', { rowIndex: item.rowIndex, finalState: item.reactions });
}

  // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹æ•´åˆæ€§æ¤œè¨¼
  validateReactionConsistency(rowIndex, optimisticState, serverState) {
    const inconsistencies = [];
    
    // å„ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
    this.reactionTypes.forEach(rt => {
      const reaction = rt.key;
      const optimistic = optimisticState[reaction] || { count: 0, reacted: false };
      const server = serverState[reaction] || { count: 0, reacted: false };
      
      if (optimistic.reacted !== server.reacted) {
        inconsistencies.push({
          reaction,
          type: 'reacted_mismatch',
          optimistic: optimistic.reacted,
          server: server.reacted
        });
      }
      
      if (Math.abs(optimistic.count - server.count) > 1) {
        inconsistencies.push({
          reaction,
          type: 'count_significant_diff',
          optimistic: optimistic.count,
          server: server.count,
          diff: server.count - optimistic.count
        });
      }
    });
    
    if (inconsistencies.length > 0) {
      console.warn('âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º:', {
        rowIndex,
        inconsistencies,
        optimisticState,
        serverState
      });
      
      // ä¸æ•´åˆã‚’è¨˜éŒ²ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
      this.recordReactionInconsistency(rowIndex, inconsistencies);
    } else {
      console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹æ•´åˆæ€§ç¢ºèª:', { rowIndex });
    }
    
    return inconsistencies;
  }

  // ä¸æ•´åˆè¨˜éŒ²ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
  recordReactionInconsistency(rowIndex, inconsistencies) {
    if (!this.reactionInconsistencies) {
      this.reactionInconsistencies = [];
    }
    
    this.reactionInconsistencies.push({
      timestamp: new Date().toISOString(),
      rowIndex,
      inconsistencies
    });
    
    // æœ€æ–°10ä»¶ã®ã¿ä¿æŒ
    if (this.reactionInconsistencies.length > 10) {
      this.reactionInconsistencies.shift();
    }
  }

  applyFallbackReactionUpdate(item, reaction) {
    if (!item.reactions) {
        item.reactions = {};
    }
    
    // ä»–ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã¾ãšè§£é™¤
    this.reactionTypes.forEach(rt => {
      if (rt.key !== reaction && item.reactions[rt.key]?.reacted) {
        item.reactions[rt.key].count = Math.max(0, item.reactions[rt.key].count - 1);
        item.reactions[rt.key].reacted = false;
      }
    });
    
    if (!item.reactions[reaction]) {
        item.reactions[reaction] = { count: 0, reacted: false };
    }
    
    // Toggle reaction state
    if (item.reactions[reaction].reacted) {
        item.reactions[reaction].count = Math.max(0, item.reactions[reaction].count - 1);
        item.reactions[reaction].reacted = false;
    } else {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
        item.reactions[reaction].reacted = true;
    }
}

  // å³åº§UIæ›´æ–°ï¼ˆrequestAnimationFrameã‚’ä½¿ã‚ãªã„åŒæœŸæ›´æ–°ï¼‰
  async immediateUIUpdate(rowIndex, reaction) {
    const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
    if (!item || !item.reactions || !item.reactions[reaction]) {
      console.warn('âš ï¸ immediateUIUpdate: ã‚¢ã‚¤ãƒ†ãƒ ã¾ãŸã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      return;
    }

    try {
      // ã‚«ãƒ¼ãƒ‰ã®UIæ›´æ–°ï¼ˆåŒæœŸå®Ÿè¡Œï¼‰
      const card = document.querySelector(`[data-row-index="${rowIndex}"]`);
      if (card && card instanceof HTMLElement) {
        this.updateCardReactions(card, item);
        this.applyReactionStyles(card, item);
      }

      // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
      if (!this.elements.answerModalContainer.classList.contains('hidden')) {
        const modalRowIndex = this.elements.modalReactionContainer
          .querySelector('[data-row-index]')?.dataset.rowIndex;
        if (modalRowIndex == rowIndex) {
          this.updateModalReactionButtons(item);
        }
      }

      console.log('âš¡ å³åº§UIæ›´æ–°å®Œäº†:', { rowIndex, reaction });
    } catch (error) {
      console.error('âŒ å³åº§UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  async updateReactionUI(item, immediate = false) {
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: å¤‰æ›´ãŒå¿…è¦ãªå ´åˆã®ã¿æ›´æ–°
    const lastUpdateKey = `ui_update_${item.rowIndex}`;
    const currentStateHash = this.calculateStateHash(item);
    const lastStateHash = this.lastUIStates?.get(lastUpdateKey);
    
    if (lastStateHash === currentStateHash && !immediate) {
      console.log(`âš¡ UIæ›´æ–°ã‚¹ã‚­ãƒƒãƒ— (å¤‰æ›´ãªã—): rowIndex=${item.rowIndex}`);
      return;
    }
    
    // çŠ¶æ…‹ãƒãƒƒã‚·ãƒ¥ã‚’è¨˜éŒ²
    if (!this.lastUIStates) this.lastUIStates = new Map();
    this.lastUIStates.set(lastUpdateKey, currentStateHash);

    if (immediate) {
      // å³åº§å®Ÿè¡Œï¼ˆrequestAnimationFrameã‚’ä½¿ã‚ãªã„ï¼‰
      try {
        const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
        if (card && card instanceof HTMLElement) {
          this.updateCardReactions(card, item);
          this.applyReactionStyles(card, item);
        } else {
          console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex = this.elements.modalReactionContainer
            .querySelector('[data-row-index]')?.dataset.rowIndex;
          if (modalRowIndex == item.rowIndex) {
            this.updateModalReactionButtons(item);
            this.applyReactionStyles(this.elements.answerModalCard, item);
          }
        }

        console.log('âš¡ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³UIå³åº§æ›´æ–°å®Œäº†:', {
          rowIndex: item.rowIndex,
          reactions: item.reactions
        });
      } catch (error) {
        console.error('âŒ UIå³åº§æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      }
      return;
    }

    // é€šå¸¸å®Ÿè¡Œï¼ˆrequestAnimationFrameä½¿ç”¨ï¼‰
    return new Promise(resolve => {
        requestAnimationFrame(() => {
            try {
                // ã‚«ãƒ¼ãƒ‰ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºã‚’æ›´æ–°
                const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
                if (card && card instanceof HTMLElement) {
                    this.updateCardReactions(card, item);
                    this.applyReactionStyles(card, item);
                } else {
                    console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
                }

                // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
                if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                    const modalRowIndex = this.elements.modalReactionContainer
                      .querySelector('[data-row-index]')?.dataset.rowIndex;
                    if (modalRowIndex == item.rowIndex) {
                      this.updateModalReactionButtons(item);
                      this.applyReactionStyles(this.elements.answerModalCard, item);
                    }
                }

                console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³UIæ›´æ–°å®Œäº†:', {
                  rowIndex: item.rowIndex,
                  reactions: item.reactions
                });
                resolve();
            } catch (error) {
                console.error('UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                resolve();
            }
        });
    });
  }

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ã‚·ãƒ¼ãƒˆåã«åŸºã¥ããƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚­ãƒ¼ç”Ÿæˆ
  getScopedKey(base) {
    const userId = this.state?.userId || USER_ID;
    return `${base}_${userId}_${SHEET_NAME}`;
  }

  // lastSeenCountæ°¸ç¶šåŒ–æ©Ÿèƒ½
  loadLastSeenCount() {
    try {
      const key = this.getScopedKey('lastSeenCount');
      const stored = localStorage.getItem(key);
      const count = stored ? parseInt(stored, 10) : 0;
      
      console.log('ğŸ“¥ lastSeenCountå¾©å…ƒ:', { key, count });
      return isNaN(count) ? 0 : count;
    } catch (error) {
      console.warn('âš ï¸ lastSeenCountèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      return 0;
    }
  }

  // çœŸã®åˆå›ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹åˆ¤å®š
  isFirstTimeBoardAccess() {
    try {
      // 1. lastSeenCountã®å­˜åœ¨ç¢ºèª
      const hasLastSeen = localStorage.getItem(this.getScopedKey('lastSeenCount')) !== null;

      // 2. å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å­˜åœ¨ç¢ºèª
      const hasDiffCards = localStorage.getItem(this.getScopedKey('differentialCards')) !== null;
      
      // 3. åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã®ç¢ºèª
      const hasInitialLoad = this.initialDataLoaded === true;
      
      // 4. DOMå†…ã®æ—¢å­˜ã‚«ãƒ¼ãƒ‰ç¢ºèª
      const container = this.elements?.answersContainer;
      const hasDOMCards = container && container.querySelectorAll('.answer-card').length > 0;
      
      // çœŸã®åˆå›åˆ¤å®š: ã™ã¹ã¦ãŒæœªè¨­å®š/åˆæœŸçŠ¶æ…‹ã®å ´åˆ
      const isFirstTime = !hasLastSeen && !hasDiffCards && !hasInitialLoad && !hasDOMCards;
      
      console.log('ğŸ” åˆå›åˆ¤å®šçµæœ:', {
        hasLastSeen,
        hasDiffCards,
        hasInitialLoad,
        hasDOMCards,
        isFirstTime
      });
      
      return isFirstTime;
    } catch (error) {
      console.warn('âš ï¸ åˆå›åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨å´ï¼ˆåˆå›ã§ã¯ãªã„ï¼‰ã¨åˆ¤å®š
      return false;
    }
  }

  saveLastSeenCount(count) {
    try {
      const key = this.getScopedKey('lastSeenCount');
      localStorage.setItem(key, count.toString());
      
      console.log('ğŸ’¾ lastSeenCountä¿å­˜:', { key, count });
    } catch (error) {
      console.warn('âš ï¸ lastSeenCountä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  updateLastSeenCount(newCount) {
    if (typeof newCount === 'number' && newCount >= 0) {
      const oldCount = this.state.lastSeenCount;
      this.state.lastSeenCount = newCount;
      this.saveLastSeenCount(newCount);
      
      console.log('ğŸ“Š lastSeenCountæ›´æ–°:', { 
        oldCount, 
        newCount,
        timestamp: new Date().toISOString()
      });
    }
  }

  // å·®åˆ†ã‚«ãƒ¼ãƒ‰ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
  loadDifferentialCards() {
    try {
      const key = this.getScopedKey('differentialCards');
      const stored = localStorage.getItem(key);
      const cards = stored ? JSON.parse(stored) : [];
      
      console.log('ğŸ“¥ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒ:', { key, count: cards.length });
      return Array.isArray(cards) ? cards : [];
    } catch (error) {
      console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  saveDifferentialCards(cardIds) {
    try {
      const key = this.getScopedKey('differentialCards');
      const existing = this.loadDifferentialCards();
      const merged = [...new Set([...existing, ...cardIds])];
      localStorage.setItem(key, JSON.stringify(merged));
      
      console.log('ğŸ’¾ å·®åˆ†ã‚«ãƒ¼ãƒ‰ä¿å­˜:', { key, count: merged.length, new: cardIds.length });
    } catch (error) {
      console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  clearDifferentialCards() {
    try {
      const key = this.getScopedKey('differentialCards');
      localStorage.removeItem(key);
      console.log('ğŸ—‘ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªã‚¢:', { key });
    } catch (error) {
      console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªã‚¢ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  // å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å¾©å…ƒï¼ˆãƒšãƒ¼ã‚¸å†èª­ã¿è¾¼ã¿æ™‚ï¼‰
  restoreDifferentialCards() {
    const differentialCardIds = this.loadDifferentialCards();
    if (differentialCardIds.length === 0) return;

    console.log('ğŸ”„ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒé–‹å§‹:', differentialCardIds.length + 'ä»¶');
    
    const container = this.elements.answersContainer;
    if (!container) return;

    // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‹ã‚‰å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒ¼ã‚¯
    const allCards = container.querySelectorAll('.answer-card');
    let restoredCount = 0;
    
    allCards.forEach(card => {
      const rowIndex = parseInt(card.getAttribute('data-row-index'));
      if (differentialCardIds.includes(rowIndex)) {
        card.setAttribute('data-differential-card', 'true');
        card.setAttribute('data-restored', 'true');
        restoredCount++;
        console.log('ğŸ“Œ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒ:', rowIndex);
      }
    });
    
    console.log('âœ… å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒå®Œäº†:', restoredCount + 'ä»¶');
  }

  async handleReactionError(error, rowIndex, reaction) {
    console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', {
        error: error.message,
        rowIndex,
        reaction,
        timestamp: new Date().toISOString()
    });
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (window.messageManager) {
        window.messageManager.show(
            'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
            'error',
            3000
        );
    }
  }
  
  showErrorFeedback(btn, message) {
    if (!btn) return;
    
    // å…ƒã®ã‚¯ãƒ©ã‚¹ã‚’ä¿å­˜
    const originalClasses = btn.className;
    
    // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
    btn.classList.add('bg-red-500');
    btn.title = message;
    
    // 2ç§’å¾Œã«å…ƒã«æˆ»ã™
    setTimeout(() => {
      btn.className = originalClasses;
      btn.title = '';
    }, 2000);
  }
  
  async handleHighlight(rowIndex) {
    // Highlight processing started
    
    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å´ã§ç®¡ç†è€…æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã§ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å´ã®ãƒã‚§ãƒƒã‚¯ã¯ä¸è¦
    
    const numericRowIndex = parseInt(rowIndex, 10);
    const highlightKey = `${numericRowIndex}-highlight`;
    
    // Enhanced debounce for highlight operations
    if (this.highlightDebounce.has(highlightKey)) {
      clearTimeout(this.highlightDebounce.get(highlightKey));
      return; // Ignore rapid highlight clicks
    }
    
    // Rate limiting for highlights
    const now = Date.now();
    const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
    if (now - lastHighlightTime < StudyQuestApp.CONSTANTS.HIGHLIGHT_RATE_LIMIT_MS) {
      return;
    }
    
    // æ—¢ã«å‡¦ç†ä¸­ã®å ´åˆã¯ç„¡è¦–
    if (this.pendingReactions.has(highlightKey)) {
      return;
    }
    
    this.pendingReactions.add(highlightKey);
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(highlightKey, now);
    
    const btns = document.querySelectorAll('.highlight-btn[data-row-index="' + numericRowIndex + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    
    if (!item) {
      this.pendingReactions.delete(highlightKey);
      return;
    }
    
    // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘ ï¼šUIæ›´æ–°ã‚’ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºã®ã¿ã«é™å®š
    btns.forEach(btn => {
        btn.classList.add('loading');
        btn.disabled = true;
    });
    
    try {
        // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘¡ï¼šå…ˆã«ã‚µãƒ¼ãƒãƒ¼ã¨é€šä¿¡ã™ã‚‹
        const res = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);

        if (res && res.status === 'ok') {
            // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘¢ï¼šã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”æˆåŠŸå¾Œã«ã€UIã‚’å®Œå…¨ã«æ›´æ–°ã™ã‚‹
            item.highlight = res.highlight;
            requestAnimationFrame(() => this.applyUpdates([item])); // æ¬¡ã®æç”»ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®‰å…¨ã«UIã‚’æ›´æ–°

            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚Œã°ãã¡ã‚‰ã‚‚æ›´æ–°
            if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
                if (modalRowIndex == rowIndex) {
                    this.updateModalContent(item);
                }
            }
            
            // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ“ä½œå¾Œã®çŠ¶æ…‹åŒæœŸç¢ºèªï¼ˆé…å»¶å®Ÿè¡Œï¼‰
            setTimeout(() => {
                this.verifyHighlightSync(numericRowIndex, res.highlight);
            }, 1000);
        } else {
            throw new Error(res?.message || 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
    } catch (error) {
        console.error('Failed to toggle highlight:', error);
        
        // æ¨©é™ã‚¨ãƒ©ãƒ¼ã®ç‰¹åˆ¥å‡¦ç†
        if (error.message && error.message.includes('ç®¡ç†è€…ã®ã¿')) {
            this.showErrorFeedback(btns[0], 'æ¨©é™ã‚¨ãƒ©ãƒ¼: ç®¡ç†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™');
            console.warn('ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½ã¯ç®¡ç†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™');
        } else {
            this.showErrorFeedback(btns[0], 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
    } finally {
        // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘£ï¼šæœ€å¾Œã«ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
        btns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
    }
  }

  // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèª
  async verifyHighlightSync(rowIndex, expectedHighlight) {
    try {
      const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
      if (!item) return;
      
      // UIçŠ¶æ…‹ã¨ã‚µãƒ¼ãƒãƒ¼å¿œç­”ã®ä¸€è‡´ç¢ºèª
      if (item.highlight !== expectedHighlight) {
        console.warn(`âš ï¸ ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: rowIndex=${rowIndex}, UI=${item.highlight}, Expected=${expectedHighlight}`);
        
        // ä¸æ•´åˆã®å ´åˆã¯å¼·åˆ¶çš„ã«ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã«åˆã‚ã›ã‚‹
        item.highlight = expectedHighlight;
        requestAnimationFrame(() => this.applyUpdates([item]));
        
        console.log('âœ… ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’ä¿®æ­£ã—ã¾ã—ãŸ');
      } else {
        console.log('âœ… ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèª: æ­£å¸¸');
      }
    } catch (error) {
      console.error('ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  // åŒ…æ‹¬çš„åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
  async performSyncHealthCheck() {
    console.log('ğŸ” åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–‹å§‹');
    const issues = [];
    
    try {
      // 1. ãƒ‡ãƒ¼ã‚¿å–å¾—åŒæœŸãƒã‚§ãƒƒã‚¯
      const lastDataLoad = this.lastDataLoadTime || 0;
      const minutesSinceLastLoad = (Date.now() - lastDataLoad) / (1000 * 60);

      if (minutesSinceLastLoad > 5) {
        issues.push({
          type: 'data_staleness',
          severity: 'warning',
          message: `æœ€å¾Œã®ãƒ‡ãƒ¼ã‚¿å–å¾—ã‹ã‚‰${Math.round(minutesSinceLastLoad)}åˆ†çµŒé`,
          recommendation: 'ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚’å®Ÿè¡Œ'
        });
      }
      
      // 2. ä¿ç•™ä¸­ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèª
      if (this.pendingReactions.size > 0) {
        issues.push({
          type: 'pending_reactions',
          severity: 'warning',
          message: `${this.pendingReactions.size}ä»¶ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå‡¦ç†ä¸­`,
          data: Array.from(this.pendingReactions)
        });
      }
      
      // 3. UIçŠ¶æ…‹ã¨ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
      const uiButtons = document.querySelectorAll('.reaction-btn, .highlight-btn');
      const inconsistentButtons = [];
      
      uiButtons.forEach(btn => {
        const rowIndex = parseInt(btn.dataset.rowIndex);
        const item = this.state.currentAnswers.find(i => i.rowIndex === rowIndex);
        
        if (!item) {
          inconsistentButtons.push({
            button: btn,
            issue: 'data_missing',
            rowIndex
          });
          return;
        }
        
        if (btn.classList.contains('reaction-btn')) {
          const reaction = btn.dataset.reaction;
          const isPressed = btn.getAttribute('aria-pressed') === 'true';
          const dataState = item.reactions?.[reaction]?.reacted === true;
          
          if (isPressed !== dataState) {
            inconsistentButtons.push({
              button: btn,
              issue: 'reaction_state_mismatch',
              rowIndex,
              reaction,
              uiState: isPressed,
              dataState
            });
          }
        }
        
        if (btn.classList.contains('highlight-btn')) {
          const isHighlighted = btn.classList.contains('highlighted');
          const dataState = item.highlight === true;
          
          if (isHighlighted !== dataState) {
            inconsistentButtons.push({
              button: btn,
              issue: 'highlight_state_mismatch',
              rowIndex,
              uiState: isHighlighted,
              dataState
            });
          }
        }
      });
      
      if (inconsistentButtons.length > 0) {
        issues.push({
          type: 'ui_data_inconsistency',
          severity: 'error',
          message: `${inconsistentButtons.length}ä»¶ã®UIçŠ¶æ…‹ä¸æ•´åˆ`,
          data: inconsistentButtons
        });
      }
      
      // 4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
      if (this.cache && typeof this.cache.size === 'number') {
        if (this.cache.size > 100) {
          issues.push({
            type: 'cache_bloat',
            severity: 'info',
            message: `ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºãŒå¤§ãã„: ${this.cache.size}ä»¶`,
            recommendation: 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã‚’æ¤œè¨'
          });
        }
      }
      
      // 5. çµæœå‡ºåŠ›
      if (issues.length === 0) {
        console.log('âœ… åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: å•é¡Œãªã—');
        return { status: 'healthy', issues: [] };
      } else {
        console.warn('âš ï¸ åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: å•é¡Œæ¤œå‡º', issues);
        return { status: 'issues_detected', issues };
      }
      
    } catch (error) {
      console.error('âŒ åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
      return { 
        status: 'check_failed', 
        error: error.message,
        issues: []
      };
    }
  }

  // ä¸æ•´åˆã®è‡ªå‹•ä¿®å¾©
  async fixSyncIssues(healthCheckResult) {
    if (!healthCheckResult.issues || healthCheckResult.issues.length === 0) {
      return { fixed: 0, skipped: 0 };
    }
    
    let fixed = 0;
    let skipped = 0;
    
    for (const issue of healthCheckResult.issues) {
      try {
        switch (issue.type) {
          case 'ui_data_inconsistency':
            // UIçŠ¶æ…‹ã‚’ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ã«åˆã‚ã›ã‚‹
            for (const inconsistency of issue.data) {
              const item = this.state.currentAnswers.find(i => i.rowIndex === inconsistency.rowIndex);
              if (item) {
                await this.applyUpdates([item]);
                fixed++;
              }
            }
            break;
            
          case 'data_staleness':
            // ãƒ‡ãƒ¼ã‚¿ã‚’å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
            console.log('ğŸ”„ å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã€å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Ÿè¡Œ');
            await this.forceDataRefresh();
            fixed++;
            break;
            
          case 'cache_bloat':
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
            if (this.cache && typeof this.cache.clear === 'function') {
              this.cache.clear();
              fixed++;
            }
            break;
            
          default:
            skipped++;
            break;
        }
      } catch (fixError) {
        console.error(`ä¿®å¾©å¤±æ•— (${issue.type}):`, fixError);
        skipped++;
      }
    }
    
    console.log(`ğŸ”§ è‡ªå‹•ä¿®å¾©å®Œäº†: ${fixed}ä»¶ä¿®å¾©, ${skipped}ä»¶ã‚¹ã‚­ãƒƒãƒ—`);
    return { fixed, skipped };
  }

  // å®šæœŸçš„ãªåŒæœŸç›£è¦–ã®é–‹å§‹
  startSyncMonitoring() {
    // æ—¢å­˜ã®ç›£è¦–ãŒå‹•ã„ã¦ã„ã‚‹å ´åˆã¯åœæ­¢
    if (this.syncMonitoringInterval) {
      clearInterval(this.syncMonitoringInterval);
    }
    
    // 5åˆ†é–“éš”ã§åŒæœŸçŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    this.syncMonitoringInterval = setInterval(async () => {
      try {
        const healthCheck = await this.performSyncHealthCheck();
        
        // é‡è¦ãªå•é¡ŒãŒã‚ã£ãŸå ´åˆã¯è‡ªå‹•ä¿®å¾©ã‚’è©¦è¡Œ
        if (healthCheck.status === 'issues_detected') {
          const criticalIssues = healthCheck.issues.filter(issue => 
            issue.severity === 'error' || issue.type === 'ui_data_inconsistency'
          );
          
          if (criticalIssues.length > 0) {
            console.log('ğŸ”§ é‡è¦ãªåŒæœŸå•é¡Œã‚’æ¤œå‡ºã€è‡ªå‹•ä¿®å¾©ã‚’å®Ÿè¡Œ');
            await this.fixSyncIssues({ issues: criticalIssues });
          }
        }
      } catch (error) {
        console.error('åŒæœŸç›£è¦–ã‚¨ãƒ©ãƒ¼:', error);
      }
    }, 5 * 60 * 1000); // 5åˆ†é–“éš”
    
    console.log('âœ… åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆ5åˆ†é–“éš”ï¼‰');
  }

  // åŒæœŸç›£è¦–ã®åœæ­¢
  stopSyncMonitoring() {
    if (this.syncMonitoringInterval) {
      clearInterval(this.syncMonitoringInterval);
      this.syncMonitoringInterval = null;
      console.log('ğŸ›‘ åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ');
    }
  }

  // ã‚¢ã‚¤ãƒ†ãƒ çŠ¶æ…‹ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ï¼ˆå¤‰æ›´æ¤œå‡ºç”¨ï¼‰
  calculateStateHash(item) {
    const state = {
      reactions: item.reactions,
      highlight: item.highlight,
      rowIndex: item.rowIndex
    };
    return JSON.stringify(state);
  }

  // ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆé–‹ç™ºãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
  async testBatchPerformance() {
    console.log('ğŸ§ª ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    const testResults = {
      batchTest: null,
      individualTest: null,
      comparison: null
    };
    
    try {
      // ãƒ†ã‚¹ãƒˆç”¨ã®æ¨¡æ“¬ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œãƒ‡ãƒ¼ã‚¿
      const testOperations = [];
      const testRowCount = Math.min(this.state.currentAnswers.length, 5); // æœ€å¤§5è¡Œã§ãƒ†ã‚¹ãƒˆ
      
      for (let i = 0; i < testRowCount; i++) {
        const item = this.state.currentAnswers[i];
        if (item) {
          testOperations.push({
            rowIndex: item.rowIndex,
            reaction: 'LIKE',
            timestamp: Date.now()
          });
        }
      }
      
      if (testOperations.length === 0) {
        console.warn('âš ï¸ ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
        return { error: 'ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³' };
      }
      
      console.log(`ğŸ“Š ${testOperations.length}ä»¶ã®æ“ä½œã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ`);
      
      // 1. ãƒãƒƒãƒå‡¦ç†ã®ãƒ†ã‚¹ãƒˆ
      console.log('ğŸ”„ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
      const batchStartTime = performance.now();
      
      try {
        // ãƒãƒƒãƒå‡¦ç†ã¯å®Ÿéš›ã«ã‚µãƒ¼ãƒãƒ¼ã‚’å‘¼ã°ãšã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®å‡¦ç†æ™‚é–“ã®ã¿æ¸¬å®š
        this.addToBatchQueue(testOperations[0].rowIndex, testOperations[0].reaction);
        for (let i = 1; i < testOperations.length; i++) {
          this.addToBatchQueue(testOperations[i].rowIndex, testOperations[i].reaction);
        }
        
        const batchEndTime = performance.now();
        testResults.batchTest = {
          duration: batchEndTime - batchStartTime,
          operationCount: testOperations.length,
          avgTimePerOp: (batchEndTime - batchStartTime) / testOperations.length
        };
        
        console.log('âœ… ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.batchTest);
      } catch (error) {
        console.error('âŒ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        testResults.batchTest = { error: error.message };
      }
      
      // 2. å€‹åˆ¥å‡¦ç†ã®ãƒ†ã‚¹ãƒˆï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
      console.log('ğŸ”„ å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
      const individualStartTime = performance.now();
      
      try {
        // å€‹åˆ¥å‡¦ç†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®APIå‘¼ã³å‡ºã—ãªã—ï¼‰
        for (const operation of testOperations) {
          // ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã™ã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
          this.reactionQueue.set(`${operation.rowIndex}-${operation.reaction}`, operation);
          // å°ã•ãªé…å»¶ã§APIå‘¼ã³å‡ºã—ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          await new Promise(resolve => setTimeout(resolve, 1));
        }
        
        const individualEndTime = performance.now();
        testResults.individualTest = {
          duration: individualEndTime - individualStartTime,
          operationCount: testOperations.length,
          avgTimePerOp: (individualEndTime - individualStartTime) / testOperations.length
        };
        
        console.log('âœ… å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.individualTest);
      } catch (error) {
        console.error('âŒ å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        testResults.individualTest = { error: error.message };
      }
      
      // 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ
      if (testResults.batchTest && testResults.individualTest && 
          !testResults.batchTest.error && !testResults.individualTest.error) {
        
        const speedImprovement = testResults.individualTest.duration / testResults.batchTest.duration;
        const efficiencyGain = ((testResults.individualTest.avgTimePerOp - testResults.batchTest.avgTimePerOp) 
                               / testResults.individualTest.avgTimePerOp) * 100;
        
        testResults.comparison = {
          speedImprovement: speedImprovement,
          efficiencyGain: efficiencyGain,
          recommendation: speedImprovement > 1.2 ? 'ãƒãƒƒãƒå‡¦ç†æ¨å¥¨' : 
                         speedImprovement < 0.8 ? 'å€‹åˆ¥å‡¦ç†æ¨å¥¨' : 'åŒç¨‹åº¦'
        };
        
        console.log('ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒçµæœ:', testResults.comparison);
      }
      
      // 4. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ï¼ˆæ¦‚ç®—ï¼‰
      const memoryInfo = performance.memory ? {
        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024)
      } : { info: 'ãƒ¡ãƒ¢ãƒªæƒ…å ±ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“' };
      
      testResults.memoryUsage = memoryInfo;
      
      console.log('ğŸ§ª ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†', testResults);
      return testResults;
      
    } catch (error) {
      console.error('âŒ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      return { error: error.message, partialResults: testResults };
    }
  }

  // ãƒãƒƒãƒå‡¦ç†ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
  validateBatchSystem() {
    console.log('ğŸ” ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯');
    
    const issues = [];
    
    // 1. ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
    if (!this.batchQueue) {
      issues.push('ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    } else if (this.batchQueue.size > 100) {
      issues.push(`ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: ${this.batchQueue.size}`);
    }
    
    // 2. å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
    if (!this.reactionQueue) {
      issues.push('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    } else if (this.reactionQueue.size > 50) {
      issues.push(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: ${this.reactionQueue.size}`);
    }
    
    // 3. å‡¦ç†çŠ¶æ…‹ã®ç¢ºèª
    if (this.isProcessingReactionQueue && this.batchProcessingActive) {
      issues.push('å€‹åˆ¥å‡¦ç†ã¨ãƒãƒƒãƒå‡¦ç†ãŒåŒæ™‚ã«å‹•ä½œä¸­ã§ã™');
    }
    
    // 4. è¨­å®šã®ç¢ºèª
    if (this.enableBatchProcessing === undefined) {
      issues.push('ãƒãƒƒãƒå‡¦ç†è¨­å®šãŒæœªå®šç¾©ã§ã™');
    }
    
    // 5. çµæœ
    if (issues.length === 0) {
      console.log('âœ… ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: æ­£å¸¸');
      return { status: 'healthy', issues: [] };
    } else {
      console.warn('âš ï¸ ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: å•é¡Œæ¤œå‡º', issues);
      return { status: 'issues_detected', issues };
    }
  }

  // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆé–‹ç™ºãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
  async testNotificationEdgeCases() {
    console.log('ğŸ§ª é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    const testResults = {
      tests: [],
      summary: { passed: 0, failed: 0, total: 0 }
    };
    
    try {
      // ãƒ†ã‚¹ãƒˆ1: åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®é€šçŸ¥
      console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ1: åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—â†’ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã‚·ãƒŠãƒªã‚ª');
      const test1 = await this.testInitialLoadFailureNotification();
      testResults.tests.push(test1);
      
      // ãƒ†ã‚¹ãƒˆ2: é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª
      console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ2: é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª');
      const test2 = this.testNotificationBannerElements();
      testResults.tests.push(test2);
      
      // ãƒ†ã‚¹ãƒˆ3: é€šçŸ¥æ¡ä»¶ã®ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèª
      console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ3: é€šçŸ¥æ¡ä»¶ãƒ­ã‚¸ãƒƒã‚¯ã®ç¢ºèª');
      const test3 = this.testNotificationLogic();
      testResults.tests.push(test3);
      
      // ãƒ†ã‚¹ãƒˆ4: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª
      console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ4: é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª');
      const test4 = await this.testNotificationDebounce();
      testResults.tests.push(test4);
      
      // çµæœé›†è¨ˆ
      testResults.tests.forEach(test => {
        testResults.summary.total++;
        if (test.passed) {
          testResults.summary.passed++;
        } else {
          testResults.summary.failed++;
        }
      });
      
      console.log('âœ… é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.summary);
      return testResults;
      
    } catch (error) {
      console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      return { error: error.message, partialResults: testResults };
    }
  }

  async testInitialLoadFailureNotification() {
    const testName = 'åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®é€šçŸ¥';
    try {
      // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
      const originalInitialDataLoaded = this.initialDataLoaded;
      const originalHadInitialDataLoadFailure = this.hadInitialDataLoadFailure;
      const originalLastSeenCount = this.state.lastSeenCount;
      
      // ãƒ†ã‚¹ãƒˆçŠ¶æ…‹ã‚’è¨­å®š
      this.initialDataLoaded = false;
      this.hadInitialDataLoadFailure = true;
      this.state.lastSeenCount = 0;
      
      console.log('ğŸ”§ ãƒ†ã‚¹ãƒˆçŠ¶æ…‹è¨­å®š:', {
        initialDataLoaded: this.initialDataLoaded,
        hadInitialDataLoadFailure: this.hadInitialDataLoadFailure,
        lastSeenCount: this.state.lastSeenCount
      });
      
      // ãƒ¢ãƒƒã‚¯é€šçŸ¥é–¢æ•°
      let notificationShown = false;
      const originalShowNewContentBanner = this.showNewContentBanner;
      this.showNewContentBanner = (newItems) => {
        notificationShown = true;
        console.log('ğŸ¯ ãƒ†ã‚¹ãƒˆä¸­ï¼šé€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ -', newItems, 'ä»¶');
        return originalShowNewContentBanner.call(this, newItems);
      };
      
      // æ¨¡æ“¬çš„ãª handleInitialContentLoad å‘¼ã³å‡ºã—
      await this.handleInitialContentLoad('ã™ã¹ã¦-newest', 1);
      
      // çµæœæ¤œè¨¼
      const passed = notificationShown && this.state.lastSeenCount === 1 && !this.hadInitialDataLoadFailure;
      
      // çŠ¶æ…‹ã‚’å¾©å…ƒ
      this.initialDataLoaded = originalInitialDataLoaded;
      this.hadInitialDataLoadFailure = originalHadInitialDataLoadFailure;
      this.state.lastSeenCount = originalLastSeenCount;
      this.showNewContentBanner = originalShowNewContentBanner;
      
      return {
        name: testName,
        passed,
        details: {
          notificationShown,
          finalLastSeenCount: this.state.lastSeenCount,
          failureFlagCleared: !this.hadInitialDataLoadFailure
        }
      };
      
    } catch (error) {
      return { name: testName, passed: false, error: error.message };
    }
  }
  
  testNotificationBannerElements() {
    const testName = 'é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª';
    try {
      const elements = {
        banner: this.elements.newContentBanner,
        text: this.elements.newContentText,
        refreshBtn: this.elements.refreshContentBtn,
        dismissBtn: this.elements.dismissBannerBtn
      };
      
      const missing = [];
      Object.entries(elements).forEach(([key, element]) => {
        if (!element) {
          missing.push(key);
        }
      });
      
      const passed = missing.length === 0;
      
      return {
        name: testName,
        passed,
        details: {
          elementsFound: Object.keys(elements).length - missing.length,
          totalElements: Object.keys(elements).length,
          missingElements: missing
        }
      };
      
    } catch (error) {
      return { name: testName, passed: false, error: error.message };
    }
  }
  
  testNotificationLogic() {
    const testName = 'é€šçŸ¥æ¡ä»¶ãƒ­ã‚¸ãƒƒã‚¯ã®ç¢ºèª';
    try {
      const scenarios = [
        { newCount: 5, lastSeen: 3, shouldNotify: true, expected: 2 },
        { newCount: 3, lastSeen: 3, shouldNotify: false, expected: 0 },
        { newCount: 2, lastSeen: 3, shouldNotify: false, expected: 0 },
        { newCount: 1, lastSeen: 0, shouldNotify: true, expected: 1 }
      ];
      
      const results = scenarios.map(scenario => {
        const shouldNotify = scenario.newCount > scenario.lastSeen;
        const newItems = shouldNotify ? scenario.newCount - scenario.lastSeen : 0;
        
        return {
          scenario,
          actualShouldNotify: shouldNotify,
          actualNewItems: newItems,
          correct: shouldNotify === scenario.shouldNotify && newItems === scenario.expected
        };
      });
      
      const passed = results.every(result => result.correct);
      
      return {
        name: testName,
        passed,
        details: {
          scenariosTested: scenarios.length,
          scenariosPassed: results.filter(r => r.correct).length,
          results
        }
      };
      
    } catch (error) {
      return { name: testName, passed: false, error: error.message };
    }
  }
  
  async testNotificationDebounce() {
    const testName = 'é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª';
    try {
      // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®ãŸã‚ã«çŸ­æ™‚é–“ã§è¤‡æ•°å›é€šçŸ¥ã‚’è©¦è¡Œ
      const originalLastNotificationTime = this.lastNotificationTime;
      
      let notificationCount = 0;
      const originalShowNewContentBanner = this.showNewContentBanner;
      
      this.showNewContentBanner = (newItems) => {
        notificationCount++;
        console.log('ğŸ¯ ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼šé€šçŸ¥å›æ•° =', notificationCount);
        return originalShowNewContentBanner.call(this, newItems);
      };
      
      // æœ€åˆã®é€šçŸ¥
      this.lastNotificationTime = null;
      await this.checkForNewItems(1);
      const firstNotificationCount = notificationCount;
      
      // çŸ­æ™‚é–“å†…ã§ã®2å›ç›®ã®é€šçŸ¥ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ã•ã‚Œã‚‹ã¹ãï¼‰
      this.lastNotificationTime = Date.now() - 1500; // 1.5ç§’å‰ã«è¨­å®š
      await this.checkForNewItems(2);
      const secondNotificationCount = notificationCount;
      
      // ååˆ†ãªæ™‚é–“å¾Œã®3å›ç›®ã®é€šçŸ¥ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ã•ã‚Œãªã„ã¹ãï¼‰
      this.lastNotificationTime = Date.now() - 3000; // 3ç§’å‰ã«è¨­å®š
      await this.checkForNewItems(3);
      const thirdNotificationCount = notificationCount;
      
      // å¾©å…ƒ
      this.showNewContentBanner = originalShowNewContentBanner;
      this.lastNotificationTime = originalLastNotificationTime;
      
      // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãŒæ­£ã—ãå‹•ä½œã—ã¦ã„ã‚‹å ´åˆ: 1å›ç›®ã¨3å›ç›®ã§é€šçŸ¥ã€2å›ç›®ã¯ã‚¹ã‚­ãƒƒãƒ—
      const passed = firstNotificationCount === 1 && secondNotificationCount === 1 && thirdNotificationCount === 2;
      
      return {
        name: testName,
        passed,
        details: {
          firstNotification: firstNotificationCount,
          secondNotification: secondNotificationCount,
          thirdNotification: thirdNotificationCount,
          expectedBehavior: '1â†’1â†’2 (2å›ç›®ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹)'
        }
      };
      
    } catch (error) {
      return { name: testName, passed: false, error: error.message };
    }
  }
  
  // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
  validateNotificationSystem() {
    console.log('ğŸ” é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯');
    
    const issues = [];
    
    // 1. é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª
    if (!this.elements.newContentBanner) {
      issues.push('newContentBannerè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }
    if (!this.elements.newContentText) {
      issues.push('newContentTextè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }
    if (!this.elements.refreshContentBtn) {
      issues.push('refreshContentBtnè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }
    
    // 2. åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
    if (this.initialDataLoaded === undefined) {
      issues.push('initialDataLoadedçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
    }
    if (this.hadInitialDataLoadFailure === undefined) {
      issues.push('hadInitialDataLoadFailureçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
    }
    
    // 3. é€šçŸ¥çŠ¶æ…‹ã®ç¢ºèª
    if (this.state.lastSeenCount === undefined) {
      issues.push('lastSeenCountçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
    }
    
    // 4. ãƒãƒ¼ãƒªãƒ³ã‚°çŠ¶æ…‹ã®ç¢ºèª
    if (!this.pollingSettings || this.pollingSettings.enabled === undefined) {
      issues.push('ãƒãƒ¼ãƒªãƒ³ã‚°è¨­å®šãŒä¸æ­£ã§ã™');
    }
    
    // 5. çµæœ
    if (issues.length === 0) {
      console.log('âœ… é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: æ­£å¸¸');
      return { status: 'healthy', issues: [] };
    } else {
      console.warn('âš ï¸ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: å•é¡Œæ¤œå‡º', issues);
      return { status: 'issues_detected', issues };
    }
  }
  
  async toggleAdminMode() {
    // Temporarily disable button to prevent duplicate clicks
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.disabled = true;
    }
    
    try {
      const enable = !this.state.showAdminFeatures;
      
      // ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯
      if (enable) {
        if (!this.state.isAdminUser || !window.hasAdminCapability) {
          console.warn('ç®¡ç†è€…æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
          return;
        }
        
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œæ™‚ã®ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
        const confirmed = await this.showAdminModeConfirmation();
        if (!confirmed) {
          return; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆ
        }
        
        // æœ€åˆã®ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ã¿ã‚µãƒ¼ãƒãƒ¼å´ã§å†ç¢ºèªï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if (!this.adminModeVerified) {
          try {
            const ok = await this.gas.checkAdmin();
            if (!ok) {
              console.warn('ã‚µãƒ¼ãƒãƒ¼å´ã®æ¨©é™ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
              // ãƒ­ãƒ¼ã‚«ãƒ«ã®æ¨©é™æƒ…å ±ã‚’ä¿¡é ¼ã—ã¦ç¶™ç¶š
            }
            this.adminModeVerified = true;
          } catch (e) {
            console.warn('æ¨©é™ç¢ºèªAPIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ­ãƒ¼ã‚«ãƒ«ã®æ¨©é™æƒ…å ±ã‚’ä¿¡é ¼ã—ã¦ç¶™ç¶š
          }
        }
      }
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚’æ›´æ–°
      window.showAdminFeatures = enable;
      window.showHighlightToggle = this.state.isAdminUser; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
      
      debugLog('toggleAdminModeçŠ¶æ…‹æ›´æ–°:', {
        enable,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: window.showAdminFeatures,
        showHighlightToggle: window.showHighlightToggle
      });
      if (enable) {
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¼·åˆ¶çš„ã«åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã‚’è¡¨ç¤º
        window.showCounts = true;
        window.displayMode = 'named';
        window.isStudentMode = false;
        window.showScoreSort = window.showCounts;
        debugLog('ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–: åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã‚’å¼·åˆ¶è¡¨ç¤º', {
          showCounts: window.showCounts,
          displayMode: window.displayMode
        });
      } else {
        // é–²è¦§ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ã‚µãƒ¼ãƒãƒ¼è¨­å®šã«æˆ»ã™
        window.showCounts = this.serverShowCounts;
        window.displayMode = this.serverDisplayMode;
        window.isStudentMode = true;
        window.showScoreSort = window.showCounts;
        debugLog('é–²è¦§ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–: ã‚µãƒ¼ãƒãƒ¼è¨­å®šã‚’å¾©å…ƒ', {
          showCounts: window.showCounts,
          displayMode: window.displayMode,
          serverShowCounts: this.serverShowCounts,
          serverDisplayMode: this.serverDisplayMode
        });
      }
      
      // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹æ™‚ã¯å¼·åˆ¶çš„ã«ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚æ›´æ–°
      if (enable) {
        this.state.displayMode = 'named';
        this.state.showCounts = true;
        this.state.isStudentMode = false;
      } else {
        this.state.displayMode = this.serverDisplayMode;
        this.state.showCounts = this.serverShowCounts;
        this.state.isStudentMode = true;
      }
      
      // Update local state from global variables (but preserve displayMode if in admin mode)
      this.updateConfigFromGlobals();
      
      // Re-enforce admin mode settings after updateConfigFromGlobals
      if (enable) {
        this.state.displayMode = 'named';
        this.state.showCounts = true;
      }
      
      // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã®çŠ¶æ…‹ã‚’ç¢ºèª
      debugLog('ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã®çŠ¶æ…‹ç¢ºèª:', {
        enable,
        stateDisplayMode: this.state.displayMode,
        stateShowCounts: this.state.showCounts,
        windowDisplayMode: window.displayMode,
        windowShowCounts: window.showCounts
      });
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦æ–°ã—ã„è¨­å®šã§å†æç”»
      this.cache.clear();
      
      // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¨ã¦å‰Šé™¤ã—ã¦å¼·åˆ¶å†ç”Ÿæˆ
      this.elements.answersContainer.innerHTML = '';
      
      // UIçŠ¶æ…‹ã‚’æ›´æ–°
      this.updateSortOptions();
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯è¨­å®šå¤‰æ›´ã®ãŸã‚å†æç”»ãŒå¿…è¦
      this.loadSheetData({ bypassCache: true }).then(() => {
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã«æ–°ç€ãƒã‚§ãƒƒã‚¯ã®åŸºæº–ã‚’æ›´æ–°
        this.updateLastSeenCount(this.state.currentAnswers.length);
        console.log('ğŸ”„ ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå®Œäº†ã€æ–°ç€ãƒã‚§ãƒƒã‚¯åŸºæº–æ›´æ–°:', {
          newBaselineCount: this.state.lastSeenCount,
          adminMode: this.state.showAdminFeatures
        });
      });
    } finally {
      // Re-enable button
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.disabled = false;
      }
    }
  }
  
  /**
   * ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
   */
  async showAdminModeConfirmation() {
    return new Promise((resolve) => {
      // ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ã‚’ä½œæˆ
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
          <div class="flex items-center mb-4">
            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center">
              <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
              </svg>
            </div>
            <div class="ml-4">
              <h3 class="text-lg font-medium text-gray-900">ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã‹ï¼Ÿ</h3>
            </div>
          </div>
          <div class="mb-6">
            <p class="text-sm text-gray-600">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€<strong>ç”Ÿå¾’ã®åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ãŒè¡¨ç¤º</strong>ã•ã‚Œã¾ã™ã€‚<br>
              ç”»é¢å…±æœ‰æ™‚ãªã©ã¯ååˆ†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
            </p>
          </div>
          <div class="flex justify-end space-x-3">
            <button type="button" class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
            <button type="button" class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-orange-600 border border-transparent rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
            </button>
          </div>
        </div>
      `;
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
      const cancelBtn = modal.querySelector('.cancel-btn');
      const confirmBtn = modal.querySelector('.confirm-btn');
      
      const cleanup = () => {
        document.body.removeChild(modal);
      };
      
      cancelBtn.addEventListener('click', () => {
        cleanup();
        resolve(false);
      });
      
      confirmBtn.addEventListener('click', () => {
        cleanup();
        resolve(true);
      });
      
      // Escapeã‚­ãƒ¼ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«
      const handleKeydown = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          document.removeEventListener('keydown', handleKeydown);
          resolve(false);
        }
      };
      document.addEventListener('keydown', handleKeydown);
      
      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
      document.body.appendChild(modal);
      
      // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç¢ºèªãƒœã‚¿ãƒ³ã«ç§»å‹•
      setTimeout(() => confirmBtn.focus(), 100);
    });
  }
  
  async endPublication() {
    if (!confirm('å…¬é–‹ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿç”Ÿå¾’ã¯å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã‚Šã¾ã™ã€‚')) {
      return;
    }
    
    // ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è¨­å®š
    const endPublicationBtn = this.elements.endPublicationBtn;
    let originalButtonContent = '';
    if (endPublicationBtn) {
      originalButtonContent = endPublicationBtn.innerHTML;
      endPublicationBtn.disabled = true;
      endPublicationBtn.innerHTML = `
        <svg class="w-3 h-3 animate-spin inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        å…¬é–‹çµ‚äº†ä¸­...
      `;
    }
    
    try {
      console.log('ğŸ”„ å…¬é–‹çµ‚äº†å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...');
      
      // ã‚µãƒ¼ãƒãƒ¼ã«å…¬é–‹çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
      const result = await this.runGas('clearActiveSheet');
      
      console.log('âœ… å…¬é–‹çµ‚äº†å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸ:', result);
      
      // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
      const successMessage = result.message || 'å…¬é–‹ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚éå…¬é–‹ç”»é¢ã«ç§»å‹•ã—ã¾ã™ã€‚';
      if (window.sharedModals) {
        window.sharedModals.showAlert('å…¬é–‹çµ‚äº†', successMessage, 'success');
      } else {
        alert(successMessage);
      }
      
      // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰Unpublished.htmlã«ç§»å‹•ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ï¼‰
      setTimeout(() => {
        this.redirectToUnpublishedPage();
      }, 1500);
      
    } catch (error) {
      console.error('âŒ å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
      
      // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ§‹æˆ
      let errorMsg = 'å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ';
      if (error && error.message) {
        errorMsg += ': ' + error.message;
      } else if (typeof error === 'string') {
        errorMsg += ': ' + error;
      }
      
      // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
      if (window.sharedModals) {
        window.sharedModals.showAlert('ã‚¨ãƒ©ãƒ¼', errorMsg, 'error');
      } else {
        alert(errorMsg);
      }
      
      // ãƒœã‚¿ãƒ³ã‚’å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
      if (endPublicationBtn && originalButtonContent) {
        endPublicationBtn.disabled = false;
        endPublicationBtn.innerHTML = originalButtonContent;
      }
    }
  }
  redirectToUnpublishedPage() {
    // å…¬é–‹åœæ­¢æ™‚ã¯æ¬¡å›ç®¡ç†ãƒ‘ãƒãƒ«ã‚’é–‹ã„ãŸã¨ãã«å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ã«ã™ã‚‹
    try {
      localStorage.setItem('expandAllSections', 'true');
      console.log('âœ… ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³å…¨å±•é–‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã—ãŸ');
    } catch (error) {
      console.warn('âš ï¸ localStorageè¨­å®šã«å¤±æ•—:', error);
    }
    
    // Force redirect to Unpublished.html for both admin and viewers
    google.script.run
      .withSuccessHandler(function(webAppUrl) {
        const url = new URL(webAppUrl);
        // Redirect to Unpublished.html
        url.pathname = url.pathname.replace(/\/[^\/]*$/, '/Unpublished.html');
        window.location.href = url.toString();
      })
      .withFailureHandler(function(error) {
        console.error('Failed to get web app URL:', error);
        // Fallback: try relative path
        window.location.href = './Unpublished.html';
      })
      .getWebAppUrl();
  }
  
  endAdminMode() {
    google.script.run
      .withSuccessHandler(function(adminUrl) {
        const url = new URL(adminUrl);
        url.searchParams.set('mode', 'admin');
        window.location.href = url.toString();
      })
      .getWebAppUrl();
  }
  
  /**
   * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’localStorageã«ä¿å­˜
   * @param {number} rowIndex - è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   * @param {object} reactions - ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  saveReactionState(rowIndex, reactions) {
    try {
      // æ—¢å­˜ã®ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const existingData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      
      // ç¾åœ¨ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿å­˜
      existingData[rowIndex] = {};
      Object.keys(reactions).forEach(reactionType => {
        const reaction = reactions[reactionType];
        if (reaction && reaction.reacted) {
          existingData[rowIndex][reactionType] = {
            reacted: true,
            timestamp: new Date().toISOString()
          };
        }
      });
      
      // ç©ºã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¯å‰Šé™¤
      if (Object.keys(existingData[rowIndex]).length === 0) {
        delete existingData[rowIndex];
      }
      
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(existingData));
      debugLog('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿å­˜:', { rowIndex, reactions: existingData[rowIndex] });
    } catch (error) {
      console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ä¿å­˜ã«å¤±æ•—:', error);
    }
  }
  
  /**
   * localStorageã‹ã‚‰ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿
   * @returns {object} ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹
   */
  loadReactionState() {
    try {
      const savedData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      debugLog('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿:', savedData);
      return savedData;
    } catch (error) {
      console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
      return {};
    }
  }
  
  /**
   * ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«é©ç”¨
   * @param {array} answers - å›ç­”ãƒ‡ãƒ¼ã‚¿é…åˆ—
   */
  applyReactionState(answers) {
    const savedReactions = this.loadReactionState();
    let modified = false;

    answers.forEach(answer => {
      if (!savedReactions[answer.rowIndex]) {
        savedReactions[answer.rowIndex] = {};
      }
      const savedReaction = savedReactions[answer.rowIndex];

      if (answer.reactions) {
        Object.keys(answer.reactions).forEach(reactionType => {
          const info = answer.reactions[reactionType];
          if (!info) return;

          const serverReacted = !!info.reacted;
          const localReacted = !!savedReaction[reactionType];

          info.reacted = serverReacted;

          if (serverReacted) {
            if (!localReacted) {
              if (!savedReactions[answer.rowIndex]) {
                savedReactions[answer.rowIndex] = {};
              }
              savedReactions[answer.rowIndex][reactionType] = {
                reacted: true,
                timestamp: new Date().toISOString()
              };
              modified = true;
            }
          } else if (localReacted) {
            delete savedReaction[reactionType];
            modified = true;
          }

          if (Object.keys(savedReaction).length === 0) {
            delete savedReactions[answer.rowIndex];
          }

          debugLog(`âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹åŒæœŸ [è¡Œ${answer.rowIndex}][${reactionType}]:`, {
            serverReacted,
            localReacted,
            finalReacted: info.reacted,
            timestamp: new Date().toISOString()
          });
        });
      }
    });

    if (modified) {
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(savedReactions));
    }

    debugLog('ã‚µãƒ¼ãƒãƒ¼ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹åŒæœŸå®Œäº†');
  }

  updateModalReactionButtons(item) {
    if (!this.elements.modalReactionContainer) return;
    
    this.reactionTypes.forEach(rt => {
      const info = item.reactions?.[rt.key] || { count: 0, reacted: false };
      const modalBtn = this.elements.modalReactionContainer.querySelector(`[data-reaction="${rt.key}"]`);
      
      if (modalBtn) {
        // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºæ›´æ–°
        const countEl = modalBtn.querySelector('.reaction-count');
        if (countEl && this.state.showCounts) {
          countEl.textContent = info.count;
        }
        
        // ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
        const svgEl = modalBtn.querySelector('svg');
        if (svgEl) {
          svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);
        }
        
        // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
        const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
        modalBtn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
        modalBtn.classList.add(colorClass);
        modalBtn.classList.toggle('liked', info.reacted);
        modalBtn.setAttribute('aria-pressed', info.reacted.toString());
        
        // aria-labelæ›´æ–°
        const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
        const reactionName = reactionNames[rt.key] || rt.key;
        const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count}ä»¶)` : ''}`;
        modalBtn.setAttribute('aria-label', ariaLabel);
      }
    });
  }
  applyUpdates(items) {
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: å¤‰æ›´ãŒå¿…è¦ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿å‡¦ç†
    const itemsToUpdate = items.filter(item => {
      const updateKey = `apply_update_${item.rowIndex}`;
      const currentHash = this.calculateStateHash(item);
      const lastHash = this.lastApplyStates?.get(updateKey);
      
      if (lastHash === currentHash) {
        return false; // å¤‰æ›´ãªã— - ã‚¹ã‚­ãƒƒãƒ—
      }
      
      // çŠ¶æ…‹ã‚’è¨˜éŒ²
      if (!this.lastApplyStates) this.lastApplyStates = new Map();
      this.lastApplyStates.set(updateKey, currentHash);
      return true; // å¤‰æ›´ã‚ã‚Š - æ›´æ–°å¯¾è±¡
    });
    
    if (itemsToUpdate.length === 0) {
      console.log('âš¡ applyUpdates: å…¨ã‚¢ã‚¤ãƒ†ãƒ ã‚¹ã‚­ãƒƒãƒ— (å¤‰æ›´ãªã—)');
      return;
    }
    
    console.log(`âš¡ applyUpdates: ${itemsToUpdate.length}/${items.length}ä»¶ã‚’æ›´æ–°`);

    // ãƒãƒƒãƒå‡¦ç†ç”¨ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©
    const reactionUpdates = [];
    
    itemsToUpdate.forEach(item => {
      this.reactionTypes.forEach(rt => {
        if (item.reactions && item.reactions[rt.key]) {
          reactionUpdates.push({
            rowIndex: item.rowIndex,
            reaction: rt.key,
            count: item.reactions[rt.key].count,
            reacted: item.reactions[rt.key].reacted,
            shouldDisplay: item.reactions[rt.key].count > 0
          });
        }
      });
      const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
      if (card) {
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('liked', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          const label = item.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
          highlightBtn.setAttribute('aria-label', label);
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
          }
        }
        let badge = card.querySelector('.highlight-badge');
        if (item.highlight && !badge) {
          badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } else if (!item.highlight && badge) {
          badge.remove();
        }
      }
    });

    // ãƒãƒƒãƒå‡¦ç†ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ã‚’å®Ÿè¡Œ
    if (reactionUpdates.length > 0) {
      this.batchUpdateReactionButtons(reactionUpdates);
    }
  }
  showAnswerModal(rowIndex) {
    if (DEBUG_MODE) console.log('ğŸ“± [MODAL DEBUG] showAnswerModal called:', {
        rowIndex: rowIndex,
        rowIndexType: typeof rowIndex,
        timestamp: new Date().toISOString()
    });

    // Show answer modal called

    // Data search context
    
    // æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆfilteredDataã¨currentAnswersã®ä¸¡æ–¹ã‹ã‚‰ï¼‰
    let data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
    // Data search in currentAnswers
    
    if (!data && this.state.filteredData) {
      data = this.state.filteredData.find(r => r.rowIndex == rowIndex);
      debugLog('Data search in filteredData:', {
        found: !!data,
        searchRowIndex: rowIndex,
        availableRowIndexes: this.state.filteredData?.map(r => r.rowIndex) || []
      });
    }
    
    if (!data) {
      debugLog('ERROR: No data found for rowIndex:', {
        rowIndex: rowIndex,
        currentAnswers: this.state.currentAnswers,
        filteredData: this.state.filteredData
      });
      return;
    }
    
    debugLog('Data found for modal:', {
      rowIndex: rowIndex,
      data: data,
      opinion: data.opinion?.substring(0, 50) + '...',
      reason: data.reason?.substring(0, 50) + '...'
    });
    this.state.lastFocusedElement = document.activeElement;
    this.elements.modalAnswer.innerHTML = '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + this.escapeHtml(data.opinion || '') + '</p>' + '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + this.escapeHtml(data.reason || '') + '</p>';
    const showName = this.state.displayMode === 'named';
    let modalDisplayName = '';
    
    // Debug: Log modal display mode state
    debugLog('Modal display state:', {
      displayMode: this.state.displayMode,
      showName,
      showAdminFeatures: this.state.showAdminFeatures,
      isAdminUser: this.state.isAdminUser,
      dataName: data.name,
      dataEmail: data.email
    });
    
    if (showName) {
      // åå‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°emailã‹ã‚‰ç”Ÿæˆ
      if (data.name) {
        modalDisplayName = data.name;
      } else if (data.email) {
        modalDisplayName = data.email.split('@')[0];
      }
    }
    
    this.elements.modalStudentName.textContent = modalDisplayName;
    const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
    this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ãã‚«ãƒ¼ãƒ‰è‰²ã®é©ç”¨
    debugLog('ãƒ¢ãƒ¼ãƒ€ãƒ«ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾é©ç”¨:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions,
      element: this.elements.answerModalCard.className
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
    debugLog('ãƒ¢ãƒ¼ãƒ€ãƒ«è£…é£¾é©ç”¨å¾Œ:', {
      className: this.elements.answerModalCard.className
    });
    
    this.elements.answerModalContainer.classList.remove('hidden');
    this.elements.answerModalContainer.classList.add('modal-fade');
    this.elements.answerModalCard.classList.add('modal-scale');
    
    this.elements.answerModalCloseBtn.focus();
  }
  updateModalContent(data) {
    if (!data) return;
    
    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã‚’æ›´æ–°
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
    debugLog('updateModalContentè£…é£¾é©ç”¨:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
  }
  hideAnswerModal() {
    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalContainer.classList.remove('modal-fade');
    this.elements.answerModalCard.classList.remove('modal-scale');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  showInfoModal() {
    this.state.lastFocusedElement = document.activeElement;
    this.elements.infoModalContainer.classList.remove('hidden');
    this.elements.infoModalContainer.classList.add('modal-fade');
    this.elements.infoModalCard.classList.add('modal-scale');
    
    // Ensure modal starts from the top
    this.elements.infoModalCard.scrollTop = 0;
    
    // Focus on the modal container first, then the button
    setTimeout(() => {
      this.elements.infoModalConfirmBtn.focus();
    }, 100);
  }
  hideInfoModal() {
    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalContainer.classList.remove('modal-fade');
    this.elements.infoModalCard.classList.remove('modal-scale');
    
    // Note: localStorage 'introSeen' flag removed to allow modal to show on every board update
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  getIcon(name, classes = '', solid = false) {
    // Cache icons to avoid repeated string concatenation
    const cacheKey = `icon-${name}-${classes}-${solid}`;
    const cachedIcon = this.cache.get(cacheKey);
    if (cachedIcon) {
      return cachedIcon;
    }
    
    let key = name;
    if (ICONS[name + '-outline'] || ICONS[name + '-solid']) {
      key = solid ? name + '-solid' : name + '-outline';
    }
    const icon = ICONS[key];
    if (!icon) {
      console.warn('Icon not found:', key);
      const fallback = '<span aria-hidden="true" class="' + classes + '">â­</span>';
      this.cache.set(cacheKey, fallback);
      return fallback;
    }
    const result = '<span aria-hidden="true" class="' + classes + '">' + icon + '</span>';
    this.cache.set(cacheKey, result);
    return result;
  }
  renderIcons() {
    if (this.elements.infoIconLike) {
      this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
    }
    if (this.elements.infoIconUnderstand) {
      this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
    }
    if (this.elements.infoIconCurious) {
      this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
    }
    if (this.elements.infoIconHighlight) {
      this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
    }
    if (this.elements.iconClose) {
      this.elements.iconClose.innerHTML = this.getIcon('x');
    }
    if (this.elements.iconGrid) {
      this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
    }
  }
  debounce(func, delay) {
    // Use SharedUtilities with instance-specific keys
    const key = `studyquest-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.debounce.debounce(() => func.apply(this, args), key, delay);
    };
  }
  
  throttle(func, delay) {
    // Use SharedUtilities with instance-specific keys
    const key = `studyquest-throttle-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.throttle.throttle(() => func.apply(this, args), key, delay);
    };
  }
  updateSortOptions() {
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.style.display = 'block';
      } else {
        this.elements.scoreOption.style.display = 'none';
        if (this.elements.sortOrder.value === 'score') {
          this.elements.sortOrder.value = 'newest';
        }
      }
    }
  }
  updateConfigFromGlobals() {
    debugLog('updateConfigFromGlobalså‰ã®çŠ¶æ…‹:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      currentDisplayMode: this.state.displayMode
    });
    
    this.state.isStudentMode = window.isStudentMode;
    this.state.showCounts = window.showCounts;
    window.showScoreSort = window.showCounts;
    this.state.showAdminFeatures = window.showAdminFeatures;
    this.state.showHighlightToggle = this.state.isAdminUser; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
    this.state.showScoreSort = window.showScoreSort;
    this.state.showPublishControls = window.showPublishControls;
    
    // Only update displayMode if not in admin mode
    if (!this.state.showAdminFeatures) {
      this.state.displayMode = window.displayMode;
    }
    
    debugLog('updateConfigFromGlobalså¾Œã®çŠ¶æ…‹:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      finalDisplayMode: this.state.displayMode,
      windowDisplayMode: window.displayMode
    });
  }
  escapeHtml(str) {
    if (!str) return '';
    return str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }

  // Performance optimization methods
  detectLowPerformanceDevice() {
    const userAgent = navigator.userAgent;
    const platform = navigator.platform;
    const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
    const cores = navigator.hardwareConcurrency || 4;
    
    // Detect low-end devices
    if (memory <= 2 || cores <= 2) return true;
    if (userAgent.includes('Mobile') && !userAgent.includes('iPad')) return true;
    if (platform.includes('Win32') && cores <= 4) return true;
    
    return false;
  }

  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measurePerformance = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      if (frameCount > 0) {
        this.performanceMetrics.frameTime = delta;
        
        // If frame time is consistently over 16ms, enable low performance mode
        if (delta > PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
          console.warn('Low performance detected, enabling optimizations');
          this.isLowPerformanceMode = true;
          this.optimizeForLowPerformance();
        }
      }
      
      lastTime = now;
      frameCount++;
      
      if (frameCount < 60) { // Monitor first 60 frames
        requestAnimationFrame(measurePerformance);
      }
    };
    
    requestAnimationFrame(measurePerformance);
  }

  optimizeForLowPerformance() {
    debugLog('Enabling low performance optimizations');
    
    // Reduce animation and transition durations
    document.documentElement.style.setProperty('--transition-duration', '0.1s');
    document.documentElement.style.setProperty('--animation-duration', '0.1s');
    document.documentElement.style.setProperty('--backdrop-blur', '4px');
    
    // Create comprehensive low-performance stylesheet
    const style = document.createElement('style');
    style.id = 'low-performance-optimizations';
    style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        -webkit-backdrop-filter: blur(4px) !important;
        backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover {
        transform: scale(1.02) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        border: 3px solid #9333ea !important;
        border-image: none !important;
        box-shadow: 0 0 12px rgba(147, 51, 234, 0.5) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
    document.head.appendChild(style);
    
    // Add low-performance class to body for CSS targeting
    document.body.classList.add('low-performance');
    
    // Reduce polling frequency
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = setInterval(() => this.loadSheetData({ showLoading: false }), 30000); // 30s instead of 15s
    }
  }

  setupObservers() {
    // Intersection Observer for virtual scrolling - optimized for performance
    if ('IntersectionObserver' in window) {
      // Enhanced debounce visibility changes with batching to reduce excessive firing
      const debouncedVisibilityHandler = this.debounce((entries) => {
        // Batch entries by card to prevent rapid state changes on the same element
        const cardChanges = new Map();
        
        entries.forEach(entry => {
          const card = entry.target;
          const rowIndex = card.dataset.rowIndex;
          
          // Keep only the latest change for each card
          cardChanges.set(rowIndex, { card, entry });
        });
        
        // Process batched changes
        cardChanges.forEach(({ card, entry }) => {
          // Only log significant visibility changes for debugging
          if (DEBUG_MODE && (entry.intersectionRatio === 0 || entry.intersectionRatio === 1)) {
            debugLog('IntersectionObserver visibility change:', {
              rowIndex: card.dataset.rowIndex,
              isIntersecting: entry.isIntersecting,
              intersectionRatio: entry.intersectionRatio
            });
          }

          if (entry.isIntersecting) {
            // Card is becoming visible
            if (!card.classList.contains('visible')) {
              card.classList.add('visible');
              card.classList.remove('hidden-card');
              // Restore visibility and display if it was hidden
              if (card.style.visibility === 'hidden') {
                card.style.visibility = 'visible';
              }
              if (card.style.display === 'none') {
                card.style.display = '';
              }
            }
          } else {
            // MODIFIED: Do not hide cards for virtual scrolling - keep them in DOM
            // This prevents cards from disappearing when scrolling back up
            // Only mark as not visible for optimization purposes
            if (entry.intersectionRatio === 0 && card.classList.contains('visible')) {
              card.classList.remove('visible');
              card.classList.add('hidden-card');
              // Do NOT hide or remove from DOM - just mark as not visible
            }
          }
        });
      }, 50); // Increased debounce to 50ms for better stability
      
      this.visibilityObserver = new IntersectionObserver(debouncedVisibilityHandler, {
        rootMargin: `${VIEWPORT_BUFFER}px`,
        threshold: [0, 1.0] // Simplified thresholds: fully out vs fully in
      });
    }

    // ResizeObserver for responsive adjustments
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(this.debounce(() => {
        this.adjustLayout();
      }, 100));
      this.resizeObserver.observe(this.elements.answersContainer);
    }
  }

  deferredRender(callback, priority = 'normal') {
    if (this.isLowPerformanceMode) {
      // Use requestIdleCallback for low priority updates
      this.idleCallbackId = requestIdleCallback(callback, { timeout: IDLE_TIMEOUT });
    } else {
      // Use requestAnimationFrame for normal updates
      this.animationFrameId = requestAnimationFrame(callback);
    }
  }

  batchDOMUpdates(updates) {
    const startTime = performance.now();
    let processedCount = 0;
    
    const processBatch = () => {
      while (processedCount < updates.length && (performance.now() - startTime) < PERFORMANCE_BUDGET) {
        updates[processedCount]();
        processedCount++;
      }
      
      if (processedCount < updates.length) {
        // Continue in next frame
        requestAnimationFrame(processBatch);
      }
    };
    
    processBatch();
  }

  getReusableFragment() {
    if (this.domFragmentPool.length > 0) {
      return this.domFragmentPool.pop();
    }
    return document.createDocumentFragment();
  }

  recycleFragment(fragment) {
    // Clear fragment content and reuse
    while (fragment.firstChild) {
      fragment.removeChild(fragment.firstChild);
    }
    if (this.domFragmentPool.length < 10) { // Limit pool size
      this.domFragmentPool.push(fragment);
    }
  }

  throttledUpdate(key, callback, delay = 100) {
    if (this.deferredUpdates.has(key)) {
      return;
    }
    
    this.deferredUpdates.add(key);
    setTimeout(() => {
      callback();
      this.deferredUpdates.delete(key);
    }, delay);
  }

  cleanup() {
    // Consolidated cache cleanup
    this.cache.cleanup();

    // Clear DOM fragment pool
    this.domFragmentPool.length = 0;

    debugLog('Cache cleanup completed', {
      cacheSize: this.cache.size
    });
  }
  
  // Enhanced cache methods with timestamp tracking

  // ===== Virtual Scrolling Methods =====
  
  setupScrollObserver() {
    if (!this.elements.answersContainer) {
      console.warn('setupScrollObserver: answersContainer not found');
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    if (cards.length === 0) {
      debugLog('setupScrollObserver: No cards found, skipping setup');
      return;
    }
    
    // Clear existing scroll observer if it exists
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
    }
    
    // Create scroll observer for dynamic loading with debouncing
    const debouncedScrollHandler = this.debounce((entries) => {
      // Only process the first intersecting entry to prevent multiple simultaneous loads
      const intersectingEntry = entries.find(entry => entry.isIntersecting);
      if (intersectingEntry) {
        debugLog('setupScrollObserver: Trigger card intersecting:', intersectingEntry.target.dataset.rowIndex);
        this.handleVirtualScroll(intersectingEntry.target);
      }
    }, 150); // 150ms debounce for scroll triggers to prevent rapid firing
    
    this.scrollObserver = new IntersectionObserver(debouncedScrollHandler, {
      root: null,
      rootMargin: '300px', // Increased buffer for even smoother loading
      threshold: 0.1
    });
    
    // Observe the last few elements for dynamic loading trigger
    const observeCount = Math.min(3, cards.length); // Reduced to last 3 cards for better performance
    const observedCards = [];
    
    for (let i = cards.length - observeCount; i < cards.length; i++) {
      if (cards[i] && cards[i].dataset.rowIndex) {
        this.scrollObserver.observe(cards[i]);
        observedCards.push(cards[i].dataset.rowIndex);
      }
    }
    
    debugLog('setupScrollObserver: Observing cards for dynamic loading:', {
      totalCards: cards.length,
      observedCount: observedCards.length,
      observedRowIndexes: observedCards,
      totalItems: this.virtualScrollState?.totalItems || 0,
      renderedItems: this.virtualScrollState?.renderedItems || 0
    });
  }
  
  handleVirtualScroll(triggerElement) {
    if (!triggerElement || !this.virtualScrollState) {
      return;
    }
    
    if (this.virtualScrollState.isLoading) {
      debugLog('handleVirtualScroll: Already loading, skipping');
      return;
    }
    
    const currentCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const totalAvailable = this.state.currentAnswers.length;
    const currentRendered = currentCards.length;
    
    debugLog('handleVirtualScroll triggered:', {
      currentRendered,
      totalAvailable,
      triggerRowIndex: triggerElement.dataset.rowIndex
    });
    
    // Check if we need to load more items
    if (currentRendered < totalAvailable) {
      this.loadMoreItems();
    } else {
      // Optimize visible elements when we've rendered everything
      this.optimizeVisibleElements();
    }
  }
  
  loadMoreItems() {
    if (this.virtualScrollState.isLoading) {
      return;
    }
    
    this.virtualScrollState.isLoading = true;
    
    // Enhanced item tracking - use Set instead of relying on DOM count
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
      // Initialize with existing cards in DOM
      const existingCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      existingCards.forEach(card => {
        if (card.dataset.rowIndex) {
          this.virtualScrollState.renderedRowIndexes.add(card.dataset.rowIndex);
        }
      });
    }
    
    // Use dynamic batch sizing for better performance adaptation
    const dynamicBatchSize = getDynamicBatchSize(this.performanceMetrics);
    const batchSize = this.isLowPerformanceMode ? Math.min(CHUNK_SIZE, dynamicBatchSize) : dynamicBatchSize;
    
    // Find items that haven't been rendered yet
    const unrenderedItems = this.state.currentAnswers.filter(item => 
      !this.virtualScrollState.renderedRowIndexes.has(String(item.rowIndex))
    );
    
    // Take next batch of unrendered items
    const remainingItems = unrenderedItems.slice(0, batchSize);
    
    if (remainingItems.length === 0) {
      this.virtualScrollState.isLoading = false;
      debugLog('loadMoreItems: No more items to load - all items rendered');
      return;
    }
    
    debugLog('loadMoreItems: Loading', remainingItems.length, 'additional items with batch size', batchSize, 
      'Total rendered:', this.virtualScrollState.renderedRowIndexes.size, 'Total available:', this.state.currentAnswers.length);
    
    // Use deferred rendering for performance
    this.deferredRender(() => {
      this.renderAdditionalItems(remainingItems);
    });
  }
  
  renderAdditionalItems(items) {
    if (!items || items.length === 0) {
      this.virtualScrollState.isLoading = false;
      debugLog('renderAdditionalItems: No items to render');
      return;
    }
    
    const fragment = this.getReusableFragment();
    const changedItems = [];
    let successfullyCreated = 0;
    
    // Ensure renderedRowIndexes exists
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
    }
    
    items.forEach((item) => {
      const rowIndexStr = String(item.rowIndex);
      
      // Skip if already rendered (defensive check)
      if (this.virtualScrollState.renderedRowIndexes.has(rowIndexStr)) {
        debugLog('renderAdditionalItems: Item', rowIndexStr, 'already rendered, skipping');
        return;
      }
      
      const card = this.createAnswerCard(item);
      if (card) {
        card.classList.add('new-card');
        
        // Track this item as rendered
        this.virtualScrollState.renderedRowIndexes.add(rowIndexStr);
        
        // Add to visibility observer
        if (this.visibilityObserver) {
          this.visibilityObserver.observe(card);
        }
        
        // Add to scroll observer for the last few items
        const isLastFew = items.indexOf(item) >= items.length - 3;
        if (isLastFew && this.scrollObserver) {
          this.scrollObserver.observe(card);
        }
        
        fragment.appendChild(card);
        changedItems.push(item);
        successfullyCreated++;
      } else {
        console.warn('renderAdditionalItems: Failed to create card for item:', item.rowIndex);
      }
    });
    
    // Append new items to container
    if (fragment.children.length > 0) {
      this.elements.answersContainer.appendChild(fragment);
      
      // Update virtual scroll state with actual counts
      this.virtualScrollState.renderedItems = this.elements.answersContainer.children.length;
      
      debugLog('renderAdditionalItems: Added', fragment.children.length, 'new cards. Total rendered:', 
        this.virtualScrollState.renderedRowIndexes.size, 'DOM children:', this.virtualScrollState.renderedItems);
    } else {
      debugLog('renderAdditionalItems: No cards were successfully created from', items.length, 'items');
    }
    
    // Apply updates if needed
    if (changedItems.length > 0) {
      this.deferredRender(() => this.applyUpdates(changedItems));
    }
    
    // Recycle fragment
    this.recycleFragment(fragment);
    
    // Reset loading state
    this.virtualScrollState.isLoading = false;
    
    // Validate state consistency
    this.validateVirtualScrollState();
  }
  
  validateVirtualScrollState() {
    if (!this.virtualScrollState || !this.virtualScrollState.renderedRowIndexes) {
      return;
    }
    
    const domCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const domRowIndexes = new Set();
    
    domCards.forEach(card => {
      if (card.dataset.rowIndex) {
        domRowIndexes.add(card.dataset.rowIndex);
      }
    });
    
    const trackedCount = this.virtualScrollState.renderedRowIndexes.size;
    const domCount = domRowIndexes.size;
    const totalAvailable = this.state.currentAnswers.length;
    
    // Check for inconsistencies
    const missingInDOM = [...this.virtualScrollState.renderedRowIndexes].filter(x => !domRowIndexes.has(x));
    const extraInDOM = [...domRowIndexes].filter(x => !this.virtualScrollState.renderedRowIndexes.has(x));
    
    if (missingInDOM.length > 0 || extraInDOM.length > 0 || trackedCount !== domCount) {
      console.warn('Virtual scroll state inconsistency detected:', {
        trackedCount,
        domCount,
        totalAvailable,
        missingInDOM: missingInDOM.slice(0, 5),
        extraInDOM: extraInDOM.slice(0, 5)
      });
      
      // Auto-repair: sync tracked state with DOM reality
      this.virtualScrollState.renderedRowIndexes = domRowIndexes;
      this.virtualScrollState.renderedItems = domCount;
      
      debugLog('validateVirtualScrollState: Auto-repaired state. New tracked count:', domCount);
    }
  }
  
  optimizeVisibleElements() {
    if (!this.elements.answersContainer || this.virtualScrollState.isLoading) {
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    let hiddenCount = 0;
    let restoredCount = 0;
    const viewportHeight = window.innerHeight;
    const hideThreshold = viewportHeight * 3; // Increased threshold for better UX
    
    // Track hidden cards for better restoration
    if (!this.virtualScrollState.hiddenCards) {
      this.virtualScrollState.hiddenCards = new Set();
    }
    
    cards.forEach((card) => {
      const rect = card.getBoundingClientRect();
      const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
      const rowIndex = card.dataset.rowIndex;
      const isCurrentlyHidden = this.virtualScrollState.hiddenCards.has(rowIndex);
      
      if (!isInViewport && !isCurrentlyHidden) {
        // Calculate distance from viewport
        const distanceFromViewport = rect.top > viewportHeight 
          ? rect.top - viewportHeight  // Below viewport
          : -rect.bottom;             // Above viewport
        
        // Only hide cards that are really far away
        if (distanceFromViewport > hideThreshold) {
          this.hideCard(card, rowIndex);
          hiddenCount++;
        }
      } else if (isInViewport && isCurrentlyHidden) {
        // Restore cards that are back in viewport
        this.restoreCard(card, rowIndex);
        restoredCount++;
      }
    });
    
    if (hiddenCount > 0 || restoredCount > 0) {
      debugLog('optimizeVisibleElements: Hidden', hiddenCount, 'cards, restored', restoredCount, 'cards');
    }
  }
  
  hideCard(card, rowIndex) {
    // Use CSS transform instead of visibility for better performance
    card.style.transform = 'translateZ(0) scale(0.01)';
    card.style.opacity = '0';
    card.style.pointerEvents = 'none';
    card.classList.add('hidden-card');
    this.virtualScrollState.hiddenCards.add(rowIndex);
    
    // Temporarily unobserve from intersection observers to prevent state confusion
    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(card);
    }
    if (this.scrollObserver) {
      this.scrollObserver.unobserve(card);
    }
  }
  
  restoreCard(card, rowIndex) {
    // Restore card to full visibility
    card.style.transform = '';
    card.style.opacity = '';
    card.style.pointerEvents = '';
    card.classList.remove('hidden-card');
    card.classList.add('visible');
    this.virtualScrollState.hiddenCards.delete(rowIndex);
    
    // Re-add to intersection observers
    if (this.visibilityObserver) {
      this.visibilityObserver.observe(card);
    }
    
    // Only re-add to scroll observer if it's one of the last few cards
    const allCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const cardIndex = Array.from(allCards).indexOf(card);
    const isLastFew = cardIndex >= allCards.length - 3;
    
    if (isLastFew && this.scrollObserver) {
      this.scrollObserver.observe(card);
    }
  }
  
  // Reset virtual scrolling state for debugging and recovery
  resetVirtualScrollState() {
    debugLog('resetVirtualScrollState: Resetting virtual scroll state');
    
    // Clear state
    this.virtualScrollState = {
      renderedItems: 0,
      totalItems: this.state.currentAnswers.length,
      isLoading: false,
      renderedRowIndexes: new Set(),
      hiddenCards: new Set()
    };
    
    // Clear all observers
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
      this.scrollObserver = null;
    }
    
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
      this.visibilityObserver = null;
    }
    
    // Restore all cards to visible state
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    cards.forEach(card => {
      card.style.transform = '';
      card.style.opacity = '';
      card.style.pointerEvents = '';
      card.style.visibility = '';
      card.classList.remove('hidden-card');
      card.classList.add('visible');
    });
    
    // Re-setup observers
    this.setupObservers();
    
    debugLog('resetVirtualScrollState: Virtual scroll state reset complete');
  }
}
// ===== å…±é€šãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±å‡¦ç†é–¢æ•° =====
// AdminPanel.html ã¨ Login.html ã§å…±é€šä½¿ç”¨

/**
 * ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
 * @param {Function} onSuccess - æˆåŠŸæ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
 * @param {Function} onError - ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
 */
function loadDomainInfo(onSuccess, onError) {
  google.script.run
    .withSuccessHandler(info => {
      displayDomainInfo(info);
      if (onSuccess) onSuccess(info);
    })
    .withFailureHandler(error => {
      console.error('ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
      displayDomainInfo({ error: error.message || error });
      if (onError) onError(error);
    })
    .getDeployUserDomainInfo();
}

/**
 * ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
 * @param {Object} info - ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function displayDomainInfo(info) {
  const headerDomainMatch = document.getElementById('header-domain-match');
  const headerDomainMismatch = document.getElementById('header-domain-mismatch');
  const headerDomainInitial = document.getElementById('header-domain-initial');
  const headerDomainMatchText = document.getElementById('header-domain-match-text');
  const headerDomainMismatchText = document.getElementById('header-domain-mismatch-text');

  // å…¨ã¦ã®è¡¨ç¤ºã‚’ä¸€æ—¦éè¡¨ç¤ºã«ã™ã‚‹
  if (headerDomainMatch) headerDomainMatch.classList.add('hidden');
  if (headerDomainMismatch) headerDomainMismatch.classList.add('hidden');
  if (headerDomainInitial) headerDomainInitial.classList.add('hidden');
  
  if (!info || info.error) {
    console.warn('ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚¨ãƒ©ãƒ¼:', info?.error);
    if (headerDomainInitial) headerDomainInitial.classList.remove('hidden');
    return;
  }

  if (info.isDomainMatch) {
    // ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒä¸€è‡´ã—ã¦ã„ã‚‹å ´åˆ
    if (headerDomainMatch && headerDomainMatchText) {
      headerDomainMatch.classList.remove('hidden');
      if (info.deployDomain) {
        headerDomainMatchText.textContent = `${info.deployDomain} ãƒ‰ãƒ¡ã‚¤ãƒ³`;
      } else {
        headerDomainMatchText.textContent = 'ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹';
      }
    }
  } else {
    // ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸ä¸€è‡´ã®å ´åˆ
    if (headerDomainMismatch && headerDomainMismatchText) {
      headerDomainMismatch.classList.remove('hidden');
      headerDomainMismatchText.textContent = info.currentDomain;
    }
  }
}

/**
 * ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
 */
function loadFormLink() {
  google.script.run
    .withSuccessHandler(formInfo => {
      if (formInfo && formInfo.formUrl) {
        const formLinkBtn = document.getElementById('form-link-btn');
        if (formLinkBtn) {
          formLinkBtn.href = formInfo.formUrl;
          formLinkBtn.classList.remove('hidden');
        }
      }
    })
    .withFailureHandler(error => {
      console.warn('ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    })
    .getActiveFormInfo(USER_ID);
}

try {
  if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
    window.studyQuestApp.destroy();
  }
  // ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼è¡¨ç¤º
  showSystemFlow();
  
  document.addEventListener('DOMContentLoaded', () => {
  const app = new StudyQuestApp();
});
  
  // Expose debug functions globally for console access
  window.debugAnswerCards = () => {
    if (window.studyQuestApp && window.studyQuestApp.debugAnswerCards) {
      window.studyQuestApp.debugAnswerCards();
    } else {
      console.log('StudyQuestApp not available or debug function not found');
    }
  };
  
  // Enhanced global debug function with additional utility methods
  window.debugClickAnswerCard = (cardIndex = 0, options = {}) => {
    if (window.studyQuestApp && window.studyQuestApp.debugClickAnswerCard) {
      return window.studyQuestApp.debugClickAnswerCard(cardIndex, options);
    } else {
      console.log('StudyQuestApp not available or debug function not found');
      return { success: false, error: 'StudyQuestApp not available' };
    }
  };

  // ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
  window.showSystemFlow = showSystemFlow;
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒ‡ãƒ¼ã‚¿æ§‹é€ ç¢ºèªæ©Ÿèƒ½
  window.debugCurrentData = () => {
    if (window.studyQuestApp && window.studyQuestApp.state) {
      console.log('ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ :', {
        currentAnswers: window.studyQuestApp.state.currentAnswers,
        currentAnswersLength: window.studyQuestApp.state.currentAnswers?.length,
        firstItem: window.studyQuestApp.state.currentAnswers?.[0],
        header: window.studyQuestApp.elements?.headingLabel?.textContent
      });
    } else {
      console.log('StudyQuestApp not available');
    }
  };

  // Additional global debug utilities
  window.debugClickAllAnswerCards = async (options = {}) => {
    if (!window.studyQuestApp) {
      console.log('StudyQuestApp not available');
      return { success: false, error: 'StudyQuestApp not available' };
    }
    
    const container = window.studyQuestApp.elements?.answersContainer;
    if (!container) {
      console.log('No answers container found');
      return { success: false, error: 'No answers container found' };
    }
    
    const answerCards = container.querySelectorAll('.answer-card');
    const results = [];
    
    console.log(`Found ${answerCards.length} answer cards, clicking all...`);
    
    for (let i = 0; i < answerCards.length; i++) {
      try {
        const result = await window.studyQuestApp.debugClickAnswerCard(i, { 
          ...options, 
          logDetails: false // Reduce noise when clicking all cards
        });
        results.push(result);
        
        if (options.delay && i < answerCards.length - 1) {
          // Add proper delay between clicks if specified
          await new Promise(resolve => setTimeout(resolve, options.delay));
        }
      } catch (error) {
        console.error(`Error clicking card ${i}:`, error);
        results.push({ success: false, error: error.message, cardIndex: i });
      }
    }
    
    return {
      success: true,
      totalCards: answerCards.length,
      results
    };
  };

  // ãƒãƒƒãƒå‡¦ç†åˆ¶å¾¡é–¢æ•°ï¼ˆãƒ‡ãƒãƒƒã‚°/é‹ç”¨åˆ¶å¾¡ç”¨ï¼‰
  window.toggleBatchProcessing = (enable = null) => {
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return;
    }
    
    if (enable === null) {
      // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒˆã‚°ãƒ«
      app.enableBatchProcessing = !app.enableBatchProcessing;
    } else {
      app.enableBatchProcessing = Boolean(enable);
    }
    
    console.log('ğŸ”§ ãƒãƒƒãƒå‡¦ç†:', app.enableBatchProcessing ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹');
    console.log('ğŸ’¡ å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã¯å¸¸ã«å‹•ä½œã—ã¾ã™ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¿è¨¼ï¼‰');
    return app.enableBatchProcessing;
  };

  window.getBatchProcessingStatus = () => {
    const app = window.studyQuestApp;
    if (!app) return null;
    
    return {
      enabled: app.enableBatchProcessing,
      active: app.batchProcessingActive,
      queueSize: app.reactionQueue.size,
      batchQueueSize: app.reactionBatchQueue.size,
      settings: {
        timeout: app.BATCH_TIMEOUT,
        sizeLimit: app.BATCH_SIZE_LIMIT
      }
    };
  };

  window.debugGetAnswerCardInfo = (cardIndex = 0) => {
    if (!window.studyQuestApp) {
      console.log('StudyQuestApp not available');
      return { success: false, error: 'StudyQuestApp not available' };
    }
    
    // Validate cardIndex
    if (typeof cardIndex !== 'number' || cardIndex < 0 || !Number.isInteger(cardIndex)) {
      console.log('Invalid card index:', cardIndex);
      return { success: false, error: 'Invalid card index. Must be a non-negative integer.' };
    }
    
    const container = window.studyQuestApp.elements?.answersContainer;
    if (!container) {
      console.log('No answers container found');
      return { success: false, error: 'No answers container found' };
    }
    
    const answerCards = container.querySelectorAll('.answer-card');
    if (answerCards.length === 0) {
      console.log('No answer cards found');
      return { success: false, error: 'No answer cards found' };
    }
    
    if (cardIndex >= answerCards.length) {
      console.log('Card index out of bounds');
      return { success: false, error: 'Card index out of bounds', totalCards: answerCards.length };
    }
    
    const card = answerCards[cardIndex];
    
    try {
      const cardInfo = {
        index: cardIndex,
        className: card.className,
        dataset: { ...card.dataset },
        rowIndex: card.dataset.rowIndex,
        boundingRect: card.getBoundingClientRect(),
        computedStyle: {
          display: getComputedStyle(card).display,
          visibility: getComputedStyle(card).visibility,
          opacity: getComputedStyle(card).opacity
        },
        textContent: card.textContent?.trim() || '',
        innerHTML: card.innerHTML
      };
      
      console.log('Answer card info:', cardInfo);
      return { success: true, cardInfo };
    } catch (error) {
      console.error('Error getting card info:', error);
      return { success: false, error: `Error getting card info: ${error.message}` };
    }
  };

  // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®å°‚ç”¨ãƒ†ã‚¹ãƒˆé–¢æ•°
  window.testReactionSystem = async (options = {}) => {
    console.log('ğŸ§ª ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    if (!window.studyQuestApp) {
      console.error('âŒ StudyQuestApp not available');
      return { success: false, error: 'StudyQuestApp not available' };
    }

    const {
      cardIndex = 0,
      reaction = 'LIKE',
      verbose = true
    } = options;

    const testResults = {
      success: false,
      tests: [],
      errors: []
    };

    try {
      // Test 1: ã‚«ãƒ¼ãƒ‰å­˜åœ¨ç¢ºèª
      const cardInfo = window.debugGetAnswerCardInfo(cardIndex);
      if (!cardInfo.success) {
        testResults.errors.push('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + cardInfo.error);
        return testResults;
      }
      
      const rowIndex = cardInfo.cardInfo.rowIndex;
      testResults.tests.push({
        name: 'ã‚«ãƒ¼ãƒ‰å­˜åœ¨ç¢ºèª',
        status: 'passed',
        data: { cardIndex, rowIndex }
      });

      // Test 2: ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³å­˜åœ¨ç¢ºèª
      const container = window.studyQuestApp.elements.answersContainer;
      const card = container.querySelectorAll('.answer-card')[cardIndex];
      const reactionBtn = card.querySelector(`[data-reaction="${reaction}"]`);
      
      if (!reactionBtn) {
        testResults.errors.push(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${reaction}`);
        return testResults;
      }
      
      testResults.tests.push({
        name: 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³å­˜åœ¨ç¢ºèª',
        status: 'passed',
        data: { reaction, button: reactionBtn.outerHTML }
      });

      // Test 3: åˆæœŸçŠ¶æ…‹è¨˜éŒ²
      const initialState = {
        reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
        count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
        classes: reactionBtn.className
      };
      
      testResults.tests.push({
        name: 'åˆæœŸçŠ¶æ…‹è¨˜éŒ²',
        status: 'passed',
        data: initialState
      });

      if (verbose) console.log('ğŸ“Š åˆæœŸçŠ¶æ…‹:', initialState);

      // Test 4: ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ãƒ†ã‚¹ãƒˆ
      console.log('ğŸ”„ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ãƒ†ã‚¹ãƒˆé–‹å§‹...');
      
      const clickEvent = new MouseEvent('click', { bubbles: true });
      
      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…æ©Ÿã™ã‚‹æº–å‚™
      const reactionKey = `${rowIndex}-${reaction}`;
      let reactionCompletePromise = null;
      
      if (window.studyQuestApp && window.studyQuestApp.waitForReactionComplete) {
        reactionCompletePromise = window.studyQuestApp.waitForReactionComplete(reactionKey, 3000);
      }
      
      reactionBtn.dispatchEvent(clickEvent);
      
      // å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿï¼ˆé«˜åº¦ãªå‹•çš„ã‚·ã‚¹ãƒ†ãƒ ï¼‰
      try {
        const updateResult = await window.studyQuestApp.waitForReactionUpdate(rowIndex, reaction, null, 3000);
        if (updateResult.stateChanged || updateResult.changeDetectedAt) {
          console.log('âœ… çŠ¶æ…‹å¤‰åŒ–æ¤œå‡º:', updateResult);
        } else if (updateResult.timeout) {
          console.warn('âš ï¸ å‹•çš„å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿå®Ÿè¡Œ');
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      } catch (error) {
        console.warn('âš ï¸ å‹•çš„å¾…æ©Ÿã‚¨ãƒ©ãƒ¼:', error.message);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ™‚é–“å¾…æ©Ÿ
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      const afterClickState = {
        reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
        count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
        classes: reactionBtn.className
      };
      
      testResults.tests.push({
        name: 'ã‚¯ãƒªãƒƒã‚¯å¾ŒçŠ¶æ…‹',
        status: 'passed',
        data: afterClickState
      });

      if (verbose) console.log('ğŸ“Š ã‚¯ãƒªãƒƒã‚¯å¾ŒçŠ¶æ…‹:', afterClickState);

      // Test 5: çŠ¶æ…‹å¤‰åŒ–æ¤œè¨¼
      const stateChanged = 
        initialState.reacted !== afterClickState.reacted ||
        initialState.count !== afterClickState.count;
      
      testResults.tests.push({
        name: 'çŠ¶æ…‹å¤‰åŒ–æ¤œè¨¼',
        status: stateChanged ? 'passed' : 'failed',
        data: { 
          changed: stateChanged,
          reactedChanged: initialState.reacted !== afterClickState.reacted,
          countChanged: initialState.count !== afterClickState.count
        }
      });

      // Test 6: å†åº¦ã‚¯ãƒªãƒƒã‚¯ã—ã¦æˆ»ã‚‹ã‹ãƒ†ã‚¹ãƒˆ
      console.log('ğŸ”„ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å–æ¶ˆãƒ†ã‚¹ãƒˆé–‹å§‹...');
      
      // 2å›ç›®ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…æ©Ÿ
      let secondReactionPromise = null;
      if (window.studyQuestApp && window.studyQuestApp.waitForReactionComplete) {
        secondReactionPromise = window.studyQuestApp.waitForReactionComplete(reactionKey, 3000);
      }
      
      reactionBtn.dispatchEvent(clickEvent);
      
      // 2å›ç›®ã®å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿï¼ˆé«˜åº¦ãªå‹•çš„ã‚·ã‚¹ãƒ†ãƒ ï¼‰
      try {
        const secondUpdateResult = await window.studyQuestApp.waitForReactionUpdate(rowIndex, reaction, null, 3000);
        if (secondUpdateResult.stateChanged || secondUpdateResult.changeDetectedAt) {
          console.log('âœ… 2å›ç›®çŠ¶æ…‹å¤‰åŒ–æ¤œå‡º:', secondUpdateResult);
        } else if (secondUpdateResult.timeout) {
          console.warn('âš ï¸ 2å›ç›®å‹•çš„å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿå®Ÿè¡Œ');
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      } catch (error) {
        console.warn('âš ï¸ 2å›ç›®å‹•çš„å¾…æ©Ÿã‚¨ãƒ©ãƒ¼:', error.message);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ™‚é–“å¾…æ©Ÿ
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      const finalState = {
        reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
        count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
        classes: reactionBtn.className
      };
      
      testResults.tests.push({
        name: 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å–æ¶ˆå¾ŒçŠ¶æ…‹',
        status: 'passed',
        data: finalState
      });

      if (verbose) console.log('ğŸ“Š å–æ¶ˆå¾ŒçŠ¶æ…‹:', finalState);

      // Test 7: å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«æ¤œè¨¼
      const backToInitial = 
        initialState.reacted === finalState.reacted &&
        initialState.count === finalState.count;
      
      testResults.tests.push({
        name: 'å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«æ¤œè¨¼',
        status: backToInitial ? 'passed' : 'failed',
        data: { 
          backToInitial,
          initialState,
          finalState
        }
      });

      testResults.success = testResults.tests.every(test => test.status === 'passed');

      console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†');
      console.table(testResults.tests.map(t => ({
        ãƒ†ã‚¹ãƒˆå: t.name,
        çµæœ: t.status,
        è©³ç´°: JSON.stringify(t.data)
      })));

      return testResults;

    } catch (error) {
      console.error('âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
      testResults.errors.push(error.message);
      return testResults;
    }
  };

  // è¤‡æ•°ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®ãƒ†ã‚¹ãƒˆ
  window.testAllReactions = async (cardIndex = 0) => {
    console.log('ğŸ§ª å…¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    const reactions = ['LIKE', 'UNDERSTAND', 'CURIOUS'];
    const results = [];
    
    for (const reaction of reactions) {
      console.log(`\n--- ${reaction} ãƒ†ã‚¹ãƒˆ ---`);
      const result = await window.testReactionSystem({ 
        cardIndex, 
        reaction, 
        verbose: false 
      });
      results.push({ reaction, ...result });
      
      // ãƒ†ã‚¹ãƒˆé–“ã®å¾…æ©Ÿ
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log('\nğŸ“Š å…¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆçµæœ:');
    console.table(results.map(r => ({
      ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³: r.reaction,
      æˆåŠŸ: r.success ? 'âœ…' : 'âŒ',
      ãƒ†ã‚¹ãƒˆæ•°: r.tests.length,
      ã‚¨ãƒ©ãƒ¼æ•°: r.errors.length
    })));
    
    return results;
  };

  // === é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•° ===
  
  // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
  window.testNotificationSystem = async () => {
    console.log('ğŸ§ª é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    try {
      const results = await app.testNotificationEdgeCases();
      console.log('ğŸ“Š é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆçµæœ:', results);
      return results;
    } catch (error) {
      console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      return { success: false, error: error.message };
    }
  };
  
  // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
  window.validateNotificationSystem = () => {
    console.log('ğŸ” é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯é–‹å§‹');
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    try {
      const results = app.validateNotificationSystem();
      console.log('ğŸ“Š é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§:', results);
      return results;
    } catch (error) {
      console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
      return { success: false, error: error.message };
    }
  };
  
  // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã‚·ãƒŠãƒªã‚ªã®æ‰‹å‹•ãƒ†ã‚¹ãƒˆ
  window.simulateInitialLoadFailure = async () => {
    console.log('ğŸ§ª åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã‚·ãƒŠãƒªã‚ªã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹');
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    try {
      // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
      const originalInitialDataLoaded = app.initialDataLoaded;
      const originalHadInitialDataLoadFailure = app.hadInitialDataLoadFailure;
      const originalLastSeenCount = app.state.lastSeenCount;
      
      // å¤±æ•—çŠ¶æ…‹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      app.initialDataLoaded = false;
      app.hadInitialDataLoadFailure = true;
      app.state.lastSeenCount = 0;
      
      console.log('ğŸ”§ å¤±æ•—çŠ¶æ…‹è¨­å®š:', {
        initialDataLoaded: app.initialDataLoaded,
        hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
        lastSeenCount: app.state.lastSeenCount
      });
      
      // é€šçŸ¥ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’è¨­å®š
      let notificationShown = false;
      const originalShowNewContentBanner = app.showNewContentBanner;
      app.showNewContentBanner = (newItems) => {
        notificationShown = true;
        console.log('ğŸ¯ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ï¼šé€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ -', newItems, 'ä»¶');
        return originalShowNewContentBanner.call(app, newItems);
      };
      
      // ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      await app.handleInitialContentLoad('ã™ã¹ã¦-newest', 1);
      
      const result = {
        success: true,
        notificationShown,
        finalState: {
          initialDataLoaded: app.initialDataLoaded,
          hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
          lastSeenCount: app.state.lastSeenCount
        }
      };
      
      // çŠ¶æ…‹ã‚’å¾©å…ƒ
      app.initialDataLoaded = originalInitialDataLoaded;
      app.hadInitialDataLoadFailure = originalHadInitialDataLoadFailure;
      app.state.lastSeenCount = originalLastSeenCount;
      app.showNewContentBanner = originalShowNewContentBanner;
      
      console.log('âœ… ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†:', result);
      return result;
      
    } catch (error) {
      console.error('âŒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
      return { success: false, error: error.message };
    }
  };
  
  // ç¾åœ¨ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’å–å¾—
  window.getNotificationSystemStatus = () => {
    const app = window.studyQuestApp;
    if (!app) return null;
    
    return {
      initialDataLoaded: app.initialDataLoaded,
      hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
      lastSeenCount: app.state.lastSeenCount,
      pollingEnabled: app.pollingSettings?.enabled,
      notificationElements: {
        banner: !!app.elements.newContentBanner,
        text: !!app.elements.newContentText,
        refreshBtn: !!app.elements.refreshContentBtn,
        dismissBtn: !!app.elements.dismissBannerBtn
      },
      bannerVisible: app.elements.newContentBanner && !app.elements.newContentBanner.classList.contains('hidden'),
      lastNotificationTime: app.lastNotificationTime,
      currentAnswersCount: app.state.currentAnswers?.length || 0
    };
  };
  
  // é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã®ãƒ†ã‚¹ãƒˆ
  window.testNotificationDebounce = async () => {
    console.log('ğŸ§ª é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    try {
      return await app.testNotificationDebounce();
    } catch (error) {
      console.error('âŒ ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      return { success: false, error: error.message };
    }
  };

  // === ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­æ©Ÿèƒ½ ===
  
  // ãƒ‡ãƒ¼ã‚¿å–å¾—çŠ¶æ³ã®è©³ç´°è¨ºæ–­
  window.diagnoseDataFetch = async () => {
    console.log('ğŸ”¬ ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­é–‹å§‹');
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    const diagnosis = {
      timestamp: new Date().toISOString(),
      userState: {
        userId: app.state.userId,
        currentAnswersCount: app.state.currentAnswers?.length || 0,
        lastSeenCount: app.state.lastSeenCount,
        initialDataLoaded: app.initialDataLoaded,
        hadInitialDataLoadFailure: app.hadInitialDataLoadFailure
      },
      uiState: {
        classFilter: app.elements.classFilter?.value || 'unknown',
        sortOrder: app.elements.sortOrder?.value || 'unknown',
        showAdminFeatures: app.state.showAdminFeatures
      },
      tests: [],
      recommendations: []
    };
    
    try {
      // ãƒ†ã‚¹ãƒˆ1: è»½é‡ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ
      console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ1: ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ');
      const startTime = performance.now();
      const countData = await app.gas.getDataCount(
        diagnosis.uiState.classFilter,
        diagnosis.uiState.sortOrder,
        diagnosis.uiState.showAdminFeatures
      );
      const countTime = performance.now() - startTime;
      
      diagnosis.tests.push({
        name: 'ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ',
        duration: Math.round(countTime),
        result: countData,
        success: !!countData && countData.count !== undefined
      });
      
      // ãƒ†ã‚¹ãƒˆ2: ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—
      console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ2: ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—');
      const fullStartTime = performance.now();
      const fullData = await app.gas.getPublishedSheetData(
        app.state.userId,
        diagnosis.uiState.classFilter,
        diagnosis.uiState.sortOrder,
        diagnosis.uiState.showAdminFeatures,
        false
      );
      const fullTime = performance.now() - fullStartTime;
      
      diagnosis.tests.push({
        name: 'ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—',
        duration: Math.round(fullTime),
        result: {
          status: fullData?.status,
          dataCount: fullData?.data?.length || 0,
          sheetName: fullData?.sheetName
        },
        success: !!fullData && !!fullData.data
      });
      
      // ãƒ†ã‚¹ãƒˆ3: å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—
      if (diagnosis.userState.lastSeenCount > 0) {
        console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ3: å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—');
        const incrementalStartTime = performance.now();
        const incrementalData = await app.gas.getIncrementalSheetData(
          diagnosis.uiState.classFilter,
          diagnosis.uiState.sortOrder,
          diagnosis.uiState.showAdminFeatures,
          diagnosis.userState.lastSeenCount
        );
        const incrementalTime = performance.now() - incrementalStartTime;
        
        diagnosis.tests.push({
          name: 'å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—',
          duration: Math.round(incrementalTime),
          result: {
            newCount: incrementalData?.newCount || 0,
            totalCount: incrementalData?.totalCount || 0,
            status: incrementalData?.status
          },
          success: !!incrementalData && incrementalData.status !== 'error'
        });
      }
      
      // è¨ºæ–­çµæœã®è©•ä¾¡ã¨æ¨å¥¨äº‹é …
      const countResult = diagnosis.tests.find(t => t.name === 'ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ');
      const fullResult = diagnosis.tests.find(t => t.name === 'ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—');
      
      if (countResult && fullResult) {
        if (countResult.success && fullResult.success) {
          const expectedCount = countResult.result.count || 0;
          const actualCount = fullResult.result.dataCount || 0;
          
          if (expectedCount !== actualCount) {
            diagnosis.recommendations.push({
              level: 'warning',
              message: `ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡º: ã‚«ã‚¦ãƒ³ãƒˆ=${expectedCount}, å®Ÿéš›=${actualCount}`,
              action: 'ã‚µãƒ¼ãƒãƒ¼å´ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„'
            });
          } else if (expectedCount === 0) {
            diagnosis.recommendations.push({
              level: 'info',
              message: 'ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã›ã‚“',
              action: 'ãƒ•ã‚©ãƒ¼ãƒ ã«æ–°ã—ã„å›ç­”ã‚’æŠ•ç¨¿ã—ã¦ãã ã•ã„'
            });
          } else {
            diagnosis.recommendations.push({
              level: 'success',
              message: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™',
              action: 'å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„'
            });
          }
        } else {
          diagnosis.recommendations.push({
            level: 'error',
            message: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
            action: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„'
          });
        }
      }
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡
      const avgTime = diagnosis.tests.reduce((sum, test) => sum + test.duration, 0) / diagnosis.tests.length;
      if (avgTime > 3000) {
        diagnosis.recommendations.push({
          level: 'warning',
          message: `å¿œç­”æ™‚é–“ãŒé…ã„ (å¹³å‡${Math.round(avgTime)}ms)`,
          action: 'ã‚µãƒ¼ãƒãƒ¼ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„'
        });
      }
      
      console.log('ğŸ“Š ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­å®Œäº†:', diagnosis);
      return diagnosis;
      
    } catch (error) {
      console.error('âŒ è¨ºæ–­ã‚¨ãƒ©ãƒ¼:', error);
      diagnosis.tests.push({
        name: 'è¨ºæ–­å®Ÿè¡Œ',
        duration: 0,
        result: null,
        success: false,
        error: error.message
      });
      return diagnosis;
    }
  };
  
  // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
  window.monitorDataFetchPerformance = async (duration = 60000) => {
    console.log(`ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–é–‹å§‹ (${duration/1000}ç§’é–“)`);
    
    const app = window.studyQuestApp;
    if (!app) {
      console.error('StudyQuestApp not found');
      return { success: false, error: 'StudyQuestApp not found' };
    }
    
    const monitor = {
      startTime: Date.now(),
      duration: duration,
      samples: [],
      summary: {}
    };
    
    const interval = setInterval(async () => {
      try {
        const startTime = performance.now();
        const countData = await app.gas.getDataCount('ã™ã¹ã¦', 'newest', false);
        const endTime = performance.now();
        
        monitor.samples.push({
          timestamp: Date.now(),
          duration: Math.round(endTime - startTime),
          success: !!countData,
          count: countData?.count || 0
        });
        
        console.log(`ğŸ“Š ã‚µãƒ³ãƒ—ãƒ«${monitor.samples.length}: ${Math.round(endTime - startTime)}ms`);
        
      } catch (error) {
        monitor.samples.push({
          timestamp: Date.now(),
          duration: 0,
          success: false,
          error: error.message
        });
      }
    }, 5000); // 5ç§’é–“éš”
    
    // æŒ‡å®šæ™‚é–“å¾Œã«ç›£è¦–çµ‚äº†
    setTimeout(() => {
      clearInterval(interval);
      
      // çµ±è¨ˆè¨ˆç®—
      const successful = monitor.samples.filter(s => s.success);
      const failed = monitor.samples.filter(s => !s.success);
      
      if (successful.length > 0) {
        const durations = successful.map(s => s.duration);
        monitor.summary = {
          totalSamples: monitor.samples.length,
          successfulSamples: successful.length,
          failedSamples: failed.length,
          successRate: (successful.length / monitor.samples.length * 100).toFixed(1) + '%',
          avgDuration: Math.round(durations.reduce((a, b) => a + b, 0) / durations.length),
          minDuration: Math.min(...durations),
          maxDuration: Math.max(...durations),
          medianDuration: durations.sort((a, b) => a - b)[Math.floor(durations.length / 2)]
        };
      } else {
        monitor.summary = {
          totalSamples: monitor.samples.length,
          successfulSamples: 0,
          failedSamples: failed.length,
          successRate: '0%',
          error: 'å…¨ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ãŒå¤±æ•—ã—ã¾ã—ãŸ'
        };
      }
      
      console.log('ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–å®Œäº†:', monitor.summary);
    }, duration);
    
    return monitor;
  };
  
  // ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®åŒ…æ‹¬çš„ãªãƒ¬ãƒãƒ¼ãƒˆ
  window.getSystemStatusReport = () => {
    const app = window.studyQuestApp;
    if (!app) return null;
    
    const report = {
      timestamp: new Date().toISOString(),
      application: {
        version: '2.0',
        initialDataLoaded: app.initialDataLoaded,
        hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
        pollingActive: app.pollingSettings?.enabled,
        batchProcessingEnabled: app.enableBatchProcessing
      },
      data: {
        currentAnswersCount: app.state.currentAnswers?.length || 0,
        lastSeenCount: app.state.lastSeenCount,
        visibleCardsCount: document.querySelectorAll('.answer-card').length,
        userId: app.state.userId?.substring(0, 8) + '...'
      },
      ui: {
        classFilter: app.elements.classFilter?.value,
        sortOrder: app.elements.sortOrder?.value,
        showAdminFeatures: app.state.showAdminFeatures,
        notificationBannerVisible: app.elements.newContentBanner && !app.elements.newContentBanner.classList.contains('hidden')
      },
      performance: {
        memoryUsage: performance.memory ? {
          used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
          total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
        } : 'unavailable'
      }
    };
    
    console.log('ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ãƒ¬ãƒãƒ¼ãƒˆ:', report);
    return report;
  };
  
  // ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã¨ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å–å¾—
  loadDomainInfo();
  loadFormLink();
  
  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
  });
} catch (error) {
  console.error('Error creating StudyQuestApp instance:', error);
  const container = document.getElementById('answers');
  if (container) {
    const msg = StudyQuestApp.prototype.escapeHtml(error.message || '');
    container.innerHTML = '<div class="text-red-400 p-4">ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + msg + '</div>';
  }
}
</script>
