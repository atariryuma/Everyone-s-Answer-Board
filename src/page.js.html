<script>
/**
 * StudyQuest Answer Board - Optimized Version
 * パフォーマンス最適化とコード短縮を実現
 */

// ==================== 設定定数 ====================
const CONFIG = Object.freeze({
  // アニメーション設定
  ANIMATION: {
    CARD_FADE_DURATION: 0.5,
    CARD_MOVE_DURATION: 0.7,
    MODAL_DURATION: 0.3,
    STAGGER_AMOUNT: 0.3
  },
  
  // ポーリング設定
  POLLING: {
    INTERVAL_MS: 15000,
    DEBOUNCE_MS: 200
  },
  
  // レンダリング設定
  RENDER: {
    BATCH_SIZE: 50,
    VIRTUAL_SCROLL_THRESHOLD: 150,
    SKELETON_COUNT_MULTIPLIER: 2
  },
  
  // キャッシュ設定
  CACHE: {
    TTL: 300000, // 5分
    MAX_SIZE: 100
  },
  
  // デバッグ設定
  DEBUG: false
});

// ==================== ユーティリティ関数 ====================
const Utils = {
  // メモ化関数
  memoize(fn, keyGenerator) {
    const cache = new Map();
    const kg = keyGenerator || ((...args) => JSON.stringify(args));
    return (...args) => {
      const key = kg(...args);
      if (cache.has(key)) return cache.get(key);
      const result = fn.apply(this, args);
      cache.set(key, result);
      if (cache.size > CONFIG.CACHE.MAX_SIZE) {
        const firstKey = cache.keys().next().value;
        cache.delete(firstKey);
      }
      return result;
    };
  },
  
  // デバウンス関数
  debounce(fn, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn.apply(this, args), delay);
    };
  },
  
  // スロットル関数
  throttle(fn, limit) {
    let inThrottle;
    return (...args) => {
      if (!inThrottle) {
        fn.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  },
  
  // HTMLエスケープ
  escapeHtml(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  },
  
  // DOM更新のバッチ処理
  batchDOMUpdates(updates) {
    if (!updates.length) return;
    requestAnimationFrame(() => {
      const fragment = document.createDocumentFragment();
      updates.forEach(update => {
        if (typeof update === 'function') update();
        else if (update instanceof Node) fragment.appendChild(update);
      });
      if (fragment.children.length > 0) {
        return fragment;
      }
    });
  },
  
  // GSAPが利用可能か確認
  async waitForGSAP() {
    return new Promise(resolve => {
      if (typeof window.gsap !== 'undefined') {
        resolve();
      } else {
        const checkInterval = setInterval(() => {
          if (typeof window.gsap !== 'undefined') {
            clearInterval(checkInterval);
            resolve();
          }
        }, 50);
      }
    });
  }
};

// ==================== メインアプリケーションクラス ====================
class StudyQuestApp {
  constructor() {
    // キャッシュ
    this.cache = new Map();
    this.renderCache = new WeakMap();
    
    // 状態管理
    this.state = {
      currentAnswers: [],
      filteredAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      currentFilter: 'すべて',
      currentSort: 'newest',
      gridColumns: 4,
      // 権限・表示設定
      isStudentMode: window.isStudentMode !== false,
      showCounts: window.showCounts === true,
      showAdminFeatures: window.showAdminFeatures === true,
      showHighlightToggle: window.showHighlightToggle === true,
      displayMode: window.displayMode || 'anonymous',
      isAdminUser: false,
      sheetName: typeof SHEET_NAME !== 'undefined' ? SHEET_NAME : ''
    };
    
    // DOM要素のキャッシュ
    this.elements = this.cacheElements();
    
    // イベントハンドラ
    this.handlers = {};
    
    // デバウンス・スロットル済み関数
    this.debouncedRender = Utils.debounce(() => this.render(), CONFIG.POLLING.DEBOUNCE_MS);
    this.throttledScroll = Utils.throttle(() => this.handleScroll(), 100);
    
    // リアクションタイプ
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up', label: 'いいね', color: 'red' },
      { key: 'UNDERSTAND', icon: 'lightbulb', label: 'なるほど', color: 'yellow' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus', label: '気になる', color: 'green' }
    ];
    
    // 処理中のリアクション管理
    this.pendingReactions = new Set();
    this.lastReactionTimes = new Map();
    
    // ポーリングタイマー
    this.pollingTimer = null;
    
    // 仮想スクロール状態
    this.virtualScroll = {
      enabled: false,
      startIndex: 0,
      endIndex: 0,
      itemHeight: 150
    };
    
    // 初期化
    this.init();
  }
  
  // DOM要素をキャッシュ
  cacheElements() {
    const ids = [
      'main-container', 'main-header', 'answers', 'sizeSlider', 'sliderValue',
      'headingLabel', 'sheetNameText', 'modeLabel', 'adminToggleBtn', 'answerCount',
      'answerModalContainer', 'answerModalCloseBtn', 'answerModalCard', 'modalAnswer',
      'modalStudentName', 'modalReactions', 'modalFooter', 'infoModalContainer',
      'infoModalCard', 'infoModalConfirmBtn', 'classFilter', 'sortOrder', 'scoreOption',
      'controlsFooter', 'modeToggleBtn', 'footerIcon'
    ];
    
    const elements = {};
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) elements[id.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = el;
    });
    
    elements.body = document.body;
    return elements;
  }
  
  // 初期化
  async init() {
    await Utils.waitForGSAP();
    this.setupEventListeners();
    this.loadSavedSettings();
    await this.verifyAdmin();
    this.adjustLayout();
    await this.loadInitialData();
    this.startPolling();
  }
  
  // イベントリスナーの設定（イベント委譲で最適化）
  setupEventListeners() {
    // メインコンテナのイベント委譲
    this.elements.answers?.addEventListener('click', this.handleCardClick.bind(this));
    this.elements.answers?.addEventListener('keydown', this.handleCardKeydown.bind(this));
    
    // スライダー
    this.elements.sizeSlider?.addEventListener('input', e => {
      this.state.gridColumns = parseInt(e.target.value);
      localStorage.setItem('boardColumns', this.state.gridColumns);
      this.elements.sliderValue.textContent = this.state.gridColumns;
      this.debouncedRender();
    });
    
    // フィルター・ソート
    this.elements.classFilter?.addEventListener('change', () => this.applyFilters());
    this.elements.sortOrder?.addEventListener('change', () => this.applyFilters());
    
    // モーダル
    this.elements.answerModalCloseBtn?.addEventListener('click', () => this.hideModal());
    this.elements.answerModalContainer?.addEventListener('click', e => {
      if (e.target === e.currentTarget) this.hideModal();
    });
    this.elements.modalReactions?.addEventListener('click', this.handleModalReaction.bind(this));
    this.elements.infoModalConfirmBtn?.addEventListener('click', () => this.hideInfoModal());
    
    // 管理者モード切り替え
    this.elements.adminToggleBtn?.addEventListener('click', () => this.toggleAdminMode());
    this.elements.modeToggleBtn?.addEventListener('click', () => this.togglePreviewMode());
    
    // キーボードショートカット
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') this.hideModal();
    });
    
    // ウィンドウリサイズ
    window.addEventListener('resize', Utils.debounce(() => this.adjustLayout(), 100));
    
    // ページ表示状態
    document.addEventListener('visibilitychange', () => {
      document.hidden ? this.stopPolling() : this.startPolling();
    });
    
    // 仮想スクロール
    this.elements.answers?.addEventListener('scroll', this.throttledScroll.bind(this));
  }
  
  // カードクリックハンドラ（イベント委譲）
  handleCardClick(e) {
    const card = e.target.closest('.answer-card');
    if (!card) return;
    
    const rowIndex = card.dataset.rowIndex;
    
    // リアクションボタン
    const reactionBtn = e.target.closest('.reaction-btn');
    if (reactionBtn) {
      e.stopPropagation();
      this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
      return;
    }
    
    // ハイライトボタン
    const highlightBtn = e.target.closest('.highlight-btn');
    if (highlightBtn) {
      e.stopPropagation();
      this.handleHighlight(rowIndex);
      return;
    }
    
    // カード本体クリック → モーダル表示
    this.showModal(rowIndex);
  }
  
  // カードキーボードハンドラ
  handleCardKeydown(e) {
    if (e.key !== 'Enter' && e.key !== ' ') return;
    
    const card = e.target.closest('.answer-card');
    if (!card) return;
    
    e.preventDefault();
    const rowIndex = card.dataset.rowIndex;
    
    const focusedBtn = document.activeElement;
    if (focusedBtn.matches('.reaction-btn')) {
      this.handleReaction(rowIndex, focusedBtn.dataset.reaction);
    } else if (focusedBtn.matches('.highlight-btn')) {
      this.handleHighlight(rowIndex);
    } else {
      this.showModal(rowIndex);
    }
  }
  
  // モーダル内リアクションハンドラ
  handleModalReaction(e) {
    const btn = e.target.closest('.reaction-btn');
    if (!btn) return;
    this.handleReaction(btn.dataset.rowIndex, btn.dataset.reaction);
  }
  
  // Google Apps Script関数の実行
  async runGas(funcName, ...args) {
    return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script?.run) {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          [funcName](...args);
      } else {
        // デバッグ用モックデータ
        this.getMockData(funcName, ...args).then(resolve).catch(reject);
      }
    });
  }
  
  // モックデータ生成
  getMockData(funcName) {
    return new Promise(resolve => {
      setTimeout(() => {
        if (funcName === 'getPublishedSheetData') {
          resolve({
            header: 'テスト問題',
            sheetName: 'テストシート',
            rows: Array.from({ length: 10 }, (_, i) => ({
              rowIndex: i + 1,
              name: this.state.displayMode === 'named' ? `生徒${i + 1}` : '',
              class: `${Math.floor(Math.random() * 3) + 1}年${String.fromCharCode(65 + Math.floor(Math.random() * 3))}組`,
              opinion: `これは意見${i + 1}です。`,
              reason: `理由${i + 1}の説明文です。`,
              reactions: {
                UNDERSTAND: { count: Math.floor(Math.random() * 10), reacted: Math.random() < 0.3 },
                LIKE: { count: Math.floor(Math.random() * 10), reacted: Math.random() < 0.3 },
                CURIOUS: { count: Math.floor(Math.random() * 10), reacted: Math.random() < 0.3 }
              },
              highlight: Math.random() < 0.2
            }))
          });
        } else if (funcName === 'addReaction') {
          resolve({ status: 'ok', reactions: {} });
        } else if (funcName === 'toggleHighlight') {
          resolve({ status: 'ok', highlight: true });
        } else if (funcName === 'checkAdmin') {
          resolve(true);
        }
      }, 300);
    });
  }
  
  // 設定の読み込み
  loadSavedSettings() {
    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols) {
      this.state.gridColumns = parseInt(savedCols);
      if (this.elements.sizeSlider) this.elements.sizeSlider.value = this.state.gridColumns;
      if (this.elements.sliderValue) this.elements.sliderValue.textContent = this.state.gridColumns;
    }
  }
  
  // 管理者権限確認
  async verifyAdmin() {
    try {
      const isAdmin = await this.runGas('checkAdmin');
      if (isAdmin) {
        this.state.isAdminUser = true;
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.remove('hidden');
          this.elements.adminToggleBtn.removeAttribute('hidden');
          this.updateAdminButtonText();
        }
      }
    } catch (e) {
      console.error('Admin check failed:', e);
    }
  }
  
  // レイアウト調整
  adjustLayout() {
    const footerHeight = this.elements.controlsFooter?.offsetHeight || 0;
    if (this.elements.body) {
      this.elements.body.style.paddingBottom = `${footerHeight + 16}px`;
    }
  }
  
  // 初期データロード
  async loadInitialData() {
    await this.loadSheetData(true, true);
  }
  
  // データロード
  async loadSheetData(showLoading = true, isInitial = false) {
    if (this.state.isLoading && showLoading) return;
    this.state.isLoading = true;
    
    if (showLoading) {
      this.showSkeletons();
    }
    
    try {
      const filter = isInitial ? 'すべて' : (this.elements.classFilter?.value || 'すべて');
      const sort = this.elements.sortOrder?.value || 'newest';
      
      const data = await this.runGas('getPublishedSheetData', filter, sort);
      
      this.state.sheetName = data.sheetName;
      this.state.currentAnswers = data.rows || [];
      
      if (isInitial) {
        this.populateClassFilter(data.rows);
        if (this.elements.sheetNameText) {
          this.elements.sheetNameText.textContent = `シート: ${Utils.escapeHtml(data.sheetName || '不明')}`;
        }
      }
      
      if (this.elements.headingLabel) {
        this.elements.headingLabel.textContent = Utils.escapeHtml(data.header || '問題');
      }
      
      this.applyFilters();
      
    } catch (error) {
      console.error('データロードエラー:', error);
      this.showError(error.message);
    } finally {
      this.state.isLoading = false;
    }
  }
  
  // クラスフィルター生成
  populateClassFilter(rows) {
    if (!this.elements.classFilter) return;
    
    const classes = ['すべて', ...new Set(rows.map(r => r.class).filter(Boolean))];
    this.elements.classFilter.innerHTML = classes
      .map(c => `<option value="${Utils.escapeHtml(c)}">${Utils.escapeHtml(c)}</option>`)
      .join('');
    this.elements.classFilter.classList.remove('hidden');
  }
  
  // フィルター・ソート適用
  applyFilters() {
    const filter = this.elements.classFilter?.value || 'すべて';
    const sort = this.elements.sortOrder?.value || 'newest';
    
    // フィルタリング
    let filtered = [...this.state.currentAnswers];
    if (filter !== 'すべて') {
      filtered = filtered.filter(r => r.class === filter);
    }
    
    // ソート
    switch (sort) {
      case 'random':
        filtered.sort(() => Math.random() - 0.5);
        break;
      case 'score':
        filtered.sort((a, b) => {
          const scoreA = this.calculateScore(a);
          const scoreB = this.calculateScore(b);
          return scoreB - scoreA;
        });
        break;
      // 'newest'はデフォルト順序を保持
    }
    
    this.state.filteredAnswers = filtered;
    this.render();
  }
  
  // スコア計算
  calculateScore(item) {
    if (!item.reactions) return 0;
    return this.reactionTypes.reduce((sum, rt) => 
      sum + (item.reactions[rt.key]?.count || 0), 0);
  }
  
  // レンダリング（最適化版）
  async render() {
    const container = this.elements.answers;
    if (!container) return;
    
    const data = this.state.filteredAnswers;
    
    // グリッド設定
    container.className = `grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-${this.state.gridColumns}`;
    
    // 回答数更新
    if (this.elements.answerCount) {
      this.elements.answerCount.innerHTML = `${this.getIcon('users', 'w-4 h-4 inline-block -mt-1')}<span>${data.length}件</span>`;
    }
    
    // 空状態
    if (data.length === 0) {
      container.innerHTML = '<p class="text-center text-gray-500 col-span-full mt-8">回答がありません。</p>';
      return;
    }
    
    // 仮想スクロール判定
    const useVirtual = data.length > CONFIG.RENDER.VIRTUAL_SCROLL_THRESHOLD;
    
    if (useVirtual) {
      this.renderVirtual(data);
    } else {
      await this.renderAll(data);
    }
  }
  
  // 全件レンダリング
  async renderAll(data) {
    const container = this.elements.answers;
    const fragment = document.createDocumentFragment();
    const newCards = [];
    
    // 既存カードのマップ
    const existingMap = new Map();
    container.querySelectorAll('.answer-card').forEach(card => {
      existingMap.set(card.dataset.rowIndex, card);
    });
    
    // カード生成・更新
    data.forEach(item => {
      const rowId = String(item.rowIndex);
      let card = existingMap.get(rowId);
      
      if (!card) {
        card = this.createCard(item);
        newCards.push(card);
        fragment.appendChild(card);
      } else {
        this.updateCard(card, item);
        existingMap.delete(rowId);
      }
    });
    
    // 不要なカードを削除
    existingMap.forEach(card => card.remove());
    
    // 新規カードを追加
    if (fragment.children.length > 0) {
      container.appendChild(fragment);
      
      // GSAP アニメーション
      if (window.gsap && newCards.length > 0) {
        window.gsap.set(newCards, { opacity: 0, y: 30, scale: 0.95 });
        window.gsap.to(newCards, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: CONFIG.ANIMATION.CARD_FADE_DURATION,
          ease: "power2.out",
          stagger: {
            amount: Math.min(CONFIG.ANIMATION.STAGGER_AMOUNT, newCards.length * 0.05),
            from: "start"
          }
        });
      }
    }
  }
  
  // 仮想スクロールレンダリング
  renderVirtual(data) {
    const container = this.elements.answers;
    const viewportHeight = container.clientHeight;
    const scrollTop = container.scrollTop;
    
    // 表示範囲の計算
    const itemHeight = this.virtualScroll.itemHeight;
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.ceil((scrollTop + viewportHeight) / itemHeight);
    
    // バッファを追加
    const bufferSize = 5;
    this.virtualScroll.startIndex = Math.max(0, startIndex - bufferSize);
    this.virtualScroll.endIndex = Math.min(data.length, endIndex + bufferSize);
    
    // 表示範囲のデータのみレンダリング
    const visibleData = data.slice(this.virtualScroll.startIndex, this.virtualScroll.endIndex);
    this.renderAll(visibleData);
    
    // スペーサーを追加
    const topHeight = this.virtualScroll.startIndex * itemHeight;
    const bottomHeight = (data.length - this.virtualScroll.endIndex) * itemHeight;
    
    container.style.paddingTop = `${topHeight}px`;
    container.style.paddingBottom = `${bottomHeight}px`;
  }
  
  // スクロールハンドラ
  handleScroll() {
    if (this.state.filteredAnswers.length > CONFIG.RENDER.VIRTUAL_SCROLL_THRESHOLD) {
      this.renderVirtual(this.state.filteredAnswers);
    }
  }
  
  // カード作成
  createCard(data) {
    const card = document.createElement('div');
    card.className = `relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer${data.highlight ? ' highlighted' : ''}`;
    card.dataset.rowIndex = data.rowIndex;
    card.setAttribute('role', 'article');
    card.setAttribute('tabindex', '0');
    
    // リアクション背景クラス
    this.applyReactionStyles(card, data);
    
    // コンテンツ生成
    const content = this.generateCardContent(data);
    card.innerHTML = content;
    
    // ハイライトバッジ
    if (data.highlight) {
      const badge = document.createElement('span');
      badge.className = 'highlight-badge absolute top-1 right-1';
      badge.innerHTML = this.getIcon('star', '', true);
      card.appendChild(badge);
    }
    
    return card;
  }
  
  // カード更新
  updateCard(card, data) {
    // ハイライト状態
    card.classList.toggle('highlighted', data.highlight);
    
    // リアクション背景
    this.applyReactionStyles(card, data);
    
    // リアクションボタン更新
    this.updateReactionButtons(card, data);
    
    // ハイライトバッジ
    let badge = card.querySelector('.highlight-badge');
    if (data.highlight && !badge) {
      badge = document.createElement('span');
      badge.className = 'highlight-badge absolute top-1 right-1';
      badge.innerHTML = this.getIcon('star', '', true);
      card.appendChild(badge);
    } else if (!data.highlight && badge) {
      badge.remove();
    }
  }
  
  // カードコンテンツ生成
  generateCardContent(data) {
    const showName = this.state.displayMode === 'named';
    const nameHtml = showName ? `<div><span class="font-bold text-sm text-gray-200">${Utils.escapeHtml(data.name)}</span></div>` : '';
    
    // リアクションボタン
    const reactionButtons = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const countHtml = this.state.showCounts ? `<span class="reaction-count font-bold text-lg text-gray-200">${info.count || 0}</span>` : '';
      
      return `<button type="button" class="reaction-btn like-btn flex items-center gap-1 text-${rt.color}-500${info.reacted ? ' liked' : ''}" 
        data-row-index="${data.rowIndex}" data-reaction="${rt.key}" 
        aria-label="${rt.label}" aria-pressed="${info.reacted}">
        ${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countHtml}
      </button>`;
    }).join('');
    
    // ハイライトボタン
    const highlightBtn = this.state.showHighlightToggle ? 
      `<button type="button" class="highlight-btn like-btn text-yellow-400${data.highlight ? ' liked' : ''}" 
        aria-label="ハイライト" aria-pressed="${data.highlight}" data-row-index="${data.rowIndex}">
        ${this.getIcon('star', 'w-5 h-5', true)}
      </button>` : '';
    
    return `
      <div class="relative flex-grow mb-3 answer-preview">
        <h3 class="opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight">
          ${Utils.escapeHtml(data.opinion || '')}
        </h3>
        <p class="text-gray-100 whitespace-pre-wrap break-words mt-4">
          ${Utils.escapeHtml(data.reason || '')}
        </p>
      </div>
      <div class="text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex ${nameHtml ? 'justify-between' : 'justify-end'} items-center">
        ${nameHtml}
        <div class="flex items-center gap-1" role="group" aria-label="回答への反応">
          ${reactionButtons}
          ${highlightBtn}
        </div>
      </div>`;
  }
  
  // リアクションスタイル適用
  applyReactionStyles(card, data) {
    // 既存のリアクション背景クラスを削除
    card.className = card.className.replace(/reaction-bg-\S+/g, '').replace(/reaction-border-\d/g, '');
    
    if (!data.reactions) return;
    
    // アクティブなリアクション
    const active = this.reactionTypes.filter(rt => 
      data.reactions[rt.key]?.count > 0
    ).map(rt => rt.key);
    
    // 背景クラス
    if (active.length === 1) {
      const mapping = { LIKE: 'like', UNDERSTAND: 'understand', CURIOUS: 'curious' };
      card.classList.add(`reaction-bg-${mapping[active[0]]}`);
    } else if (active.length === 2) {
      const combo = active.sort().join('-').toLowerCase();
      const mapping = {
        'like-understand': 'like-understand',
        'curious-like': 'like-curious',
        'curious-understand': 'understand-curious'
      };
      card.classList.add(`reaction-bg-${mapping[combo] || 'all'}`);
    } else if (active.length > 2) {
      card.classList.add('reaction-bg-all');
    }
    
    // ボーダー太さ
    const total = this.reactionTypes.reduce((sum, rt) => 
      sum + (data.reactions[rt.key]?.count || 0), 0);
    
    if (total >= 10) card.classList.add('reaction-border-3');
    else if (total >= 5) card.classList.add('reaction-border-2');
    else if (total > 0) card.classList.add('reaction-border-1');
  }
  
  // リアクションボタン更新
  updateReactionButtons(card, data) {
    this.reactionTypes.forEach(rt => {
      const btn = card.querySelector(`.reaction-btn[data-reaction="${rt.key}"]`);
      if (!btn) return;
      
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      
      // 状態更新
      btn.classList.toggle('liked', info.reacted);
      btn.setAttribute('aria-pressed', info.reacted);
      
      // カウント更新
      const countEl = btn.querySelector('.reaction-count');
      if (countEl && this.state.showCounts) {
        countEl.textContent = info.count || 0;
      }
      
      // アイコン更新
      const icon = btn.querySelector('svg')?.parentElement;
      if (icon) {
        icon.innerHTML = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);
      }
    });
    
    // ハイライトボタン
    const highlightBtn = card.querySelector('.highlight-btn');
    if (highlightBtn) {
      highlightBtn.classList.toggle('liked', data.highlight);
      highlightBtn.setAttribute('aria-pressed', data.highlight);
    }
  }
  
  // リアクション処理
  async handleReaction(rowIndex, reaction) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;
    
    // 重複防止
    const now = Date.now();
    const lastTime = this.lastReactionTimes.get(reactionKey);
    if (lastTime && now - lastTime < 1000) return;
    
    if (this.pendingReactions.has(reactionKey)) return;
    
    // データ確認
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    if (!item) return;
    
    // UI更新（楽観的更新）
    this.pendingReactions.add(reactionKey);
    this.lastReactionTimes.set(reactionKey, now);
    
    const buttons = document.querySelectorAll(`[data-row-index="${numericRowIndex}"][data-reaction="${reaction}"]`);
    buttons.forEach(btn => btn.disabled = true);
    
    // 現在の状態を反転
    const currentState = item.reactions?.[reaction]?.reacted || false;
    if (!item.reactions) item.reactions = {};
    if (!item.reactions[reaction]) item.reactions[reaction] = { count: 0, reacted: false };
    
    item.reactions[reaction].reacted = !currentState;
    item.reactions[reaction].count += currentState ? -1 : 1;
    item.reactions[reaction].count = Math.max(0, item.reactions[reaction].count);
    
    // UI即座更新
    this.updateReactionButtonsForItem(item);
    
    // アニメーション
    if (window.gsap) {
      buttons.forEach(btn => {
        window.gsap.fromTo(btn, { scale: 1 }, {
          scale: 1.2,
          duration: 0.15,
          ease: "power2.out",
          yoyo: true,
          repeat: 1
        });
      });
    }
    
    try {
      // サーバー更新
      const res = await this.runGas('addReaction', numericRowIndex, reaction, this.state.sheetName);
      if (res?.status === 'ok' && res.reactions) {
        item.reactions = res.reactions;
        this.updateReactionButtonsForItem(item);
      }
    } catch (error) {
      console.error('リアクションエラー:', error);
      // エラー時は元に戻す
      item.reactions[reaction].reacted = currentState;
      item.reactions[reaction].count += currentState ? 1 : -1;
      this.updateReactionButtonsForItem(item);
    } finally {
      buttons.forEach(btn => btn.disabled = false);
      this.pendingReactions.delete(reactionKey);
    }
  }
  
  // リアクションボタンUIの更新
  updateReactionButtonsForItem(item) {
    const cards = document.querySelectorAll(`.answer-card[data-row-index="${item.rowIndex}"]`);
    cards.forEach(card => {
      this.updateReactionButtons(card, item);
      this.applyReactionStyles(card, item);
    });
    
    // モーダル内のボタンも更新
    const modalBtns = this.elements.modalReactions?.querySelectorAll(`[data-row-index="${item.rowIndex}"]`);
    modalBtns?.forEach(btn => {
      const reaction = btn.dataset.reaction;
      const info = item.reactions?.[reaction] || { count: 0, reacted: false };
      
      btn.classList.toggle('liked', info.reacted);
      const countEl = btn.querySelector('.reaction-count');
      if (countEl) countEl.textContent = info.count || 0;
    });
  }
  
  // ハイライト処理
  async handleHighlight(rowIndex) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    if (!item) return;
    
    const buttons = document.querySelectorAll(`.highlight-btn[data-row-index="${numericRowIndex}"]`);
    buttons.forEach(btn => btn.disabled = true);
    
    try {
      const res = await this.runGas('toggleHighlight', numericRowIndex, this.state.sheetName, item.highlight);
      if (res?.status === 'ok') {
        item.highlight = res.highlight;
        const cards = document.querySelectorAll(`.answer-card[data-row-index="${numericRowIndex}"]`);
        cards.forEach(card => this.updateCard(card, item));
      }
    } catch (error) {
      console.error('ハイライトエラー:', error);
    } finally {
      buttons.forEach(btn => btn.disabled = false);
    }
  }
  
  // モーダル表示
  showModal(rowIndex) {
    const data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
    if (!data) return;
    
    this.state.lastFocusedElement = document.activeElement;
    
    // コンテンツ設定
    this.elements.modalAnswer.innerHTML = `
      <p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">
        ${Utils.escapeHtml(data.opinion || '')}
      </p>
      <p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">
        ${Utils.escapeHtml(data.reason || '')}
      </p>`;
    
    // 名前表示
    const showName = this.state.displayMode === 'named';
    this.elements.modalStudentName.textContent = showName ? data.name : '';
    
    // リアクションボタン
    this.elements.modalReactions.innerHTML = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const countHtml = this.state.showCounts ? 
        `<span class="reaction-count font-bold text-2xl text-gray-200">${info.count}</span>` : '';
      
      return `<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 text-${rt.color}-500${info.reacted ? ' liked' : ''}" 
        data-row-index="${rowIndex}" data-reaction="${rt.key}">
        ${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countHtml}
      </button>`;
    }).join('');
    
    // 表示アニメーション
    this.elements.answerModalContainer.classList.remove('hidden');
    
    if (window.gsap) {
      window.gsap.set(this.elements.answerModalContainer, { opacity: 0 });
      window.gsap.set(this.elements.answerModalCard, { scale: 0.7, y: 50, opacity: 0 });
      
      const tl = window.gsap.timeline();
      tl.to(this.elements.answerModalContainer, {
        opacity: 1,
        duration: 0.2,
        ease: "power2.out"
      })
      .to(this.elements.answerModalCard, {
        scale: 1,
        y: 0,
        opacity: 1,
        duration: 0.4,
        ease: "back.out(1.7)"
      }, "-=0.1")
      .call(() => this.elements.answerModalCloseBtn.focus());
    } else {
      this.elements.answerModalCloseBtn.focus();
    }
  }
  
  // モーダル非表示
  hideModal() {
    if (window.gsap) {
      const tl = window.gsap.timeline();
      tl.to(this.elements.answerModalCard, {
        scale: 0.7,
        y: 30,
        opacity: 0,
        duration: 0.25,
        ease: "power2.in"
      })
      .to(this.elements.answerModalContainer, {
        opacity: 0,
        duration: 0.15,
        ease: "power2.in"
      }, "-=0.1")
      .call(() => {
        this.elements.answerModalContainer.classList.add('hidden');
        if (this.state.lastFocusedElement) {
          this.state.lastFocusedElement.focus();
        }
      });
    } else {
      this.elements.answerModalContainer.classList.add('hidden');
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
  }
  
  // 情報モーダル非表示
  hideInfoModal() {
    if (window.gsap) {
      const tl = window.gsap.timeline();
      tl.to(this.elements.infoModalCard, {
        scale: 0.8,
        y: 25,
        opacity: 0,
        duration: 0.2,
        ease: "power2.in"
      })
      .to(this.elements.infoModalContainer, {
        opacity: 0,
        duration: 0.15,
        ease: "power2.in"
      }, "-=0.1")
      .call(() => {
        this.elements.infoModalContainer.classList.add('hidden');
        localStorage.setItem('introSeen', '1');
        if (this.state.lastFocusedElement) {
          this.state.lastFocusedElement.focus();
        }
      });
    } else {
      this.elements.infoModalContainer.classList.add('hidden');
      localStorage.setItem('introSeen', '1');
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
  }
  
  // 管理者モード切り替え
  async toggleAdminMode() {
    const enable = !this.state.showAdminFeatures;
    
    if (enable) {
      try {
        const ok = await this.runGas('checkAdmin');
        if (!ok) {
          console.warn('管理者権限がありません');
          return;
        }
      } catch (e) {
        console.error('権限確認エラー:', e);
        return;
      }
    }
    
    // 状態更新
    this.state.showAdminFeatures = enable;
    this.state.showHighlightToggle = enable;
    this.state.showCounts = enable;
    this.state.displayMode = enable ? 'named' : 'anonymous';
    
    this.updateAdminButtonText();
    await this.loadSheetData(true, true);
  }
  
  // 管理者ボタンテキスト更新
  updateAdminButtonText() {
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
    }
    if (this.elements.modeLabel) {
      this.elements.modeLabel.textContent = this.state.showAdminFeatures ? '管理モード' : '閲覧モード';
    }
  }
  
  // プレビューモード切り替え
  togglePreviewMode() {
    if (this.state.displayMode === 'anonymous') {
      // 学生→管理者
      this.state.isStudentMode = false;
      this.state.showCounts = true;
      this.state.showAdminFeatures = true;
      this.state.showHighlightToggle = true;
      this.state.displayMode = 'named';
      this.elements.modeToggleBtn.textContent = '学生';
      this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-red-600 hover:bg-red-700 text-white text-sm';
    } else {
      // 管理者→学生
      this.state.isStudentMode = true;
      this.state.showCounts = false;
      this.state.showAdminFeatures = false;
      this.state.showHighlightToggle = false;
      this.state.displayMode = 'anonymous';
      this.elements.modeToggleBtn.textContent = '管理者';
      this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-blue-600 hover:bg-blue-700 text-white text-sm';
    }
    
    this.loadSheetData(true);
  }
  
  // アイコン取得
  getIcon(name, classes = '', solid = false) {
    const icons = {
      'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
      'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
      'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
      'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
      'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
      'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
      'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>',
      'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>'
    };
    
    const key = solid && icons[`${name}-solid`] ? `${name}-solid` : 
                icons[`${name}-outline`] ? `${name}-outline` : name;
    
    return `<span aria-hidden="true" class="${classes}">${icons[key] || ''}</span>`;
  }
  
  // スケルトン表示
  showSkeletons() {
    const container = this.elements.answers;
    const count = this.state.gridColumns * CONFIG.RENDER.SKELETON_COUNT_MULTIPLIER;
    
    container.innerHTML = '';
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < count; i++) {
      const skeleton = document.createElement('div');
      skeleton.className = 'answer-card glass-panel rounded-xl p-4 skeleton';
      skeleton.innerHTML = `
        <div class="flex-1 space-y-3">
          <div class="h-6 w-3/4 rounded bg-gray-500/30"></div>
          <div class="h-4 w-full rounded bg-gray-500/20"></div>
          <div class="h-4 w-5/6 rounded bg-gray-500/20"></div>
        </div>
        <div class="mt-4 h-8 rounded bg-gray-500/20"></div>`;
      fragment.appendChild(skeleton);
    }
    
    container.appendChild(fragment);
  }
  
  // エラー表示
  showError(message) {
    const container = this.elements.answers;
    container.innerHTML = `
      <div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">
        <p class="font-bold">データの読み込みに失敗しました。</p>
        <p class="text-sm mt-2">${Utils.escapeHtml(message)}</p>
        <button onclick="window.studyQuestApp.loadInitialData()" 
          class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">
          再試行
        </button>
      </div>`;
  }
  
  // ポーリング開始
  startPolling() {
    this.stopPolling();
    this.pollingTimer = setInterval(() => {
      this.loadSheetData(false);
    }, CONFIG.POLLING.INTERVAL_MS);
  }
  
  // ポーリング停止
  stopPolling() {
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
      this.pollingTimer = null;
    }
  }
  
  // クリーンアップ
  destroy() {
    this.stopPolling();
    // イベントリスナーの削除などのクリーンアップ処理
  }
}

// ==================== アプリケーション起動 ====================
document.addEventListener('DOMContentLoaded', () => {
  // 既存インスタンスのクリーンアップ
  if (window.studyQuestApp?.destroy) {
    window.studyQuestApp.destroy();
  }
  
  // 新規インスタンス作成
  window.studyQuestApp = new StudyQuestApp();
  
  // ページアンロード時のクリーンアップ
  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp?.destroy) {
      window.studyQuestApp.destroy();
    }
  });
});

// デバッグモードのログ出力
if (CONFIG.DEBUG) {
  console.log('StudyQuest App - Optimized Version Loaded');
}
</script>