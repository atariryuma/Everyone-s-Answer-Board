  <script>
    'use strict';
    
    const CONFIG = Object.freeze({
      CACHE_DURATION: 120000,      // 2分キャッシュ
      POLLING_INTERVAL: 90000,     // 90秒ポーリング
      SEARCH_DEBOUNCE: 400,        // 400ms検索デバウンス
      ANIMATION_DURATION: 300,     // 300msアニメーション
      MAX_DISPLAY_COLUMNS: 6,      // 最大表示列数
      MIN_DISPLAY_COLUMNS: 1       // 最小表示列数
    });
    
    const getSecureVars = () => ({
      showAdminFeatures: !!window.showAdminFeatures,
      isAdminUser: !window.isStudentMode,
      userId: window.userId || null
    });
    
    const ICONS = Object.freeze({
      lightbulb: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2m8.66-10H20M4 12H2m15.07-7.07L17.66 6.34M6.34 6.34L4.93 4.93m12.14 12.14L15.66 15.66M6.34 17.66L4.93 19.07"/></svg>',
      thumbup: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M7 10v12l5-3 5 3V10l-5-8-5 8z"/></svg>',
      search: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/><path d="M11 8v6M8 11h6"/></svg>',
      x: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>',
      star: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26 12,2"/></svg>',
      grid: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18"/><path d="M12 3v18M3 12h18"/></svg>',
      users: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
    });
    
    /**
     * FilterManager - フィルタリング機能専門クラス
     * 教育現場での重要な機能（クラス絞り込み、検索、ソート）を管理
     */
    class FilterManager {
      constructor() {
        this.filters = {
          classFilter: '',
          searchQuery: '',
          sortOrder: 'newest'
        };
        this.originalData = [];
        this.filteredData = [];
        this.availableClasses = new Set();
      }

      setData(data) {
        this.originalData = data || [];
        this.extractAvailableClasses();
        this.updateClassFilter();
        this.applyFilters();
      }

      extractAvailableClasses() {
        this.availableClasses.clear();
        this.originalData.forEach(item => {
          if (item.class && typeof item.class === 'string' && item.class.trim()) {
            this.availableClasses.add(item.class.trim());
          }
        });
      }

      updateClassFilter() {
        const classFilterEl = document.getElementById('classFilter');
        if (!classFilterEl) return;

        const currentValue = classFilterEl.value;
        const firstOption = classFilterEl.querySelector('option[value=""]');
        classFilterEl.innerHTML = '';
        if (firstOption) {
          classFilterEl.appendChild(firstOption);
        }

        const sortedClasses = Array.from(this.availableClasses).sort();
        sortedClasses.forEach(className => {
          const option = document.createElement('option');
          option.value = className;
          option.textContent = className;
          classFilterEl.appendChild(option);
        });

        classFilterEl.value = currentValue;
      }

      setFilter(filterType, value) {
        if (this.filters.hasOwnProperty(filterType)) {
          this.filters[filterType] = value;
          this.applyFilters();
        }
      }

      clearFilters() {
        this.filters = {
          classFilter: '',
          searchQuery: '',
          sortOrder: 'newest'
        };

        const elements = {
          classFilter: document.getElementById('classFilter'),
          searchInput: document.getElementById('searchInput'),
          sortOrder: document.getElementById('sortOrder')
        };

        Object.entries(elements).forEach(([key, element]) => {
          if (element) {
            element.value = key === 'sortOrder' ? 'newest' : '';
          }
        });

        this.applyFilters();
      }

      applyFilters() {
        let filtered = [...this.originalData];

        if (this.filters.classFilter) {
          filtered = filtered.filter(item => 
            item.class && item.class.trim() === this.filters.classFilter
          );
        }

        if (this.filters.searchQuery) {
          const query = this.filters.searchQuery.toLowerCase().trim();
          filtered = filtered.filter(item => {
            return (
              (item.opinion && item.opinion.toLowerCase().includes(query)) ||
              (item.reason && item.reason.toLowerCase().includes(query)) ||
              (item.name && item.name.toLowerCase().includes(query)) ||
              (item.class && item.class.toLowerCase().includes(query))
            );
          });
        }

        switch (this.filters.sortOrder) {
          case 'newest':
            filtered.sort((a, b) => (b.rowIndex || 0) - (a.rowIndex || 0));
            break;
          case 'reactions':
            filtered.sort((a, b) => {
              const reactionA = this.getTotalReactions(a);
              const reactionB = this.getTotalReactions(b);
              return reactionB - reactionA;
            });
            break;
        }

        this.filteredData = filtered;
        return filtered;
      }

      getTotalReactions(item) {
        if (!item.reactions) return 0;
        return Object.values(item.reactions).reduce((total, reaction) => {
          return total + (reaction.count || 0);
        }, 0);
      }

      getFilteredData() {
        return this.filteredData;
      }

      getFilterStatus() {
        const hasFilters = Object.values(this.filters).some(value => 
          value && value !== 'newest'
        );
        
        return {
          hasFilters,
          totalItems: this.originalData.length,
          filteredItems: this.filteredData.length,
          filters: { ...this.filters }
        };
      }
    }

    /**
     * AnswerApp - メインアプリケーション制御クラス
     * データ管理、状態管理、API通信を統合
     */
    class AnswerApp {
      constructor() {
        this.vars = getSecureVars();
        this.config = null;
        this.answers = [];
        this.isLoading = false;
        this.pollingInterval = null;
        this.cache = new Map();
        this.cacheTimers = new Map();
        this.isProduction = typeof google !== 'undefined' && google.script?.run;
        
        this.answerRenderer = new AnswerRenderer();
        this.filterManager = new FilterManager();
        
        this.init();
      }
      
      async init() {
        try {
          const [config] = await Promise.all([
            this.loadConfig(),
            this.setupUI(),
            this.setupEventListeners()
          ]);
          
          this.config = config;
          await this.loadAnswers();
          this.startPolling();
          
        } catch (error) {
          this.handleError('初期化エラー', error);
        }
      }
      
      async loadConfig() {
        const cacheKey = `config_${this.vars.userId}`;
        const cached = this.getCache(cacheKey);
        if (cached) return cached;
        
        try {
          const config = await this.callGAS('getUserConfig', this.vars.userId) || {};
          this.setCache(cacheKey, config, CONFIG.CACHE_DURATION);
          return config;
        } catch (error) {
          console.error('設定読み込みエラー:', error);
          return {};
        }
      }
      
      async loadAnswers(sortOrder = 'newest') {
        if (this.isLoading) return;
        this.isLoading = true;
        
        try {
          const rawData = await this.callGAS('getPublishedSheetData', this.vars.userId, 'すべて', sortOrder);
          
          if (!rawData?.data && !rawData?.rows) {
            const emptyResult = {
              answers: [],
              header: rawData?.header || '問題',
              sheetName: rawData?.sheetName || '不明'
            };
            this.updateUI(emptyResult);
            return;
          }
          
          const data = rawData.data || rawData.rows || [];
          const answers = data
            .filter(item => item?.opinion)
            .map(item => this.normalizeAnswer(item))
            .filter(answer => answer.opinion);
          
          const result = {
            answers,
            header: rawData.header || '問題',
            sheetName: rawData.sheetName || '不明'
          };
          
          this.answers = result.answers;
          this.updateUI(result);
          
        } catch (error) {
          this.handleError('データロードエラー', error);
        } finally {
          this.isLoading = false;
        }
      }
      
      async updateReaction(rowIndex, reactionKey) {
        return await this.callGAS('addReaction', this.vars.userId, rowIndex, reactionKey);
      }
      
      updateUI(data) {
        this.filterManager.setData(data.answers);
        this.answerRenderer.updateHeader(data.header, data.sheetName);
        this.renderFilteredResults();
      }
      
      renderFilteredResults() {
        const filteredData = this.filterManager.getFilteredData();
        const status = this.filterManager.getFilterStatus();
        
        this.answerRenderer.renderAnswers(filteredData);
        this.answerRenderer.updateAnswerCount(status.filteredItems);
        this.updateFilterStatusDisplay(status);
      }
      
      normalizeAnswer(item) {
        return {
          rowIndex: parseInt(item.rowIndex) || 1,
          opinion: String(item.opinion || '').trim(),
          reason: String(item.reason || '').trim(),
          name: String(item.name || '').trim(),
          class: String(item.class || '').trim(),
          email: String(item.email || '').trim(),
          reactions: this.normalizeReactions(item.reactions),
          highlight: Boolean(item.highlight),
          timestamp: item.timestamp || new Date().toISOString()
        };
      }
      
      normalizeReactions(reactions) {
        const defaults = {
          UNDERSTAND: { count: 0, reacted: false },
          LIKE: { count: 0, reacted: false },
          CURIOUS: { count: 0, reacted: false }
        };
        
        if (!reactions) return defaults;
        
        const normalized = {};
        for (const [key, defaultValue] of Object.entries(defaults)) {
          normalized[key] = {
            count: Math.max(0, parseInt(reactions[key]?.count) || 0),
            reacted: Boolean(reactions[key]?.reacted)
          };
        }
        
        return normalized;
      }
      
      callGAS(funcName, ...args) {
        return new Promise((resolve, reject) => {
          if (this.isProduction) {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              [funcName](...args);
          } else {
            this.mockResponse(funcName, resolve);
          }
        });
      }
      
      mockResponse(funcName, resolve) {
        setTimeout(() => {
          if (funcName === 'getPublishedSheetData') {
            resolve({
              header: 'テスト問題: あなたが思う理想的な学習方法は？',
              sheetName: 'テスト回答シート',
              data: [
                {
                  rowIndex: 1, name: '田中太郎', class: '3年A組',
                  opinion: 'グループでの討論を通じて、互いの意見を交換しながら学ぶことが効果的だと思います。',
                  reason: '一人で勉強するよりも、他の人の考えを聞くことで新しい視点を得られるからです。',
                  reactions: { UNDERSTAND: {count: 8, reacted: false}, LIKE: {count: 12, reacted: true}, CURIOUS: {count: 3, reacted: false} },
                  highlight: true
                },
                {
                  rowIndex: 2, name: '佐藤花子', class: '3年B組',
                  opinion: '実際の体験や実験を通じて、手を動かしながら学ぶことが大切です。',
                  reason: '本や資料だけでは理解しにくいことも、体験することで記憶に残りやすくなります。',
                  reactions: { UNDERSTAND: {count: 15, reacted: true}, LIKE: {count: 6, reacted: false}, CURIOUS: {count: 9, reacted: false} },
                  highlight: false
                }
              ]
            });
          } else if (funcName === 'addReaction') {
            resolve({ success: true, count: Math.floor(Math.random() * 20) + 1 });
          } else if (funcName === 'getUserConfig') {
            resolve({ displaySettings: { showName: true, showClass: true, showEmail: false } });
          } else {
            resolve({});
          }
        }, 200 + Math.random() * 300);
      }
      
      setCache(key, value, ttl) {
        this.cache.set(key, value);
        
        if (ttl) {
          const timer = setTimeout(() => {
            this.cache.delete(key);
            this.cacheTimers.delete(key);
          }, ttl);
          
          if (this.cacheTimers.has(key)) {
            clearTimeout(this.cacheTimers.get(key));
          }
          this.cacheTimers.set(key, timer);
        }
      }
      
      getCache(key) {
        return this.cache.get(key);
      }
      
      clearCache() {
        this.cache.clear();
        this.cacheTimers.forEach(timer => clearTimeout(timer));
        this.cacheTimers.clear();
      }
      
      setupUI() {
        this.answerRenderer.renderIcons();
        this.updateUIState();
        return Promise.resolve();
      }
      
      setupEventListeners() {
        // スライダーイベント
        const slider = document.getElementById('sizeSlider');
        if (slider) {
          slider.addEventListener('input', () => {
            localStorage.setItem('boardColumns', slider.value);
            this.answerRenderer.updateGridColumns(slider.value);
          });
          
          const saved = localStorage.getItem('boardColumns');
          if (saved) {
            slider.value = saved;
            this.answerRenderer.updateGridColumns(saved);
          }
        }
        
        // フィルターイベント
        this.setupFilterEvents();
        
        // コンテナイベント
        const container = document.getElementById('answers');
        if (container) {
          container.addEventListener('click', (e) => {
            const btn = e.target.closest('.reaction-btn');
            const card = e.target.closest('.answer-card');
            
            if (btn) {
              e.stopPropagation();
              const rowIndex = parseInt(btn.dataset.rowIndex);
              const reaction = btn.dataset.reaction;
              if (rowIndex && reaction) {
                this.handleReaction(rowIndex, reaction, btn);
              }
            } else if (card && !btn) {
              const rowIndex = parseInt(card.dataset.rowIndex);
              if (rowIndex) this.showModal(rowIndex);
            }
          });
        }
        
        // 管理者切り替え
        const adminBtn = document.getElementById('adminToggleBtn');
        if (adminBtn) {
          adminBtn.addEventListener('click', () => {
            window.location.href = window.location.href.replace('mode=view', 'mode=admin');
          });
        }
        
        // キーボードイベント
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const modal = document.getElementById('answerModalContainer');
            if (modal && !modal.classList.contains('hidden')) {
              modal.classList.add('opacity-0');
              setTimeout(() => modal.classList.add('hidden'), CONFIG.ANIMATION_DURATION);
            }
          }
        });
        
        return Promise.resolve();
      }
      
      setupFilterEvents() {
        const classFilter = document.getElementById('classFilter');
        if (classFilter) {
          classFilter.addEventListener('change', (e) => {
            this.filterManager.setFilter('classFilter', e.target.value);
            this.renderFilteredResults();
          });
        }
        
        // 検索入力（デバウンス付き）
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          let debounceTimer;
          searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
              this.filterManager.setFilter('searchQuery', e.target.value);
              this.renderFilteredResults();
            }, CONFIG.SEARCH_DEBOUNCE);
          });
        }
        
        // ソート順変更
        const sortOrder = document.getElementById('sortOrder');
        if (sortOrder) {
          sortOrder.addEventListener('change', (e) => {
            this.loadAnswers(e.target.value);
          });
        }
        
        // フィルタクリアボタン
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        if (clearFiltersBtn) {
          clearFiltersBtn.addEventListener('click', () => {
            this.filterManager.clearFilters();
            this.renderFilteredResults();
          });
        }
      }
      
      updateUIState() {
        const adminBtn = document.getElementById('adminToggleBtn');
        const modeLabel = document.getElementById('modeLabel');
        
        if (adminBtn && this.vars.showAdminFeatures && this.vars.isAdminUser) {
          adminBtn.classList.remove('hidden');
          adminBtn.textContent = '管理パネル';
        }
        
        if (modeLabel) {
          modeLabel.textContent = this.vars.isAdminUser ? '管理者' : '学習者';
        }
      }
      
      updateFilterStatusDisplay(status) {
        const answerCount = document.getElementById('answerCount');
        if (answerCount) {
          const filterText = status.hasFilters 
            ? `${status.filteredItems}/${status.totalItems} 件` 
            : `${status.totalItems} 件`;
          
          answerCount.innerHTML = `
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
              <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
            </svg>
            ${filterText}
            ${status.hasFilters ? '<span class="text-cyan-400">（フィルタ中）</span>' : ''}
          `;
        }
        
        // クリアボタンの表示制御
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        if (clearFiltersBtn) {
          clearFiltersBtn.style.display = status.hasFilters ? 'block' : 'none';
        }
      }
      
      // リアクション処理
      async handleReaction(rowIndex, reactionKey, btn) {
        if (btn.classList.contains('loading')) return;
        
        try {
          btn.classList.add('loading');
          
          const result = await this.updateReaction(rowIndex, reactionKey);
          
          if (result.success) {
            // カウント更新
            const countEl = btn.querySelector('span');
            if (countEl) {
              countEl.textContent = result.count || 0;
            }
            
            // 状態更新
            const wasReacted = btn.classList.contains('reacted');
            btn.classList.toggle('reacted', !wasReacted);
            btn.classList.toggle('liked', !wasReacted);
            
            // アニメーション
            this.answerRenderer.animateReactionSuccess(btn);
            
            // 同じ行の他のボタンも更新
            const card = btn.closest('.answer-card');
            if (card) {
              const allReactionBtns = card.querySelectorAll('.reaction-btn');
              allReactionBtns.forEach(otherBtn => {
                if (otherBtn.dataset.reaction === reactionKey && otherBtn !== btn) {
                  const otherCountEl = otherBtn.querySelector('span');
                  if (otherCountEl) {
                    otherCountEl.textContent = result.count || 0;
                  }
                  otherBtn.classList.toggle('reacted', !wasReacted);
                  otherBtn.classList.toggle('liked', !wasReacted);
                }
              });
            }
            
          } else {
            this.showUserError(result.message || 'リアクションに失敗しました');
          }
          
        } catch (error) {
          console.error('リアクションエラー:', error);
          this.handleError('リアクション処理エラー', error);
        } finally {
          btn.classList.remove('loading');
        }
      }
      
      // モーダル表示
      showModal(rowIndex) {
        const answer = this.answers.find(a => a.rowIndex === rowIndex);
        if (answer) {
          this.answerRenderer.showModal(answer);
        }
      }
      
      // ポーリング開始
      startPolling() {
        // 90秒間隔でポーリング
        this.pollingInterval = setInterval(() => {
          if (!document.hidden) {
            this.loadAnswers();
          }
        }, CONFIG.POLLING_INTERVAL);
        
        // ページの可視性変化に応じてポーリング制御
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            if (this.pollingInterval) {
              clearInterval(this.pollingInterval);
              this.pollingInterval = null;
            }
          } else if (!this.pollingInterval) {
            this.startPolling();
          }
        });
      }
      
      handleError(context, error) {
        const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname.includes('script.google.com');
        
        console.error(`[エラー] ${context}:`, {
          message: error.message,
          stack: isDevelopment ? error.stack : undefined,
          timestamp: new Date().toISOString(),
          userId: this.vars.userId,
          userAgent: navigator.userAgent.substring(0, 100)
        });
        
        const userMessage = isDevelopment 
          ? `${context}: ${error.message}` 
          : 'システムエラーが発生しました。時間をおいて再度お試しください。';
          
        this.showUserError(userMessage);
      }
      
      // ユーザー向けエラー表示
      showUserError(message) {
        const existing = document.querySelector('.error-notification');
        if (existing) existing.remove();
        
        const notification = document.createElement('div');
        notification.className = 'error-notification fixed top-4 right-4 bg-red-600 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm opacity-0 transform translate-x-full transition-all duration-300';
        notification.innerHTML = `
          <div class="flex items-center gap-2">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <span class="flex-1">${message}</span>
            <button class="ml-2 hover:bg-red-700 rounded p-1" onclick="this.parentElement.parentElement.remove()">
              <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        `;
        
        document.body.appendChild(notification);
        
        requestAnimationFrame(() => {
          notification.classList.remove('opacity-0', 'translate-x-full');
        });
        setTimeout(() => {
          if (notification.parentNode) {
            notification.classList.add('opacity-0', 'translate-x-full');
            setTimeout(() => notification.remove(), 300);
          }
        }, 8000);
      }
      
      // 破棄処理
      destroy() {
        // ポーリング停止
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        }
        
        // キャッシュクリア
        this.clearCache();
      }
    }


    /**
     * AnswerRenderer - DOM操作・レンダリング専門クラス
     */
    class AnswerRenderer {
      constructor() {
        this.reactions = [
          {key: 'LIKE', icon: 'thumbup', color: 'red'},
          {key: 'UNDERSTAND', icon: 'lightbulb', color: 'yellow'},
          {key: 'CURIOUS', icon: 'search', color: 'green'}
        ];
      }
      
      // 回答一覧レンダリング
      renderAnswers(answers) {
        const container = document.getElementById('answers');
        if (!container) return;
        
        container.innerHTML = '';
        
        answers.forEach((answer, index) => {
          const card = this.createAnswerCard(answer);
          container.appendChild(card);
          
          // ネイティブCSS アニメーション
          card.style.opacity = '0';
          card.style.transform = 'translateY(20px)';
          
          setTimeout(() => {
            card.style.transition = `opacity ${CONFIG.ANIMATION_DURATION}ms ease-out, transform ${CONFIG.ANIMATION_DURATION}ms ease-out`;
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, index * 50);
        });
      }
      
      // 回答カード作成
      createAnswerCard(answer) {
        const card = document.createElement('div');
        card.className = `answer-card glass-panel rounded-xl p-4 flex flex-col shadow-lg border-2 border-cyan-400/80 cursor-pointer${answer.highlight ? ' highlighted' : ''}`;
        card.dataset.rowIndex = answer.rowIndex;
        card.tabIndex = 0;
        
        // コンテンツ
        const content = document.createElement('div');
        content.className = 'flex-grow mb-3';
        
        const opinion = document.createElement('h3');
        opinion.className = 'text-cyan-200 text-xl font-semibold leading-tight mb-2';
        opinion.textContent = answer.opinion;
        content.appendChild(opinion);
        
        if (answer.reason) {
          const reason = document.createElement('p');
          reason.className = 'text-gray-100 mt-2';
          reason.textContent = answer.reason;
          content.appendChild(reason);
        }
        
        card.appendChild(content);
        
        // フッター
        const footer = document.createElement('div');
        footer.className = 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-between items-center';
        
        // ID情報
        const identity = this.createIdentity(answer);
        if (identity) footer.appendChild(identity);
        
        // リアクション
        const reactions = document.createElement('div');
        reactions.className = 'flex items-center gap-1';
        
        this.reactions.forEach(r => {
          const btn = this.createReactionButton(answer, r);
          reactions.appendChild(btn);
        });
        
        footer.appendChild(reactions);
        card.appendChild(footer);
        
        // ハイライトバッジ
        if (answer.highlight) {
          const badge = document.createElement('span');
          badge.className = 'absolute top-1 right-1 text-yellow-300';
          badge.appendChild(this.createIcon('star', 'w-6 h-6'));
          card.appendChild(badge);
        }
        
        return card;
      }
      
      // ID情報作成
      createIdentity(answer) {
        const config = window.answerController?.config?.displaySettings || {};
        const parts = [];
        
        if (config.showName && answer.name) parts.push(answer.name);
        if (config.showClass && answer.class) parts.push(`(${answer.class})`);
        if (config.showEmail && answer.email) parts.push(answer.email);
        
        if (!parts.length) return null;
        
        const div = document.createElement('div');
        div.className = 'text-sm text-gray-200';
        div.textContent = parts.join(' ');
        return div;
      }
      
      // リアクションボタン作成
      createReactionButton(answer, reaction) {
        const info = answer.reactions[reaction.key] || {count: 0, reacted: false};
        const btn = document.createElement('button');
        
        btn.type = 'button';
        btn.dataset.rowIndex = answer.rowIndex;
        btn.dataset.reaction = reaction.key;
        btn.className = this.getReactionClass(reaction.color, info.reacted);
        
        btn.appendChild(this.createIcon(reaction.icon, 'w-4 h-4'));
        
        const count = document.createElement('span');
        count.className = 'ml-1 text-xs';
        count.textContent = info.count;
        btn.appendChild(count);
        
        return btn;
      }
      
      // リアクションクラス取得
      getReactionClass(color, reacted) {
        const base = 'reaction-btn flex items-center px-2 py-1 rounded border-2 transition-all ';
        if (reacted) {
          return base + `bg-${color}-500/20 border-${color}-500 text-${color}-400`;
        }
        return base + `bg-transparent border-${color}-500/30 text-${color}-500/60 hover:bg-${color}-500/10`;
      }
      
      /**
       * 🖼️ アイコン作成
       */
      createIcon(name, classes = '') {
        const svg = ICONS[name];
        if (!svg) return document.createElement('span');
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');
        const element = doc.documentElement;
        
        if (classes) element.className = classes;
        element.setAttribute('aria-hidden', 'true');
        
        return element;
      }
      
      /**
       * 📊 グリッド列数更新
       */
      updateGridColumns(columnCount) {
        const container = document.getElementById('answers');
        const sliderValue = document.getElementById('sliderValue');
        
        if (container && sliderValue) {
          const validColumns = [1, 2, 3, 4, 5, 6];
          const columns = validColumns.includes(parseInt(columnCount)) ? parseInt(columnCount) : 4;
          sliderValue.textContent = columns;
          container.className = `grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-${columns}`;
        }
      }
      
      /**
       * 📊 回答数更新
       */
      updateAnswerCount(count) {
        const el = document.getElementById('answerCount');
        if (el) {
          el.innerHTML = '';
          el.appendChild(this.createIcon('users', 'w-4 h-4 mr-2'));
          el.appendChild(document.createTextNode(`${count}件`));
        }
      }
      
      /**
       * 📝 ヘッダー更新
       */
      updateHeader(header, sheetName) {
        const headingEl = document.getElementById('headingLabel');
        const sheetEl = document.getElementById('sheetNameText');
        
        if (headingEl) headingEl.textContent = header;
        if (sheetEl) sheetEl.textContent = 'シート: ' + sheetName;
      }
      
      // リアクションアニメーション
      animateReactionSuccess(button) {
        button.style.transition = 'transform 0.2s ease-out';
        button.style.transform = 'scale(1.2)';
        
        setTimeout(() => {
          button.style.transform = 'scale(1)';
        }, 200);
        
        setTimeout(() => {
          button.style.transition = '';
        }, 400);
      }
      
      // モーダル表示
      showModal(answer) {
        const modal = document.getElementById('answerModalContainer');
        const modalContent = document.getElementById('modalAnswer');
        const modalName = document.getElementById('modalStudentName');
        const modalReactions = document.getElementById('modalReactions');
        
        if (!modal || !modalContent) return;
        
        // コンテンツ設定
        modalContent.innerHTML = `
          <h2 class="text-2xl font-bold text-cyan-200 mb-4">回答内容</h2>
          <p class="text-xl leading-relaxed mb-4">${answer.opinion}</p>
          ${answer.reason ? `
            <h3 class="text-lg font-semibold text-cyan-400 mb-2">理由・根拠</h3>
            <p class="text-gray-200 leading-relaxed">${answer.reason}</p>
          ` : ''}
        `;
        
        if (modalName) {
          modalName.textContent = answer.name || '匿名';
        }
        
        // リアクションボタン作成
        if (modalReactions) {
          modalReactions.innerHTML = '';
          this.reactions.forEach(r => {
            const btn = this.createReactionButton(answer, r);
            modalReactions.appendChild(btn);
          });
        }
        
        // モーダル表示
        modal.classList.remove('hidden');
        requestAnimationFrame(() => {
          modal.classList.remove('opacity-0');
        });
        
        // クローズイベント
        this.setupModalCloseEvents(modal);
      }
      
      /**
       * ✖️ モーダルクローズイベント
       */
      setupModalCloseEvents(modal) {
        const closeModal = () => {
          modal.classList.add('opacity-0');
          setTimeout(() => modal.classList.add('hidden'), 300);
        };
        
        // ESCキー
        const handleEsc = (e) => {
          if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', handleEsc);
          }
        };
        document.addEventListener('keydown', handleEsc);
        
        // 背景クリック
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeModal();
        }, { once: true });
        
        // クローズボタン
        const closeBtn = document.getElementById('answerModalCloseBtn');
        if (closeBtn) {
          closeBtn.addEventListener('click', closeModal, { once: true });
        }
      }
      
      /**
       * 🖼️ アイコン初期化
       */
      renderIcons() {
        const iconConfigs = [
          ['answerModalCloseBtn', 'x', 'w-6 h-6'],
          ['footerIcon', 'grid', 'w-4 h-4'],
          ['infoIconLike', 'thumbup', 'w-5 h-5'],
          ['infoIconUnderstand', 'lightbulb', 'w-5 h-5'],
          ['infoIconCurious', 'search', 'w-5 h-5'],
          ['infoIconHighlight', 'star', 'w-5 h-5']
        ];
        
        iconConfigs.forEach(([elementId, iconName, className]) => {
          const element = document.getElementById(elementId);
          if (element) {
            element.innerHTML = '';
            const icon = this.createIcon(iconName, className);
            element.appendChild(icon);
          }
        });
      }
    }
    
    // アプリケーション初期化
    try {
      if (window.answerController?.destroy) {
        window.answerController.destroy();
      }
      window.answerController = new AnswerApp();
      
      window.addEventListener('beforeunload', () => {
        window.answerController?.destroy();
      });
      
      setupUI() {
        this.answerRenderer.renderIcons();
        this.updateUIState();
        return Promise.resolve();
      }
      
      setupEventListeners() {
        // スライダーイベント
        const slider = document.getElementById('sizeSlider');
        if (slider) {
          slider.addEventListener('input', () => {
            localStorage.setItem('boardColumns', slider.value);
            this.answerRenderer.updateGridColumns(slider.value);
          });
          
          const saved = localStorage.getItem('boardColumns');
          if (saved) {
            slider.value = saved;
            this.answerRenderer.updateGridColumns(saved);
          }
        }
        
        // フィルターイベント
        this.setupFilterEvents();
        
        // コンテナイベント
        const container = document.getElementById('answers');
        if (container) {
          container.addEventListener('click', (e) => {
            const btn = e.target.closest('.reaction-btn');
            const card = e.target.closest('.answer-card');
            
            if (btn) {
              e.stopPropagation();
              const rowIndex = parseInt(btn.dataset.rowIndex);
              const reaction = btn.dataset.reaction;
              if (rowIndex && reaction) {
                this.handleReaction(rowIndex, reaction, btn);
              }
            } else if (card && !btn) {
              const rowIndex = parseInt(card.dataset.rowIndex);
              if (rowIndex) this.showModal(rowIndex);
            }
          });
        }
        
        // 管理者切り替え
        const adminBtn = document.getElementById('adminToggleBtn');
        if (adminBtn) {
          adminBtn.addEventListener('click', () => {
            window.location.href = window.location.href.replace('mode=view', 'mode=admin');
          });
        }
        
        // キーボードイベント
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const modal = document.getElementById('answerModalContainer');
            if (modal && !modal.classList.contains('hidden')) {
              modal.classList.add('opacity-0');
              setTimeout(() => modal.classList.add('hidden'), 300);
            }
          }
        });
        
        return Promise.resolve();
      }
      
      setupFilterEvents() {
        const classFilter = document.getElementById('classFilter');
        if (classFilter) {
          classFilter.addEventListener('change', (e) => {
            this.filterManager.setFilter('classFilter', e.target.value);
            this.renderFilteredResults();
          });
        }
        
        // リアクション数フィルタ
        const reactionFilter = document.getElementById('reactionFilter');
        if (reactionFilter) {
          reactionFilter.addEventListener('change', (e) => {
            this.filterManager.setFilter('reactionFilter', e.target.value);
            this.renderFilteredResults();
          });
        }
        
        // 検索入力（デバウンス付き）
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          let debounceTimer;
          searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
              this.filterManager.setFilter('searchQuery', e.target.value);
              this.renderFilteredResults();
            }, 300);
          });
        }
        
        // ソート順変更
        const sortOrder = document.getElementById('sortOrder');
        if (sortOrder) {
          sortOrder.addEventListener('change', (e) => {
            this.loadAnswers(e.target.value);
          });
        }
        
        // フィルタクリアボタン
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        if (clearFiltersBtn) {
          clearFiltersBtn.addEventListener('click', () => {
            this.filterManager.clearFilters();
            this.renderFilteredResults();
          });
        }
      }
      
      updateUIState() {
        const adminBtn = document.getElementById('adminToggleBtn');
        const modeLabel = document.getElementById('modeLabel');
        
        if (adminBtn && this.vars.showAdminFeatures && this.vars.isAdminUser) {
          adminBtn.classList.remove('hidden');
          adminBtn.textContent = '管理パネル';
        }
        
        if (modeLabel) {
          modeLabel.textContent = this.vars.isAdminUser ? '管理者' : '学習者';
        }
      }
      
      async loadAnswers(sortOrder = 'newest') {
        if (this.isLoading) return;
        this.isLoading = true;
        
        try {
          const data = await this.answerService.loadAnswers(sortOrder);
          this.answers = data.answers;
          
          // FilterManagerにデータを設定
          this.filterManager.setData(data.answers);
          
          // UIRenderer更新
          this.answerRenderer.updateHeader(data.header, data.sheetName);
          this.renderFilteredResults();
          
        } catch (error) {
          this.handleError('データロードエラー', error);
        } finally {
          this.isLoading = false;
        }
      }
      
      renderFilteredResults() {
        const filteredData = this.filterManager.getFilteredData();
        const status = this.filterManager.getFilterStatus();
        
        // UIに反映
        this.answerRenderer.renderAnswers(filteredData);
        this.answerRenderer.updateAnswerCount(status.filteredItems);
        this.updateFilterStatusDisplay(status);
      }
      
      updateFilterStatusDisplay(status) {
        const answerCount = document.getElementById('answerCount');
        if (answerCount) {
          const filterText = status.hasFilters 
            ? `${status.filteredItems}/${status.totalItems} 件` 
            : `${status.totalItems} 件`;
          
          answerCount.innerHTML = `
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
              <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
            </svg>
            ${filterText}
            ${status.hasFilters ? '<span class="text-cyan-400">（フィルタ中）</span>' : ''}
          `;
        }
        
        // クリアボタンの表示制御
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        if (clearFiltersBtn) {
          clearFiltersBtn.style.display = status.hasFilters ? 'block' : 'none';
        }
      }
      
      async handleReaction(rowIndex, reactionKey, btn) {
        if (btn.classList.contains('loading')) return;
        
        try {
          btn.classList.add('loading');
          
          const result = await this.answerService.updateReaction(rowIndex, reactionKey);
          
          if (result.success) {
            // カウント更新
            const countEl = btn.querySelector('span');
            if (countEl) {
              countEl.textContent = result.count || 0;
            }
            
            // 状態更新
            const wasReacted = btn.classList.contains('reacted');
            btn.classList.toggle('reacted', !wasReacted);
            btn.classList.toggle('liked', !wasReacted);
            
            // アニメーション
            this.answerRenderer.animateReactionSuccess(btn);
            
            // 同じ行の他のボタンも更新
            const card = btn.closest('.answer-card');
            if (card) {
              const allReactionBtns = card.querySelectorAll('.reaction-btn');
              allReactionBtns.forEach(otherBtn => {
                if (otherBtn.dataset.reaction === reactionKey && otherBtn !== btn) {
                  const otherCountEl = otherBtn.querySelector('span');
                  if (otherCountEl) {
                    otherCountEl.textContent = result.count || 0;
                  }
                  otherBtn.classList.toggle('reacted', !wasReacted);
                  otherBtn.classList.toggle('liked', !wasReacted);
                }
              });
            }
            
          } else {
            this.showUserError(result.message || 'リアクションに失敗しました');
          }
          
        } catch (error) {
          console.error('リアクションエラー:', error);
          this.handleError('リアクション処理エラー', error);
        } finally {
          btn.classList.remove('loading');
        }
      }
      
      showModal(rowIndex) {
        const answer = this.answers.find(a => a.rowIndex === rowIndex);
        if (answer) {
          this.answerRenderer.showModal(answer);
        }
      }
      
      startPolling() {
        // 1分間隔でポーリング
        this.pollingInterval = setInterval(() => {
          if (!document.hidden) {
            this.loadAnswers();
          }
        }, 60000);
        
        // ページの可視性変化に応じてポーリング制御
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            if (this.pollingInterval) {
              clearInterval(this.pollingInterval);
              this.pollingInterval = null;
            }
          } else if (!this.pollingInterval) {
            this.startPolling();
          }
        });
      }
      
      
      destroy() {
        // ポーリング停止
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        }
        
        // キャッシュクリア
        if (this.answerService?.clearCache) {
          this.answerService.clearCache();
        }
      }
    }
    
    // Initialize app
    try {
      if (window.answerController?.destroy) {
        window.answerController.destroy();
      }
      window.answerController = new AnswerController();
      
      window.addEventListener('beforeunload', () => {
        window.answerController?.destroy();
      });
      
    } catch (error) {
      console.error('[初期化失敗]', {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString(),
        url: window.location.href
      });
      
      const container = document.getElementById('answers') || document.body;
      const errorDiv = document.createElement('div');
      errorDiv.className = 'fixed inset-0 bg-gray-900 text-white p-8 flex items-center justify-center z-50';
      errorDiv.innerHTML = `
        <div class="text-center max-w-md">
          <svg class="w-16 h-16 text-red-400 mx-auto mb-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="15" y1="9" x2="9" y2="15"></line>
            <line x1="9" y1="9" x2="15" y2="15"></line>
          </svg>
          <h2 class="text-xl font-bold mb-2">システムエラー</h2>
          <p class="text-gray-300 mb-4">アプリケーションの初期化に失敗しました。</p>
          <button onclick="window.location.reload()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white">
            再読み込み
          </button>
        </div>
      `;
      container.appendChild(errorDiv);
    }
  </script>