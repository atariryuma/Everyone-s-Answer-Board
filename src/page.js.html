<script>
  // === TEMPLATE LAYER - 2024 GAS Best Practice ===
  // 統一されたテンプレート変数受け取りシステム

  /**
   * 🦾 スマート診断システム - 問題を自動特定してユーザーに適切なガイダンスを提供
   */
  const smartDiagnosis = () => {
    const issues = [];
    const solutions = [];
    
    // 診断1: テンプレート展開状況
    if (!window.USER_ID || typeof window.USER_ID === 'object' || window.USER_ID.trim() === '') {
      issues.push('テンプレート変数が正しく展開されていません');
      solutions.push('🔄 ページをリロードしてください');
    }
    
    // 診断2: URLパラメータ状況  
    const urlUserId = new URLSearchParams(window.location.search).get('userId');
    if (!urlUserId) {
      issues.push('URLにユーザーIDが含まれていません');
      solutions.push('🔗 正しいリンクからアクセスしてください');
    }
    
    // 診断3: システム設定状況
    if (window.DIAGNOSTIC_INFO) {
      if (!window.DIAGNOSTIC_INFO.hasSpreadsheetId) {
        issues.push('データソース（スプレッドシート）が設定されていません');
        solutions.push('🛠️ 管理パネルでデータソースを接続してください');
      }
      if (!window.DIAGNOSTIC_INFO.hasSheetName) {
        issues.push('シート名が設定されていません');
        solutions.push('📊 管理パネルでシートを選択してください');
      }
    }
    
    return { issues, solutions, severity: issues.length > 0 ? 'needs_setup' : 'healthy' };
  };
  
  /**
   * ✅ configJSON中心型アーキテクチャ - 自動回復不要
   */
  const autoRecovery = async (diagnosis) => {
    return diagnosis.severity === 'healthy';
  };
  
  /**
   * 📱 ユーザーフレンドリーエラー表示
   */
  const showUserFriendlyError = (diagnosis) => {
    const container = this._getCachedElement('answersContainer');
    if (!container) return;
    
    const errorHtml = `
      <div class="setup-guide-container" style="max-width: 600px; margin: 2rem auto; padding: 2rem; background: #fff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <div class="setup-header" style="text-align: center; margin-bottom: 2rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">🛠️</div>
          <h2 style="color: #2563eb; margin-bottom: 0.5rem;">初期設定が必要です</h2>
          <p style="color: #6b7280;">回答ボードを使用するために、いくつかの設定が必要です。</p>
        </div>
        
        <div class="issues-list" style="margin-bottom: 2rem;">
          <h3 style="color: #dc2626; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <span>❌</span> 解決が必要な問題
          </h3>
          <ul style="list-style: none; padding: 0; margin-bottom: 2rem;">
            ${diagnosis.issues.map(issue => `
              <li style="padding: 0.75rem; margin-bottom: 0.5rem; background: #fef2f2; border-left: 4px solid #dc2626; border-radius: 4px;">
                ${issue}
              </li>
            `).join('')}
          </ul>
          
          <h3 style="color: #059669; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <span>✅</span> 推奨される解決策
          </h3>
          <ul style="list-style: none; padding: 0;">
            ${diagnosis.solutions.map(solution => `
              <li style="padding: 0.75rem; margin-bottom: 0.5rem; background: #ecfdf5; border-left: 4px solid #059669; border-radius: 4px;">
                ${solution}
              </li>
            `).join('')}
          </ul>
        </div>
        
        <div class="action-buttons" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
          <button onclick="window.location.reload()" 
                  style="padding: 0.75rem 1.5rem; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: flex; align-items: center; gap: 0.5rem;">
            🔄 ページをリロード
          </button>
          <button onclick="window.location.href = window.location.href.split('?')[0] + '?mode=admin&userId=' + (window.USER_ID || '')" 
                  style="padding: 0.75rem 1.5rem; background: #059669; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: flex; align-items: center; gap: 0.5rem;">
            🛠️ 管理パネルへ
          </button>
        </div>
        
        <div class="help-text" style="margin-top: 2rem; padding: 1rem; background: #f8fafc; border-radius: 6px; text-align: center; color: #64748b; font-size: 0.875rem;">
          📞 お困りの場合は管理者にお問い合わせください
        </div>
      </div>
    `;
    
    container.innerHTML = errorHtml;
  };
  
  /**
   * ✅ CLAUDE.md準拠: configJSONベース設定取得（スマート診断統合）
   * @returns {Promise<Object>} 設定オブジェクト
   */
  const getConfigFromBackend = async () => {
    // 🦾 スマート診断実行
    const diagnosis = smartDiagnosis();
    debugInfo('🦾 システム診断結果:', diagnosis);
    
    // 🎆 自動回復試行
    if (diagnosis.severity !== 'healthy') {
      const recovered = await autoRecovery(diagnosis);
      if (recovered) {
        debugInfo('✅ 自動回復成功 - 再診断を実行');
        return getConfigFromBackend(); // 再帰的再試行
      }
    }
    
    try {
      // 🚀 複数ソースからuserId取得（超効率化）
      let userId = new URLSearchParams(window.location.search).get('userId');
      
      // フォールバック1: 既存のCONFIGから取得
      if (!userId && CONFIG && CONFIG.userId) {
        userId = CONFIG.userId;
      }
      
      // フォールバック2: テンプレート変数から取得（GAS側で展開される可能性）
      if (!userId && window.USER_ID) {
        userId = window.USER_ID;
      }
      
      if (!userId) {
        // 📱 ユーザーフレンドリーエラー表示
        showUserFriendlyError(diagnosis);
        throw new Error('ユーザーIDを取得できません。初期設定が必要です。');
      }
      
      // SecurityValidator使用でセキュリティ強化
      if (!SecurityValidator.isValidUUID(userId)) {
        throw new Error('無効なuserID形式です');
      }

      // App名前空間パターン使用
      return await App.getConfig().getUserConfig(userId);
    } catch (error) {
      console.error('❌ getConfigFromBackend エラー:', error);
      
      // エラーが診断関連でない場合、ユーザーフレンドリーエラーを表示
      if (diagnosis.severity !== 'healthy') {
        showUserFriendlyError(diagnosis);
      }
      
      throw error;
    }
  };

  // configJSON中心設定（CLAUDE.md準拠）
  let CONFIG = {};
  
  // 設定初期化
  const initializeConfig = async () => {
    try {
      CONFIG = await getConfigFromBackend();
      Object.assign(window, CONFIG);
      debugInfo('✅ Config初期化完了:', CONFIG.userId);
    } catch (error) {
      console.error('❌ Config初期化エラー:', error);
      
      // 📱 ユーザーフレンドリーエラーハンドリング
      const diagnosis = smartDiagnosis();
      if (diagnosis.severity !== 'healthy') {
        debugInfo('📱 ユーザーフレンドリーエラー表示をスキップ（既に表示済み）');
        return; // 既にshowUserFriendlyErrorが呼ばれているため、フォールバック設定は不要
      }
      
      // フォールバック設定（SHEET_NAME空文字対策）
      const fallbackUserId = new URLSearchParams(window.location.search).get('userId') || '';
      const fallbackSheetName = window.SHEET_NAME || 'Sheet1'; // テンプレート変数フォールバック
      
      CONFIG = Object.freeze({
        showCounts: false,
        displayMode: 'anonymous',
        sheetName: fallbackSheetName,
        userId: fallbackUserId,
        ownerName: '',
        showAdminFeatures: false,
        showHighlightToggle: false,
        showScoreSort: false,
        isStudentMode: true,
        isAdminUser: false,
        mapping: {}
      });
      Object.assign(window, CONFIG);
    }
  };


  // === APPLICATION CONSTANTS ===
  // GAS optimized constants
  const RENDER_BATCH_SIZE = 50; // 件数闾值最適化: 大量データ対応
  const CHUNK_SIZE = 5; // DOM operations per chunk
  const IDLE_TIMEOUT = 5000; // requestIdleCallback timeout
  
  // 生産環境対応デバッグシステム
  const DEBUG_MODE = window.location.search.includes('debug=true') || window.localStorage?.getItem('debug') === 'true';
  const PERF_MODE = !DEBUG_MODE; // プロダクションでは性能重視
  
  // 最適化されたログシステム
  const Logger = {
    debug: DEBUG_MODE ? console.debug.bind(console) : () => {},
    // 情報ログ（重要な情報のみ）
    info: (msg, ...args) => console.info(`📊 ${msg}`, ...args),
    // 警告（本番でも必要）
    warn: (msg, ...args) => console.warn(`⚠️ ${msg}`, ...args),
    // エラー（本番でも必要）  
    error: (msg, ...args) => console.error(`❌ ${msg}`, ...args),
    // 性能ログ（条件付き）
    perf: PERF_MODE ? () => {} : (msg, ...args) => Logger.perf(`⚡ ${msg}`, ...args)
  };
  
  const debugLog = Logger.debug;

  // アイコンシステム
  const ICONS = Object.freeze({
    'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
    'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
    'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
    'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
    'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
    'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    x: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
    'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
    'star-solid': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
    'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
    users: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
  });

  // ✅ CLAUDE.md準拠: SYSTEM_CONSTANTS統合 + 必須UI定数
  const VIEWPORT_BUFFER = 100; // setupObservers用の必須定数
  
  const SYSTEM_CONSTANTS = Object.freeze({
    REACTIONS: Object.freeze({
      KEYS: ['UNDERSTAND', 'LIKE', 'CURIOUS'],
      LABELS: Object.freeze({
        UNDERSTAND: 'なるほど！',
        LIKE: 'いいね！',
        CURIOUS: 'もっと知りたい！',
        HIGHLIGHT: 'ハイライト'
      })
    }),
    TIMEOUTS: Object.freeze({
      SHORT: 1000,
      MEDIUM: 5000,
      LONG: 30000,
      FLOW: 300000
    }),
    DISPLAY_MODES: Object.freeze({
      ANONYMOUS: 'anonymous',
      NAMED: 'named',
      EMAIL: 'email'
    })
  });

  // ✅ CLAUDE.md準拠: App名前空間パターン（効率化版）
  const createGasMethod = (methodName, funcName, errorContext) => {
    return async (...args) => {
      try {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [funcName](...args);
        });
      } catch (error) {
        console.error(`❌ ${errorContext} エラー:`, error);
        throw error;
      }
    };
  };

  const App = {
    getConfig: () => ({
      getUserConfig: createGasMethod('getUserConfig', 'getCurrentConfig', 'App.getConfig.getUserConfig')
    }),

    getAccess: () => ({
      verifyAccess: createGasMethod('verifyAccess', 'verifyUserAccess', 'App.getAccess.verifyAccess')
    }),

    getData: () => ({
      getPublishedSheetData: createGasMethod('getPublishedSheetData', 'getPublishedSheetData', 'App.getData.getPublishedSheetData'),
      addReaction: createGasMethod('addReaction', 'addReaction', 'App.getData.addReaction'),
      removeReaction: createGasMethod('removeReaction', 'removeReaction', 'App.getData.removeReaction'),
      batchAddReaction: createGasMethod('batchAddReaction', 'batchAddReaction', 'App.getData.batchAddReaction')
    }),

    getForm: () => ({
      getActiveFormInfo: createGasMethod('getActiveFormInfo', 'getActiveFormInfo', 'App.getForm.getActiveFormInfo')
    }),

    getDomain: () => ({
      getSystemDomainInfo: createGasMethod('getSystemDomainInfo', 'getSystemDomainInfo', 'App.getDomain.getSystemDomainInfo')
    }),

    getStatus: () => ({
      async checkPublicationStatus(userId) {
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => reject(new Error('Publication status check timeout')), SYSTEM_CONSTANTS.TIMEOUTS.SHORT * 8);
          const cleanup = (fn) => (...args) => { clearTimeout(timeout); fn(...args); };
          
          google.script.run
            .withSuccessHandler(cleanup(resolve))
            .withFailureHandler(cleanup(reject))
            .checkCurrentPublicationStatus(userId);
        }).catch(error => { console.error('❌ App.getStatus.checkPublicationStatus エラー:', error); throw error; });
      }
    })
  };

  // ✅ CLAUDE.md準拠: SecurityValidator統合
  const SecurityValidator = {
    isValidUUID(uuid) {
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      return typeof uuid === 'string' && uuidRegex.test(uuid);
    },

    isValidEmail(email) {
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      return typeof email === 'string' && emailRegex.test(email);
    },

    sanitizeInput(input) {
      if (typeof input !== 'string') return '';
      return input.replace(/[<>&"']/g, (match) => {
        const entities = {
          '<': '&lt;',
          '>': '&gt;',
          '&': '&amp;',
          '"': '&quot;',
          "'": '&#x27;'
        };
        return entities[match];
      });
    }
  };

  // Generic cache for data storage
  class Cache {
    constructor() {
      this.data = new Map();
    }
    set(key, value) {
      this.data.set(key, value);
    }
    get(key) {
      return this.data.get(key);
    }
    has(key) {
      return this.data.has(key);
    }
    delete(key) {
      this.data.delete(key);
    }
    clear() {
      this.data.clear();
    }
    get size() {
      return this.data.size;
    }
    cleanup() {
      // 古いエントリをクリーンアップ（最大100個まで保持）
      if (this.data.size > 100) {
        const entries = Array.from(this.data.entries());
        const keepEntries = entries.slice(-50); // 最新50個を保持
        this.data.clear();
        keepEntries.forEach(([key, value]) => this.data.set(key, value));
      }
    }
  }

  class AnswerBoardApp {
    // アプリケーション定数
    static CONSTANTS = Object.freeze({
      REACTION_RATE_LIMIT_MS: 500,
      HIGHLIGHT_RATE_LIMIT_MS: 500,
      CACHE_TTL_MS: 1000,
      RETRY_DELAY_MS: 2000,
      POLLING_INTERVAL_MS: 5000,
      INIT_TIMEOUT_MS: 30000,
    });

    // 🚀 Phase3最適化: 高速DOM要素キャッシュ
    _getCachedElement(id, useCache = true) {
      if (!useCache) return document.getElementById(id);
      
      if (this.elementCache.has(id)) {
        const cached = this.elementCache.get(id);
        // 要素がDOMに存在するか確認
        if (cached && document.contains(cached)) {
          return cached;
        }
        // 無効なキャッシュを削除
        this.elementCache.delete(id);
      }
      
      const element = document.getElementById(id);
      if (element) {
        this.elementCache.set(id, element);
      }
      return element;
    }

    // 🚀 Phase5最適化: コード重複削減ヘルパー
    _createElement(tag, classes = [], attributes = {}) {
      const el = document.createElement(tag);
      if (classes.length) el.className = classes.join(' ');
      Object.entries(attributes).forEach(([key, value]) => el.setAttribute(key, value));
      return el;
    }

    _toggleClasses(element, classes, condition) {
      classes.forEach(cls => condition ? element.classList.add(cls) : element.classList.remove(cls));
      return element;
    }

    _setAttributes(element, attributes) {
      Object.entries(attributes).forEach(([key, value]) => element.setAttribute(key, value));
      return element;
    }

    /**
     * ユーザーIDを検証し、必要に応じてフォールバック値を提供
     * @param {string} userId - 検証するユーザーID
     * @returns {string} 有効なユーザーID、またはフォールバック値
     */
    validateUserId(userId) {
      // 基本的な検証
      if (!userId || typeof userId !== 'string' || userId.trim() === '') {
        console.warn('⚠️ Invalid or empty userId provided:', userId);

        // URLパラメータからuserIdを取得するフォールバック
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const fallbackUserId = urlParams.get('userId');

          if (fallbackUserId) {
            Logger.debug(
              '✅ Using fallback userId from URL parameters:',
              fallbackUserId
            );
            return fallbackUserId;
          }
        } catch (error) {
          console.warn(
            '⚠️ Failed to get userId from URL parameters:',
            error.message
          );
        }

        // 最後のフォールバック
        console.error('❌ No valid userId available. Data loading may fail.');
        return '';
      }

      // UUID形式の基本的な形式チェック（36文字、ハイフン付き）
      if (userId.length === 36 && userId.includes('-')) {
        Logger.debug(
          '✅ Valid userId format detected:',
          userId.substring(0, 8) + '...'
        );
        return userId;
      }

      // その他の形式も許可するが警告を出す
      console.warn(
        '⚠️ Unusual userId format, but proceeding:',
        userId.substring(0, 8) + '...'
      );
      return userId;
    }

    constructor() {
      this.cache = new Cache();
      this.visibilityObserver = null;
      this.resizeObserver = null;
      this.deferredUpdates = new Set();
      this.animationFrameId = null;
      this.idleCallbackId = null;
      this.domFragmentPool = [];
      this.isLowPerformanceMode = true;
      
      // 🚀 Phase3最適化: DOMキャッシュシステム
      this.elementCache = new Map();
      this.elements = {
        body: document.body,
        mainContainer: this._getCachedElement('main-container'),
        answersContainer: this._getCachedElement('answers'),
        sizeSlider: this._getCachedElement('sizeSlider'),
        sliderValue: this._getCachedElement('sliderValue'),
        headingLabel: this._getCachedElement('headingLabel'),
        sheetNameText: this._getCachedElement('sheetNameText'),
        endPublicationBtn: this._getCachedElement('endPublicationBtn'),
        adminToggleBtn: this._getCachedElement('adminToggleBtn'),
        answerCount: this._getCachedElement('answerCount'),
        answerModalContainer: this._getCachedElement('answerModalContainer'),
        answerModalCloseBtn: this._getCachedElement('answerModalCloseBtn'),
        answerModalCard: this._getCachedElement('answerModalCard'),
        modalAnswer: this._getCachedElement('modalAnswer'),
        modalStudentName: this._getCachedElement('modalStudentName'),
        modalReactionContainer: this._getCachedElement('modalReactions'),
        modalFooter: this._getCachedElement('modalFooter'),
        infoModalContainer: this._getCachedElement('infoModalContainer'),
        infoModalCard: this._getCachedElement('infoModalCard'),
        infoModalConfirmBtn: this._getCachedElement('infoModalConfirmBtn'),
        infoIconLike: this._getCachedElement('infoIconLike'),
        infoIconUnderstand: this._getCachedElement('infoIconUnderstand'),
        infoIconCurious: this._getCachedElement('infoIconCurious'),
        infoIconHighlight: this._getCachedElement('infoIconHighlight'),
        newContentBanner: this._getCachedElement('newContentBanner'),
        newContentText: this._getCachedElement('newContentText'),
        refreshContentBtn: this._getCachedElement('refreshContentBtn'),
        dismissBannerBtn: this._getCachedElement('dismissBannerBtn'),
        iconClose: this._getCachedElement('iconClose'),
        iconGrid: this._getCachedElement('iconGrid'),
        classFilter: this._getCachedElement('classFilter'),
        sortOrder: this._getCachedElement('sortOrder'),
        scoreOption: this._getCachedElement('scoreOption'),
        footer: this._getCachedElement('controlsFooter'),
        loadingOverlay: this._getCachedElement('loading-overlay'),
      };
      this.state = {
        currentAnswers: [], // CLAUDE.md準拠: 常に配列として初期化
        isLoading: false,
        lastFocusedElement: null,
        isStudentMode: window.isStudentMode,
        isAdminUser: window.isAdminUser,
        showCounts: window.showCounts,
        showAdminFeatures: false, // 初期状態は常に閲覧モード
        showHighlightToggle: window.isAdminUser, // 管理者なら常に表示
        showScoreSort: window.showScoreSort,
        displayMode: window.displayMode,
        sheetName: CONFIG.sheetName || 'Sheet1',
        tenantId: this.validateUserId(CONFIG.userId), // Validate and add userId to state
        hasNewContent: false,
        newContentCount: 0,
        lastSeenCount: this.loadLastSeenCount(), // ローカルストレージから復元
        pollingFailureCount: 0,
        startTime: Date.now(), // パフォーマンス監視用
      };

      // 新着チェック用の初期化
      this.lastViewKey = null;
      this.initialDataLoaded = false;
      this.hadInitialDataLoadFailure = false; // 初期データロード失敗フラグ

      // Initial state setup complete
      this.serverShowCounts = window.showCounts;
      this.serverDisplayMode = window.displayMode;
      this.pollingInterval = null;
      this.handlers = {};
      this.adminModeVerified = false; // 管理モード切り替え時の権限確認フラグ
      this.reactionDebounce = new Map(); // リアクションのデバウンス処理用
      this.highlightDebounce = new Map(); // ハイライトのデバウンス処理用
      this.pendingReactions = new Set(); // 処理中のリアクション
      this.reactionQueue = new Map(); // リアクション操作キュー
      this.reactionEventListeners = new Map(); // 処理完了通知用
      this.isProcessingReactionQueue = false; // キュー処理中フラグ

      // バッチ処理システム（既存機能に影響しない追加機能）
      this.enableBatchProcessing = true; // バッチ処理有効フラグ（簡単に無効化可能）
      this.reactionBatchQueue = new Map(); // rowIndex -> reactions[] のバッチキュー
      this.batchTimer = null; // バッチ処理タイマー
      this.BATCH_TIMEOUT = 500; // 500ms以内の操作をバッチ化
      this.BATCH_SIZE_LIMIT = 5; // 最大バッチサイズ（控えめに設定）
      this.batchProcessingActive = false; // バッチ処理中フラグ

      // イベントリスナー重複登録防止フラグ
      this.eventDelegationSetup = false;
      this.nonCriticalListenersSetup = false;
      this.modalOperationPending = false;
      this.reactionTypes = Object.freeze([
        Object.freeze({ key: 'LIKE', icon: 'hand-thumb-up' }),
        Object.freeze({ key: 'UNDERSTAND', icon: 'lightbulb' }),
        Object.freeze({ key: 'CURIOUS', icon: 'magnifying-glass-plus' }),
      ]);

      // リアクション状態保存用のキー
      this.reactionStorageKey = `reactions_${CONFIG.userId}_${CONFIG.sheetName}`;
      this.gas = {
        getPublishedSheetData: (classFilter, sort, adminMode, bypassCache) =>
          this.runGas(
            'getPublishedSheetData',
            this.state.tenantId,
            classFilter,
            sort,
            adminMode,
            bypassCache
          ),
        getIncrementalSheetData: (classFilter, sort, adminMode, sinceRowCount) =>
          this.runGas(
            'getIncrementalSheetData',
            this.state.tenantId,
            classFilter,
            sort,
            adminMode,
            sinceRowCount
          ),
        getAvailableSheets: () => this.runGas('getAvailableSheets', this.state.tenantId),
        addReactionBatch: (batchOperations) =>
          this.runGas('addReactionBatch', this.state.tenantId, batchOperations), // 新しいバッチAPI
        addReaction: (rowIndex, reaction, sheetName) =>
          this.runGas('addReaction', this.state.tenantId, rowIndex, reaction, sheetName),
        toggleHighlight: (rowIndex, sheetName) =>
          this.runGas('toggleHighlight', this.state.tenantId, rowIndex, sheetName),
        checkAdmin: () => this.runGas('checkAdmin', this.state.tenantId),
        clearCache: () => this.runGas('refreshBoardData', this.state.tenantId),
        validateData: () => this.validateBoardDataIntegrity(),
        getDataCount: (classFilter, sortOrder, adminMode) =>
          this.runGas('getDataCount', this.state.tenantId, classFilter, sortOrder, adminMode),
      };

      // Polling settings
      this.pollingSettings = {
        enabled: true,
        interval: 30000, // 30秒間隔
        maxRetries: 3,
        currentRetries: 0,
      };
      const savedCols = localStorage.getItem('boardColumns');
      if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
        this.elements.sizeSlider.value = savedCols;
        this.elements.sliderValue.textContent = savedCols;
      }
      this.init().catch((error) => {
        console.error('❌ AnswerBoardApp: Fatal initialization error:', error);
        this.displayInitializationError('アプリケーションの起動に失敗しました: ' + error.message);
      });

      // パブリケーション状態監視システムの初期化
      this.initPublicationStatusMonitoring();
    }

    // 効率化ヘルパーメソッド
    withElement(elementName, callback) {
      const element = this.elements[elementName];
      if (element) callback(element);
      return this;
    }

    withElements(elementNames, callback) {
      const elements = elementNames.map(name => this.elements[name]).filter(Boolean);
      if (elements.length > 0) callback(elements);
      return this;
    }
    // Helper for card reaction updates
    updateCardIfExists(rowIndex, item, warningMsg = null) {
      const card = document.querySelector(`[data-row-index="${rowIndex}"]`);
      if (card && card.nodeType) {
        this.updateCardReactions(card, item);
        this.applyReactionStyles(card, item);
      } else if (warningMsg) {
        console.warn(warningMsg, rowIndex);
      }
      return card;
    }

    // CLAUDE.md準拠: 安全なデータアクセスメソッド
    getCurrentAnswers() {
      if (!Array.isArray(this.state.currentAnswers)) {
        console.warn(
          'getCurrentAnswers: currentAnswersが配列ではありません。空配列で初期化します。',
          this.state.currentAnswers
        );
        this.state.currentAnswers = [];
      }
      return this.state.currentAnswers;
    }

    setCurrentAnswers(answers) {
      const safeAnswers = Array.isArray(answers) ? answers : [];
      this.state.currentAnswers = safeAnswers;
      Logger.debug('setCurrentAnswers: 設定完了', { length: safeAnswers.length });
    }

    // currentAnswersの安全な長さ取得
    getCurrentAnswersLength() {
      return this.getCurrentAnswers().length;
    }

    // Reset state for clean initialization (Phase 1.2)
    resetStateForCleanInit() {
      Logger.debug('🔄 Resetting state for clean initialization...');

      // Reset core data arrays
      this.state.currentAnswers = [];
      this.state.hasNewContent = false;
      this.state.newContentCount = 0;
      this.state.pollingFailureCount = 0;

      // Clear DOM to prevent inconsistency
      const container = this.elements.answersContainer;
      if (container) {
        const existingCards = container.querySelectorAll('.answer-card');
        if (existingCards.length > 0) {
          Logger.debug('🧹 Clearing', existingCards.length, 'existing DOM cards during init reset');
          // Remove observers
          existingCards.forEach((card) => {
            if (this.visibilityObserver) {
              this.visibilityObserver.unobserve(card);
            }
            if (this.scrollObserver) {
              this.scrollObserver.unobserve(card);
            }
          });
          container.innerHTML = '';
        }
      }

      // Clear differential cards to prevent residual data
      this.clearDifferentialCards();

      // Reset initialization flags
      this.initialDataLoaded = false;
      this.hadInitialDataLoadFailure = false;
      this.lastViewKey = null;

      // Clear content check flags
      this.contentCheckInProgress = false;

      // Reset current active sheet state
      this.state.currentActiveSheet = CONFIG.sheetName;

      Logger.debug('✅ State reset completed', {
        currentAnswers: this.state.currentAnswers?.length || 0,
        initialDataLoaded: this.initialDataLoaded,
        currentActiveSheet: this.state.currentActiveSheet,
      });
    }

    // Unified state management synchronization (Phase 2.3)
    synchronizeStateAfterDataUpdate(newData, context = 'unknown') {
      Logger.debug(`🔄 Synchronizing state after data update (${context})...`);

      const dataLength = newData ? newData.length : 0;
      const previousLength = this.state.currentAnswers?.length || 0;

      // Step 1: Update data
      this.state.currentAnswers = newData || [];

      // Step 2: Update count-related state variables simultaneously
      this.updateLastSeenCount(dataLength);

      // Step 3: Update content flags
      if (dataLength > previousLength) {
        this.state.hasNewContent = true;
        this.state.newContentCount = dataLength - previousLength;
      } else {
        this.state.hasNewContent = false;
        this.state.newContentCount = 0;
      }

      // Step 4: Reset polling failure count on successful data update
      this.state.pollingFailureCount = 0;

      // Phase 4.1: Enhanced monitoring and logging (※ DOM整合性はレンダリング後にチェック)
      // this.logDataConsistencyMetrics(context, dataLength, previousLength); // レンダリング後に移動

      Logger.debug('✅ State synchronization completed:', {
        context,
        dataLength,
        previousLength,
        hasNewContent: this.state.hasNewContent,
        newContentCount: this.state.newContentCount,
        lastSeenCount: this.state.lastSeenCount,
      });

      return {
        dataLength,
        hasChanges: dataLength !== previousLength,
      };
    }

    // Comprehensive data consistency and cache monitoring (Phase 4.1)
    logDataConsistencyMetrics(context, currentDataLength, previousDataLength) {
      const domCardCount = this.elements.answersContainer
        ? this.elements.answersContainer.querySelectorAll('.answer-card').length
        : 0;

      const metrics = {
        timestamp: new Date().toISOString(),
        context,
        dataMetrics: {
          currentLength: currentDataLength,
          previousLength: previousDataLength,
          lastSeenCount: this.state.lastSeenCount,
          changeAmount: currentDataLength - previousDataLength,
        },
        domMetrics: {
          cardCount: domCardCount,
          dataVsDom: currentDataLength - domCardCount,
          isConsistent: currentDataLength === domCardCount,
        },
        stateMetrics: {
          hasNewContent: this.state.hasNewContent,
          newContentCount: this.state.newContentCount,
          pollingFailureCount: this.state.pollingFailureCount,
          initialDataLoaded: this.initialDataLoaded,
        },
      };

      // Alert on significant inconsistencies + 自動修復試行
      if (!metrics.domMetrics.isConsistent) {
        console.warn('⚠️ DOM-Data inconsistency detected:', {
          data: currentDataLength,
          dom: domCardCount,
          context,
        });

        // 🔧 自動修復の試行（初回読み込み時のみ、無限ループ防止）
        if (context === 'performDataLoad' && currentDataLength > 0 && domCardCount < currentDataLength / 2) {
          Logger.debug('🔧 DOM-Data不整合を自動修復中...', {
            expectedData: currentDataLength,
            actualDOM: domCardCount,
            trigger: 'auto_repair'
          });
          
          // 次のフレームで修復実行（非同期で実行）
          requestAnimationFrame(() => {
            this.attemptConsistencyRepair(currentDataLength, domCardCount, context);
          });
        }
      }

      return metrics;
    }

    // 🔧 DOM-Data整合性の自動修復メソッド
    attemptConsistencyRepair(expectedData, actualDOM, context) {
      try {
        Logger.debug('🔧 整合性修復開始:', { expectedData, actualDOM, context });
        
        // スケルトンやローディングカードを除去
        const container = this.elements.answersContainer;
        if (container) {
          const skeletons = container.querySelectorAll('.skeleton, .loading');
          if (skeletons.length > 0) {
            Logger.debug('🧹 修復：スケルトンカード削除', skeletons.length + '個');
            skeletons.forEach(skeleton => skeleton.remove());
          }
          
          // データが存在するがDOMが少ない場合、再レンダリングを強制
          if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
            Logger.debug('🔄 修復：データ再レンダリング実行', this.state.currentAnswers.length + '件');
            this.renderBoard(this.state.currentAnswers, []);
          }
        }
        
        Logger.debug('✅ 整合性修復完了');
        
      } catch (error) {
        console.warn('⚠️ 整合性修復中にエラー:', error.message);
        // エラーが発生してもシステムを停止させない
      }
    }

    // Cache hit/miss tracking (Phase 4.1)
    logCacheActivity(operation, hit, details = {}) {
      const cacheLog = {
        timestamp: new Date().toISOString(),
        operation,
        hit,
        details,
        context: this.state.currentActiveSheet || 'unknown',
      };

      // Store cache metrics
      if (!this.cacheMetrics) this.cacheMetrics = [];
      this.cacheMetrics.push(cacheLog);
      if (this.cacheMetrics.length > 20) {
        this.cacheMetrics.shift();
      }
    }

    // Enhanced error handling and recovery system (Phase 4.2)
    async handleDataLoadError(error, context, retryOptions = {}) {
      const {
        maxRetries = 2,
        retryDelay = 1000,
        fallbackStrategy = 'clearAndReload',
      } = retryOptions;

      console.error(`❌ Data load error in ${context}:`, error);

      // Log detailed error information
      this.logErrorDetails(error, context);

      // Increment failure count
      this.state.pollingFailureCount = (this.state.pollingFailureCount || 0) + 1;

      // Determine recovery strategy based on error type and failure count
      const recoveryStrategy = this.determineRecoveryStrategy(error, context);

      try {
        switch (recoveryStrategy) {
          case 'retry':
            Logger.debug(`🔄 Attempting retry for ${context}...`);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return await this.executeRecoveryRetry(context);

          case 'clearAndReload':
            Logger.debug(`🔄 Executing clear and reload for ${context}...`);
            return await this.executeRecoveryReload();

          case 'fallbackMode':
            Logger.debug(`🔄 Switching to fallback mode for ${context}...`);
            return await this.executeRecoveryFallback();

          default:
            Logger.debug(`ℹ️ No recovery action taken for ${context}`);
            this.displayUserFriendlyError(error, context);
            return null;
        }
      } catch (recoveryError) {
        console.error('❌ Recovery strategy failed:', recoveryError);
        this.displayUserFriendlyError(error, context, true);
        return null;
      }
    }

    logErrorDetails(error, context) {
      const errorDetails = {
        timestamp: new Date().toISOString(),
        context,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name,
        },
        state: {
          currentAnswersLength: this.state.currentAnswers?.length || 0,
          lastSeenCount: this.state.lastSeenCount,
          pollingFailureCount: this.state.pollingFailureCount,
          isLoading: this.state.isLoading,
        },
        environment: {
          userAgent: navigator.userAgent,
          currentSheet: this.state.currentActiveSheet,
          timeSinceInit: Date.now() - this.state.startTime,
        },
      };

      Logger.debug('📝 Error Details (Phase 4.2):', errorDetails);

      // Store error history
      if (!this.errorHistory) this.errorHistory = [];
      this.errorHistory.push(errorDetails);
      if (this.errorHistory.length > 5) {
        this.errorHistory.shift();
      }
    }

    /**
     * パブリケーション状態監視システムの初期化
     * キャッシュ関連のアクセス問題を防ぐため、リアルタイムで状態を監視
     */
    initPublicationStatusMonitoring() {
      Logger.debug('🔍 初期化: パブリケーション状態監視システム');

      // 定期的なパブリケーション状態チェック（3分間隔）
      this.publicationCheckInterval = setInterval(() => {
        this.checkPublicationStatus();
      }, 180000); // 3分 = 180,000ms

      // ページの可視性変更時（ユーザーがタブに戻ってきた時）の状態チェック
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          Logger.debug('📱 ページが可視状態に戻りました - パブリケーション状態をチェック');
          this.checkPublicationStatus();
        }
      });

      // ページフォーカス時の状態チェック
      window.addEventListener('focus', () => {
        Logger.debug('🎯 ページがフォーカスされました - パブリケーション状態をチェック');
        this.checkPublicationStatus();
      });

      // 初回チェック（10秒後に実行）
      setTimeout(() => {
        this.checkPublicationStatus();
      }, 10000);
    }

    /**
     * パブリケーション状態の実際のチェック処理
     * 非公開状態が検出された場合、Unpublished.htmlにリダイレクト
     */
    async checkPublicationStatus() {
      try {
        Logger.debug('🔍 パブリケーション状態をチェック中...');

        // ✅ CLAUDE.md準拠: App名前空間パターン使用
        const userId = window.USER_ID || new URLSearchParams(window.location.search).get('userId');
        if (!userId) {
          console.error('❌ パブリケーション状態チェック: userIdが取得できません');
          return { error: 'userId is required', isPublished: false };
        }
        const result = await App.getStatus().checkPublicationStatus(userId);

        Logger.debug('📊 パブリケーション状態チェック結果:', result);

        // 非公開状態が検出された場合の処理
        if (result && result.isPublished === false) {
          Logger.debug('⚠️ ボードが非公開状態に変更されました - Unpublished.htmlにリダイレクト');

          // キャッシュをクリア
          if (this.cache && typeof this.cache.clear === 'function') {
            this.cache.clear();
          }
          if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
            window.unifiedCache.clear();
          }

          // ローカルストレージのキャッシュもクリア
          try {
            Object.keys(localStorage).forEach((key) => {
              if (key.includes('studyquest') || key.includes('board') || key.includes('sheet')) {
                localStorage.removeItem(key);
              }
            });
          } catch (e) {
            console.warn('localStorage clear warning:', e);
          }

          // 非公開ページにリダイレクト（キャッシュバスティング付き）
          const unpublishedUrl = new URL(window.location.href);
          unpublishedUrl.searchParams.delete('mode'); // mode=viewを削除
          unpublishedUrl.searchParams.set('_cb', Date.now()); // キャッシュバスティング

          window.location.href = unpublishedUrl.toString();
          return;
        }

        // 公開状態の場合は正常継続
        Logger.debug('✅ ボードは正常に公開中です');
      } catch (error) {
        console.warn('⚠️ パブリケーション状態チェックでエラー:', error.message);
        // エラーの場合は継続（ネットワーク問題などを考慮）
      }
    }

    determineRecoveryStrategy(error, context) {
      // Determine best recovery strategy based on error characteristics
      const failCount = this.state.pollingFailureCount;
      return failCount <= 2 ? 'retry' : failCount <= 5 ? 'clearAndReload' : 'fallbackMode';
    }

    async executeRecoveryRetry(context) {
      try {
        await this.clearDataCaches(true);
        return await this.loadSheetData({ bypassCache: true, isInitialLoad: false });
      } catch (retryError) {
        throw new Error(`Retry failed: ${retryError.message}`);
      }
    }

    async executeRecoveryReload() {
      try {
        await this.clearAllCardsForEmptyData();
        this.resetStateForCleanInit();
        return await this.loadSheetData({ bypassCache: true, isInitialLoad: true });
      } catch (reloadError) {
        throw new Error(`Reload failed: ${reloadError.message}`);
      }
    }

    async executeRecoveryFallback() {
      // Implement minimal functional state
      this.displayEmptyState();
      this.provideFeedback(
        'データの読み込みに問題が発生しました。ページを更新してください。',
        'error'
      );

      // Reset polling to longer intervals
      if (this.pollingTimeout) {
        clearTimeout(this.pollingTimeout);
        this.currentPollInterval = 60000; // 1 minute
        this.startPolling();
      }

      return { fallbackMode: true };
    }

    displayUserFriendlyError(error, context, isRecoveryFailed = false) {
      let userMessage = 'データの読み込み中に問題が発生しました。';

      if (isRecoveryFailed) {
        userMessage = '復旧処理が失敗しました。ページを再読み込みしてください。';
      } else if (context.includes('polling')) {
        userMessage = '新着チェック中に問題が発生しました。自動的に再試行します。';
      } else if (context.includes('initial')) {
        userMessage =
          'アプリケーションの初期化中に問題が発生しました。ページを再読み込みしてください。';
      }

      this.provideFeedback(userMessage, 'error');
    }

    async init() {
      try {
        // 初回アクセス時にデジタルシティズンシップモーダルを表示（読み込みと同時進行）
        const hasSeenDigitalCitizenship = localStorage.getItem('hasSeenDigitalCitizenship');
        const shouldShowModal =
          !hasSeenDigitalCitizenship ||
          (hasSeenDigitalCitizenship && Date.now() > parseInt(hasSeenDigitalCitizenship));

        if (shouldShowModal && window.sharedModals) {
          Logger.debug('🌐 初回アクセス/期限切れ: デジタルシティズンシップモーダルを表示');
          window.sharedModals.showDigitalCitizenship();
          // 表示済みフラグを設定（24時間有効）
          const expiry = Date.now() + 24 * 60 * 60 * 1000;
          localStorage.setItem('hasSeenDigitalCitizenship', expiry.toString());
        }

        // 初期ロード状態を表示
        this.showLoadingOverlay();

        // タイムアウト設定（15秒）
        this.initTimeoutId = setTimeout(() => {
          this.hideLoadingOverlay();
          console.warn('ページの初期化に時間がかかっています。ページを再読み込みしてください。');
        }, 15000);

        // Reset state for clean initialization
        this.resetStateForCleanInit();

        // Critical path only - non-blocking
        this.setupCriticalElements();
        this.showMinimalSkeleton();

        // Apply default low performance tweaks
        this.optimizeForLowPerformance();

        // Show info modal while loading sheet data in the background
        this.showInfoModal();

        // Kick off data loading without blocking UI
        this.loadDataImmediate()
          .catch((error) => {
            console.error('❌ AnswerBoardApp: Critical error in loadDataImmediate:', error);
            this.displayInitializationError(
              'アプリケーションの初期化中にエラーが発生しました: ' + error.message
            );
          })
          .finally(() => {
            if (this.initTimeoutId) {
              clearTimeout(this.initTimeoutId);
              this.initTimeoutId = null;
            }
          });
      } catch (error) {
        console.error('❌ AnswerBoardApp: Critical error in init():', error);
        this.displayInitializationError(
          'アプリケーションの初期化中にエラーが発生しました: ' + error.message
        );

        // Clear timeout on error
        if (this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }

        // Hide loading overlay on error
        this.hideLoadingOverlay();
        return; // Exit early on initialization failure
      }

      // Defer all non-critical operations
      requestIdleCallback(
        () => {
          this.setupNonCriticalEventListeners();
          this.renderIcons();
          this.adjustLayout();
          this.updateSortOptions();
          this.setupObservers();
          // Initial admin state setup - 管理者権限があっても最初は閲覧モードで起動
          if (window.hasAdminCapability && window.isAdminUser) {
            this.state.isAdminUser = true;
            this.state.showAdminFeatures = false; // 初期は閲覧モード
            if (this.elements.adminToggleBtn) {
              this.elements.adminToggleBtn.classList.remove('hidden');
              this.elements.adminToggleBtn.removeAttribute('hidden');
              this.elements.adminToggleBtn.style.display = ''; // 表示を確実に
              this.elements.adminToggleBtn.textContent = '管理モード';
            }
          } else {
            // 非管理者の場合は管理機能を完全に無効化
            this.state.isAdminUser = false;
            this.state.showAdminFeatures = false;
            if (this.elements.adminToggleBtn) {
              this.elements.adminToggleBtn.classList.add('hidden');
              this.elements.adminToggleBtn.setAttribute('hidden', '');
              this.elements.adminToggleBtn.style.display = 'none'; // 確実に非表示
            }
          }

          // Start polling for new answers
          this.startNewAnswerPolling();

          // Start sync monitoring
          this.startSyncMonitoring();
        },
        { timeout: 50 }
      );

      // AdminPanelからのメッセージをリッスン
      window.addEventListener('message', async (event) => {
        if (event.data && event.data.type === 'REFRESH_BOARD_DATA') {
          // Refresh board data message received
          try {
            await this.loadSheetData({ bypassCache: true });
            // Show info modal on board refresh
            this.showInfoModal();
          } catch (error) {
            console.error('ボードデータ更新エラー:', error);
          }
        } else if (event.data && event.data.type === 'BOARD_PUBLISHED') {
          // 新しいボードが公開された時の即座更新
          Logger.debug('新しいボードが公開されました:', event.data.sheetName);
          try {
            // キャッシュバイパスで新しいデータをチェック
            await this.checkForNewContentLight(true);
            // 必要に応じてフルリフレッシュ
            await this.loadSheetData({ bypassCache: true });
            // Show info modal when new board is published
            this.showInfoModal();
          } catch (error) {
            console.warn('新しいボードの即座更新でエラー:', error);
            // エラー時もフルリフレッシュを実行
            try {
              await this.loadSheetData({ bypassCache: true });
            } catch (loadError) {
              console.error('フォールバック読み込みもエラー:', loadError);
            }
            // Show info modal even on error
            this.showInfoModal();
          }
        } else if (event.data && event.data.type === 'FORM_CREATED') {
          // フォームが作成された時のフォームリンク更新
          Logger.debug('📝 新しいフォームが作成されました:', event.data.formUrl);
          try {
            const formLinkBtn = this._getCachedElement('form-link-btn');
            if (formLinkBtn && event.data.formUrl) {
              formLinkBtn.href = event.data.formUrl;
              formLinkBtn.classList.remove('hidden');
              Logger.debug('✅ フォームリンクが更新されました');
            }
          } catch (error) {
            console.warn('フォームリンク更新でエラー:', error);
          }
        }
      });

      // BroadcastChannelで他のタブからの更新通知も受信
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.addEventListener('message', async (event) => {
          if (event.data && event.data.type === 'BOARD_PUBLISHED') {
            Logger.debug('BroadcastChannelから新しいボード公開を受信:', event.data.sheetName);
            try {
              await this.checkForNewContentLight(true);
              await this.loadSheetData({ bypassCache: true });
              // Show info modal when board is updated via BroadcastChannel
              this.showInfoModal();
            } catch (error) {
              console.warn('BroadcastChannel経由の更新でエラー:', error);
              try {
                await this.loadSheetData({ bypassCache: true });
              } catch (loadError) {
                console.error('BroadcastChannel フォールバック読み込みもエラー:', loadError);
              }
              // Show info modal even on error
              this.showInfoModal();
            }
          } else if (event.data && event.data.type === 'FORM_CREATED') {
            // フォームが作成された時のフォームリンク更新（BroadcastChannel）
            Logger.debug('📝 BroadcastChannelから新しいフォーム作成を受信:', event.data.formUrl);
            try {
              const formLinkBtn = this._getCachedElement('form-link-btn');
              if (formLinkBtn && event.data.formUrl) {
                formLinkBtn.href = event.data.formUrl;
                formLinkBtn.classList.remove('hidden');
                Logger.debug('✅ フォームリンクが更新されました（BroadcastChannel）');
              }
            } catch (error) {
              console.warn('BroadcastChannel フォームリンク更新でエラー:', error);
            }
          }
        });
      }
    }
    setupCriticalElements() {
      if (this.elements.headingLabel) {
        // 問題文を常に表示（読み込み中は表示しない）
        const opinionHeader =
          __OPINION_HEADER__.startsWith('<') || __OPINION_HEADER__.includes('読み込み')
            ? 'お題' // デフォルトテキスト
            : this.escapeHtml(__OPINION_HEADER__);
        this.elements.headingLabel.textContent = opinionHeader;
      }

      // Only setup absolutely critical event listeners
      this.setupEventDelegation();
      this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
      if (this.elements.answerModalCloseBtn) {
        this.elements.answerModalCloseBtn.addEventListener(
          'click',
          this.handlers.onAnswerModalCloseClick
        );
      }
      // Size slider for immediate response with throttling
      const debouncedRender = this.debounce(() => this.renderBoard(true, false), 200);
      this.handlers.onSizeSliderInput = this.throttle((e) => {
        localStorage.setItem('boardColumns', e.target.value);
        debouncedRender();
      }, 100); // Throttle to 100ms

      if (this.elements.sizeSlider) {
        this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, {
          passive: true,
        });
      }
    }

    setupNonCriticalEventListeners() {
      // 重複登録防止
      if (this.nonCriticalListenersSetup) {
        // Non-critical event listeners already set up
        return;
      }

      // answersContainer のクリックリスナーは setupEventDelegation() で登録済み

      // Modal handlers
      this.handlers.onAnswerModalContainerClick = (e) => {
        if (e.target === e.currentTarget) {
          this.hideAnswerModal();
        }
      };
      if (this.elements.answerModalContainer) {
        this.elements.answerModalContainer.addEventListener(
          'click',
          this.handlers.onAnswerModalContainerClick
        );
      }
      if (this.elements.infoModalConfirmBtn) {
        this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
        this.elements.infoModalConfirmBtn.addEventListener(
          'click',
          this.handlers.onInfoModalConfirmClick
        );
      }
      this.handlers.onModalReactionClick = (e) => {
        const btn = e.target.closest('.reaction-btn');
        const highlightBtn = e.target.closest('.highlight-btn');

        if (highlightBtn) {
          const id = highlightBtn.dataset.rowIndex;
          if (id) {
            this.handleHighlight(id);
          }
        } else if (btn) {
          const id = btn.dataset.rowIndex;
          const reaction = btn.dataset.reaction;
          if (id && reaction) {
            this.handleReaction(id, reaction);
          }
        }
      };
      if (this.elements.modalReactionContainer) {
        this.elements.modalReactionContainer.addEventListener(
          'click',
          this.handlers.onModalReactionClick
        );
      }
      this.handlers.onClassFilterChange = async () => {
        this.dismissNewContentBanner(); // フィルター変更時は既存の通知を消去
        try {
          await this.loadSheetData({ bypassCache: true });
          this.updateLastSeenCount(this.state.currentAnswers?.length || 0); // 新しいベースラインを設定
        } catch (error) {
          console.error('クラスフィルター変更時のデータ読み込みエラー:', error);
        }
      };
      this.handlers.onSortOrderChange = async () => {
        this.dismissNewContentBanner(); // ソート変更時は既存の通知を消去
        try {
          await this.loadSheetData({ bypassCache: true });
          this.updateLastSeenCount(this.state.currentAnswers?.length || 0); // 新しいベースラインを設定
        } catch (error) {
          console.error('ソート順変更時のデータ読み込みエラー:', error);
        }
      };
      if (this.elements.classFilter) {
        this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
      }
      if (this.elements.sortOrder) {
        this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
      }
      if (this.elements.endPublicationBtn) {
        this.handlers.onEndPublicationClick = () => this.endPublication();
        this.elements.endPublicationBtn.addEventListener(
          'click',
          this.handlers.onEndPublicationClick
        );
      }
      if (this.elements.adminToggleBtn) {
        this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
        this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
      }

      // 新着通知バナーのイベントハンドラー
      if (this.elements.refreshContentBtn) {
        this.handlers.onRefreshContentClick = async () => {
          try {
            await this.refreshContent();
          } catch (error) {
            console.error('コンテンツ更新エラー:', error);
          }
        };
        this.elements.refreshContentBtn.addEventListener(
          'click',
          this.handlers.onRefreshContentClick
        );
      }
      if (this.elements.dismissBannerBtn) {
        this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
        this.elements.dismissBannerBtn.addEventListener(
          'click',
          this.handlers.onDismissBannerClick
        );
      }
      this.handlers.onDocumentKeydown = (e) => {
        if (e.key === 'Escape') {
          this.hideAnswerModal();
        }
      };
      document.addEventListener('keydown', this.handlers.onDocumentKeydown);
      this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
      window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
      this.handlers.onVisibilityChange = () => {
        if (document.hidden) {
          this.stopPolling();
          // Cleanup when page is hidden
          this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
        } else {
          this.startPolling();
        }
      };
      document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, {
        passive: true,
      });

      this.nonCriticalListenersSetup = true;
      // Non-critical event listener setup complete
    }
    /**
     * イベント委譲の設定（安定版の堅牢なロジックを採用）
     * これにより、クリックイベントが他のイベントと競合しなくなります。
     */
    setupEventDelegation() {
      // 重複登録防止
      if (this.eventDelegationSetup) {
        // Event delegation already set up
        return;
      }

      this.handlers.onAnswersContainerClick = (e) => {
        const answerCard = e.target.closest('.answer-card');

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
          return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
          return;
        }

        // リアクションボタンのクリックを処理
        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
          e.stopPropagation(); // ★重要: イベントの伝播を止め、カード本体のクリックと分離
          if (!reactionBtn.disabled) {
            this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
          }
          return;
        }

        // ハイライトボタンのクリックを処理
        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
          e.stopPropagation(); // ★重要: 同様にイベントの伝播を停止
          if (!highlightBtn.disabled) {
            this.handleHighlight(rowIndex);
          }
          return;
        }

        // 上記以外の場合は、カード本体のクリックとしてモーダルを表示
        this.showAnswerModal(rowIndex);
      };

      if (this.elements.answersContainer) {
        // 既存のリスナーをクリアしてから追加
        this.elements.answersContainer.removeEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
        this.elements.answersContainer.addEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
        this.eventDelegationSetup = true;
      } else {
        console.error('No answers container found for event delegation');
      }
    }

    adjustLayout() {
      if (this.baseBodyPadding === undefined) {
        this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
      }
      const footerHeight = this.elements.footer.offsetHeight;
      this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
    }
    // ✅ CLAUDE.md準拠: App名前空間パターン使用
    async runGas(funcName, ...args) {
      const cacheKey = funcName + JSON.stringify(args);
      const isStateChanging = ['toggleHighlight', 'addReaction', 'endPublication'].includes(funcName);

      if (!isStateChanging) {
        const cached = this.cache.get(cacheKey);
        if (cached) {
          return Promise.resolve(cached);
        }
      }

      try {
        const userId = CONFIG.userId || '';
        let result;

        // ✅ App名前空間パターンでの統一データアクセス
        switch (funcName) {
          case 'getPublishedSheetData':
            result = await App.getData().getPublishedSheetData(userId, ...args);
            break;
          case 'addReaction':
            result = await App.getData().addReaction(userId, ...args);
            break;
          case 'removeReaction':
            result = await App.getData().removeReaction(userId, ...args);
            break;
          case 'batchAddReaction':
            result = await App.getData().batchAddReaction(userId, ...args);
            break;
          case 'getActiveFormInfo':
            result = await App.getForm().getActiveFormInfo(userId);
            break;
          case 'getSystemDomainInfo':
            result = await App.getDomain().getSystemDomainInfo();
            break;
          default:
            // フォールバック: 直接呼び出し（段階的移行用）
            result = await new Promise((resolve, reject) => {
              if (typeof google !== 'undefined' && google.script && google.script.run) {
                google.script.run
                  .withSuccessHandler(resolve)
                  .withFailureHandler(reject)
                  .withUserObject({ tenantId: userId })
                  [funcName](...args);
              } else {
                // GAS実行環境が利用できない場合
                reject(new Error('Google Apps Script実行環境が利用できません'));
              }
            });
        }

        if (!isStateChanging) {
          this.cache.set(cacheKey, result, SYSTEM_CONSTANTS.TIMEOUTS.LONG);
        }

        return result;
      } catch (error) {
        console.error('❌ runGas エラー:', { funcName, args, error });
        throw error;
      }
    }
    async verifyAdminAsync() {
      // Use server-provided flag first (fast)
      if (window.isAdminUser) {
        this.state.isAdminUser = true;
        this.state.showHighlightToggle = true; // 管理者なら常に表示
        // Admin permissions verified
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
        return;
      }

      // Fallback API call (slower)
      let prevState;
      try {
        const isAdmin = await this.gas.checkAdmin();
        if (isAdmin) {
          window.isAdminUser = true;
          this.state.isAdminUser = true;
          this.state.showHighlightToggle = true; // 管理者なら常に表示
          // API admin permissions verified
          this.updateAdminButtonUI();
          this.updateEndPublicationButtonUI();
        }
      } catch (e) {
        console.error('Admin check failed', e);
      }
    }

    // 管理者UI更新の共通メソッド
    updateAdminButtonUI() {
      // Only show admin toggle button for administrators, never for viewers
      if (this.elements.adminToggleBtn && this.state.isAdminUser) {
        // Show button for admin users only
        this.elements.adminToggleBtn.classList.remove('hidden');
        this.elements.adminToggleBtn.removeAttribute('hidden');

        // Always show "管理モード" text, never show "閲覧モード" to avoid confusion
        this.elements.adminToggleBtn.textContent = '管理モード';

        // Apply styling based on current admin mode state
        if (this.state.showAdminFeatures) {
          // Active admin mode: highlighted styling
          this.elements.adminToggleBtn.classList.remove('text-gray-500', 'opacity-60');
          this.elements.adminToggleBtn.classList.add(
            'bg-cyan-600',
            'hover:bg-cyan-700',
            'text-white',
            'shadow-lg',
            'ring-2',
            'ring-cyan-400/50'
          );
        } else {
          // Inactive admin mode: subtle gray styling
          this.elements.adminToggleBtn.classList.remove(
            'bg-cyan-600',
            'hover:bg-cyan-700',
            'text-white',
            'shadow-lg',
            'ring-2',
            'ring-cyan-400/50'
          );
          this.elements.adminToggleBtn.classList.add('text-gray-500', 'opacity-60');
        }
      } else {
        // Hide button for non-admin users
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.add('hidden');
          this.elements.adminToggleBtn.setAttribute('hidden', '');
        }
      }
    }

    updateEndPublicationButtonUI() {
      if (this.elements.endPublicationBtn) {
        if (this.state.showAdminFeatures) {
          this.elements.endPublicationBtn.classList.remove('hidden');
          this.elements.endPublicationBtn.removeAttribute('hidden');
        } else {
          this.elements.endPublicationBtn.classList.add('hidden');
          this.elements.endPublicationBtn.setAttribute('hidden', '');
        }
      }
    }

    // サーバー管理者権限確認の共通メソッド
    async checkServerAdminPermission() {
      try {
        const isAdmin = await this.gas.checkAdmin();
        if (!isAdmin) {
          throw new Error('サーバー側で管理者権限が確認できませんでした');
        }
        return true;
      } catch (error) {
        console.error('管理者権限確認エラー:', error);
        throw error;
      }
    }

    async checkForNewContentLight(bypassCache = false) {
      // ポーリング実行中の場合は重複実行を防ぐ
      if (this.contentCheckInProgress) {
        Logger.debug('Content check already in progress, skipping...');
        return;
      }

      try {
        this.contentCheckInProgress = true;

        // 基本状態の検証
        if (!this.validateContentCheckPrerequisites()) {
          return;
        }

        // パラメータの準備
        const { selectedClass, sortOrder } = this.prepareContentCheckParams();

        // キャッシュクリア（必要な場合）
        if (bypassCache) {
          await this.clearCacheForContentCheck();
        }

        // サーバーから件数を取得
        const countData = await this.fetchContentCount(selectedClass, sortOrder);

        // レスポンスの処理
        await this.processContentCountResponse(countData, selectedClass, sortOrder);
      } catch (error) {
        await this.handleContentCheckError(error);
      } finally {
        this.contentCheckInProgress = false;
      }
    }

    validateContentCheckPrerequisites() {
      // 必要な要素の存在確認
      if (!this.elements.classFilter || !this.elements.sortOrder) {
        console.warn('Required UI elements not available for content check');
        return false;
      }

      // 初期化状態の確認
      if (!this.state.tenantId) {
        console.warn('User ID not available for content check');
        return false;
      }

      return true;
    }

    prepareContentCheckParams() {
      let selectedClass = this.elements.classFilter.value || 'すべて';
      if (!selectedClass.trim()) {
        selectedClass = 'すべて';
      }

      // 「すべて」の場合はnullに変換してサーバーに送信
      const classFilter = !selectedClass || selectedClass === 'すべて' ? null : selectedClass;
      const sortOrder = this.elements.sortOrder.value || 'newest';

      return { selectedClass, classFilter, sortOrder };
    }

    async clearCacheForContentCheck() {
      try {
        await this.gas.clearCache();
        Logger.debug('✅ Cache cleared for content check');
      } catch (error) {
        console.warn('⚠️ Failed to clear cache:', error.message);
        // Continue without cache clearing
      }
    }

    async fetchContentCount(selectedClass, sortOrder) {
      const countData = await this.gas.getDataCount(
        selectedClass,
        sortOrder,
        this.state.showAdminFeatures
      );

      if (!countData) {
        throw new Error('No response from server for content count');
      }

      return countData;
    }

    async processContentCountResponse(countData, selectedClass, sortOrder) {
      const newCount = countData.count || 0;
      const currentCount = this.state.currentAnswers?.length || 0;
      const lastSeen = this.state.lastSeenCount || 0;

      // Enhanced consistency verification (Phase 3.1)
      const consistencyCheck = {
        lightCheckCount: newCount,
        currentDataCount: currentCount,
        lastSeenCount: lastSeen,
        hasInconsistency: Math.abs(newCount - currentCount) > 0 && currentCount > 0,
        significantChange: newCount !== lastSeen,
      };

      Logger.debug('📊 Enhanced content count check (Phase 3.1):', {
        newCount,
        currentCount,
        lastSeenCount: lastSeen,
        selectedClass,
        sortOrder,
        hadInitialFailure: this.hadInitialDataLoadFailure,
        consistencyCheck,
      });

      // ポーリング成功のマーク - unified state management (Phase 2.3)
      this.state.pollingFailureCount = 0;

      // 現在のビューキー
      const currentViewKey = `${selectedClass}-${sortOrder}`;

      // 初回データロード完了の処理
      if (!this.initialDataLoaded) {
        await this.handleInitialContentLoad(currentViewKey, newCount);
        return;
      }

      // ビュー設定変更の処理
      if (this.lastViewKey !== currentViewKey) {
        await this.handleViewChange(currentViewKey, newCount);
        return;
      }

      // 新着コンテンツの検出
      await this.checkForNewItems(newCount);
    }

    async handleInitialContentLoad(currentViewKey, newCount) {
      this.lastViewKey = currentViewKey;

      // 初期データロード失敗後の初回成功ポーリング時の特別処理
      if (this.hadInitialDataLoadFailure && newCount > this.state.lastSeenCount) {
        Logger.debug('🔄 初期データロード失敗後の新着検出:', {
          newCount,
          lastSeenCount: this.state.lastSeenCount,
          difference: newCount - this.state.lastSeenCount,
        });

        await this.checkForNewItems(newCount);
        return; // データ取得成功まで基準は更新しない
      }

      this.updateLastSeenCount(newCount);
      this.initialDataLoaded = true;

      Logger.debug('✅ Initial content load completed:', {
        viewKey: currentViewKey,
        count: newCount,
        hadPreviousFailure: this.hadInitialDataLoadFailure,
      });
    }

    async handleViewChange(currentViewKey, newCount) {
      Logger.debug('🔄 View settings changed:', {
        from: this.lastViewKey,
        to: currentViewKey,
        newCount,
      });

      this.lastViewKey = currentViewKey;
      this.updateLastSeenCount(newCount);
      this.dismissNewContentBanner();
    }

    async checkForNewItems(newCount) {
      const currentCount = this.state.currentAnswers?.length || 0;
      const lastSeen = this.state.lastSeenCount || 0;

      // Enhanced new item detection with consistency validation (Phase 3.1)
      const detectionMetrics = {
        lightCheckCount: newCount,
        currentDataCount: currentCount,
        lastSeenCount: lastSeen,
        expectedNewItems: newCount - lastSeen,
        hasNewItems: newCount > lastSeen,
        dataIsStale: currentCount > 0 && newCount > currentCount,
      };

      Logger.debug('📢 Enhanced new content detection (Phase 3.1):', detectionMetrics);

      if (detectionMetrics.hasNewItems && detectionMetrics.expectedNewItems > 0) {
        const newItems = detectionMetrics.expectedNewItems;

        // 新着通知バナーを表示
        this.showNewContentBanner(newItems);
      }
    }

    // 自動リフレッシュ機能は無効化 - 新着時は常に通知バナー表示
    shouldAutoRefresh(newItems) {
      return false;
    }

    async handleContentCheckError(error) {
      this.state.pollingFailureCount++;

      console.warn('❌ Content check failed:', {
        error: error.message,
        failureCount: this.state.pollingFailureCount,
      });

      // 連続失敗時の対処
      if (this.state.pollingFailureCount >= 3) {
        Logger.debug('⏳ Too many polling failures, extending interval...');
        await this.handlePollingFailures();
      }
    }

    async handlePollingFailures() {
      this.stopPolling();

      // 5秒後にポーリング再開
      setTimeout(() => {
        this.startPolling();
        this.state.pollingFailureCount = 0;
        Logger.debug('✅ Polling restarted after failure recovery');
      }, 5000);
    }

    // 新着通知バナーを表示
    showNewContentBanner(newItems) {
      if (!this.elements.newContentBanner) return;

      // デバウンス：短時間内の連続通知を防ぐ
      const now = Date.now();
      if (this.lastNotificationTime && now - this.lastNotificationTime < 2000) {
        Logger.debug('🚫 通知デバウンス: 短時間内の連続通知をスキップ');
        return;
      }
      this.lastNotificationTime = now;

      // 既に表示されている場合は、新しい数で上書き（累積しない）
      if (!this.elements.newContentBanner.classList.contains('hidden')) {
        Logger.debug('📱 通知更新: 既存バナーを新しい数で更新', {
          oldCount: this.state.newContentCount,
          newCount: newItems,
        });
        this.state.newContentCount = newItems; // 累積せず上書き
      } else {
        this.state.newContentCount = newItems;
      }

      this.state.hasNewContent = true;

      const message =
        this.state.newContentCount === 1
          ? '新しい意見が投稿されました'
          : `${this.state.newContentCount}件の新しい意見が投稿されました`;
      this.elements.newContentText.textContent = message;

      this.elements.newContentBanner.classList.remove('hidden');

      // アニメーションをリセットしてから適用
      this.elements.newContentBanner.style.animation = '';

      // 3秒後にバウンスアニメーション
      setTimeout(() => {
        if (!this.elements.newContentBanner.classList.contains('hidden')) {
          this.elements.newContentBanner.style.animation = 'bounce 1s ease-in-out';
        }
      }, 3000);

      Logger.debug('📢 新着通知表示:', {
        count: this.state.newContentCount,
        message: message,
      });
    }

    // 新着バナーを閉じる
    dismissNewContentBanner() {
      if (!this.elements.newContentBanner) return;

      this.elements.newContentBanner.classList.add('hidden');
      this.elements.newContentBanner.style.animation = '';
      this.state.hasNewContent = false;
      this.state.newContentCount = 0;
    }

    // コンテンツ更新（通知バナーからの呼び出し）
    async refreshContent() {
      try {
        // まず増分更新を試行
        await this.refreshContentIncremental();
      } catch (error) {
        console.error('コンテンツ更新エラー:', error);
        // 増分更新が失敗した場合はフル更新にフォールバック
        Logger.debug('🔄 フォールバック: 全体更新を実行');
        await this.refreshContentFull();
      }
    }

    // 増分コンテンツ更新（新しいカードのみ取得・追加）
    async refreshContentIncremental() {
      this.dismissNewContentBanner();

      try {
        const originalText = this.elements.refreshContentBtn
          ? this.elements.refreshContentBtn.textContent
          : '';
        if (this.elements.refreshContentBtn) {
          this.elements.refreshContentBtn.textContent = '更新中...';
          this.elements.refreshContentBtn.disabled = true;
        }

        Logger.debug('🔄 増分リフレッシュ開始 - 基準行数:', this.state.lastSeenCount || 0);

        // 現在のフィルタ設定を取得
        const selectedClass = this.elements.classFilter
          ? this.elements.classFilter.value
          : 'すべて';
        const classFilter = !selectedClass || selectedClass === 'すべて' ? null : selectedClass;
        const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
        const adminMode = this.state.showAdminFeatures;

        Logger.debug('📤 増分取得パラメータ:', {
          originalSelectedClass: selectedClass,
          processedClassFilter: classFilter,
        });

        // 増分データを取得
        const incrementalData = await this.gas.getIncrementalSheetData(
          classFilter,
          sortOrder,
          adminMode,
          this.state.lastSeenCount || 0
        );

        Logger.debug('📊 API整合性ログ - 増分データ取得完了:', {
          endpoint: 'getIncrementalSheetData',
          requestParams: {
            classFilter,
            sortOrder,
            adminMode,
            sinceRowCount: this.state.lastSeenCount || 0,
          },
          responseStructure: {
            status: incrementalData.status,
            newCount: incrementalData.newCount,
            totalCount: incrementalData.totalCount,
            hasData: !!incrementalData.data,
          },
          contextInfo: {
            purpose: 'refreshContentIncremental',
            currentAnswersLength: this.state.currentAnswers?.length || 0,
          },
        });

        if (incrementalData.status === 'error') {
          throw new Error(incrementalData.message);
        }

        // Enhanced incremental data analysis (Phase 3.2) - 改善版
        const preUpdateAnalysis = {
          newCount: incrementalData.newCount,
          totalCount: incrementalData.totalCount,
          hasNewData: incrementalData.newCount > 0,
          lastSeenCount: this.state.lastSeenCount,
          serverExpectedCount: incrementalData.totalCount,
          serverNewItems: incrementalData.newCount,
        };

        Logger.debug('📥 Enhanced incremental analysis (Phase 3.2) - 改善版:', preUpdateAnalysis);

        // サーバーベースの一貫性チェック（DOM更新前の最小限チェック）
        const criticalInconsistency = {
          zeroStateWithServerData:
            preUpdateAnalysis.totalCount > 0 &&
            (this.state.currentAnswers?.length || 0) === 0 &&
            this.state.lastSeenCount > 0,
          significantCountMismatch:
            Math.abs(preUpdateAnalysis.totalCount - this.state.lastSeenCount) > 10,
        };

        // 重大な不整合のみフルリフレッシュ（false positiveを削減）
        if (
          criticalInconsistency.zeroStateWithServerData ||
          criticalInconsistency.significantCountMismatch
        ) {
          console.warn('🚨 重大なサーバー・クライアント不整合検出 - フルリフレッシュ実行:', {
            preUpdateAnalysis,
            criticalInconsistency,
            currentAnswersLength: this.state.currentAnswers?.length || 0,
          });

          // 重大な不整合の場合のみ全体リフレッシュを実行
          await this.refreshContentFull();
          return;
        }

        // 新しいデータがない場合
        if (incrementalData.newCount === 0) {
          this.provideFeedback('最新の状態です', 'info');
          // Use unified state management even for no-data updates (Phase 2.3)
          this.synchronizeStateAfterDataUpdate(
            this.state.currentAnswers,
            'incrementalRefresh-noNewData'
          );
          return;
        }

        // Prepare merged data with proper ordering (Phase 3.2)
        let mergedData;
        if (sortOrder === 'newest') {
          mergedData = incrementalData.data.concat(this.state.currentAnswers);
        } else {
          mergedData = this.state.currentAnswers.concat(incrementalData.data);
        }

        // First: DOM update with new cards
        await this.appendNewCards(incrementalData.data, sortOrder);

        // Second: Unified state synchronization (Phase 2.3 + 3.2)
        this.synchronizeStateAfterDataUpdate(mergedData, 'incrementalRefresh');

        // Third: Clear server cache for consistency across sort orders
        this.gas.clearCache().catch((err) => console.warn('Cache clear failed', err));

        Logger.debug('✅ 増分リフレッシュ完了:', {
          addedCards: incrementalData.newCount,
          totalCards: this.state.currentAnswers?.length || 0,
          newBaseline: this.state.lastSeenCount,
        });

        this.provideFeedback(`${incrementalData.newCount}件の新しい投稿を追加しました`, 'success');
      } catch (error) {
        console.error('増分コンテンツ更新に失敗:', error);

        // エラー時は従来の全体更新にフォールバック
        Logger.debug('🔄 フォールバック: 全体更新を実行');
        await this.refreshContentFull();
      } finally {
        // ボタンを元に戻す
        if (this.elements.refreshContentBtn) {
          this.elements.refreshContentBtn.textContent =
            this.elements.refreshContentBtn.textContent.includes('更新中')
              ? originalText || '更新して表示'
              : this.elements.refreshContentBtn.textContent;
          this.elements.refreshContentBtn.disabled = false;
        }
      }
    }

    // 全体コンテンツ更新（従来の方法）
    async refreshContentFull() {
      try {
        // lastSeenCountを保持（安定化のため）
        const preservedLastSeenCount = this.state.lastSeenCount;

        // 従来の手動リフレッシュ時はキャッシュをクリアして最新データを取得
        this.cache.clear();
        Logger.debug(
          '🔄 全体リフレッシュ開始 - キャッシュクリア完了, lastSeenCount保持:',
          preservedLastSeenCount
        );

        await this.loadSheetData({ bypassCache: true });

        // 手動リフレッシュ後の新着チェック基準更新戦略
        const shouldUpdateLastSeen =
          (this.state.currentAnswers?.length || 0) > preservedLastSeenCount;

        if (shouldUpdateLastSeen) {
          // データが増加している場合のみ更新
          this.updateLastSeenCount(this.state.currentAnswers?.length || 0);
          Logger.debug('🔄 全体リフレッシュ完了、新着基準更新（データ増加）:', {
            newLastSeenCount: this.state.lastSeenCount,
            preservedCount: preservedLastSeenCount,
            currentAnswersLength: this.state.currentAnswers?.length || 0,
          });
        } else {
          // データが減少または同じ場合は保持
          this.state.lastSeenCount = preservedLastSeenCount;
          Logger.debug('🔄 全体リフレッシュ完了、新着基準保持（データ不変）:', {
            preservedLastSeenCount: preservedLastSeenCount,
            currentAnswersLength: this.state.currentAnswers?.length || 0,
            maintainedStability: true,
          });
        }

        this.provideFeedback('更新完了！', 'success');
      } catch (error) {
        console.error('全体コンテンツ更新に失敗:', error);
        this.provideFeedback('更新失敗', 'error');
        throw error;
      }
    }

    // 新着回答のポーリング開始
    startNewAnswerPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
      }

      this.pollingInterval = setInterval(async () => {
        if (!this.pollingSettings.enabled) return;

        try {
          await this.checkForNewAnswers();
          this.pollingSettings.currentRetries = 0; // 成功時はリトライカウントをリセット
        } catch (error) {
          this.pollingSettings.currentRetries++;
          console.warn(
            `ポーリングエラー (${this.pollingSettings.currentRetries}/${this.pollingSettings.maxRetries}):`,
            error
          );

          if (this.pollingSettings.currentRetries >= this.pollingSettings.maxRetries) {
            console.error('ポーリング最大リトライ数に達したため停止');
            this.stopNewAnswerPolling();
          }
        }
      }, this.pollingSettings.interval);

      Logger.debug('🔄 新着回答ポーリング開始:', {
        interval: this.pollingSettings.interval,
        enabled: this.pollingSettings.enabled,
      });
    }

    // 新着回答のポーリング停止
    stopNewAnswerPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        Logger.debug('⏹️ 新着回答ポーリング停止');
      }
    }

    // 新着回答の確認
    async checkForNewAnswers() {
      if (this.state.isLoading) return; // 既にロード中の場合は跳ばす

      try {
        const selectedClass = this.elements.classFilter
          ? this.elements.classFilter.value
          : 'すべて';
        const classFilter = !selectedClass || selectedClass === 'すべて' ? null : selectedClass;
        const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
        const adminMode = this.state.showAdminFeatures;

        Logger.debug('📤 新着確認パラメータ:', {
          originalSelectedClass: selectedClass,
          processedClassFilter: classFilter,
        });

        const incrementalData = await this.gas.getIncrementalSheetData(
          classFilter,
          sortOrder,
          adminMode,
          this.state.lastSeenCount || 0
        );

        if (incrementalData.status === 'error') {
          throw new Error(incrementalData.message);
        }

        // 新着データがある場合
        if (incrementalData.newCount > 0) {
          Logger.debug('🆕 新着回答検出:', {
            newCount: incrementalData.newCount,
            totalCount: incrementalData.totalCount,
          });

          this.state.hasNewContent = true;
          this.state.newContentCount = incrementalData.newCount;
          this.showNewContentBanner(incrementalData.newCount);
        }
      } catch (error) {
        console.error('新着確認エラー:', error);
        throw error;
      }
    }

    // コンテンツを更新（手動） - 増分更新を優先
    async refreshContent() {
      // 増分更新を試行、失敗時は全体更新にフォールバック
      await this.refreshContentIncremental();
    }

    // 新しいカードを既存のカードコンテナに追加
    async appendNewCards(newData, sortOrder = 'newest') {
      if (!newData || newData.length === 0) return;

      Logger.debug('📌 新しいカードを追加:', newData.length + '件');

      const container = this.elements.answersContainer;
      if (!container) return;

      this.removeEmptyState();

      // 新しいカードを作成してコンテナに追加
      const fragment = document.createDocumentFragment();
      const addedCardIds = [];

      for (const data of newData) {
        const cardElement = this.createAnswerCard(data);
        if (cardElement) {
          // 差分追加カードとしてマーク
          cardElement.setAttribute('data-differential-card', 'true');
          cardElement.setAttribute('data-added-timestamp', Date.now().toString());

          // 新しいカードであることを示すアニメーション
          cardElement.style.opacity = '0';
          cardElement.style.transform = 'translateY(20px)';
          fragment.appendChild(cardElement);

          // 追加されたカードのIDを記録
          if (data.rowIndex !== undefined) {
            addedCardIds.push(data.rowIndex);
          }
        }
      }

      // 差分追加カードのIDをローカルストレージに保存
      if (addedCardIds.length > 0) {
        this.saveDifferentialCards(addedCardIds);
      }

      if (sortOrder === 'newest') {
        container.prepend(fragment);
      } else {
        container.appendChild(fragment);
      }

      // アニメーションで新しいカードを表示
      await new Promise((resolve) => {
        requestAnimationFrame(() => {
          const newCards = container.querySelectorAll('.answer-card[style*="opacity: 0"]');
          newCards.forEach((card, index) => {
            setTimeout(() => {
              card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
              card.style.opacity = '1';
              card.style.transform = 'translateY(0)';
            }, index * 100); // 100msずつ遅延して順次表示
          });

          // 全てのアニメーションが完了するまで待機
          setTimeout(resolve, newCards.length * 100 + 300);
        });
      });
    }

    // ユーザーフィードバック表示
    provideFeedback(message, type = 'info') {
      if (!this.elements.refreshContentBtn) return;

      const originalText = this.elements.refreshContentBtn.textContent;
      const originalBackground = this.elements.refreshContentBtn.style.background;

      this.elements.refreshContentBtn.textContent = message;

      switch (type) {
        case 'success':
          this.elements.refreshContentBtn.style.background = 'rgba(16, 185, 129, 0.3)';
          break;
        case 'error':
          this.elements.refreshContentBtn.style.background = 'rgba(239, 68, 68, 0.3)';
          break;
        case 'info':
          this.elements.refreshContentBtn.style.background = 'rgba(59, 130, 246, 0.3)';
          break;
      }

      setTimeout(() => {
        this.elements.refreshContentBtn.textContent = originalText;
        this.elements.refreshContentBtn.style.background = originalBackground;
      }, 2000);
    }

    startPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
      }

      // Adaptive polling: start with normal interval, adjust based on success/failure
      this.pollSuccessCount = 0;
      this.pollFailureCount = 0;
      this.currentPollInterval = this.isLowPerformanceMode ? 30000 : 15000;

      const adaptivePoll = async () => {
        Logger.debug('⏰ ポーリング実行:', {
          currentInterval: this.currentPollInterval,
          successCount: this.pollSuccessCount,
          failureCount: this.pollFailureCount,
          timestamp: new Date().toLocaleTimeString(),
        });

        try {
          await this.checkForNewContentLight();
          this.pollSuccessCount++;
          this.pollFailureCount = 0;

          // Reduce interval on consistent success (but not below minimum)
          if (this.pollSuccessCount > 3 && this.currentPollInterval > 10000) {
            this.currentPollInterval = Math.max(10000, this.currentPollInterval * 0.9);
          }

          Logger.debug('✅ ポーリング成功:', {
            successCount: this.pollSuccessCount,
            nextInterval: this.currentPollInterval,
          });
        } catch (error) {
          this.pollFailureCount++;
          this.pollSuccessCount = 0;

          // Increase interval on failures (exponential backoff)
          if (this.pollFailureCount > 2) {
            this.currentPollInterval = Math.min(60000, this.currentPollInterval * 1.5);
          }
          console.warn('❌ ポーリング失敗:', error, {
            failureCount: this.pollFailureCount,
            newInterval: this.currentPollInterval,
          });
        }

        // Schedule next poll with current interval
        this.pollingTimeout = setTimeout(adaptivePoll, this.currentPollInterval);
      };

      // Start first poll
      this.pollingTimeout = setTimeout(adaptivePoll, this.currentPollInterval);

      // Start automatic cleanup for memory management
      // 定期的なクリーンアップとメモリ管理
      this.cleanupInterval = setInterval(
        () => {
          this.performMemoryCleanup();
        },
        5 * 60 * 1000
      ); // Cleanup every 5 minutes

      // 長時間実行監視（1時間ごと）
      this.longRunningCheckInterval = setInterval(
        () => {
          this.checkLongRunningPerformance();
        },
        60 * 60 * 1000
      ); // Check every hour
    }
    stopPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }

      if (this.pollingTimeout) {
        clearTimeout(this.pollingTimeout);
        this.pollingTimeout = null;
      }

      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = null;
      }

      if (this.longRunningCheckInterval) {
        clearInterval(this.longRunningCheckInterval);
        this.longRunningCheckInterval = null;
      }
    }

    // メモリ管理とクリーンアップ
    performMemoryCleanup() {
      try {
        Logger.debug('🧹 Performing memory cleanup...');

        // キャッシュクリーンアップ
        if (this.cache) {
          const cacheSize = this.cache.size();
          this.cache.cleanup();
          Logger.debug('🗑️ Cache cleanup completed', { cacheSize });
        }

        // 古いDOM要素の参照をクリア
        this.cleanupDOMReferences();

        // イベントリスナーの整理
        this.cleanupEventListeners();

        // 仮想スクロール状態の最適化
        this.optimizeVirtualScrollState();

        Logger.debug('✅ Memory cleanup completed');
      } catch (error) {
        console.warn('⚠️ Memory cleanup failed:', error);
      }
    }

    cleanupDOMReferences() {
      // 削除されたDOM要素への参照をクリア
      const elementsToCheck = ['answersContainer', 'loadingOverlay', 'newContentBanner'];
      elementsToCheck.forEach((key) => {
        const element = this.elements[key];
        if (element && !document.contains(element)) {
          Logger.debug(`🧹 Removing stale DOM reference: ${key}`);
          delete this.elements[key];
        }
      });
    }

    cleanupEventListeners() {
      // 重複したイベントリスナーの確認とクリーンアップ
      if (this.handlers) {
        Object.keys(this.handlers).forEach((key) => {
          if (typeof this.handlers[key] !== 'function') {
            Logger.debug(`🧹 Removing invalid handler: ${key}`);
            delete this.handlers[key];
          }
        });
      }
    }

    optimizeVirtualScrollState() {
      // 仮想スクロール状態の最適化
      if (this.virtualScrollState && this.virtualScrollState.renderedRowIndexes) {
        const size = this.virtualScrollState.renderedRowIndexes.size;
        if (size > 1000) {
          // 大量のインデックスが蓄積されている場合
          Logger.debug(`🧹 Optimizing virtual scroll state (${size} items)`);
          this.virtualScrollState.renderedRowIndexes.clear();
          this.virtualScrollState.renderedItems = 0;
        }
      }
    }

    checkLongRunningPerformance() {
      try {
        const uptime = Date.now() - this.state.startTime;
        const uptimeHours = Math.floor(uptime / (1000 * 60 * 60));

        Logger.debug(`⏰ Long-running check: ${uptimeHours}h uptime`);

        // 2時間以上実行されている場合のパフォーマンス対策
        if (uptimeHours >= 2) {
          Logger.debug('🔧 Applying long-running optimizations...');

          // ポーリング間隔を延長（負荷軽減）
          if (this.currentPollInterval < 60000) {
            // 1分未満の場合
            this.currentPollInterval = Math.min(60000, this.currentPollInterval * 1.5);
            Logger.debug(`📉 Polling interval extended to ${this.currentPollInterval}ms`);
          }

          // 強制的なメモリクリーンアップ
          this.performMemoryCleanup();

          // 可能であればガベージコレクションを促す
          if (window.gc && typeof window.gc === 'function') {
            window.gc();
            Logger.debug('🗑️ Manual garbage collection triggered');
          }
        }

        // 6時間以上の場合は警告
        if (uptimeHours >= 6) {
          console.warn(
            '⚠️ Application has been running for over 6 hours. Consider refreshing the page.'
          );
          this.showWarningMessage(
            '長時間の実行が検出されました。パフォーマンス向上のため、ページの再読み込みを推奨します。'
          );
        }
      } catch (error) {
        console.warn('⚠️ Long-running performance check failed:', error);
      }
    }

    showWarningMessage(message) {
      // 警告メッセージを表示（既存のshowErrorMessageを参考に）
      const warningDiv = this._createElement('div');
      warningDiv.className =
        'fixed top-4 right-4 z-50 bg-yellow-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md border-l-4 border-yellow-400';
      
      const warningIcon = this.getIcon('x', 'w-5 h-5 mr-2');
      const closeIcon = this.getIcon('x', 'w-4 h-4');
      
      warningDiv.innerHTML = `
      <div class="flex items-center">
        ${warningIcon}
        <span class="text-sm">${this.escapeHtml(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 hover:bg-yellow-700 rounded p-1">
          ${closeIcon}
        </button>
      </div>
    `;

      document.body.appendChild(warningDiv);

      // 10秒後に自動削除
      setTimeout(() => {
        if (warningDiv.parentNode) {
          warningDiv.parentNode.removeChild(warningDiv);
        }
      }, 10000);
    }

    destroy() {
      this.stopPolling();
      this.cleanup();
      if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
        this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
      }
      if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
        this.elements.answerModalCloseBtn.removeEventListener(
          'click',
          this.handlers.onAnswerModalCloseClick
        );
      }
      if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
        this.elements.answerModalContainer.removeEventListener(
          'click',
          this.handlers.onAnswerModalContainerClick
        );
      }
      if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
        this.elements.infoModalConfirmBtn.removeEventListener(
          'click',
          this.handlers.onInfoModalConfirmClick
        );
      }
      if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
        this.elements.modalReactionContainer.removeEventListener(
          'click',
          this.handlers.onModalReactionClick
        );
      }
      if (this.elements.classFilter && this.handlers.onClassFilterChange) {
        this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
      }
      if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
        this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
      }
      if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
        this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
      }
      if (this.handlers.onDocumentKeydown) {
        document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
      }
      if (this.handlers.onWindowResize) {
        window.removeEventListener('resize', this.handlers.onWindowResize);
      }
      if (this.handlers.onVisibilityChange) {
        document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
      }
      if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
        this.elements.answersContainer.removeEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
      }
      if (this.handlers.onDocumentClick) {
        document.removeEventListener('click', this.handlers.onDocumentClick);
      }
      // Cleanup observers
      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
      // Cancel any pending callbacks
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
      }
      if (this.idleCallbackId) {
        cancelIdleCallback(this.idleCallbackId);
      }
      // 漏れていたイベントリスナーの削除
      if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
        this.elements.refreshContentBtn.removeEventListener(
          'click',
          this.handlers.onRefreshContentClick
        );
      }
      if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
        this.elements.dismissBannerBtn.removeEventListener(
          'click',
          this.handlers.onDismissBannerClick
        );
      }
      if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
        this.elements.endPublicationBtn.removeEventListener(
          'click',
          this.handlers.onEndPublicationClick
        );
      }
      if (this.elements.sheetSelector && this.handlers.onSheetSelectorChange) {
        this.elements.sheetSelector.removeEventListener(
          'change',
          this.handlers.onSheetSelectorChange
        );
      }

      // イベントリスナー設定フラグのリセット
      this.eventDelegationSetup = false;
      this.nonCriticalListenersSetup = false;
      this.modalOperationPending = false;

      // Clear caches
      this.cache.clear();
      this.deferredUpdates.clear();
      this.domFragmentPool.length = 0;
    }
    async loadDataImmediate() {
      try {
        Logger.debug('🚀 AnswerBoardApp: Starting immediate data loading...');

        // 1. Validate essential prerequisites
        if (!this.validatePrerequisites()) {
          console.error(
            '❌ AnswerBoardApp: Prerequisites validation failed, aborting initialization'
          );
          this.displayInitializationError(
            'アプリケーションの初期化に必要な条件が満たされていません'
          );
          return;
        }

        // 2. Verify admin status to ensure proper initialization
        Logger.debug('🔍 AnswerBoardApp: Verifying admin status...');
        await this.verifyAdminAsync().catch((error) => {
          console.warn(
            '⚠️ AnswerBoardApp: Admin verification failed, continuing with default permissions:',
            error.message
          );
        });

        // 3. Start loading immediately without waiting
        Logger.debug('📊 AnswerBoardApp: Starting sheet data loading...');
        try {
          await this.loadSheetData({ showLoading: false, isInitialLoad: true, bypassCache: true });
          Logger.debug('✅ AnswerBoardApp: Sheet data loaded, restoring differential cards...');

          // 差分カードの復元
          this.restoreDifferentialCards();

          Logger.debug('✅ AnswerBoardApp: Starting polling...');
          this.startPolling();
        } catch (error) {
          console.error('❌ AnswerBoardApp: Sheet data loading failed:', error);
          this.displayDataLoadError(error.message || 'データの読み込みに失敗しました');
        }

        // 4. Load sheets in background only for administrators
        if (this.state.isAdminUser) {
          Logger.debug('👑 AnswerBoardApp: Loading available sheets for admin user...');
          try {
            await this.loadAvailableSheets();
          } catch (error) {
            console.warn('⚠️ AnswerBoardApp: Available sheets loading failed:', error.message);
          }
        }

        Logger.debug('🎯 AnswerBoardApp: Immediate loading initialization completed');
      } catch (error) {
        console.error('❌ AnswerBoardApp: Critical error in loadDataImmediate:', error);
        this.displayInitializationError(
          'アプリケーションの初期化中にエラーが発生しました: ' + error.message
        );
      }
    }

    /**
     * Validate essential prerequisites for app initialization
     * @returns {boolean} true if all prerequisites are met
     */
    validatePrerequisites() {
      const userId = window.USER_ID || new URLSearchParams(window.location.search).get('userId');
      const checks = [
        { name: 'userId', value: userId, required: true },
        { name: 'answersContainer', value: this.elements.answersContainer, required: true },
        { name: 'sheetName', value: this.state.sheetName, required: false },
        {
          name: 'google.script.run',
          value: typeof google !== 'undefined' && google.script && google.script.run,
          required: true,
        },
      ];

      let allValid = true;
      Logger.debug('🔍 AnswerBoardApp: Validating prerequisites:');

      checks.forEach((check) => {
        const isValid = check.required ? !!check.value : true;
        const status = isValid ? '✅' : '❌';
        Logger.debug(
          `  ${status} ${check.name}: ${check.required ? 'required' : 'optional'} - ${isValid ? 'OK' : 'MISSING'}`
        );

        if (check.required && !isValid) {
          allValid = false;
        }
      });

      // 検証済みのuserIdをstateに保存
      if (userId && allValid) {
        this.state.tenantId = userId;
      }

      return allValid;
    }

    // Unified error display system
    displayError(message, type = 'init') {
      const container = this.elements.answersContainer;
      if (!container) return;
      
      const config = {
        init: { color: 'red', iconName: 'x', title: '初期化エラー', buttons: 'reload' },
        data: { color: 'yellow', iconName: 'x', title: 'データ読み込みエラー', buttons: 'both' }
      }[type];
      
      const retryBtn = config.buttons === 'both' ? `
          <button onclick="window.answerBoardApp && window.answerBoardApp.loadSheetData({ bypassCache: true, isInitialLoad: true })" 
            class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600">再試行</button>` : '';
      
      const iconSvg = this.getIcon(config.iconName, `mx-auto h-12 w-12 text-${config.color}-500`);
      
      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        ${iconSvg}
        <h3 class="mt-2 text-lg font-medium text-${config.color}-400">${config.title}</h3>
        <p class="mt-1 text-sm text-gray-400">${this.escapeHtml(message)}</p>
        <div class="mt-6 space-x-3">
          <button onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600">
            ページを再読み込み
          </button>${retryBtn}
        </div>
      </div>`;
    }
    displayInitializationError(message) { this.displayError(message, 'init'); }
    displayDataLoadError(message) { this.displayError(message, 'data'); }

    showErrorMessage(message, isTemporary = true) {
      // 一時的なエラーメッセージを表示（トースト風）
      const errorDiv = this._createElement('div');
      errorDiv.className =
        'fixed top-4 right-4 z-50 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md';
      
      const errorIcon = this.getIcon('x', 'w-5 h-5 mr-2');
      
      errorDiv.innerHTML = `
      <div class="flex items-center">
        ${errorIcon}
        <span class="text-sm">${this.escapeHtml(message)}</span>
      </div>
    `;

      document.body.appendChild(errorDiv);

      if (isTemporary) {
        // 5秒後に自動削除
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 5000);
      }

      return errorDiv;
    }

    showMinimalSkeleton() {
      // シンプルなローディング表示
      const container = this.elements.answersContainer;
      if (!container) return;
      
      container.innerHTML = `
        <div class="text-center py-16 col-span-full">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-400"></div>
          <p class="mt-4 text-gray-400">データを読み込み中...</p>
        </div>
      `;
    }

    displayEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      const emptyIcon = this.getIcon('x', 'mx-auto h-12 w-12 text-gray-500');

      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        ${emptyIcon}
        <h3 class="mt-2 text-lg font-medium text-white">まだ回答がありません</h3>
        <p class="mt-1 text-sm text-gray-400">最初の回答者になりましょう！</p>
      </div>
    `;
    }

    /**
     * 空状態のバナーを削除します。
     */
    removeEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      const banner = container.querySelector('[data-empty-state="true"]');
      if (banner) {
        banner.remove();
      }
    }

    safeDisplayEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      // 既存のカードがあるかチェック
      const existingCards = container.querySelectorAll('.answer-card');
      if (existingCards.length > 0) {
        Logger.debug(
          'safeDisplayEmptyState: 既存カードが',
          existingCards.length,
          '個あるため空状態を表示しません'
        );
        return; // カードがある場合は空状態を表示しない
      }

      // currentAnswersもチェック
      if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
        Logger.debug(
          'safeDisplayEmptyState: currentAnswersに',
          this.state.currentAnswers?.length || 0,
          '個のアイテムがあるため空状態を表示しません'
        );
        return; // データがある場合も空状態を表示しない
      }

      // ローディング中は表示しない
      if (this.state.isLoading) {
        Logger.debug('safeDisplayEmptyState: ローディング中のため空状態を表示しません');
        return;
      }

      Logger.debug('safeDisplayEmptyState: 条件を満たしたため空状態を表示します');
      this.displayEmptyState();
    }

    async clearAllCardsForEmptyData() {
      // 真の初回判定: localStorage状態 + DOM状態を確認
      const isFirstTime = this.isFirstTimeBoardAccess();

      if (isFirstTime) {
        Logger.debug('🎯 初回ボードアクセス: 初期化処理を実行します');
      } else {
        Logger.debug('🗑️ clearAllCardsForEmptyData: 空データ受信のため全カードをクリアします');
      }

      // currentAnswersを空にリセット
      this.state.currentAnswers = [];

      // DOM内の全カードをクリア
      const container = this.elements.answersContainer;
      if (container) {
        const existingCards = container.querySelectorAll('.answer-card');

        if (existingCards.length > 0) {
          if (isFirstTime) {
            Logger.debug(
              '初回ボード初期化: DOM内の',
              existingCards.length,
              '個の要素を初期化します'
            );
          } else {
            Logger.debug(
              'clearAllCardsForEmptyData: DOMから',
              existingCards.length,
              '個のカードを削除します'
            );
          }

          // オブザーバーからカードを解除
          existingCards.forEach((card) => {
            if (this.visibilityObserver) {
              this.visibilityObserver.unobserve(card);
            }
            if (this.scrollObserver) {
              this.scrollObserver.unobserve(card);
            }
          });

          // DOMをクリア
          container.innerHTML = '';

          // DOM clearing completion wait (Phase 1.3)
          await new Promise((resolve) => requestAnimationFrame(resolve));
          Logger.debug('✅ DOM清除完了、次のフレームで差分復元準備完了');
        }
      }

      // バーチャルスクロール状態をリセット
      if (this.virtualScrollState) {
        this.virtualScrollState = {
          renderedItems: 0,
          totalItems: 0,
          isLoading: false,
          renderedRowIndexes: new Set(),
          cardRegistry: new Map(),
        };
      }

      Logger.debug('✅', isFirstTime ? '初回初期化完了' : 'clearAllCardsForEmptyData: クリア完了');
    }

    async validatePostLoadState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      const domCards = container.querySelectorAll('.answer-card');
      const dataLength = this.state.currentAnswers ? this.state.currentAnswers.length : 0;

      Logger.debug(
        '🔍 validatePostLoadState: DOMカード数:',
        domCards.length,
        'currentAnswers数:',
        dataLength
      );

      // 空データなのにDOMにカードが残っている場合
      if (dataLength === 0 && domCards.length > 0) {
        console.warn(
          '⚠️ 状態不整合検出: 空データなのにDOMに',
          domCards.length,
          '個のカードが残っています'
        );

        // 空データのためのクリーンアップを実行
        await this.clearAllCardsForEmptyData();

        // 空状態を表示
        this.displayEmptyState();

        Logger.debug('✅ 状態不整合を修正しました');
      } else if (dataLength !== domCards.length) {
        // 仮想スクロール時は正常な状態なので警告を出さない
        const isVirtualScrollActive = dataLength > RENDER_BATCH_SIZE;
        
        if (isVirtualScrollActive) {
          Logger.debug(`🌀 仮想スクロールアクティブ: DOM=${domCards.length}, データ=${dataLength} (正常状態)`);
        } else {
          // 通常レンダリングでの不整合のみ警告
          console.warn(
            '⚠️ 状態不整合検出: DOMカード数とデータ数が一致しません。DOM:',
            domCards.length,
            'データ:',
            dataLength
          );
          // 不整合がある場合は再レンダリング
          Logger.debug('再レンダリングを実行します...');
          this.renderBoard(false, false);
        }
      } else {
        Logger.debug('✅ 状態検証: DOMとデータの状態が一致しています');
      }

      // 設定と表示内容の一致性を検証
      this.validateConfigConsistency();
    }

    validateConfigConsistency() {
      // フロントエンドの表示している質問文を取得
      const displayedHeader = this.elements.headingLabel
        ? this.elements.headingLabel.textContent
        : '';

      // 現在のデータ数とポーリングで取得したカウントを比較
      const currentDataCount = this.state.currentAnswers ? this.state.currentAnswers.length : 0;

      Logger.debug('🔍 設定一致性検証:', {
        表示中の質問文: displayedHeader,
        現在のデータ数: currentDataCount,
        最新ポーリング結果: this.lastPollingResult || '未実行',
      });

      // ポーリング結果と現在のデータ数の不一致を検出
      if (this.lastPollingResult && this.lastPollingResult.newCount !== currentDataCount) {
        console.warn('⚠️ データ不整合検出:', {
          ポーリングカウント: this.lastPollingResult.newCount,
          表示データ数: currentDataCount,
          差分: this.lastPollingResult.newCount - currentDataCount,
        });

        // 不整合が検出された場合の対応
        this.handleDataInconsistency();
      }
    }

    async handleDataInconsistency() {
      Logger.debug('🔄 データ不整合を解決するため詳細分析を開始します...');

      try {
        // 1. 現在の状態を詳細に分析
        const currentState = await this.analyzeCurrentDataState();

        // 2. 不整合の種類を特定
        const inconsistencyType = this.classifyInconsistency(currentState);

        // 3. 不整合タイプに応じた修復戦略を実行
        await this.executeRepairStrategy(inconsistencyType, currentState);
      } catch (error) {
        console.error('⚠️ データ不整合修復でエラー:', error);
        // フォールバック: 従来の強制リフレッシュ
        this.forceDataRefresh().catch((fallbackError) => {
          console.error('⚠️ フォールバック強制リフレッシュもエラー:', fallbackError);
        });
      }
    }

    async analyzeCurrentDataState() {
      const container = this.elements.answersContainer;
      const domCards = container ? container.querySelectorAll('.answer-card') : [];

      return {
        domCardCount: domCards.length,
        stateDataCount: this.state.currentAnswers ? this.state.currentAnswers.length : 0,
        lastSeenCount: this.state.lastSeenCount || 0,
        pollingResult: this.lastPollingResult,
        hasLocalStorage: this.hasRelevantLocalStorage(),
        isInitialLoad: !this.initialDataLoaded,
        timestamp: new Date().toISOString(),
      };
    }

    classifyInconsistency(state) {
      if (state.isInitialLoad && state.domCardCount > 0) {
        return 'phantom_cards_on_init';
      } else if (state.stateDataCount === 0 && state.pollingResult?.newCount > 0) {
        return 'empty_state_with_server_data';
      } else if (state.domCardCount !== state.stateDataCount) {
        return 'dom_state_mismatch';
      } else if (state.lastSeenCount > state.stateDataCount) {
        return 'seen_count_ahead';
      } else {
        return 'general_inconsistency';
      }
    }

    async executeRepairStrategy(type, state) {
      Logger.debug('🔧 不整合修復戦略:', type, state);

      switch (type) {
        case 'phantom_cards_on_init':
          Logger.debug('👻 初回読み込み時の幽霊カードを修復');
          await this.clearAllCardsForEmptyData();
          await this.loadSheetData({ bypassCache: true });
          break;

        case 'empty_state_with_server_data':
          Logger.debug('📡 サーバーデータ存在時の空状態を修復');
          await this.performServerDataSync();
          break;

        case 'dom_state_mismatch':
          Logger.debug('🔄 DOM-State不整合を修復');
          await this.resyncDOMWithState();
          break;

        case 'seen_count_ahead':
          Logger.debug('📊 lastSeenCount先行問題を修復');
          this.updateLastSeenCount(state.stateDataCount);
          break;

        default:
          Logger.debug('🔄 一般的な不整合修復');
          await this.forceDataRefresh();
      }
    }

    hasRelevantLocalStorage() {
      const userId = this.state?.userId || CONFIG.userId;
      const sheetName = CONFIG.sheetName;

      return {
        hasLastSeen: localStorage.getItem(`lastSeenCount_${userId}_${sheetName}`) !== null,
        hasDiffCards: localStorage.getItem(`differentialCards_${userId}_${sheetName}`) !== null,
      };
    }

    async performServerDataSync() {
      Logger.debug('🔄 サーバーデータ同期開始');

      // 軽量チェックで最新のカウントを取得
      const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
      const classFilter = !selectedClass || selectedClass === 'すべて' ? null : selectedClass;

      Logger.debug('📤 軽量チェックパラメータ:', {
        originalSelectedClass: selectedClass,
        processedClassFilter: classFilter,
      });

      const countData = await this.gas.getDataCount(
        classFilter,
        'newest',
        this.state.showAdminFeatures
      );

      Logger.debug('📊 API整合性ログ - 軽量チェック完了:', {
        endpoint: 'getDataCount',
        requestParams: {
          classFilter,
          sortOrder: 'newest',
          showAdminFeatures: this.state.showAdminFeatures,
        },
        responseData: countData,
        contextInfo: {
          lastSeenCount: this.state.lastSeenCount,
          currentAnswersLength: this.state.currentAnswers?.length || 0,
          purpose: 'performServerDataSync',
        },
      });

      Logger.debug('📊 サーバーカウント確認:', countData);

      if (countData && countData.count > 0) {
        // サーバーにデータがある場合は強制再読み込み
        await this.loadSheetData({ bypassCache: true });
      } else {
        // サーバーにもデータがない場合は空状態を表示
        this.displayEmptyState();
      }
    }

    async resyncDOMWithState() {
      Logger.debug('🔄 DOM-State再同期開始');

      // 現在のstateデータに基づいてDOMを再構築
      if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
        this.renderBoard(this.state.currentAnswers, []);
      } else {
        await this.clearAllCardsForEmptyData();
        this.displayEmptyState();
      }
    }

    async forceDataRefresh() {
      Logger.debug('🗑️ 強制データリフレッシュ開始...');

      // lastSeenCountを保持（安定化のため）
      const preservedLastSeenCount = this.state.lastSeenCount;

      // フロントエンドキャッシュをクリア
      if (this.cache) {
        this.cache.clear();
        Logger.debug(
          '✅ フロントエンドキャッシュをクリア, lastSeenCount保持:',
          preservedLastSeenCount
        );
      }

      // サーバーキャッシュをクリア
      try {
        await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .refreshBoardData();
        });
        Logger.debug('✅ サーバーキャッシュをクリア');
      } catch (error) {
        console.warn('⚠️ サーバーキャッシュクリアでエラー:', error);
      }

      // 強制データ再読み込み
      await this.loadSheetData({ bypassCache: true });

      // lastSeenCount復元（安定化のため）
      const shouldPreserveLastSeen =
        (this.state.currentAnswers?.length || 0) <= preservedLastSeenCount;
      if (shouldPreserveLastSeen && preservedLastSeenCount > 0) {
        this.state.lastSeenCount = preservedLastSeenCount;
        Logger.debug('✅ 強制データリフレッシュ完了、lastSeenCount復元:', {
          preservedCount: preservedLastSeenCount,
          currentAnswersLength: this.state.currentAnswers?.length || 0,
          stabilityMaintained: true,
        });
      } else {
        Logger.debug('✅ 強制データリフレッシュ完了、新データによりlastSeenCount更新:', {
          oldCount: preservedLastSeenCount,
          newCount: this.state.lastSeenCount,
          currentAnswersLength: this.state.currentAnswers?.length || 0,
        });
      }
    }

    /**
     * データ取得結果の有効性を判定
     * @param {object} result - サーバーからの応答
     * @returns {boolean} 有効なデータかどうか
     */
    isValidDataResult(result) {
      try {
        // 基本構造の確認
        if (!result || typeof result !== 'object') {
          Logger.debug('🔍 データ判定: 結果がオブジェクトではない');
          return false;
        }

        // レスポンス構造の詳細ログ
        Logger.debug('🔍 データ判定: レスポンス構造確認', {
          hasStatus: 'status' in result,
          status: result.status,
          hasData: 'data' in result,
          dataType: Array.isArray(result.data) ? 'array' : typeof result.data,
          dataLength: Array.isArray(result.data) ? result.data.length : 'N/A',
          hasHeader: 'header' in result,
          hasSheetName: 'sheetName' in result,
          keys: Object.keys(result),
        });

        // 2つの可能なレスポンス形式に対応
        // 1. 新形式: { status: 'success', data: [...], header: '...', sheetName: '...' }
        // 2. 旧形式: { data: [...], header: '...', sheetName: '...' } (statusフィールドなし)

        const hasStatusField = 'status' in result;

        // ステータス確認（存在する場合のみ）
        if (hasStatusField && result.status !== 'success') {
          Logger.debug('🔍 データ判定: ステータスが成功ではない -', result.status);
          return false;
        }

        // データ配列の存在確認
        if (!Array.isArray(result.data)) {
          Logger.debug('🔍 データ判定: dataが配列ではない', typeof result.data);
          return false;
        }

        // ヘッダー情報の確認（任意フィールド）
        if (result.header && typeof result.header !== 'string') {
          Logger.debug('🔍 データ判定: ヘッダー情報の型が不正', typeof result.header);
          return false;
        }

        // シート名の確認（任意フィールド）
        if (result.sheetName && typeof result.sheetName !== 'string') {
          Logger.debug('🔍 データ判定: シート名の型が不正', typeof result.sheetName);
          return false;
        }

        Logger.debug('✅ データ判定: 有効なデータ構造 -', {
          status: result.status || '(no status field)',
          dataLength: result.data?.length || 0,
          hasHeader: !!result.header,
          sheetName: result.sheetName,
        });

        return true;
      } catch (error) {
        console.warn('⚠️ データ判定エラー:', error);
        return false;
      }
    }

    /**
     * データ検証失敗の理由を取得
     * @param {object} result - 検証対象のレスポンス
     * @returns {string} 失敗理由
     */
    getValidationFailureReason(result) {
      if (!result) {
        return 'レスポンスがnull/undefined';
      }
      if (typeof result !== 'object') {
        return `レスポンスがオブジェクトではない (${typeof result})`;
      }

      const hasStatusField = 'status' in result;
      if (hasStatusField && result.status !== 'success') {
        return `ステータスが成功ではない (${result.status})`;
      }

      if (!('data' in result)) {
        return 'dataフィールドが存在しない';
      }
      if (!Array.isArray(result.data)) {
        return `dataが配列ではない (${typeof result.data})`;
      }

      if (result.header && typeof result.header !== 'string') {
        return `ヘッダーの型が不正 (${typeof result.header})`;
      }
      if (result.sheetName && typeof result.sheetName !== 'string') {
        return `シート名の型が不正 (${typeof result.sheetName})`;
      }

      return '不明な検証失敗';
    }

    /**
     * リトライ機能付きデータ取得
     * @param {object} fetchParams - データ取得パラメータ
     * @param {boolean} isInitialLoad - 初期ロードかどうか
     * @returns {Promise} データ取得結果
     */
    async performDataFetchWithRetry(fetchParams, isInitialLoad) {
      // CLAUDE.md準拠: 強化されたリトライ戦略
      const MAX_ATTEMPTS = isInitialLoad ? 3 : 4; // 試行回数増加
      const retryDelays = isInitialLoad ? [300, 800, 1500] : [500, 1200, 2500, 5000]; // 指数バックオフ
      let lastError = null;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        try {
          Logger.debug(`📡 データ取得試行 ${attempt + 1}/${MAX_ATTEMPTS}:`, fetchParams);

          // データ取得を Promise で実行
          const result = await new Promise((resolve, reject) => {
            // データ件数に応じた動的タイムアウト設定
            const baseTimeout = attempt === 0 ? 30000 : 20000; // ベース: 30秒/20秒
            const dataCountEstimate = this.state.currentAnswers?.length || 0;
            const timeoutMultiplier = dataCountEstimate > 200 ? 1.5 : dataCountEstimate > 100 ? 1.25 : 1;
            const dynamicTimeout = Math.round(baseTimeout * timeoutMultiplier);
            
            Logger.debug(`⏱️ 動的タイムアウト設定: ${dynamicTimeout}ms (データ件数: ${dataCountEstimate}, 倍率: ${timeoutMultiplier})`);
            
            const timeout = setTimeout(
              () => {
                reject(new Error(`データ取得がタイムアウトしました (タイムアウト: ${dynamicTimeout}ms)`));
              },
              dynamicTimeout
            );

            // パラメータ詳細ログ
            Logger.debug(`📡 GAS API呼び出し直前 (試行 ${attempt + 1}):`, {
              tenantId: fetchParams.tenantId,
              tenantIdType: typeof fetchParams.tenantId,
              classFilter: fetchParams.classFilter,
              sortOrder: fetchParams.sortOrder,
              showAdminFeatures: fetchParams.showAdminFeatures,
              bypassCache: fetchParams.bypassCache || false,
              allFetchParams: fetchParams,
            });

            google.script.run
              .withSuccessHandler((response) => {
                clearTimeout(timeout);
                Logger.debug(`✅ GAS API成功レスポンス受信 (試行 ${attempt + 1}):`, {
                  hasResponse: !!response,
                  responseType: typeof response,
                  responseKeys: response ? Object.keys(response) : [],
                });
                resolve(response);
              })
              .withFailureHandler((error) => {
                clearTimeout(timeout);
                console.error(`❌ GAS API失敗レスポンス受信 (試行 ${attempt + 1}):`, {
                  error: error,
                  errorMessage: error ? error.message : 'Unknown error',
                  errorType: typeof error,
                });
                reject(error);
              })
              .getPublishedSheetData(
                fetchParams.tenantId,
                fetchParams.classFilter,
                fetchParams.sortOrder,
                fetchParams.showAdminFeatures,
                fetchParams.bypassCache || false
              );
          });

          // レスポンスの詳細ログ
          Logger.debug(`🔍 データ取得レスポンス (試行 ${attempt + 1}):`, {
            hasResult: !!result,
            resultType: typeof result,
            resultKeys: result ? Object.keys(result) : [],
            hasData: result && 'data' in result,
            dataType:
              result && result.data
                ? Array.isArray(result.data)
                  ? 'array'
                  : typeof result.data
                : 'undefined',
            dataLength: result && Array.isArray(result.data) ? result.data.length : 'N/A',
          });

          // 成功した場合は結果を返す - 改善された判定条件
          if (result && this.isValidDataResult(result)) {
            Logger.debug(`✅ データ取得成功 (試行 ${attempt + 1}):`, result.data?.length || 0, '件');
            return result;
          }

          // データが空またはエラーの場合
          if (result && result.status === 'error') {
            const isUserNotFoundError =
              result.message && result.message.includes('ユーザー情報が見つかりません');

            if (isUserNotFoundError && attempt < MAX_ATTEMPTS - 1) {
              console.warn(
                `⚠️ ユーザー情報エラー、リトライします (試行 ${attempt + 1}):`,
                result.message
              );

              // ユーザー情報エラーの場合は診断・修復を試行
              try {
                Logger.debug('🔧 サーバー側診断・修復を要求中...');
                await new Promise((resolve, reject) => {
                  google.script.run
                    .withSuccessHandler(resolve)
                    .withFailureHandler(reject)
                    .performAutoRepair(fetchParams.tenantId);
                });
                Logger.debug('✅ サーバー側修復完了、次の試行に進みます');
              } catch (repairError) {
                console.warn('⚠️ サーバー側修復失敗:', repairError);
              }
            } else {
              // ユーザー情報エラー以外、または最後の試行
              throw new Error(result.message || '不明なエラー');
            }
          }

          // 無効なデータの場合（詳細な理由を記録）
          const validationReason = this.getValidationFailureReason(result);
          if (attempt < MAX_ATTEMPTS - 1) {
            console.warn(
              `⚠️ 無効なデータ、リトライします (試行 ${attempt + 1}): ${validationReason}`
            );
          } else {
            console.warn(
              `❌ 最大試行回数に達しました、最後のレスポンスを返します: ${validationReason}`
            );
            // 有効でないデータでも、何らかのレスポンスがあれば返す
            return result || { status: 'error', message: 'データが見つかりませんでした', data: [] };
          }
        } catch (error) {
          lastError = error; // エラー履歴を保存
          console.error(`❌ データ取得エラー (試行 ${attempt + 1}):`, {
            message: error.message,
            stack: error.stack,
            fetchParams: fetchParams,
            timestamp: new Date().toISOString(),
          });

          // 最後の試行で失敗した場合：包括的なエラーレポートを作成
          if (attempt >= MAX_ATTEMPTS - 1) {
            const comprehensiveError = new Error(
              `データ取得に${MAX_ATTEMPTS}回失敗しました。最後のエラー: ${error.message}`
            );
            comprehensiveError.originalError = error;
            comprehensiveError.allAttempts = attempt + 1;
            comprehensiveError.fetchParams = fetchParams;
            throw comprehensiveError;
          }

          // 一時的なエラーの場合はリトライ
          const isTemporaryError =
            error.message.includes('timeout') ||
            error.message.includes('network') ||
            error.message.includes('script runtime') ||
            error.message.includes('temporarily unavailable');

          if (!isTemporaryError && error.message.includes('ユーザー情報が見つかりません')) {
            // ユーザー情報エラーは特別扱い（上記の処理に委ねる）
            throw error;
          }

          if (isTemporaryError || attempt < MAX_ATTEMPTS - 1) {
            const delay = retryDelays[attempt] || 3000;
            Logger.debug(`⏳ ${delay}ms 待機後にリトライ...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            throw error;
          }
        }
      }

      // ここに到達することはないはずですが、安全のため
      throw new Error('予期しないエラー: リトライループを抜けました');
    }

    /**
     * ユーザー情報が見つからない場合のエラー画面を表示
     * @param {string} errorMessage - エラーメッセージ
     */
    displayUserNotFoundError(errorMessage) {
      const container = this.elements.answersContainer;
      if (!container) return;

      const isUserNotFoundError =
        errorMessage &&
        (errorMessage.includes('ユーザー情報が見つかりません') ||
          errorMessage.includes('が見つかりません'));

      const errorIcon = this.getIcon('x', 'mx-auto h-12 w-12 text-red-500');

      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        ${errorIcon}
        <h3 class="mt-2 text-lg font-medium text-red-400">${isUserNotFoundError ? 'ユーザー情報が見つかりません' : 'アクセスエラー'}</h3>
        <p class="mt-1 text-sm text-gray-400">${
          isUserNotFoundError
            ? 'この回答ボードは存在しないか、アクセス権限が不正です'
            : 'この回答ボードにアクセスする権限がありません'
        }</p>
        ${
          isUserNotFoundError
            ? `
        <div class="mt-4 p-4 bg-blue-900/20 border border-blue-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-blue-400 mb-2">🔍 考えられる原因：</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>• URLのユーザーIDが無効または期限切れ</li>
            <li>• ボードが削除されたか非アクティブ化された</li>
            <li>• データベース接続に一時的な問題</li>
            <li>• サーバー側の権限設定に問題</li>
            <li>• ブラウザのセッション情報が破損</li>
          </ul>
        </div>
        <div class="mt-4 p-4 bg-green-900/20 border border-green-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-green-400 mb-2">💡 解決方法：</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>• まずページを再読み込みしてみる</li>
            <li>• 正しいボードURLを管理者に確認</li>
            <li>• 5-10分待ってから再度アクセス</li>
            <li>• 別のブラウザで試してみる</li>
            <li>• 新しい回答ボードを作成する</li>
          </ul>
        </div>
        <div class="mt-4 p-3 bg-yellow-900/20 border border-yellow-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-yellow-400 mb-2">🛠️ 自動修復：</h4>
          <p class="text-xs text-gray-400">システムは自動的に問題の修復を試行しています。数分後に再度アクセスすると解決している可能性があります。</p>
        </div>`
            : ''
        }
        <p class="mt-2 text-xs text-gray-500">エラー詳細: ${this.escapeHtml(errorMessage)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800"
          >
            ${this.getIcon('x', '-ml-1 mr-2 h-4 w-4')}
            ページを再読み込み
          </button>
        </div>
      </div>
    `;
    }

    // Add these two methods
    showLoadingOverlay(message = '') {
      if (window.unifiedLoading) {
        window.unifiedLoading.setLoading(true, {
          message: '', // No message for transparent overlay
          type: 'transparent',
          disableInteraction: true,
        });
      }

      // Add loading-active class to body and container to disable render optimizations
      // This prevents stacking context issues with the loading overlay
      document.body.classList.add('loading-active');
      if (this.elements.answersContainer) {
        this.elements.answersContainer.classList.add('loading-active');
        // Replace render-optimized with loading-safe temporarily
        if (this.elements.answersContainer.classList.contains('render-optimized')) {
          this.elements.answersContainer.classList.add('loading-safe');
        }
      }
    }

    hideLoadingOverlay() {
      if (window.unifiedLoading) {
        window.unifiedLoading.setLoading(false);
      }

      // Remove loading-active classes to restore render optimizations
      document.body.classList.remove('loading-active');
      if (this.elements.answersContainer) {
        this.elements.answersContainer.classList.remove('loading-active');
        // Remove loading-safe class to restore normal render optimization
        this.elements.answersContainer.classList.remove('loading-safe');
      }
    }

    async loadSheetData(options = {}) {
      // Normalize options with defaults
      const config = {
        showLoading: options.showLoading !== false, // default true
        bypassCache: options.bypassCache || false,
        isInitialLoad: options.isInitialLoad || false,
        requestedSheetName: options.requestedSheetName || null,
        ...options,
      };

      if (config.isInitialLoad) {
        config.bypassCache = true;
      }

      // Prevent concurrent loading
      if (this.state.isLoading && config.showLoading) {
        Logger.debug('loadSheetData: Already loading, skipping...');
        return;
      }

      try {
        this.state.isLoading = true;
        if (config.showLoading) {
          this.showLoadingOverlay();
        }

        Logger.debug('🔍 loadSheetData started:', config);
        const oldAnswers = [...(this.state.currentAnswers || [])];

        // Clear caches if needed
        if (config.bypassCache || this.shouldClearCache(config)) {
          await this.clearDataCaches(config.bypassCache && config.isInitialLoad);
        }

        // Load data with simplified parameters
        await this.performDataLoad(config, oldAnswers);
      } catch (error) {
        console.error('❌ loadSheetData error:', error);
        this.handleLoadError(error);
      } finally {
        this.state.isLoading = false;
        this.hideLoadingOverlay();
      }
    }

    shouldClearCache(config) {
      // Clear cache on sheet switching or explicit refresh
      return (
        (config.requestedSheetName &&
          config.requestedSheetName !== this.state.currentActiveSheet) ||
        (config.showLoading && !config.isInitialLoad)
      );
    }

    async clearDataCaches(isCompleteBypass = false) {
      Logger.debug('🧹 Clearing data caches...', { isCompleteBypass });

      // Clear frontend cache
      if (this.cache) {
        this.cache.clear();
        Logger.debug('✅ Frontend cache cleared');
      }

      // Clear UnifiedCache if available
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
        Logger.debug('✅ UnifiedCache cleared');
      }

      // Clear localStorage cache entries for complete bypass
      if (isCompleteBypass) {
        try {
          const keys = Object.keys(localStorage);
          const cacheKeys = keys.filter(
            (key) =>
              key.includes('cache_') ||
              key.includes('lastSeenCount_') ||
              key.includes('differentialCards_')
          );
          cacheKeys.forEach((key) => localStorage.removeItem(key));
          Logger.debug('✅ localStorage cache cleared:', cacheKeys.length, 'keys');
        } catch (error) {
          console.warn('⚠️ Failed to clear localStorage cache:', error);
        }
      }

      // Clear server cache
      try {
        await this.gas.clearCache();
        Logger.debug('✅ Server cache cleared');
      } catch (error) {
        console.warn('⚠️ Failed to clear server cache:', error);
      }
    }

    /**
     * 非公開状態遷移用の包括的キャッシュクリア
     * 既存のclearDataCachesを拡張し、より強力なキャッシュクリアを実行
     */
    clearAllCachesForUnpublished() {
      Logger.debug('🧹 非公開状態遷移: 包括的キャッシュクリア開始');

      try {
        // 1. 既存のキャッシュクリア機能を使用
        if (this.cache && typeof this.cache.clear === 'function') {
          this.cache.clear();
          Logger.debug('🗑️ Frontend cache cleared');
        }

        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
          Logger.debug('🗑️ Unified cache cleared');
        }

        // 2. 拡張されたローカルストレージクリア
        const localStorageKeys = Object.keys(localStorage);
        const studyQuestKeys = localStorageKeys.filter(
          (key) =>
            key.includes('studyquest') ||
            key.includes('board') ||
            key.includes('sheet') ||
            key.includes('admin') ||
            key.includes('publication') ||
            key.includes('answer') ||
            key.includes('cache_') ||
            key.includes('lastSeenCount_') ||
            key.includes('differentialCards_')
        );

        studyQuestKeys.forEach((key) => {
          localStorage.removeItem(key);
          Logger.debug('🗑️ Removed localStorage key:', key);
        });

        // 3. セッションストレージクリア
        if (window.sessionStorage) {
          const sessionKeys = Object.keys(sessionStorage);
          const studyQuestSessionKeys = sessionKeys.filter(
            (key) => key.includes('studyquest') || key.includes('board') || key.includes('admin')
          );

          studyQuestSessionKeys.forEach((key) => {
            sessionStorage.removeItem(key);
            Logger.debug('🗑️ Removed sessionStorage key:', key);
          });
        }

        // 4. アプリケーションの状態リセット
        if (this.state) {
          this.state.currentAnswers = [];
          this.state.hasNewContent = false;
          this.state.newContentCount = 0;
          this.state.lastSeenCount = 0;
        }

        // 5. キャッシュ無効化タイムスタンプ設定
        localStorage.setItem('lastUnpublishTime', Date.now().toString());
        localStorage.setItem('unpublishedRedirectTimestamp', new Date().toISOString());

        Logger.debug('✅ 非公開状態遷移用キャッシュクリア完了');
      } catch (error) {
        console.error('❌ 非公開状態キャッシュクリアでエラー:', error);
        // エラーがあっても処理は継続
      }
    }

    async performDataLoad(config, oldAnswers) {
      // Get current filter and sort settings
      const isInitialLoad = config.isInitialLoad;
      const requestedSheetName = config.requestedSheetName;
      const selectedClass = isInitialLoad
        ? 'すべて'
        : this.elements.classFilter
          ? this.elements.classFilter.value
          : 'すべて';
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';

      // Show skeleton cards during loading
      if (config.showLoading && !config.isInitialLoad) {
        // シンプルローディングで置き換え
        this.showMinimalSkeleton();
      }
      try {
        // classFilter「すべて」または空の場合はサーバーに送信しない（全データ取得のため）
        const classFilter = !selectedClass || selectedClass === 'すべて' ? null : selectedClass;

        // データ取得パラメータの詳細ログ
        const fetchParams = {
          tenantId: this.state.tenantId,
          classFilter,
          sortOrder,
          showAdminFeatures: this.state.showAdminFeatures,
          requestedSheetName,
          bypassCache: config.bypassCache || false,
        };

        Logger.debug('📤 データ取得パラメータ:', {
          ...fetchParams,
          originalSelectedClass: selectedClass,
          processedClassFilter: classFilter,
        });
        Logger.debug('📡 Starting data fetch with parameters:', fetchParams);

        // エラーハンドリング強化版のデータ取得
        await this.performDataFetchWithRetry(fetchParams, isInitialLoad)
          .then(async (result) => {
            try {
              // 初期ロードタイムアウトをクリア
              if (isInitialLoad && this.initTimeoutId) {
                clearTimeout(this.initTimeoutId);
                this.initTimeoutId = null;
              }

              if (
                !result ||
                !result.data ||
                (Array.isArray(result.data) && result.data.length === 0)
              ) {
                // 詳細なエラーログ出力
                if (result && result.status === 'error') {
                  console.error('❌ AnswerBoardApp: Data fetch failed with error:', result.message);

                  // ユーザー情報エラーの特別な処理
                  if (result.message && result.message.includes('ユーザー情報が見つかりません')) {
                    console.error(
                      '❌ AnswerBoardApp: User not found. Current tenantId:',
                      this.state.tenantId
                    );
                    console.error('❌ AnswerBoardApp: URL parameters:', window.location.href);
                    console.error('❌ AnswerBoardApp: This may indicate:');
                    console.error('  1. Invalid userId parameter in URL');
                    console.error('  2. User not registered in the system');
                    console.error('  3. Database connectivity issues');
                    console.error('  4. Session expired or corrupted');
                    console.error('❌ AnswerBoardApp: Possible solutions:');
                    console.error('  - Check if the URL parameters are correct');
                    console.error('  - Try refreshing the page');
                    console.error('  - Contact administrator if the issue persists');

                    // UIにエラーメッセージを表示
                    this.displayUserNotFoundError(result.message);
                    return;
                  }
                } else {
                  // データ不整合チェック: 軽量チェックでデータが存在するかを確認
                  console.warn('⚠️ AnswerBoardApp: Received empty or invalid data:', result);

                  try {
                    // 初期データロード時は高速復旧戦略を採用
                    if (isInitialLoad) {
                      Logger.debug('🚀 初期データロード失敗 - 高速復旧戦略を実行');

                      // 軽量チェックでデータ存在を確認
                      const countData = await this.gas.getDataCount(
                        classFilter,
                        'newest',
                        this.state.showAdminFeatures
                      );

                      if (countData && countData.count > 0) {
                        Logger.debug(
                          `⚡ 軽量チェックで${countData.count}件検出 - 後続ポーリングで復旧予定`
                        );
                        // 初期データロード失敗フラグを設定してポーリングに委ねる
                        this.hadInitialDataLoadFailure = true;
                        this.state.lastSeenCount = 0;
                      }
                    } else {
                      // 通常時は従来のフォールバック処理（簡素化版）
                      const countData = await this.gas.getDataCount(
                        classFilter,
                        'newest',
                        this.state.showAdminFeatures
                      );
                      // Enhanced consistency check with lastSeenCount (Phase 2.2)
                      const expected = countData?.count || 0;
                      const actual = result?.data ? result.data.length : 0;
                      const lastSeen = this.state.lastSeenCount || 0;

                      Logger.debug('🔍 Enhanced data consistency check (Phase 2.2):', {
                        expected,
                        actual,
                        lastSeen,
                        fullDataEmpty: actual === 0,
                        requestedSheet: requestedSheetName,
                        currentSheet: this.state.currentActiveSheet,
                        shouldTriggerRefresh: expected > 0 && actual === 0 && expected !== lastSeen,
                      });

                      // Only trigger fallback if there's significant inconsistency
                      // considering user's previously seen count
                      if (expected > 0 && actual === 0 && expected !== lastSeen) {
                        console.warn(
                          '⚠️ Significant data inconsistency detected!',
                          `Expected: ${expected}, Actual: ${actual}, LastSeen: ${lastSeen}`
                        );
                        Logger.debug('🔄 Attempting simplified fallback...');

                        // 簡素化されたフォールバック（待機時間短縮）
                        await new Promise((resolve) => setTimeout(resolve, 500));

                        const retryResult = await new Promise((resolve, reject) => {
                          google.script.run
                            .withSuccessHandler(resolve)
                            .withFailureHandler(reject)
                            .getPublishedSheetData(
                              this.state.tenantId,
                              classFilter,
                              this.elements.sortOrder ? this.elements.sortOrder.value : 'newest',
                              this.state.showAdminFeatures,
                              true
                            );
                        });

                        if (retryResult && retryResult.data && retryResult.data.length > 0) {
                          Logger.debug(
                            '✅ Fallback retry successful! Got',
                            retryResult.data.length,
                            'items'
                          );
                          result = retryResult; // 成功した結果を使用
                        } else {
                          console.warn('❌ Fallback retry also returned empty data');
                        }
                      }
                    }
                  } catch (fallbackError) {
                    console.warn('⚠️ Fallback data consistency check failed:', fallbackError);
                  }
                }

                // 再チェック後もデータが空の場合のみ空状態を表示
                if (
                  !result ||
                  !result.data ||
                  (Array.isArray(result.data) && result.data.length === 0)
                ) {
                  // 空データ受信時は古いカードを強制的にクリア
                  await this.clearAllCardsForEmptyData();

                  // 空状態を表示
                  this.displayEmptyState();
                  if (isInitialLoad) {
                    this.state.lastSeenCount = 0;
                    // 初期データロード失敗フラグを設定
                    this.hadInitialDataLoadFailure = true;
                    Logger.debug('🚨 初期データロード失敗をマーク（後続ポーリングで通知を有効化）');
                  }
                  return;
                }
              }

              Logger.debug('📊 API整合性ログ - データ受信完了:', {
                endpoint: 'getPublishedSheetData',
                requestParams: {
                  classFilter: fetchParams.classFilter,
                  sortOrder: fetchParams.sortOrder,
                  showAdminFeatures: fetchParams.showAdminFeatures,
                  bypassCache: fetchParams.bypassCache,
                },
                responseStructure: {
                  hasData: !!result.data,
                  dataLength: result.data?.length || 0,
                  hasHeader: !!result.header,
                  status: result.status,
                },
                contextInfo: {
                  isInitialLoad,
                  lastSeenCount: this.state.lastSeenCount,
                  currentAnswersLength: this.state.currentAnswers?.length || 0,
                },
              });

              Logger.debug('Received data:', result.data);

              // ===== PHASE 2.1 & 2.3: STRICT PROCESSING ORDER WITH UNIFIED STATE =====
              // Step 1 & 2: Data acquisition and unified state synchronization
              const syncResult = this.synchronizeStateAfterDataUpdate(
                result.data,
                'performDataLoad'
              );
              Logger.debug(
                '✅ Step 1-2: Data acquisition and state synchronization completed:',
                syncResult
              );

              // 取得されたデータの詳細を確認
              Logger.debug(
                '取得データ詳細:',
                (result.data || []).map((item, index) => ({
                  index: index,
                  rowIndex: item.rowIndex,
                  opinion: item.opinion?.substring(0, 50) + '...',
                  reason: item.reason,
                  reasonLength: item.reason?.length || 0,
                  reasonExists: !!item.reason,
                  reasonTrimmed: item.reason?.trim(),
                  allKeys: Object.keys(item),
                }))
              );

              // サーバーからの質問文と現在表示の一致性をチェック
              if (result.header) {
                const currentDisplayed = this.elements.headingLabel
                  ? this.elements.headingLabel.textContent
                  : '';
                // サーバー設定の質問文を強制適用
                if (result.header && this.elements.headingLabel) {
                  if (currentDisplayed !== result.header) {
                    console.info('🔄 質問文をサーバー設定に更新:', {
                      旧: currentDisplayed || '未設定',
                      新: result.header
                    });
                    this.elements.headingLabel.textContent = result.header;
                  }
                }
              }

              // Apply saved reaction states to restore user's previous reactions
              this.applyReactionState(result.data);

              // Populate class filter with available classes and make it visible
              this.populateClassFilter(result.data || []);

              // アクティブシート情報を記録（ポーリングで使用）
              this.state.activeSheetInfo = {
                sheetName: result.sheetName || 'フォームの回答 1',
                opinionHeader: result.header || 'お題',
                lastUpdated: Date.now(),
              };
              Logger.debug('📄 アクティブシート情報を更新:', this.state.activeSheetInfo);

              this.lastDataLoadTime = Date.now();

              // 🧹 データ読み込み成功時：スケルトンカードの確実なクリア
              const container = this.elements.answersContainer;
              if (!container) {
                console.warn('⚠️ answersContainer要素が見つかりません');
                return;
              }
              const existingSkeletons = container.querySelectorAll('.skeleton, .answer-card.loading');
              if (existingSkeletons.length > 0) {
                Logger.debug('🧹 データ読み込み成功：', existingSkeletons.length, '個のスケルトンカードをクリア');
                existingSkeletons.forEach(skeleton => skeleton.remove());
              }

              if (isInitialLoad) {
                // 初期データロード完了フラグを設定
                this.initialDataLoaded = true;
                const selectedClass = this.elements.classFilter
                  ? this.elements.classFilter.value
                  : 'すべて';
                const sortOrder = this.elements.sortOrder
                  ? this.elements.sortOrder.value
                  : 'newest';
                this.lastViewKey = `${selectedClass}-${sortOrder}`;
                // Initial data load completed
              }

              // Update heading with the actual question text from server (only if valid)
              if (
                result.header &&
                this.elements.headingLabel &&
                result.header !== '読み込み中...' &&
                !result.header.includes('読み込み') &&
                result.header.trim() !== ''
              ) {
                this.elements.headingLabel.textContent = result.header;
              }

              // Step 3: DOM update with proper sequencing (Phase 2.1)
              requestAnimationFrame(async () => {
                Logger.debug('✅ Step 3: DOM update starting...');
                await this.renderBoard(false, isInitialLoad);
                Logger.debug('✅ Step 3: DOM update completed');

                // Step 4: DOM整合性チェック(レンダリング後に実行)
                const currentDataLength = this.state.currentAnswers?.length || 0;
                this.logDataConsistencyMetrics('performDataLoad-after-render', currentDataLength, 0);
                
                // Step 5: Consistency validation after DOM update (Phase 2.1)
                Logger.debug('✅ Step 5: Consistency validation starting...');
                await this.validatePostLoadState();
                Logger.debug('✅ Step 5: Consistency validation completed');
              });
            } finally {
              // 成功時にローディング状態を解除
              this.state.isLoading = false;
              this.hideLoadingOverlay();
            }
          })
          .catch((error) => {
            try {
              // 初期ロードタイムアウトをクリア
              if (isInitialLoad && this.initTimeoutId) {
                clearTimeout(this.initTimeoutId);
                this.initTimeoutId = null;
              }

              console.error('❌ AnswerBoardApp: All retry attempts failed:', error);

              // Check if the error indicates the board has been unpublished
              const errorStr = error.message || error.toString();
              if (
                errorStr.includes('アクティブなシートが見つかりません') ||
                errorStr.includes('公開されていません') ||
                errorStr.includes('unpublished') ||
                errorStr.includes('not found')
              ) {
                // Board has been unpublished, redirect to Unpublished.html
                Logger.debug('Board appears to be unpublished, redirecting...');
                this.redirectToUnpublishedPage();
                return;
              }

              this.safeDisplayEmptyState();
            } finally {
              // エラー時にもローディング状態を解除
              this.state.isLoading = false;
              this.hideLoadingOverlay();
            }
          });

        // Post-processing after successful data load
        this.adjustLayout();

        if (!this.state.isAdminUser || !window.hasAdminCapability) {
          this.state.showAdminFeatures = false;
          this.state.showHighlightToggle = false;
          // 管理モードボタンを確実に非表示
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.add('hidden');
            this.elements.adminToggleBtn.setAttribute('hidden', '');
            this.elements.adminToggleBtn.style.display = 'none';
          }
        } else {
          this.state.showHighlightToggle = true;
          // 管理モードボタンを表示
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.style.display = '';
          }
          // Admin settings updated
          this.cache.clear();
          // Cache cleared due to admin highlight settings
        }

        if (isInitialLoad) {
          this.elements.answersContainer.classList.add('render-optimized');
          // If loading is active, also add loading-safe class to prevent stacking context issues
          if (
            document.body.classList.contains('loading-active') ||
            this.elements.answersContainer.classList.contains('loading-active')
          ) {
            this.elements.answersContainer.classList.add('loading-safe');
          }
        }
      } catch (error) {
        // CLAUDE.md準拠: 包括的エラーハンドリング実装
        console.error('❌ Error loading sheet data:', error);

        // 構造化ログでデバッグ情報を詳細記録
        console.error('📋 Error context:', {
          tenantId: this.state.tenantId,
          currentAnswers: this.state.currentAnswers?.length || 0,
          isInitialLoad: config.isInitialLoad,
          bypassCache: config.bypassCache,
          userAgent: navigator.userAgent,
          timestamp: new Date().toISOString(),
          stack: error.stack,
        });

        // エラータイプ分析とユーザーフレンドリーメッセージ生成
        const errorAnalysis = this.analyzeErrorType(error);
        const userMessage = this.generateUserFriendlyErrorMessage(errorAnalysis);

        // スケルトン削除
        this.elements.answersContainer.querySelectorAll('.skeleton').forEach((el) => el.remove());

        // エラー表示UI作成
        this.elements.answersContainer.innerHTML = `
          <div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg border border-red-800/30">
            <div class="mb-4">
              <svg class="w-16 h-16 mx-auto text-red-400 mb-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
              </svg>
              <p class="font-bold text-lg">${userMessage.title}</p>
            </div>
            <div class="text-sm space-y-2 mb-4">
              <p>${userMessage.description}</p>
              ${errorAnalysis.showTechnicalDetails ? `<details class="mt-2 text-left"><summary class="cursor-pointer text-yellow-400">技術詳細を表示</summary><pre class="mt-2 p-2 bg-gray-800 rounded text-xs overflow-x-auto">${this.escapeHtml(error.message || 'Unknown error')}</pre></details>` : ''}
            </div>
            <div class="flex gap-2 justify-center">
              <button id="retryLoadBtn" class="game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">
                再試行 (${errorAnalysis.retryAttempts + 1}/3)
              </button>
              ${errorAnalysis.showResetOption ? `<button id="resetAppBtn" class="game-btn bg-red-600 text-white px-4 py-2 rounded-lg font-bold border-red-800 hover:bg-red-500 text-sm">アプリリセット</button>` : ''}
            </div>
          </div>
        `;

        // エラーリトライボタンのイベントリスナー設定
        this.setupErrorRecoveryHandlers(errorAnalysis);

        // エラー統計更新
        this.updateErrorStatistics(errorAnalysis.type);

        // 同期エラーの場合にもローディング状態を解除
        this.state.isLoading = false;
        this.hideLoadingOverlay();
      }
    }

    // CLAUDE.md準拠: エラータイプ分析メソッド
    analyzeErrorType(error) {
      const errorMessage = (error.message || '').toLowerCase();
      const stack = (error.stack || '').toLowerCase();

      // エラーリトライ統計を取得
      const retryAttempts = this.getErrorRetryCount() || 0;

      let errorType = 'unknown';
      let severity = 'medium';
      let recoverable = true;
      let showTechnicalDetails = false;
      let showResetOption = false;

      // ネットワーク関連エラー
      if (
        errorMessage.includes('network') ||
        errorMessage.includes('fetch') ||
        errorMessage.includes('timeout') ||
        errorMessage.includes('connection')
      ) {
        errorType = 'network';
        severity = 'high';
        recoverable = true;
      }
      // 認証・権限エラー
      else if (
        errorMessage.includes('unauthorized') ||
        errorMessage.includes('forbidden') ||
        errorMessage.includes('ユーザー情報が見つかりません')
      ) {
        errorType = 'auth';
        severity = 'critical';
        recoverable = false;
        showTechnicalDetails = true;
        showResetOption = true;
      }
      // データベース・サーバーエラー
      else if (
        errorMessage.includes('database') ||
        errorMessage.includes('server error') ||
        errorMessage.includes('internal') ||
        stack.includes('gas')
      ) {
        errorType = 'server';
        severity = 'high';
        recoverable = true;
        showTechnicalDetails = retryAttempts > 1;
      }
      // JavaScript実行エラー
      else if (
        stack.includes('typeerror') ||
        errorMessage.includes('undefined') ||
        errorMessage.includes('null') ||
        errorMessage.includes('cannot read')
      ) {
        errorType = 'runtime';
        severity = 'medium';
        recoverable = true;
        showTechnicalDetails = true;
      }
      // リトライ回数に基づく調整
      if (retryAttempts >= 2) {
        severity = 'critical';
        showTechnicalDetails = true;
        showResetOption = true;
      }

      return {
        type: errorType,
        severity,
        recoverable,
        retryAttempts,
        showTechnicalDetails,
        showResetOption,
        originalError: error,
      };
    }

    // CLAUDE.md準拠: ユーザーフレンドリーエラーメッセージ生成
    generateUserFriendlyErrorMessage(errorAnalysis) {
      const messages = {
        network: {
          title: 'ネットワーク接続エラー',
          description: 'インターネット接続を確認して、再試行してください。',
        },
        auth: {
          title: '認証エラー',
          description:
            'ユーザー認証に問題があります。ログイン状態を確認するか、ページを更新してください。',
        },
        server: {
          title: 'サーバーエラー',
          description:
            'サーバー側で一時的な問題が発生しています。しばらく待ってから再試行してください。',
        },
        runtime: {
          title: 'アプリケーションエラー',
          description:
            'アプリケーションの処理中にエラーが発生しました。ページの更新をお試しください。',
        },
        unknown: {
          title: '予期しないエラー',
          description:
            '不明なエラーが発生しました。ページを更新するか、管理者にお問い合わせください。',
        },
      };

      const baseMessage = messages[errorAnalysis.type] || messages.unknown;

      // 重大度に応じてメッセージを調整
      if (errorAnalysis.severity === 'critical') {
        return {
          ...baseMessage,
          title: `${baseMessage.title} (深刻)`,
          description: `${baseMessage.description} 問題が継続する場合は、管理者にお問い合わせください。`,
        };
      }

      return baseMessage;
    }

    // CLAUDE.md準拠: エラー回復ハンドラー設定
    setupErrorRecoveryHandlers(errorAnalysis) {
      // 再試行ボタンのハンドラー
      const retryBtn = this._getCachedElement('retryLoadBtn');
      if (retryBtn) {
        retryBtn.addEventListener('click', async () => {
          try {
            retryBtn.textContent = '再試行中...';
            retryBtn.disabled = true;

            // エラーリトライ回数を増加
            this.incrementErrorRetryCount();

            // 指数バックオフでリトライ
            const backoffDelay = Math.min(1000 * Math.pow(2, errorAnalysis.retryAttempts), 10000);
            await new Promise((resolve) => setTimeout(resolve, backoffDelay));

            // データリロード実行
            await this.loadSheetData({ bypassCache: true, isInitialLoad: false });
          } catch (retryError) {
            console.error('❌ Retry failed:', retryError);
            retryBtn.textContent = '再試行失敗';
            retryBtn.disabled = true;
          }
        });
      }

      // アプリリセットボタンのハンドラー
      const resetBtn = this._getCachedElement('resetAppBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          if (
            confirm(
              'アプリケーションをリセットします。すべてのローカルデータが削除されます。よろしいですか？'
            )
          ) {
            this.performAppReset();
          }
        });
      }
    }

    // CLAUDE.md準拠: エラー統計管理
    getErrorRetryCount() {
      const key = 'error_retry_count';
      return parseInt(localStorage.getItem(key) || '0', 10);
    }

    incrementErrorRetryCount() {
      const key = 'error_retry_count';
      const current = this.getErrorRetryCount();
      localStorage.setItem(key, String(current + 1));
    }

    resetErrorRetryCount() {
      localStorage.removeItem('error_retry_count');
    }

    updateErrorStatistics(errorType) {
      const statsKey = 'error_statistics';
      const stats = JSON.parse(localStorage.getItem(statsKey) || '{}');

      stats[errorType] = (stats[errorType] || 0) + 1;
      stats.lastErrorTime = Date.now();

      localStorage.setItem(statsKey, JSON.stringify(stats));
    }

    // CLAUDE.md準拠: アプリケーションリセット機能
    performAppReset() {
      try {
        // ローカルストレージクリア
        const preserveKeys = ['user_preferences']; // 保持すべきキー
        const keys = Object.keys(localStorage);
        keys.forEach((key) => {
          if (!preserveKeys.includes(key)) {
            localStorage.removeItem(key);
          }
        });

        // キャッシュクリア
        if (this.cache) {
          this.cache.clear();
        }

        // エラー統計リセット
        this.resetErrorRetryCount();

        // ページリロード
        window.location.reload();
      } catch (resetError) {
        console.error('❌ App reset failed:', resetError);
        // フォールバック: 強制リロード
        window.location.href = window.location.href;
      }
    }

    async loadAvailableSheets() {
      try {
        const sheetsData = await this.gas.getAvailableSheets();
        this.populateSheetSelector(sheetsData);
      } catch (error) {
        console.error('Failed to load available sheets:', error);
        if (this.elements.sheetSelector) {
          this.elements.sheetSelector.innerHTML =
            '<option value="">エラー: シート読み込み失敗</option>';
        }
      }
    }
    populateSheetSelector(sheets) {
      const selector = this.elements.sheetSelector;

      if (!selector) return;

      if (!sheets || sheets.length === 0) {
        selector.innerHTML = '<option value="">利用可能なシートがありません</option>';
        selector.disabled = true;
        return;
      }

      // シート選択肢を構築
      if (!Array.isArray(sheets)) {
        console.error('Invalid sheets data:', sheets);
        selector.innerHTML = '<option>シートデータが無効です</option>';
        selector.disabled = true;
        return;
      }

      const options = sheets
        .map((sheet) => {
          const selected = sheet.name === this.state.sheetName ? 'selected' : ''; // Use sheet.name for comparison
          const activeLabel =
            sheet.name === this.state.sheetName ? ' (現在のアクティブシート)' : '';
          return `<option value="${this.escapeHtml(sheet.name)}" ${selected}>${this.escapeHtml(sheet.name)}${activeLabel}</option>`;
        })
        .join('');

      selector.innerHTML = options;
      selector.disabled = false;

      // 現在のアクティブシートを記録
      // this.state.currentActiveSheet is already set by loadSheetData
    }
    async switchSheet() {
      const selectedSheet = this.elements.sheetSelector.value;

      // 早期リターン: 無効な選択または同じシート
      if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
        Logger.debug('Sheet switch skipped - same sheet or invalid selection');
        return;
      }

      // 現在切り替え中の場合は処理を拒否
      if (this.sheetSwitchInProgress) {
        Logger.debug('Sheet switch already in progress - ignoring request');
        return;
      }

      Logger.debug('🔄 Starting sheet switch:', {
        from: this.state.currentActiveSheet,
        to: selectedSheet,
        tenantId: this.state.tenantId,
      });

      try {
        this.sheetSwitchInProgress = true;

        // 前処理: 状態のクリーンアップ
        await this.prepareForSheetSwitch(selectedSheet);

        // メインプロセス: データ読み込み
        await this.performSheetSwitch(selectedSheet);

        // 後処理: 状態の確定
        await this.finalizeSheetSwitch(selectedSheet);

        Logger.debug('✅ Sheet switch completed:', {
          newSheet: selectedSheet,
          dataCount: this.state.currentAnswers?.length || 0,
        });
      } catch (error) {
        console.error('❌ Sheet switch failed:', error);
        await this.handleSheetSwitchError(error, selectedSheet);
      } finally {
        this.sheetSwitchInProgress = false;
      }
    }

    async prepareForSheetSwitch(targetSheet) {
      // 必要な前提条件をチェック
      if (!this.state.tenantId) {
        throw new Error('User ID is missing - cannot switch sheet');
      }

      // UI状態をリセット
      this.dismissNewContentBanner();

      // 仮想スクロール状態をクリア
      this.clearVirtualScrollingState();

      // 既存のポーリングを一時停止
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }

      Logger.debug('Sheet switch preparation completed');
    }

    async performSheetSwitch(targetSheet) {
      const maxRetries = 3;
      let lastError = null;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          Logger.debug(`🔄 Loading sheet data (attempt ${attempt}/${maxRetries}):`, targetSheet);

          await this.loadSheetData({
            bypassCache: true,
            requestedSheetName: targetSheet,
            showLoading: true,
          });

          Logger.debug('✅ Sheet data loaded successfully on attempt', attempt);
          return; // 成功時は早期リターン
        } catch (error) {
          lastError = error;
          console.warn(`⚠️ Sheet load attempt ${attempt} failed:`, error.message);

          if (attempt < maxRetries) {
            const delay = attempt * 1000; // 指数バックオフ
            Logger.debug(`⏳ Retrying in ${delay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }

      // すべての試行が失敗した場合
      throw new Error(
        `Failed to load sheet after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`
      );
    }

    async finalizeSheetSwitch(targetSheet) {
      // 状態の確定
      this.state.currentActiveSheet = targetSheet;
      this.state.sheetName = targetSheet;

      // 新着通知の基準をリセット
      this.state.lastSeenCount = this.state.currentAnswers?.length || 0;

      // UIの更新
      this.updateSheetSelectorLabels();
      this.updateSheetDisplayName(targetSheet);

      // ポーリングを再開
      this.startPolling();

      Logger.debug('Sheet switch finalization completed');
    }

    async handleSheetSwitchError(error, targetSheet) {
      console.error('Sheet switch error details:', {
        error: error.message,
        targetSheet,
        currentSheet: this.state.currentActiveSheet,
        tenantId: this.state.tenantId,
      });

      // 元のシートの選択に戻す
      if (this.elements.sheetSelector) {
        this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
      }

      // ポーリングを再開（元のシートで）
      this.startPolling();

      // ユーザーにエラーを通知
      if (window.messageManager) {
        window.messageManager.show(
          `ボードの切り替えに失敗しました: ${error.message}`,
          'error',
          5000
        );
      }

      // 現在のデータでUI更新を試行
      try {
        this.renderBoard(false, false);
      } catch (renderError) {
        console.error('Failed to render board after sheet switch error:', renderError);
      }
    }

    updateSheetDisplayName(sheetName) {
      if (this.elements.sheetNameText && sheetName) {
        const sheetIcon = this.getIcon('users', 'w-3 h-3 inline-block mr-1');
        this.elements.sheetNameText.innerHTML = sheetIcon + this.escapeHtml(sheetName);
      }
    }

    clearVirtualScrollingState() {
      // バーチャルスクロール状態をリセット
      if (this.virtualScrollState) {
        this.virtualScrollState = {
          renderedItems: 0,
          totalItems: 0,
          isLoading: false,
          renderedRowIndexes: new Set(),
          cardRegistry: new Map(),
        };
      }

      // 既存のオブザーバーを切断
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
        this.scrollObserver = null;
      }

      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
        // visibilityObserver は setupObservers() で再作成されるので null にしない
      }
    }

    updateSheetSelectorLabels() {
      const selector = this.elements.sheetSelector;
      const options = Array.from(selector.options);

      options.forEach((option) => {
        const sheetName = option.value;
        const isActive = sheetName === this.state.currentActiveSheet;
        const cleanName = sheetName.replace(/ \(現在のアクティブシート\)$/, '');

        if (isActive) {
          option.textContent = `${cleanName} (現在のアクティブシート)`;
        } else {
          option.textContent = cleanName;
        }
      });
    }

    populateClassFilter(rows) {
      try {
        const classFilter = this.elements.classFilter;
        if (!classFilter) {
          console.warn('populateClassFilter: classFilter要素が見つかりません');
          return;
        }

        // CLAUDE.md準拠: 包括的null安全性チェック
        Logger.debug('populateClassFilter: 引数チェック', {
          rows: rows,
          isArray: Array.isArray(rows),
          length: rows ? rows.length : 'N/A',
        });

        // 安全な配列確保とクラス抽出
        const safeRows = Array.isArray(rows) ? rows : [];
        const validRows = safeRows.filter((row) => row && typeof row === 'object');
        const classValues = validRows
          .map((row) => row.class)
          .filter((cls) => cls && typeof cls === 'string' && cls.trim());

        const uniqueClasses = ['すべて', ...new Set(classValues)];

        Logger.debug('populateClassFilter: 処理結果', {
          totalRows: safeRows.length,
          validRows: validRows.length,
          classValues: classValues.length,
          uniqueClasses: uniqueClasses,
        });

        classFilter.innerHTML = uniqueClasses
          .map(
            (c) => '<option value="' + this.escapeHtml(c) + '">' + this.escapeHtml(c) + '</option>'
          )
          .join('');
        classFilter.value = 'すべて';
        classFilter.classList.remove('hidden');
      } catch (error) {
        console.error('populateClassFilter エラー:', error);
        // フォールバック: 最小限のオプションで復旧
        try {
          const classFilter = this.elements.classFilter;
          if (classFilter) {
            classFilter.innerHTML = '<option value="すべて">すべて</option>';
            classFilter.value = 'すべて';
          }
        } catch (fallbackError) {
          console.error('populateClassFilter フォールバック失敗:', fallbackError);
        }
      }
    }

    applyReactionStyles(element, data) {
      if (!element || !data || !element.nodeType) return;

      // 既存のリアクション関連クラスをクリア
      const reactionClasses = [
        'reaction-bg-like',
        'reaction-bg-understand',
        'reaction-bg-curious',
        'reaction-bg-like-understand',
        'reaction-bg-like-curious',
        'reaction-bg-understand-curious',
        'reaction-bg-like-understand-curious',
        'reaction-border-1',
        'reaction-border-2',
        'reaction-border-3',
        'highlighted',
      ];
      reactionClasses.forEach((cls) => element.classList.remove(cls));

      // ハイライト状態を適用（リアクション装飾より優先）
      if (data.highlight) {
        element.classList.add('highlighted');
        // Highlight decoration applied
        // ハイライト時はリアクション装飾をスキップ
        return;
      } else {
        // No highlight decoration
      }

      // アクティブなリアクションを特定
      const active = this.reactionTypes
        .filter(
          (rt) => data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
        )
        .map((rt) => rt.key);

      // 背景色クラスを適用
      if (active.length === 1) {
        if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
        else element.classList.add(`reaction-bg-${active[0].toLowerCase()}`);
      } else if (active.length === 2) {
        const [a, b] = active.sort();
        const combos = { 'CURIOUS,LIKE': 'like-curious', 'LIKE,UNDERSTAND': 'like-understand', 'CURIOUS,UNDERSTAND': 'understand-curious' };
        element.classList.add(`reaction-bg-${combos[`${a},${b}`] || 'mixed'}`);
      } else if (active.length === 3) {
        element.classList.add('reaction-bg-like-understand-curious');
      }

      // ボーダー幅を適用
      const totalReactions = this.reactionTypes.reduce(
        (sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0),
        0
      );
      if (totalReactions > 0) {
        const borderClass = totalReactions >= 10 ? 'reaction-border-3' : totalReactions >= 5 ? 'reaction-border-2' : 'reaction-border-1';
        element.classList.add(borderClass);
      }
    }
    async renderBoard(isLayoutChange = false, isInitialLoad = false, oldRows = []) {
      try {
        // Define newRows first to avoid TDZ error
        const newRows = this.state.currentAnswers;

        // 空データの場合の早期処理
        if (!newRows || newRows.length === 0) {
          Logger.debug('renderBoard: 空データを受信、DOMをクリアして空状態を表示します');
          await this.renderEmptyState();
          return;
        }

        // 管理者ハイライト設定の初期化
        this.initializeAdminSettings();

        // レンダリング前の状態準備
        this.prepareRenderingState(newRows);

        // メインレンダリング処理
        this.performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad);

        // レンダリング後の状態更新
        this.finalizeRenderingState();
        this.validatePostLoadState();
      } catch (error) {
        console.error('❌ renderBoard: レンダリングエラー:', error);
        this.handleRenderingError(error);
      }
    }

    async renderEmptyState() {
      await this.clearAllCardsForEmptyData();
      this.displayEmptyState();
    }

    initializeAdminSettings() {
      // 管理者の場合はハイライトトグルを確実に有効化
      if (this.state.isAdminUser && !this.state.showHighlightToggle) {
        this.state.showHighlightToggle = true;
        this.cache.clear();
      }
    }

    prepareRenderingState(newRows) {
      const container = this.elements.answersContainer;
      if (!container) {
        console.error('⚠️ prepareRenderingState: answersContainerが見つかりません');
        return;
      }
      
      // すべてのローディング要素を削除 (シンプルローディング含む)
      container.querySelectorAll('.skeleton, .loading, [data-loading="true"], .animate-spin').forEach((el) => el.remove());
      this.updateLayoutControls(newRows);
    }

    updateLayoutControls(newRows) {
      // Batch DOM updates using performance-aware batching
      const updates = [];
      if (
        this.elements.sliderValue &&
        this.elements.sizeSlider &&
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value
      ) {
        updates.push(
          () => (this.elements.sliderValue.textContent = this.elements.sizeSlider.value)
        );
      }
      if (this.elements.sizeSlider) {
        const container = this.elements.answersContainer;
        const newClassName =
          'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
        if (container.className !== newClassName) {
          updates.push(() => (container.className = newClassName));
        }
      }
      if (this.elements.answerCount) {
        const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
        const countHtml = userIcon + '<span>' + newRows.length + '件</span>';
        if (this.elements.answerCount.innerHTML !== countHtml) {
          updates.push(() => (this.elements.answerCount.innerHTML = countHtml));
        }
      }

      // Apply updates using performance-aware batching
      this.batchDOMUpdates(updates);
    }

    performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad) {
      const container = this.elements.answersContainer;
      
      // DOMクリア前に既存カードのマップを作成
      const existingMap = new Map();
      container.querySelectorAll('.answer-card').forEach((card) => {
        existingMap.set(card.dataset.rowIndex, card);
      });

      // 不要なカードを削除
      existingMap.forEach((card, id) => {
        if (!newRows.some((r) => String(r.rowIndex) === id)) {
          card.remove();
          existingMap.delete(id);
        }
      });
      
      // 既存カードマップ取得後にコンテナをクリア
      container.innerHTML = '';

      // メインレンダリング処理
      if (newRows.length > RENDER_BATCH_SIZE) {
        this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad);
      } else {
        this.renderDirectly(newRows, oldRows, container, existingMap);
      }
    }

    renderDirectly(newRows, oldRows, container, existingMap) {
      const fragment = this.getReusableFragment();

      newRows.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find((r) => r.rowIndex === row.rowIndex);

        if (!card) {
          // 新しいカードを作成（リアクション機能を含む）
          card = this.createAnswerCard(row);
          if (card) {
            card.classList.add('new-card');
            fragment.appendChild(card);
          } else {
            console.warn('renderBoard: Failed to create card for row:', row.rowIndex);
          }
        } else if (this.shouldUpdateCard(row, oldData)) {
          // 既存カードを更新（リアクション状態を保持）
          this.updateAnswerCard(card, row, oldData);
        }
      });

      if (fragment.children.length > 0) {
        container.appendChild(fragment);
      }
    }

    calculateVisibleRange(totalItems) {
      const container = this.elements.answersContainer;
      if (!container) {
        console.warn('calculateVisibleRange: answersContainer not found.');
        return { startIndex: 0, endIndex: Math.min(totalItems, 100) };
      }

      const scrollTop = container.scrollTop;
      let containerHeight = container.clientHeight;
      const cardHeight = 150;

      // 🚀 Phase1最適化: コンテナ高さ検出の堅牢化
      if (containerHeight <= 0) {
        containerHeight = container.offsetHeight || 
                         container.getBoundingClientRect().height || 
                         window.innerHeight || 800;
        Logger.debug(`🔧 containerHeight修復: ${containerHeight}px (元値: ${container.clientHeight}px)`);
      }

      let startIndex = 0;
      let endIndex = totalItems;

      if (containerHeight > 0 && totalItems > 0) {
        // 仮想スクロールによる表示範囲計算
        const visibleCards = Math.ceil(containerHeight / cardHeight);
        const bufferSize = Math.max(20, Math.ceil(visibleCards * 0.5)); // 余分なバッファ
        
        startIndex = Math.max(0, Math.floor(scrollTop / cardHeight) - bufferSize);
        endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight) + bufferSize);
        
        // 初期表示時は十分な数を表示
        if (scrollTop === 0 && startIndex === 0) {
          endIndex = Math.min(totalItems, Math.max(100, visibleCards * 2));
        }
        
        Logger.perf(`🌀 仮想スクロール範囲: ${startIndex}-${endIndex} / ${totalItems} (visible: ${visibleCards}, buffer: ${bufferSize})`);
      } else {
        // 💡 改善された初期表示ロジック: データ量に応じた適応的表示
        if (totalItems <= 100) {
          endIndex = totalItems; // 100件以下は全表示
        } else if (totalItems <= 500) {
          endIndex = Math.min(totalItems, 150); // 500件以下は150件表示
        } else {
          endIndex = Math.min(totalItems, 200); // 大量データは200件表示
        }
        Logger.perf(`📊 適応的初期表示: ${endIndex} / ${totalItems} 件`);
      }

      return { startIndex, endIndex };
    }

    renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad) {
      Logger.perf(
        'DEBUG: renderBoard - Using virtual scrolling for',
        newRows.length,
        'items (initial load:',
        isInitialLoad,
        ')'
      );

      if (isInitialLoad || (this.state.currentAnswers?.length || 0) === 0) {
        this.clearVirtualScrollingState();
      }

      // 🚀 Phase1最適化: 仮想スクロール状態の適切な初期化
      if (!this.virtualScrollState) {
        this.virtualScrollState = {
          totalItems: newRows.length,
          renderedItems: 0,
          renderedRowIndexes: new Set(),
          isLoading: false
        };
      } else {
        this.virtualScrollState.totalItems = newRows.length;
      }

      const fragment = this.getReusableFragment();
      const visibleRange = this.calculateVisibleRange(newRows.length);
      const visibleRows = newRows.slice(visibleRange.startIndex, visibleRange.endIndex);
      
      Logger.perf('🌀 Virtual scroll range:', { 
        total: newRows.length, 
        startIndex: visibleRange.startIndex, 
        endIndex: visibleRange.endIndex, 
        visibleCount: visibleRows.length 
      });

      let renderedCount = 0;
      visibleRows.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find((r) => r.rowIndex === row.rowIndex);

        if (!card) {
          card = this.createAnswerCard(row);
          if (card) {
            fragment.appendChild(card);
            this.virtualScrollState.renderedRowIndexes.add(rowId);
            renderedCount++;
          }
        } else if (this.shouldUpdateCard(row, oldData)) {
          this.updateAnswerCard(card, row, oldData);
          this.virtualScrollState.renderedRowIndexes.add(rowId);
        }
      });

      if (fragment.children.length > 0) {
        container.appendChild(fragment);
        this.virtualScrollState.renderedItems = container.children.length;
        
        // 🎯 スクロールオブザーバーを即座に設定
        this.deferredRender(() => {
          this.setupScrollObserver();
          this.showVirtualScrollInfo(visibleRows.length, newRows.length);
        });
        
        Logger.info('✅ Virtual scroll初期化完了:', { 
          rendered: renderedCount, 
          totalRendered: this.virtualScrollState.renderedItems,
          totalItems: this.virtualScrollState.totalItems 
        });
      }
    }
    
    // 仮想スクロール情報表示(プログレッシブローディング)
    showVirtualScrollInfo(displayedCount, totalCount) {
      if (displayedCount >= totalCount) return;
      
      const infoElement = this._getCachedElement('virtual-scroll-info');
      if (infoElement) {
        infoElement.remove(); // 既存の情報を削除
      }
      
      const info = this._createElement('div');
      info.id = 'virtual-scroll-info';
      info.className = 'fixed bottom-4 right-4 bg-cyan-600 text-white px-4 py-2 rounded-lg shadow-lg text-sm z-50';
      info.innerHTML = `
        <div class="flex items-center space-x-2">
          <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
          <span>${displayedCount}件表示、残り${totalCount - displayedCount}件読み込み中...</span>
        </div>
      `;
      
      document.body.appendChild(info);
      
      // 3秒後に自動消去
      setTimeout(() => {
        if (info.parentNode) {
          info.remove();
        }
      }, 3000);
    }

    shouldUpdateCard(newData, oldData) {
      if (!oldData) return true;
      
      const getTotalReactions = data => this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
      
      return getTotalReactions(newData) !== getTotalReactions(oldData) ||
        ['isHighlighted', 'opinion', 'name'].some(key => newData[key] !== oldData[key]) ||
        this.validateReasonText(newData.reason) !== this.validateReasonText(oldData.reason);
    }

    finalizeRenderingState() {
      // レンダリング完了後の状態更新
      this.updateAnswerCount();
      this.applyAnimations();
    }

    updateAnswerCount() {
      if (!this.elements.answerCount) return;

      const count = Array.isArray(this.state.currentAnswers) ? this.state.currentAnswers.length : 0;
      const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
      this.elements.answerCount.innerHTML = userIcon + '<span>' + count + '件</span>';
    }

    applyAnimations() {
      if (!this.elements.answersContainer) return;

      const newCards = this.elements.answersContainer.querySelectorAll('.new-card');
      newCards.forEach((card) => {
        requestAnimationFrame(() => {
          card.classList.remove('new-card');
        });
      });
    }

    handleRenderingError(error) {
      console.error('レンダリングエラーの詳細:', error);

      // フォールバック: 最小限の表示を試行
      try {
        const container = this.elements.answersContainer;
        container.innerHTML = `
        <div class="text-center py-8 col-span-full">
          <p class="text-red-400">表示エラーが発生しました</p>
          <button onclick="location.reload()" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded">
            再読み込み
          </button>
        </div>
      `;
      } catch (fallbackError) {
        console.error('フォールバック表示も失敗:', fallbackError);
      }
    }

    updateAnswerCard(card, newData, oldData) {
      if (!card || !newData) return;

      try {
        if (!oldData || oldData.opinion !== newData.opinion) {
          const opinionElement = card.querySelector('.opinion-text');
          if (opinionElement) {
            opinionElement.textContent = newData.opinion || '';
          }
        }

        if (
          !oldData ||
          this.validateReasonText(oldData.reason) !== this.validateReasonText(newData.reason)
        ) {
          const reasonElement = card.querySelector('.answer-preview p');
          if (reasonElement) {
            reasonElement.textContent = newData.reason || '';
          }
        }

        if (!oldData || oldData.name !== newData.name) {
          const nameElement = card.querySelector('.font-bold');
          if (nameElement) {
            nameElement.textContent = newData.name || '';
          }
        }

        // リアクション状態を保持しつつ更新
        this.updateCardReactions(card, newData);

        // ハイライト状態を更新
        this.updateCardHighlight(card, newData);
      } catch (error) {
        console.error('updateAnswerCard error:', error);
      }
    }

    updateCardReactions(card, data) {
      const reactionContainer = card.querySelector('.reaction-container');
      if (!reactionContainer) return;

      // DOM操作をバッチ化
      const updates = [];

      this.reactionTypes.forEach((reactionType) => {
        const newCount = data.reactions?.[reactionType.key]?.count || 0;
        const reacted = data.reactions?.[reactionType.key]?.reacted || false;

        // バッチ更新用にデータを蓄積
        updates.push({
          rowIndex: data.rowIndex,
          reaction: reactionType.key,
          count: newCount,
          reacted,
          shouldDisplay: newCount > 0,
        });
      });

      // バッチでDOM更新を実行
      this.batchUpdateReactionButtons(updates);
      this.updateCardReactionBackground(card, data);
    }

    // バッチ処理でリアクションボタンを更新
    batchUpdateReactionButtons(updates, options = {}) {
      const { onComplete, immediate = false } = options;
      const fragment = document.createDocumentFragment();
      const updatedElements = new Map();

      const executeUpdate = () => {
        try {
          updates.forEach((update) => {
            const buttons = document.querySelectorAll(
              `[data-row-index="${update.rowIndex}"][data-reaction="${update.reaction}"]`
            );

            buttons.forEach((btn) => {
              if (!updatedElements.has(btn)) {
                // カウント表示更新
                const countEl = btn.querySelector('.reaction-count');
                if (countEl && this.state.showCounts) {
                  countEl.textContent = update.count;
                }

                // アイコン更新
                const rt = this.reactionTypes.find((r) => r.key === update.reaction);
                const svgEl = btn.querySelector('svg');
                if (svgEl && rt) {
                  svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', update.reacted);
                }

                // スタイル更新
                const colorClass =
                  update.reaction === 'LIKE'
                    ? 'text-red-500'
                    : update.reaction === 'UNDERSTAND'
                      ? 'text-yellow-500'
                      : 'text-green-500';
                btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
                btn.classList.add(colorClass);
                btn.classList.toggle('liked', update.reacted);
                btn.setAttribute('aria-pressed', update.reacted.toString());

                // 表示/非表示
                btn.style.display = update.shouldDisplay ? 'flex' : 'none';

                // aria-label更新
                const reactionName = SYSTEM_CONSTANTS.REACTIONS.LABELS[update.reaction] || update.reaction;
                const ariaLabel = `${reactionName}${update.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${update.count}件)` : ''}`;
                btn.setAttribute('aria-label', ariaLabel);

                updatedElements.set(btn, true);
              }
            });
          });

          // 完了コールバック実行
          if (onComplete) {
            onComplete(updatedElements);
          }
        } catch (error) {
          console.error('batchUpdateReactionButtons error:', error);
          if (onComplete) {
            onComplete(updatedElements, error);
          }
        }
      };

      // 即座実行 or requestAnimationFrame
      if (immediate) {
        executeUpdate();
      } else {
        requestAnimationFrame(executeUpdate);
      }
    }

    updateCardReactionBackground(card, data) {
      // リアクションに基づいてカードの背景とボーダーを更新
      this.applyReactionStyles(card, data);
    }

    updateCardHighlight(card, data) {
      const isHighlighted = data.isHighlighted || data.highlight;

      if (isHighlighted) {
        card.classList.add('highlighted-card');
      } else {
        card.classList.remove('highlighted-card');
      }

      // Update highlight button if present
      const highlightBtn = card.querySelector('.highlight-btn');
      if (highlightBtn) {
        highlightBtn.classList.toggle('active', isHighlighted);
      }
    }

    updateExistingCard(card, row, oldData, changedItems) {
      if (oldData) {
        let hasChanges = false;

        if (oldData.opinion !== row.opinion) {
          const t = card.querySelector('.opinion-text');
          if (t) {
            t.textContent = row.opinion;
            hasChanges = true;
          }
        }

        if (oldData.reason !== row.reason) {
          const p = card.querySelector('.answer-preview p');
          if (p) {
            p.textContent = row.reason;
            hasChanges = true;
          }
        }

        if (oldData.name !== row.name) {
          const n = card.querySelector('.font-bold');
          if (n) {
            n.textContent = row.name;
            hasChanges = true;
          }
        }

        if (
          JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) ||
          oldData.highlight !== row.highlight
        ) {
          hasChanges = true;
        }

        if (hasChanges) {
          changedItems.push(row);
        }
      }
    }
    createAnswerCard(data) {
      try {
        // Data validation and sanitization
        if (!data || typeof data !== 'object') {
          console.warn('createAnswerCard: Invalid data provided:', data);
          return null;
        }


        // Ensure required properties exist with safe defaults（理由列の堅牢化）
        const safeData = {
          rowIndex: data.rowIndex || 0,
          opinion: data.opinion || '(回答なし)',
          reason: this.validateReasonText(data.reason),
          name: data.name || '',
          email: data.email || '',
          reactions: data.reactions || {},
          highlight: Boolean(data.highlight),
        };



        // Optimized cache key generation (faster than JSON.stringify)
        const cacheKey = `${safeData.rowIndex}-${safeData.opinion.slice(0, 50)}-${safeData.reason.slice(0, 30)}-${safeData.name}-${JSON.stringify(safeData.reactions)}-${safeData.highlight}-${this.state.showCounts}-${this.state.displayMode}-${this.state.showHighlightToggle}`;

        // Answer card cache check
        const cachedCard = this.cache.get(`render-${cacheKey}`);
        if (cachedCard) {
          try {
            const clonedCard = cachedCard.cloneNode(true);
            // Ensure cloned card has proper data-row-index
            clonedCard.dataset.rowIndex = safeData.rowIndex;

            // Optimized: Only update elements that need row index (avoid querySelectorAll)
            const reactionButtons = clonedCard.querySelectorAll('.reaction-btn');
            reactionButtons.forEach((btn) => {
              btn.dataset.rowIndex = safeData.rowIndex;
            });

            return clonedCard;
          } catch (cacheError) {
            console.warn('createAnswerCard: Cache clone error, creating new card:', cacheError);
            // Continue to create new card if cache fails
          }
        }

        const card = this._createElement('div');
        const highlightClass = safeData.highlight ? ' highlighted' : '';
        card.className =
          'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' +
          highlightClass;
        card.dataset.rowIndex = safeData.rowIndex;
        card.setAttribute('role', 'article');
        card.setAttribute('tabindex', '0');
        card.setAttribute(
          'aria-label',
          '回答カード: ' +
            safeData.opinion.substring(0, 50) +
            (safeData.opinion.length > 50 ? '...' : '')
        );

        // Answer card created
        let highlightBtnHtml = '';
        // Highlight button condition check
        if (this.state.showHighlightToggle) {
          const cls = safeData.highlight ? 'liked' : '';
          const highlightAriaLabel = safeData.highlight ? 'ハイライトを解除する' : 'ハイライトする';
          highlightBtnHtml =
            '<button type="button" class="highlight-btn like-btn text-purple-600 ' +
            cls +
            '" aria-label="' +
            highlightAriaLabel +
            '" aria-pressed="' +
            safeData.highlight +
            '" data-row-index="' +
            safeData.rowIndex +
            '">' +
            this.getIcon('star', 'w-5 h-5', safeData.highlight) +
            '</button>';
        }
        const showName = this.state.displayMode === 'named';
        let displayName = '';

        if (showName) {
          // 名前が利用可能な場合はそれを使用、なければemailから生成
          displayName = safeData.name || (safeData.email ? safeData.email.split('@')[0] : 'ユーザー');
        }

        const nameHtml =
          showName && displayName
            ? '<div class="name-display flex-shrink-0 mr-2"><span class="font-bold text-sm text-cyan-300 bg-gray-800/50 px-2 py-1 rounded border border-cyan-400">' +
              this.escapeHtml(displayName) +
              '</span></div>'
            : '';
        const containerClass = nameHtml
          ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex flex-col sm:flex-row justify-between items-start sm:items-center gap-y-1 min-h-[2rem]'
          : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';

        // Name display configuration complete
        const reactionButtonsHtml = this.reactionTypes
          .map((rt) => {
            try {
              const info =
                safeData.reactions && safeData.reactions[rt.key]
                  ? safeData.reactions[rt.key]
                  : { count: 0, reacted: false };
              const cls = info.reacted ? 'liked' : '';
              const colorClass =
                rt.key === 'LIKE'
                  ? 'text-red-500'
                  : rt.key === 'UNDERSTAND'
                    ? 'text-yellow-500'
                    : 'text-green-500';
              const countSpan = this.state.showCounts
                ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' +
                  (info.count || 0) +
                  '</span>'
                : '';
              const reactionName = SYSTEM_CONSTANTS.REACTIONS.LABELS[rt.key] || rt.key;
              const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count || 0}件)` : ''}`;
              return (
                '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' +
                colorClass +
                ' ' +
                cls +
                '" data-row-index="' +
                safeData.rowIndex +
                '" data-reaction="' +
                rt.key +
                '" aria-label="' +
                ariaLabel +
                '" aria-pressed="' +
                info.reacted +
                '">' +
                this.getIcon(rt.icon, 'w-5 h-5', info.reacted) +
                countSpan +
                '</button>'
              );
            } catch (reactionError) {
              console.warn('createAnswerCard: Reaction button creation error:', reactionError);
              return ''; // Skip problematic reaction button
            }
          })
          .join('');
        // Optimized: Use DocumentFragment instead of innerHTML for better performance
        const fragment = document.createDocumentFragment();

        // Create main content div
        const contentDiv = this._createElement('div');
        contentDiv.className = 'relative flex-grow mb-3 answer-preview';

        const opinionTitle = document.createElement('h3');
        opinionTitle.className =
          'opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight';
        
        // テキスト設定の強化
        try {
          opinionTitle.textContent = safeData.opinion || '(回答データが見つかりません)';
        } catch (opinionError) {
          console.error('opinionTitle設定エラー:', opinionError);
          opinionTitle.textContent = '(表示エラー)';
        }

        const reasonText = document.createElement('p');
        reasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
        
        try {
          reasonText.textContent = safeData.reason || '';
        } catch (reasonError) {
          console.error('reasonText設定エラー:', reasonError);
          reasonText.textContent = '';
        }

        contentDiv.appendChild(opinionTitle);

        // 理由テキストが存在する場合のみ追加（堅牢化）

        if (safeData.reason && safeData.reason.trim()) {
          Logger.debug('✅ 理由テキストを追加します:', safeData.reason);
          try {
            // 理由テキストの有効性を検証
            if (reasonText && reasonText.textContent === safeData.reason) {
              contentDiv.appendChild(reasonText);
              Logger.debug('✅ 理由テキスト追加完了（既存要素使用）');
            } else {
              // 理由テキスト要素の再作成が必要な場合
              const newReasonText = document.createElement('p');
              newReasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
              newReasonText.textContent = safeData.reason;
              contentDiv.appendChild(newReasonText);
              Logger.debug('✅ 理由テキスト追加完了（新規要素作成）');
            }
          } catch (reasonError) {
            // 理由テキスト追加でエラーが発生した場合の回復処理
            console.warn(
              'createAnswerCard: Reason text append error, attempting recovery:',
              reasonError
            );
            try {
              const fallbackReasonText = document.createElement('p');
              fallbackReasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
              fallbackReasonText.textContent = safeData.reason;
              contentDiv.appendChild(fallbackReasonText);
              Logger.debug('✅ 理由テキスト追加完了（フォールバック）');
            } catch (fallbackError) {
              console.error(
                'createAnswerCard: Failed to add reason text even with fallback:',
                fallbackError
              );
              // 理由テキストが追加できない場合でもカード生成は継続
            }
          }
        } else {
          Logger.debug('❌ 理由テキストが空のため追加をスキップ');
        }

        // Create footer div
        const footerDiv = this._createElement('div');
        footerDiv.className = containerClass;

        // 名前表示部分を追加
        if (nameHtml) {
          try {
            const nameContainer = this._createElement('div');
            nameContainer.className = 'name-container flex-shrink-0';
            nameContainer.innerHTML = nameHtml;
            footerDiv.appendChild(nameContainer);
          } catch (nameError) {
            console.warn('createAnswerCard: Name container creation error:', nameError);
          }
        }

        // リアクション部分を追加
        try {
          const reactionsDiv = this._createElement('div');
          reactionsDiv.className = 'flex items-center gap-1 flex-shrink-0';
          reactionsDiv.setAttribute('role', 'group');
          reactionsDiv.setAttribute('aria-label', '回答への反応');
          reactionsDiv.innerHTML = reactionButtonsHtml + highlightBtnHtml;

          footerDiv.appendChild(reactionsDiv);
        } catch (reactionError) {
          console.warn('createAnswerCard: Reactions div creation error:', reactionError);
        }

        fragment.appendChild(contentDiv);
        fragment.appendChild(footerDiv);
        card.appendChild(fragment);

        if (safeData.highlight) {
          try {
            const badge = document.createElement('span');
            badge.className = 'highlight-badge';
            badge.innerHTML = this.getIcon('star', '', true);
            card.appendChild(badge);
          } catch (badgeError) {
            console.warn('createAnswerCard: Highlight badge creation error:', badgeError);
          }
        }

        // 統一されたリアクションスタイルを適用
        try {
          this.applyReactionStyles(card, safeData);
        } catch (styleError) {
          console.warn('createAnswerCard: Reaction styles application error:', styleError);
        }

        // Cache the card for reuse (limit cache size)
        try {
          if (this.cache.size > 100) {
            this.cache.cleanup();
          }
          this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
        } catch (cacheError) {
          console.warn('createAnswerCard: Cache storage error:', cacheError);
        }

        return card;
      } catch (error) {
        console.error('createAnswerCard: Critical error creating card:', error, 'Data:', data);

        // Return a minimal error card instead of null
        try {
          const errorCard = this._createElement('div');
          errorCard.className =
            'answer-card glass-panel rounded-xl p-4 border-2 border-red-400/50 bg-red-900/20';
          errorCard.innerHTML = `
          <div class="text-red-300 text-center">
            <div class="mb-2">⚠️ カード表示エラー</div>
            <div class="text-xs text-red-400">データ処理中に問題が発生しました</div>
          </div>
        `;
          return errorCard;
        } catch (fallbackError) {
          console.error('createAnswerCard: Fallback card creation also failed:', fallbackError);
          return null;
        }
      }
    }


    /**
     * リアクション処理（既存キューイングシステム＋オプショナルバッチ処理）
     */
    async handleReaction(rowIndex, reaction) {
      const numericRowIndex = parseInt(rowIndex, 10);
      const reactionKey = `${numericRowIndex}-${reaction}`;

      // パフォーマンス最適化: 短時間での重複操作を防ぐ
      const now = Date.now();
      const lastOperation = this.lastReactionTimes?.get(reactionKey);
      if (lastOperation && now - lastOperation < 1000) {
        // 1秒以内の重複操作を防ぐ
        Logger.debug(`⚡ 重複操作スキップ: ${reactionKey}`);
        return;
      }

      // 既存の個別キューシステム（常に維持）
      this.reactionQueue.set(reactionKey, {
        rowIndex: numericRowIndex,
        reaction,
        timestamp: now,
      });

      // 最後の操作時刻を記録
      if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
      this.lastReactionTimes.set(reactionKey, now);

      // オプション: バッチ処理も並行実行（既存機能に影響なし）
      if (this.enableBatchProcessing && !this.batchProcessingActive) {
        this.addToBatchQueue(numericRowIndex, reaction);
      }

      // 既存のキュー処理を開始（既存機能を保持）
      this.processReactionQueue();
    }

    async processReactionQueue() {
      if (this.isProcessingReactionQueue) return;
      this.isProcessingReactionQueue = true;

      try {
        // バッチ処理が有効で、キューに複数アイテムがある場合はバッチ処理を試行
        if (
          this.enableBatchProcessing &&
          this.reactionQueue.size > 1 &&
          !this.batchProcessingActive
        ) {
          const canBatch = await this.tryBatchProcessing();
          if (canBatch) {
            // バッチ処理成功時は個別キューをクリア
            this.reactionQueue.clear();
            return;
          }
          // バッチ処理失敗時は既存の個別処理にフォールバック
        }

        // 既存の個別処理システム（完全に保持）
        while (this.reactionQueue.size > 0) {
          const [reactionKey, operation] = this.reactionQueue.entries().next().value;
          this.reactionQueue.delete(reactionKey);

          await this.executeReactionOperation(operation, reactionKey);
        }
      } catch (error) {
        console.error('リアクションキュー処理エラー:', error);
      } finally {
        this.isProcessingReactionQueue = false;
      }
    }

    async executeReactionOperation(operation, reactionKey) {
      const { rowIndex, reaction } = operation;

      try {
        this.pendingReactions.add(reactionKey);

        const btns = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        this.setReactionButtonsLoading(btns, true);

        const item = this.state.currentAnswers?.find((i) => i.rowIndex == rowIndex);
        if (!item) {
          throw new Error(`Item not found for rowIndex: ${rowIndex}`);
        }

        Logger.debug('📡 リアクション送信 (Server-first):', {
          rowIndex,
          reaction,
          sheetName: this.state.sheetName,
        });

        // Server-first approach: サーバーに送信してから結果を適用
        const response = await this.sendReactionToServer(rowIndex, reaction);
        await this.processReactionResponse(item, response, reaction);

        // UI更新（サーバー応答後のみ）
        await this.updateReactionUI(item, false);

        Logger.debug('✅ リアクション処理完了:', reactionKey);

        // 処理完了を通知
        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: true });
      } catch (error) {
        console.error('❌ リアクション処理エラー:', error);
        await this.handleReactionError(error, rowIndex, reaction);

        // エラー完了を通知
        this.notifyReactionComplete(reactionKey, {
          rowIndex,
          reaction,
          success: false,
          error: error.message,
        });
      } finally {
        this.pendingReactions.delete(reactionKey);

        const btns = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        this.setReactionButtonsLoading(btns, false);
      }
    }

    // リアクション処理完了通知システム
    notifyReactionComplete(reactionKey, result) {
      const listeners = this.reactionEventListeners.get(reactionKey);
      if (listeners && listeners.length > 0) {
        listeners.forEach((listener) => {
          try {
            listener(result);
          } catch (error) {
            console.error('❌ リアクション完了リスナーエラー:', error);
          }
        });
        // 一度実行したら削除
        this.reactionEventListeners.delete(reactionKey);
      }
    }

    // リアクション処理完了を待機
    waitForReactionComplete(reactionKey, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          this.reactionEventListeners.delete(reactionKey);
          reject(new Error(`Reaction timeout: ${reactionKey}`));
        }, timeout);

        const listener = (result) => {
          clearTimeout(timeoutId);
          resolve(result);
        };

        if (!this.reactionEventListeners.has(reactionKey)) {
          this.reactionEventListeners.set(reactionKey, []);
        }
        this.reactionEventListeners.get(reactionKey).push(listener);
      });
    }

    // 動的状態変化待機システム
    async waitForReactionStateChange(
      rowIndex,
      reaction,
      initialState,
      timeoutMs = 3000,
      pollIntervalMs = 50
    ) {
      const startTime = Date.now();

      const getReactionButtonState = () => {
        const buttons = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        if (buttons.length === 0) return null;

        const btn = buttons[0];
        return {
          reacted: btn.getAttribute('aria-pressed') === 'true',
          count: parseInt(btn.querySelector('.count')?.textContent || '0'),
          disabled: btn.disabled,
          classes: btn.className,
          timestamp: Date.now(),
        };
      };

      const hasStateChanged = (current, initial) => {
        if (!current || !initial) return false;
        return (
          current.reacted !== initial.reacted ||
          current.count !== initial.count ||
          current.disabled !== initial.disabled
        );
      };

      return new Promise((resolve, reject) => {
        const poll = () => {
          const currentTime = Date.now();
          if (currentTime - startTime >= timeoutMs) {
            reject(new Error(`State change timeout after ${timeoutMs}ms`));
            return;
          }

          const currentState = getReactionButtonState();
          if (hasStateChanged(currentState, initialState)) {
            resolve({
              initialState,
              currentState,
              changeDetectedAt: currentTime - startTime,
              stateChanged: true,
            });
            return;
          }

          setTimeout(poll, pollIntervalMs);
        };

        poll();
      });
    }

    // シンプルなリアクション状態監視（通知システム中心）
    async waitForReactionUpdate(rowIndex, reaction, expectedChange = null, maxWaitMs = 3000) {
      const reactionKey = `${rowIndex}-${reaction}`;

      try {
        // 完了通知システムのみを使用（シンプルで信頼性が高い）
        const result = await this.waitForReactionComplete(reactionKey, maxWaitMs);
        return result || { timeout: false, success: true };
      } catch (error) {
        console.warn(`⚠️ リアクション待機タイムアウト: ${reactionKey}`, error.message);
        return {
          error: error.message,
          timeout: true,
          success: false,
        };
      }
    }

    // リアクションボタン状態取得ヘルパー
    getReactionButtonState(rowIndex, reaction) {
      const buttons = document.querySelectorAll(
        `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
      );
      if (buttons.length === 0) return null;

      const btn = buttons[0];
      return {
        reacted: btn.getAttribute('aria-pressed') === 'true',
        count: parseInt(btn.querySelector('.count')?.textContent || '0'),
        disabled: btn.disabled,
        classes: btn.className,
        visible: btn.style.display !== 'none',
        computedStyle: getComputedStyle(btn),
        timestamp: Date.now(),
      };
    }

    // バッチ処理関連メソッド（既存機能に影響しない追加機能）

    addToBatchQueue(rowIndex, reaction) {
      try {
        if (!this.reactionBatchQueue.has(rowIndex)) {
          this.reactionBatchQueue.set(rowIndex, []);
        }

        const batchForRow = this.reactionBatchQueue.get(rowIndex);
        const existingIndex = batchForRow.findIndex((r) => r.reaction === reaction);

        if (existingIndex >= 0) {
          // 既存リアクションのタイムスタンプを更新
          batchForRow[existingIndex].timestamp = Date.now();
        } else {
          // 新しいリアクションを追加
          batchForRow.push({
            reaction,
            timestamp: Date.now(),
          });
        }

        // バッチサイズ制限チェック
        const totalBatchSize = Array.from(this.reactionBatchQueue.values()).reduce(
          (sum, reactions) => sum + reactions.length,
          0
        );

        if (totalBatchSize >= this.BATCH_SIZE_LIMIT) {
          Logger.debug('📦 バッチサイズ制限到達、即座処理実行');
          this.processBatchQueue();
        }
      } catch (error) {
        console.warn('バッチキュー追加エラー（個別処理にフォールバック）:', error);
        // エラー時は何もしない（既存の個別処理が動作）
      }
    }

    async tryBatchProcessing() {
      try {
        if (this.batchProcessingActive || this.reactionQueue.size === 0) {
          return false;
        }

        this.batchProcessingActive = true;
        Logger.debug('🔄 バッチ処理試行開始');

        // キューからバッチ操作を準備
        const batchOperations = Array.from(this.reactionQueue.values());

        if (batchOperations.length === 1) {
          // 単一操作の場合はバッチ処理しない
          this.batchProcessingActive = false;
          return false;
        }

        // バッチでサーバーに送信（新しいAPI関数が必要）
        const result = await this.gas.addReactionBatch(batchOperations);

        if (result && result.success) {
          Logger.debug('✅ バッチ処理成功:', batchOperations.length + '件');

          // バッチレスポンスを処理
          this.processBatchReactionResponse(result.data, batchOperations);

          // 完了通知
          batchOperations.forEach((op) => {
            const reactionKey = `${op.rowIndex}-${op.reaction}`;
            this.notifyReactionComplete(reactionKey, { success: true, batch: true });
          });

          return true;
        } else {
          console.warn('バッチ処理失敗、個別処理にフォールバック');
          return false;
        }
      } catch (error) {
        console.warn('バッチ処理エラー、個別処理にフォールバック:', error);
        return false;
      } finally {
        this.batchProcessingActive = false;
      }
    }

    processBatchReactionResponse(responseData, originalOperations) {
      try {
        if (!responseData || !Array.isArray(responseData)) {
          console.warn('無効なバッチレスポンス、個別処理で続行');
          return;
        }

        // 各行のレスポンスを処理（既存の仕組みを再利用）
        responseData.forEach((rowData) => {
          const item = this.state.currentAnswers.find((i) => i.rowIndex == rowData.rowIndex);
          if (item) {
            // 既存のレスポンス処理システムを使用
            this.processReactionResponse(rowData, item);
          }
        });

        Logger.debug('✅ バッチレスポンス処理完了');
      } catch (error) {
        console.error('バッチレスポンス処理エラー:', error);
        // エラー時は既存の個別処理システムが処理する
      }
    }

    setReactionButtonsLoading(buttons, isLoading) {
      buttons.forEach((btn) => {
        btn.disabled = isLoading;
        if (isLoading) {
          btn.classList.add('loading');
        } else {
          btn.classList.remove('loading');
        }
      });
    }

    async sendReactionToServer(rowIndex, reaction) {
      const response = await this.gas.addReaction(rowIndex, reaction, this.state.sheetName);

      if (!response) {
        throw new Error('サーバーからの応答がありません');
      }

      if (response.status !== 'ok') {
        throw new Error(response.message || 'リアクション送信に失敗しました');
      }

      return response;
    }

    async processReactionResponse(item, response, reaction) {
      Logger.debug('🔄 サーバー応答処理開始:', { rowIndex: item.rowIndex, reaction, response });

      // サーバー状態を絶対的に適用（楽観的更新なし）
      if (response.reactions && typeof response.reactions === 'object') {
        // サーバー状態で完全に上書き
        const serverState = response.reactions;
        item.reactions = JSON.parse(JSON.stringify(serverState));

        Logger.debug('✅ サーバー状態適用完了:', {
          rowIndex: item.rowIndex,
          reaction,
          serverState: item.reactions,
        });
      } else {
        console.warn('⚠️ 期待されたリアクション形式ではありません:', response);
        // フォールバック処理（サーバー応答が不正な場合のみ）
        this.applyFallbackReactionUpdate(item, reaction);
        Logger.debug('🔄 フォールバック処理実行:', item.reactions);
      }

      // ローカルストレージに保存（サーバー状態を保存）
      this.saveReactionState(item.rowIndex, item.reactions);

      Logger.debug('🎯 サーバー応答処理完了:', {
        rowIndex: item.rowIndex,
        finalState: item.reactions,
      });
    }

    // リアクション状態整合性検証
    validateReactionConsistency(rowIndex, optimisticState, serverState) {
      const inconsistencies = [];

      // 各リアクションタイプをチェック
      this.reactionTypes.forEach((rt) => {
        const reaction = rt.key;
        const optimistic = optimisticState[reaction] || { count: 0, reacted: false };
        const server = serverState[reaction] || { count: 0, reacted: false };

        if (optimistic.reacted !== server.reacted) {
          inconsistencies.push({
            reaction,
            type: 'reacted_mismatch',
            optimistic: optimistic.reacted,
            server: server.reacted,
          });
        }

        if (Math.abs(optimistic.count - server.count) > 1) {
          inconsistencies.push({
            reaction,
            type: 'count_significant_diff',
            optimistic: optimistic.count,
            server: server.count,
            diff: server.count - optimistic.count,
          });
        }
      });

      if (inconsistencies.length > 0) {
        console.warn('⚠️ リアクション状態不整合検出:', {
          rowIndex,
          inconsistencies,
          optimisticState,
          serverState,
        });

        // 不整合を記録（デバッグ用）
        this.recordReactionInconsistency(rowIndex, inconsistencies);
      } else {
        Logger.debug('✅ リアクション状態整合性確認:', { rowIndex });
      }

      return inconsistencies;
    }

    // 不整合記録（デバッグ用）
    recordReactionInconsistency(rowIndex, inconsistencies) {
      if (!this.reactionInconsistencies) {
        this.reactionInconsistencies = [];
      }

      this.reactionInconsistencies.push({
        timestamp: new Date().toISOString(),
        rowIndex,
        inconsistencies,
      });

      // 最新10件のみ保持
      if (this.reactionInconsistencies.length > 10) {
        this.reactionInconsistencies.shift();
      }
    }

    applyFallbackReactionUpdate(item, reaction) {
      if (!item.reactions) {
        item.reactions = {};
      }

      // 他のリアクションをまず解除
      this.reactionTypes.forEach((rt) => {
        if (rt.key !== reaction && item.reactions[rt.key]?.reacted) {
          item.reactions[rt.key].count = Math.max(0, item.reactions[rt.key].count - 1);
          item.reactions[rt.key].reacted = false;
        }
      });

      if (!item.reactions[reaction]) {
        item.reactions[reaction] = { count: 0, reacted: false };
      }

      // Toggle reaction state
      if (item.reactions[reaction].reacted) {
        item.reactions[reaction].count = Math.max(0, item.reactions[reaction].count - 1);
        item.reactions[reaction].reacted = false;
      } else {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
        item.reactions[reaction].reacted = true;
      }
    }

    // 即座UI更新（requestAnimationFrameを使わない同期更新）
    async immediateUIUpdate(rowIndex, reaction) {
      const item = this.state.currentAnswers.find((i) => i.rowIndex == rowIndex);
      if (!item || !item.reactions || !item.reactions[reaction]) {
        console.warn('⚠️ immediateUIUpdate: アイテムまたはリアクション状態が見つかりません');
        return;
      }

      try {
        // カードのUI更新（同期実行）
        this.updateCardIfExists(rowIndex, item);

        // モーダルが開いている場合はそちらも更新
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex =
            this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
              .rowIndex;
          if (modalRowIndex == rowIndex) {
            this.updateModalReactionButtons(item);
          }
        }

        Logger.debug('⚡ 即座UI更新完了:', { rowIndex, reaction });
      } catch (error) {
        console.error('❌ 即座UI更新エラー:', error);
      }
    }

    async updateReactionUI(item, immediate = false) {
      // パフォーマンス最適化: 変更が必要な場合のみ更新
      const lastUpdateKey = `ui_update_${item.rowIndex}`;
      const currentStateHash = this.calculateStateHash(item);
      const lastStateHash = this.lastUIStates?.get(lastUpdateKey);

      if (lastStateHash === currentStateHash && !immediate) {
        Logger.debug(`⚡ UI更新スキップ (変更なし): rowIndex=${item.rowIndex}`);
        return;
      }

      // 状態ハッシュを記録
      if (!this.lastUIStates) this.lastUIStates = new Map();
      this.lastUIStates.set(lastUpdateKey, currentStateHash);

      if (immediate) {
        // 即座実行（requestAnimationFrameを使わない）
        try {
          this.updateCardIfExists(item.rowIndex, item, '⚠️ カード要素が見つかりません:');

          // モーダルが開いている場合はそちらも更新
          if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex =
              this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                .rowIndex;
            if (modalRowIndex == item.rowIndex) {
              this.updateModalReactionButtons(item);
              this.applyReactionStyles(this.elements.answerModalCard, item);
            }
          }

          Logger.debug('⚡ リアクションUI即座更新完了:', {
            rowIndex: item.rowIndex,
            reactions: item.reactions,
          });
        } catch (error) {
          console.error('❌ UI即座更新エラー:', error);
        }
        return;
      }

      // 通常実行（requestAnimationFrame使用）
      return new Promise((resolve) => {
        requestAnimationFrame(() => {
          try {
            // カードのリアクション表示を更新
            if (!this.updateCardIfExists(item.rowIndex, item)) {
              console.warn('⚠️ カード要素が見つかりません:', item.rowIndex);
            }

            // モーダルが開いている場合はそちらも更新
            if (!this.elements.answerModalContainer.classList.contains('hidden')) {
              const modalRowIndex =
                this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                  .rowIndex;
              if (modalRowIndex == item.rowIndex) {
                this.updateModalReactionButtons(item);
                this.applyReactionStyles(this.elements.answerModalCard, item);
              }
            }

            Logger.debug('✅ リアクションUI更新完了:', {
              rowIndex: item.rowIndex,
              reactions: item.reactions,
            });
            resolve();
          } catch (error) {
            console.error('UI更新エラー:', error);
            resolve();
          }
        });
      });
    }

    // ユーザーIDとシート名に基づくローカルストレージキー生成
    getScopedKey(base) {
      const userId = this.state?.userId || CONFIG.userId;
      return `${base}_${userId}_${CONFIG.sheetName}`;
    }

    // lastSeenCount永続化機能
    loadLastSeenCount() {
      try {
        const key = this.getScopedKey('lastSeenCount');
        const stored = localStorage.getItem(key);
        const count = stored ? parseInt(stored, 10) : 0;

        Logger.debug('📥 lastSeenCount復元:', { key, count });
        return isNaN(count) ? 0 : count;
      } catch (error) {
        console.warn('⚠️ lastSeenCount読み込みエラー:', error);
        return 0;
      }
    }

    // 真の初回ボードアクセス判定
    isFirstTimeBoardAccess() {
      try {
        // 1. lastSeenCountの存在確認
        const hasLastSeen = localStorage.getItem(this.getScopedKey('lastSeenCount')) !== null;

        // 2. 差分カードの存在確認
        const hasDiffCards = localStorage.getItem(this.getScopedKey('differentialCards')) !== null;

        // 3. 初期データロード状態の確認
        const hasInitialLoad = this.initialDataLoaded === true;

        // 4. DOM内の既存カード確認
        const container = this.elements?.answersContainer;
        const hasDOMCards = container && container.querySelectorAll('.answer-card').length > 0;

        // 真の初回判定: すべてが未設定/初期状態の場合
        const isFirstTime = !hasLastSeen && !hasDiffCards && !hasInitialLoad && !hasDOMCards;

        Logger.debug('🔍 初回判定結果:', {
          hasLastSeen,
          hasDiffCards,
          hasInitialLoad,
          hasDOMCards,
          isFirstTime,
        });

        return isFirstTime;
      } catch (error) {
        console.warn('⚠️ 初回判定エラー:', error);
        // エラー時は安全側（初回ではない）と判定
        return false;
      }
    }

    saveLastSeenCount(count) {
      try {
        const key = this.getScopedKey('lastSeenCount');
        localStorage.setItem(key, count.toString());

        Logger.debug('💾 lastSeenCount保存:', { key, count });
      } catch (error) {
        console.warn('⚠️ lastSeenCount保存エラー:', error);
      }
    }

    updateLastSeenCount(newCount) {
      if (typeof newCount === 'number' && newCount >= 0) {
        const oldCount = this.state.lastSeenCount;
        this.state.lastSeenCount = newCount;
        this.saveLastSeenCount(newCount);

        Logger.debug('📊 lastSeenCount更新:', {
          oldCount,
          newCount,
          timestamp: new Date().toISOString(),
        });
      }
    }

    // 差分カード管理メソッド
    loadDifferentialCards() {
      try {
        const key = this.getScopedKey('differentialCards');
        const stored = localStorage.getItem(key);
        const cards = stored ? JSON.parse(stored) : [];

        Logger.debug('📥 差分カード復元:', { key, count: cards.length });
        return Array.isArray(cards) ? cards : [];
      } catch (error) {
        console.warn('⚠️ 差分カード読み込みエラー:', error);
        return [];
      }
    }

    saveDifferentialCards(cardIds) {
      try {
        const key = this.getScopedKey('differentialCards');
        const existing = this.loadDifferentialCards();
        const merged = [...new Set([...existing, ...cardIds])];
        localStorage.setItem(key, JSON.stringify(merged));

        Logger.debug('💾 差分カード保存:', { key, count: merged.length, new: cardIds.length });
      } catch (error) {
        console.warn('⚠️ 差分カード保存エラー:', error);
      }
    }

    clearDifferentialCards() {
      try {
        const key = this.getScopedKey('differentialCards');
        localStorage.removeItem(key);
        Logger.debug('🗑️ 差分カードクリア:', { key });
      } catch (error) {
        console.warn('⚠️ 差分カードクリアエラー:', error);
      }
    }

    // 差分カードの復元（ページ再読み込み時）
    restoreDifferentialCards() {
      const differentialCardIds = this.loadDifferentialCards();
      if (differentialCardIds.length === 0) return;

      Logger.debug('🔄 差分カード復元開始:', differentialCardIds.length + '件');

      const container = this.elements.answersContainer;
      if (!container) return;

      // 現在表示されているカードから差分カードをマーク
      const allCards = container.querySelectorAll('.answer-card');
      let restoredCount = 0;

      allCards.forEach((card) => {
        const rowIndex = parseInt(card.getAttribute('data-row-index'));
        if (differentialCardIds.includes(rowIndex)) {
          card.setAttribute('data-differential-card', 'true');
          card.setAttribute('data-restored', 'true');
          restoredCount++;
          Logger.debug('📌 差分カード復元:', rowIndex);
        }
      });

      Logger.debug('✅ 差分カード復元完了:', restoredCount + '件');
    }

    async handleReactionError(error, rowIndex, reaction) {
      console.error('リアクションエラーの詳細:', {
        error: error.message,
        rowIndex,
        reaction,
        timestamp: new Date().toISOString(),
      });

      // ユーザーにエラーを表示（オプション）
      if (window.messageManager) {
        window.messageManager.show(
          'リアクションの処理に失敗しました。再度お試しください。',
          'error',
          3000
        );
      }
    }

    showErrorFeedback(btn, message) {
      if (!btn) return;

      // 元のクラスを保存
      const originalClasses = btn.className;

      // エラー表示
      btn.classList.add('bg-red-500');
      btn.title = message;

      // 2秒後に元に戻す
      setTimeout(() => {
        btn.className = originalClasses;
        btn.title = '';
      }, 2000);
    }

    async handleHighlight(rowIndex) {
      // Highlight processing started

      // バックエンド側で管理者権限をチェックするので、フロントエンド側のチェックは不要

      const numericRowIndex = parseInt(rowIndex, 10);
      const highlightKey = `${numericRowIndex}-highlight`;

      // Enhanced debounce for highlight operations
      if (this.highlightDebounce.has(highlightKey)) {
        clearTimeout(this.highlightDebounce.get(highlightKey));
        return; // Ignore rapid highlight clicks
      }

      // Rate limiting for highlights
      const now = Date.now();
      const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
      if (now - lastHighlightTime < 500) {
        return;
      }

      // 既に処理中の場合は無視
      if (this.pendingReactions.has(highlightKey)) {
        return;
      }

      this.pendingReactions.add(highlightKey);
      if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
      this.lastReactionTimes.set(highlightKey, now);

      const btns = document.querySelectorAll(
        '.highlight-btn[data-row-index="' + numericRowIndex + '"]'
      );
      const item = this.state.currentAnswers.find((i) => i.rowIndex == numericRowIndex);

      if (!item) {
        this.pendingReactions.delete(highlightKey);
        return;
      }

      // ★修正ポイント①：UI更新をボタンのローディング表示のみに限定
      btns.forEach((btn) => {
        btn.classList.add('loading');
        btn.disabled = true;
      });

      try {
        // ★修正ポイント②：先にサーバーと通信する
        const res = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);

        if (res && res.status === 'ok') {
          // ★修正ポイント③：サーバーからの応答成功後に、UIを完全に更新する
          item.highlight = res.highlight;
          requestAnimationFrame(() => this.applyUpdates([item])); // 次の描画フレームで安全にUIを更新

          // モーダルが開いていればそちらも更新
          if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex =
              this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                .rowIndex;
            if (modalRowIndex == rowIndex) {
              this.updateModalContent(item);
            }
          }

          // ハイライト操作後の状態同期確認（遅延実行）
          setTimeout(() => {
            this.verifyHighlightSync(numericRowIndex, res.highlight);
          }, 1000);
        } else {
          throw new Error(res?.message || 'ハイライトの処理に失敗しました');
        }
      } catch (error) {
        console.error('Failed to toggle highlight:', error);

        // 権限エラーの特別処理
        if (error.message && error.message.includes('管理者のみ')) {
          this.showErrorFeedback(btns[0], '権限エラー: 管理者のみ利用可能です');
          console.warn('ハイライト機能は管理者のみ利用可能です');
        } else {
          this.showErrorFeedback(btns[0], 'ハイライトに失敗しました');
        }
      } finally {
        // ★修正ポイント④：最後にボタンのローディング状態を解除
        btns.forEach((btn) => {
          btn.classList.remove('loading');
          btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
      }
    }

    // ハイライト状態同期確認
    async verifyHighlightSync(rowIndex, expectedHighlight) {
      try {
        const item = this.state.currentAnswers?.find((i) => i.rowIndex == rowIndex);
        if (!item) return;

        // UI状態とサーバー応答の一致確認
        if (item.highlight !== expectedHighlight) {
          console.warn(
            `⚠️ ハイライト状態不整合検出: rowIndex=${rowIndex}, UI=${item.highlight}, Expected=${expectedHighlight}`
          );

          // 不整合の場合は強制的にサーバー状態に合わせる
          item.highlight = expectedHighlight;
          requestAnimationFrame(() => this.applyUpdates([item]));

          Logger.debug('✅ ハイライト状態を修正しました');
        } else {
          Logger.debug('✅ ハイライト状態同期確認: 正常');
        }
      } catch (error) {
        console.error('ハイライト状態同期確認エラー:', error);
      }
    }

    // 包括的同期状態監視システム
    async performSyncHealthCheck() {
      Logger.debug('🔍 同期状態ヘルスチェック開始');
      const issues = [];

      try {
        // 1. データ取得同期チェック
        const lastDataLoad = this.lastDataLoadTime || 0;
        const minutesSinceLastLoad = (Date.now() - lastDataLoad) / (1000 * 60);

        if (minutesSinceLastLoad > 5) {
          issues.push({
            type: 'data_staleness',
            severity: 'warning',
            message: `最後のデータ取得から${Math.round(minutesSinceLastLoad)}分経過`,
            recommendation: 'データ更新を実行',
          });
        }

        // 2. 保留中のリアクション確認
        if (this.pendingReactions.size > 0) {
          issues.push({
            type: 'pending_reactions',
            severity: 'warning',
            message: `${this.pendingReactions.size}件のリアクションが処理中`,
            data: Array.from(this.pendingReactions),
          });
        }

        // 3. UI状態とデータ状態の整合性チェック
        const uiButtons = document.querySelectorAll('.reaction-btn, .highlight-btn');
        const inconsistentButtons = [];

        uiButtons.forEach((btn) => {
          const rowIndex = parseInt(btn.dataset.rowIndex);
          const item = this.state.currentAnswers.find((i) => i.rowIndex === rowIndex);

          if (!item) {
            inconsistentButtons.push({
              button: btn,
              issue: 'data_missing',
              rowIndex,
            });
            return;
          }

          if (btn.classList.contains('reaction-btn')) {
            const reaction = btn.dataset.reaction;
            const isPressed = btn.getAttribute('aria-pressed') === 'true';
            const dataState = item.reactions?.[reaction]?.reacted === true;

            if (isPressed !== dataState) {
              inconsistentButtons.push({
                button: btn,
                issue: 'reaction_state_mismatch',
                rowIndex,
                reaction,
                uiState: isPressed,
                dataState,
              });
            }
          }

          if (btn.classList.contains('highlight-btn')) {
            const isHighlighted = btn.classList.contains('highlighted');
            const dataState = item.highlight === true;

            if (isHighlighted !== dataState) {
              inconsistentButtons.push({
                button: btn,
                issue: 'highlight_state_mismatch',
                rowIndex,
                uiState: isHighlighted,
                dataState,
              });
            }
          }
        });

        if (inconsistentButtons.length > 0) {
          issues.push({
            type: 'ui_data_inconsistency',
            severity: 'error',
            message: `${inconsistentButtons.length}件のUI状態不整合`,
            data: inconsistentButtons,
          });
        }

        // 4. キャッシュ状態チェック（可能な場合）
        if (this.cache && typeof this.cache.size === 'number') {
          if (this.cache.size > 100) {
            issues.push({
              type: 'cache_bloat',
              severity: 'info',
              message: `キャッシュサイズが大きい: ${this.cache.size}件`,
              recommendation: 'キャッシュクリアを検討',
            });
          }
        }

        // 5. 結果出力
        if (issues.length === 0) {
          Logger.debug('✅ 同期状態ヘルスチェック: 問題なし');
          return { status: 'healthy', issues: [] };
        } else {
          console.warn('⚠️ 同期状態ヘルスチェック: 問題検出', issues);
          return { status: 'issues_detected', issues };
        }
      } catch (error) {
        console.error('❌ 同期状態ヘルスチェックエラー:', error);
        return {
          status: 'check_failed',
          error: error.message,
          issues: [],
        };
      }
    }

    // 不整合の自動修復
    async fixSyncIssues(healthCheckResult) {
      if (!healthCheckResult.issues || healthCheckResult.issues.length === 0) {
        return { fixed: 0, skipped: 0 };
      }

      let fixed = 0;
      let skipped = 0;

      for (const issue of healthCheckResult.issues) {
        try {
          switch (issue.type) {
            case 'ui_data_inconsistency':
              // UI状態をデータ状態に合わせる
              for (const inconsistency of issue.data) {
                const item = this.state.currentAnswers.find(
                  (i) => i.rowIndex === inconsistency.rowIndex
                );
                if (item) {
                  await this.applyUpdates([item]);
                  fixed++;
                }
              }
              break;

            case 'data_staleness':
              // データを強制リフレッシュ
              Logger.debug('🔄 古いデータを検出、強制リフレッシュ実行');
              await this.forceDataRefresh();
              fixed++;
              break;

            case 'cache_bloat':
              // キャッシュクリア
              if (this.cache && typeof this.cache.clear === 'function') {
                this.cache.clear();
                fixed++;
              }
              break;

            default:
              skipped++;
              break;
          }
        } catch (fixError) {
          console.error(`修復失敗 (${issue.type}):`, fixError);
          skipped++;
        }
      }

      Logger.debug(`🔧 自動修復完了: ${fixed}件修復, ${skipped}件スキップ`);
      return { fixed, skipped };
    }

    // 定期的な同期監視の開始
    startSyncMonitoring() {
      // 既存の監視が動いている場合は停止
      if (this.syncMonitoringInterval) {
        clearInterval(this.syncMonitoringInterval);
      }

      // 5分間隔で同期状態をチェック
      this.syncMonitoringInterval = setInterval(
        async () => {
          try {
            const healthCheck = await this.performSyncHealthCheck();

            // 重要な問題があった場合は自動修復を試行
            if (healthCheck.status === 'issues_detected') {
              const criticalIssues = healthCheck.issues.filter(
                (issue) => issue.severity === 'error' || issue.type === 'ui_data_inconsistency'
              );

              if (criticalIssues.length > 0) {
                Logger.debug('🔧 重要な同期問題を検出、自動修復を実行');
                await this.fixSyncIssues({ issues: criticalIssues });
              }
            }
          } catch (error) {
            console.error('同期監視エラー:', error);
          }
        },
        5 * 60 * 1000
      ); // 5分間隔

      Logger.debug('✅ 同期状態監視を開始しました（5分間隔）');
    }

    // 同期監視の停止
    stopSyncMonitoring() {
      if (this.syncMonitoringInterval) {
        clearInterval(this.syncMonitoringInterval);
        this.syncMonitoringInterval = null;
        Logger.debug('🛑 同期状態監視を停止しました');
      }
    }

    // アイテム状態のハッシュを計算（変更検出用）
    calculateStateHash(item) {
      return JSON.stringify({ reactions: item.reactions, highlight: item.highlight, rowIndex: item.rowIndex });
    }

    // バッチ処理パフォーマンステスト（開発・デバッグ用）
    async testBatchPerformance() {
      Logger.debug('🧪 バッチ処理パフォーマンステスト開始');

      const testResults = {
        batchTest: null,
        individualTest: null,
        comparison: null,
      };

      try {
        // テスト用の模擬リアクション操作データ
        const testOperations = [];
        const testRowCount = Math.min(this.state.currentAnswers?.length || 0, 5); // 最大5行でテスト

        for (let i = 0; i < testRowCount; i++) {
          const item = this.state.currentAnswers[i];
          if (item) {
            testOperations.push({
              rowIndex: item.rowIndex,
              reaction: 'LIKE',
              timestamp: Date.now(),
            });
          }
        }

        if (testOperations.length === 0) {
          console.warn('⚠️ テスト用データが不足しています');
          return { error: 'テスト用データが不足' };
        }

        Logger.debug(`📊 ${testOperations.length}件の操作でテスト実行`);

        // 1. バッチ処理のテスト
        Logger.debug('🔄 バッチ処理テスト開始');
        const batchStartTime = performance.now();

        try {
          // バッチ処理は実際にサーバーを呼ばず、ローカルでの処理時間のみ測定
          this.addToBatchQueue(testOperations[0].rowIndex, testOperations[0].reaction);
          for (let i = 1; i < testOperations.length; i++) {
            this.addToBatchQueue(testOperations[i].rowIndex, testOperations[i].reaction);
          }

          const batchEndTime = performance.now();
          testResults.batchTest = {
            duration: batchEndTime - batchStartTime,
            operationCount: testOperations.length,
            avgTimePerOp: (batchEndTime - batchStartTime) / testOperations.length,
          };

          Logger.debug('✅ バッチ処理テスト完了:', testResults.batchTest);
        } catch (error) {
          console.error('❌ バッチ処理テストエラー:', error);
          testResults.batchTest = { error: error.message };
        }

        // 2. 個別処理のテスト（シミュレーション）
        Logger.debug('🔄 個別処理テスト開始');
        const individualStartTime = performance.now();

        try {
          // 個別処理のシミュレーション（実際のAPI呼び出しなし）
          for (const operation of testOperations) {
            // キューに追加するシミュレーション
            this.reactionQueue.set(`${operation.rowIndex}-${operation.reaction}`, operation);
            // 小さな遅延でAPI呼び出しのオーバーヘッドをシミュレート
            await new Promise((resolve) => setTimeout(resolve, 1));
          }

          const individualEndTime = performance.now();
          testResults.individualTest = {
            duration: individualEndTime - individualStartTime,
            operationCount: testOperations.length,
            avgTimePerOp: (individualEndTime - individualStartTime) / testOperations.length,
          };

          Logger.debug('✅ 個別処理テスト完了:', testResults.individualTest);
        } catch (error) {
          console.error('❌ 個別処理テストエラー:', error);
          testResults.individualTest = { error: error.message };
        }

        // 3. パフォーマンス比較
        if (
          testResults.batchTest &&
          testResults.individualTest &&
          !testResults.batchTest.error &&
          !testResults.individualTest.error
        ) {
          const speedImprovement =
            testResults.individualTest.duration / testResults.batchTest.duration;
          const efficiencyGain =
            ((testResults.individualTest.avgTimePerOp - testResults.batchTest.avgTimePerOp) /
              testResults.individualTest.avgTimePerOp) *
            100;

          testResults.comparison = {
            speedImprovement: speedImprovement,
            efficiencyGain: efficiencyGain,
            recommendation:
              speedImprovement > 1.2
                ? 'バッチ処理推奨'
                : speedImprovement < 0.8
                  ? '個別処理推奨'
                  : '同程度',
          };

          Logger.debug('📈 パフォーマンス比較結果:', testResults.comparison);
        }

        // 4. メモリ使用量チェック（概算）
        const memoryInfo = performance.memory
          ? {
              usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
              totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
            }
          : { info: 'メモリ情報は利用できません' };

        testResults.memoryUsage = memoryInfo;

        Logger.debug('🧪 バッチ処理パフォーマンステスト完了', testResults);
        return testResults;
      } catch (error) {
        console.error('❌ バッチ処理テストエラー:', error);
        return { error: error.message, partialResults: testResults };
      }
    }

    // バッチ処理の健全性チェック
    validateBatchSystem() {
      Logger.debug('🔍 バッチ処理システム健全性チェック');

      const issues = [];

      // 1. バッチキューの状態確認
      if (!this.batchQueue) {
        issues.push('バッチキューが初期化されていません');
      } else if (this.batchQueue.size > 100) {
        issues.push(`バッチキューサイズが大きすぎます: ${this.batchQueue.size}`);
      }

      // 2. 個別キューの状態確認
      if (!this.reactionQueue) {
        issues.push('リアクションキューが初期化されていません');
      } else if (this.reactionQueue.size > 50) {
        issues.push(`リアクションキューサイズが大きすぎます: ${this.reactionQueue.size}`);
      }

      // 3. 処理状態の確認
      if (this.isProcessingReactionQueue && this.batchProcessingActive) {
        issues.push('個別処理とバッチ処理が同時に動作中です');
      }

      // 4. 設定の確認
      if (this.enableBatchProcessing === undefined) {
        issues.push('バッチ処理設定が未定義です');
      }

      // 5. 結果
      if (issues.length === 0) {
        Logger.debug('✅ バッチ処理システム健全性: 正常');
        return { status: 'healthy', issues: [] };
      } else {
        console.warn('⚠️ バッチ処理システム健全性: 問題検出', issues);
        return { status: 'issues_detected', issues };
      }
    }

    // 通知システムのエッジケーステスト（開発・デバッグ用）
    async testNotificationEdgeCases() {
      Logger.debug('🧪 通知システムエッジケーステスト開始');

      const testResults = {
        tests: [],
        summary: { passed: 0, failed: 0, total: 0 },
      };

      try {
        // テスト1: 初期データロード失敗後の通知
        Logger.debug('📋 テスト1: 初期データロード失敗→ポーリング成功シナリオ');
        const test1 = await this.testInitialLoadFailureNotification();
        testResults.tests.push(test1);

        // テスト2: 通知バナー要素の存在確認
        Logger.debug('📋 テスト2: 通知バナー要素の存在確認');
        const test2 = this.testNotificationBannerElements();
        testResults.tests.push(test2);

        // テスト3: 通知条件のロジック確認
        Logger.debug('📋 テスト3: 通知条件ロジックの確認');
        const test3 = this.testNotificationLogic();
        testResults.tests.push(test3);

        // テスト4: デバウンス機能の確認
        Logger.debug('📋 テスト4: 通知デバウンス機能の確認');
        const test4 = await this.testNotificationDebounce();
        testResults.tests.push(test4);

        // 結果集計
        testResults.tests.forEach((test) => {
          testResults.summary.total++;
          if (test.passed) {
            testResults.summary.passed++;
          } else {
            testResults.summary.failed++;
          }
        });

        Logger.debug('✅ 通知システムエッジケーステスト完了:', testResults.summary);
        return testResults;
      } catch (error) {
        console.error('❌ 通知システムテストエラー:', error);
        return { error: error.message, partialResults: testResults };
      }
    }

    async testInitialLoadFailureNotification() {
      const testName = '初期データロード失敗後の通知';
      try {
        // 現在の状態を保存
        const originalInitialDataLoaded = this.initialDataLoaded;
        const originalHadInitialDataLoadFailure = this.hadInitialDataLoadFailure;
        const originalLastSeenCount = this.state.lastSeenCount;

        // テスト状態を設定
        this.initialDataLoaded = false;
        this.hadInitialDataLoadFailure = true;
        this.state.lastSeenCount = 0;

        Logger.debug('🔧 テスト状態設定:', {
          initialDataLoaded: this.initialDataLoaded,
          hadInitialDataLoadFailure: this.hadInitialDataLoadFailure,
          lastSeenCount: this.state.lastSeenCount,
        });

        // モック通知関数
        let notificationShown = false;
        const originalShowNewContentBanner = this.showNewContentBanner;
        this.showNewContentBanner = (newItems) => {
          notificationShown = true;
          Logger.debug('🎯 テスト中：通知が表示されました -', newItems, '件');
          return originalShowNewContentBanner.call(this, newItems);
        };

        // 模擬的な handleInitialContentLoad 呼び出し
        await this.handleInitialContentLoad('すべて-newest', 1);

        // 結果検証
        const passed =
          notificationShown && this.state.lastSeenCount === 1 && !this.hadInitialDataLoadFailure;

        // 状態を復元
        this.initialDataLoaded = originalInitialDataLoaded;
        this.hadInitialDataLoadFailure = originalHadInitialDataLoadFailure;
        this.state.lastSeenCount = originalLastSeenCount;
        this.showNewContentBanner = originalShowNewContentBanner;

        return {
          name: testName,
          passed,
          details: {
            notificationShown,
            finalLastSeenCount: this.state.lastSeenCount,
            failureFlagCleared: !this.hadInitialDataLoadFailure,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    testNotificationBannerElements() {
      const testName = '通知バナー要素の存在確認';
      try {
        const elements = {
          banner: this.elements.newContentBanner,
          text: this.elements.newContentText,
          refreshBtn: this.elements.refreshContentBtn,
          dismissBtn: this.elements.dismissBannerBtn,
        };

        const missing = [];
        Object.entries(elements).forEach(([key, element]) => {
          if (!element) {
            missing.push(key);
          }
        });

        const passed = missing.length === 0;

        return {
          name: testName,
          passed,
          details: {
            elementsFound: Object.keys(elements).length - missing.length,
            totalElements: Object.keys(elements).length,
            missingElements: missing,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    testNotificationLogic() {
      const testName = '通知条件ロジックの確認';
      try {
        const scenarios = [
          { newCount: 5, lastSeen: 3, shouldNotify: true, expected: 2 },
          { newCount: 3, lastSeen: 3, shouldNotify: false, expected: 0 },
          { newCount: 2, lastSeen: 3, shouldNotify: false, expected: 0 },
          { newCount: 1, lastSeen: 0, shouldNotify: true, expected: 1 },
        ];

        const results = scenarios.map((scenario) => {
          const shouldNotify = scenario.newCount > scenario.lastSeen;
          const newItems = shouldNotify ? scenario.newCount - scenario.lastSeen : 0;

          return {
            scenario,
            actualShouldNotify: shouldNotify,
            actualNewItems: newItems,
            correct: shouldNotify === scenario.shouldNotify && newItems === scenario.expected,
          };
        });

        const passed = results.every((result) => result.correct);

        return {
          name: testName,
          passed,
          details: {
            scenariosTested: scenarios.length,
            scenariosPassed: results.filter((r) => r.correct).length,
            results,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    async testNotificationDebounce() {
      const testName = '通知デバウンス機能の確認';
      try {
        // デバウンステストのために短時間で複数回通知を試行
        const originalLastNotificationTime = this.lastNotificationTime;

        let notificationCount = 0;
        const originalShowNewContentBanner = this.showNewContentBanner;

        this.showNewContentBanner = (newItems) => {
          notificationCount++;
          Logger.debug('🎯 デバウンステスト：通知回数 =', notificationCount);
          return originalShowNewContentBanner.call(this, newItems);
        };

        // 最初の通知
        this.lastNotificationTime = null;
        await this.checkForNewItems(1);
        const firstNotificationCount = notificationCount;

        // 短時間内での2回目の通知（デバウンスされるべき）
        this.lastNotificationTime = Date.now() - 1500; // 1.5秒前に設定
        await this.checkForNewItems(2);
        const secondNotificationCount = notificationCount;

        // 十分な時間後の3回目の通知（デバウンスされないべき）
        this.lastNotificationTime = Date.now() - 3000; // 3秒前に設定
        await this.checkForNewItems(3);
        const thirdNotificationCount = notificationCount;

        // 復元
        this.showNewContentBanner = originalShowNewContentBanner;
        this.lastNotificationTime = originalLastNotificationTime;

        // デバウンスが正しく動作している場合: 1回目と3回目で通知、2回目はスキップ
        const passed =
          firstNotificationCount === 1 &&
          secondNotificationCount === 1 &&
          thirdNotificationCount === 2;

        return {
          name: testName,
          passed,
          details: {
            firstNotification: firstNotificationCount,
            secondNotification: secondNotificationCount,
            thirdNotification: thirdNotificationCount,
            expectedBehavior: '1→1→2 (2回目はデバウンス)',
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    // 通知システムの健全性チェック
    validateNotificationSystem() {
      Logger.debug('🔍 通知システム健全性チェック');

      const issues = [];

      // 1. 通知バナー要素の存在確認
      if (!this.elements.newContentBanner) {
        issues.push('newContentBanner要素が見つかりません');
      }
      if (!this.elements.newContentText) {
        issues.push('newContentText要素が見つかりません');
      }
      if (!this.elements.refreshContentBtn) {
        issues.push('refreshContentBtn要素が見つかりません');
      }

      // 2. 初期化状態の確認
      if (this.initialDataLoaded === undefined) {
        issues.push('initialDataLoaded状態が未定義です');
      }
      if (this.hadInitialDataLoadFailure === undefined) {
        issues.push('hadInitialDataLoadFailure状態が未定義です');
      }

      // 3. 通知状態の確認
      if (this.state.lastSeenCount === undefined) {
        issues.push('lastSeenCount状態が未定義です');
      }

      // 4. ポーリング状態の確認
      if (!this.pollingSettings || this.pollingSettings.enabled === undefined) {
        issues.push('ポーリング設定が不正です');
      }

      // 5. 結果
      if (issues.length === 0) {
        Logger.debug('✅ 通知システム健全性: 正常');
        return { status: 'healthy', issues: [] };
      } else {
        console.warn('⚠️ 通知システム健全性: 問題検出', issues);
        return { status: 'issues_detected', issues };
      }
    }

    async toggleAdminMode() {
      // Temporarily disable button to prevent duplicate clicks
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.disabled = true;
      }

      try {
        const enable = !this.state.showAdminFeatures;

        // 管理者権限チェック
        if (enable) {
          if (!this.state.isAdminUser || !window.hasAdminCapability) {
            console.warn('管理者権限がありません。');
            return;
          }

          // 管理モード移行時の確認モーダル
          const confirmed = await this.showAdminModeConfirmation();
          if (!confirmed) {
            return; // ユーザーがキャンセルした場合
          }

          // 最初の管理モード切り替え時のみサーバー側で再確認（オプション）
          if (!this.adminModeVerified) {
            try {
              const ok = await this.gas.checkAdmin();
              if (!ok) {
                console.warn('サーバー側の権限確認に失敗しました。');
                // ローカルの権限情報を信頼して継続
              }
              this.adminModeVerified = true;
            } catch (e) {
              console.warn('権限確認API呼び出しに失敗しました', e);
              // エラーが発生してもローカルの権限情報を信頼して継続
            }
          }
        }

        // グローバル設定を更新
        window.showAdminFeatures = enable;
        window.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示

        Logger.perf('toggleAdminMode状態更新:', {
          enable,
          isAdminUser: this.state.isAdminUser,
          showAdminFeatures: window.showAdminFeatures,
          showHighlightToggle: window.showHighlightToggle,
        });
        if (enable) {
          // 管理モード時は強制的に名前とリアクション数を表示
          window.showCounts = true;
          window.displayMode = 'named';
          window.isStudentMode = false;
          window.showScoreSort = window.showCounts;
          Logger.perf('管理モード有効化: 名前とリアクション数を強制表示', {
            showCounts: window.showCounts,
            displayMode: window.displayMode,
          });
        } else {
          // 閲覧モード時はサーバー設定に戻す
          window.showCounts = this.serverShowCounts;
          window.displayMode = this.serverDisplayMode;
          window.isStudentMode = true;
          window.showScoreSort = window.showCounts;
          Logger.perf('閲覧モード有効化: サーバー設定を復元', {
            showCounts: window.showCounts,
            displayMode: window.displayMode,
            serverShowCounts: this.serverShowCounts,
            serverDisplayMode: this.serverDisplayMode,
          });
        }

        // 管理モード有効時は強制的にローカル状態も更新
        if (enable) {
          this.state.displayMode = 'named';
          this.state.showCounts = true;
          this.state.isStudentMode = false;
        } else {
          this.state.displayMode = this.serverDisplayMode;
          this.state.showCounts = this.serverShowCounts;
          this.state.isStudentMode = true;
        }

        // Update local state from global variables (but preserve displayMode if in admin mode)
        this.updateConfigFromGlobals();

        // Re-enforce admin mode settings after updateConfigFromGlobals
        if (enable) {
          this.state.displayMode = 'named';
          this.state.showCounts = true;
        }

        // 管理モード切り替え後の状態を確認
        Logger.perf('管理モード切り替え後の状態確認:', {
          enable,
          stateDisplayMode: this.state.displayMode,
          stateShowCounts: this.state.showCounts,
          windowDisplayMode: window.displayMode,
          windowShowCounts: window.showCounts,
        });

        // キャッシュをクリアして新しい設定で再描画
        this.cache.clear();

        // 管理モード切り替え時は既存のカードを全て削除して強制再生成
        this.elements.answersContainer.innerHTML = '';

        // UI状態を更新
        this.updateSortOptions();
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
        // 管理モード切り替え時は設定変更のため再描画が必要
        this.loadSheetData({ bypassCache: true }).then(() => {
          // 管理モード切り替え後に新着チェックの基準を更新
          this.updateLastSeenCount(this.state.currentAnswers?.length || 0);
          Logger.debug('🔄 管理モード切り替え完了、新着チェック基準更新:', {
            newBaselineCount: this.state.lastSeenCount,
            adminMode: this.state.showAdminFeatures,
          });
        });
      } finally {
        // Re-enable button
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.disabled = false;
        }
      }
    }

    /**
     * 管理モード移行確認モーダル
     */
    async showAdminModeConfirmation() {
      return new Promise((resolve) => {
        // モーダル要素を作成
        const modal = this._createElement('div');
        modal.className =
          'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
          const warningIcon = this.getIcon('x', 'w-6 h-6 text-orange-600');
        
        modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
          <div class="flex items-center mb-4">
            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center">
              ${warningIcon}
            </div>
            <div class="ml-4">
              <h3 class="text-lg font-medium text-gray-900">管理モードに切り替えますか？</h3>
            </div>
          </div>
          <div class="mb-6">
            <p class="text-sm text-gray-600">
              管理モードでは、<strong>生徒の名前とリアクション数が表示</strong>されます。<br>
              画面共有時などは十分注意してください。
            </p>
          </div>
          <div class="flex justify-end space-x-3">
            <button type="button" class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
              キャンセル
            </button>
            <button type="button" class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-orange-600 border border-transparent rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
              管理モードに切り替え
            </button>
          </div>
        </div>
      `;

        // イベントリスナーを追加
        const cancelBtn = modal.querySelector('.cancel-btn');
        const confirmBtn = modal.querySelector('.confirm-btn');

        const cleanup = () => {
          document.body.removeChild(modal);
        };

        cancelBtn.addEventListener('click', () => {
          cleanup();
          resolve(false);
        });

        confirmBtn.addEventListener('click', () => {
          cleanup();
          resolve(true);
        });

        // Escapeキーでキャンセル
        const handleKeydown = (e) => {
          if (e.key === 'Escape') {
            cleanup();
            document.removeEventListener('keydown', handleKeydown);
            resolve(false);
          }
        };
        document.addEventListener('keydown', handleKeydown);

        // モーダルを表示
        document.body.appendChild(modal);

        // フォーカスを確認ボタンに移動
        setTimeout(() => confirmBtn.focus(), 100);
      });
    }

    async endPublication() {
      if (!confirm('公開を終了しますか？生徒は回答ボードにアクセスできなくなります。')) {
        return;
      }

      // ボタンのローディング状態を設定
      const endPublicationBtn = this.elements.endPublicationBtn;
      let originalButtonContent = '';
      if (endPublicationBtn) {
        originalButtonContent = endPublicationBtn.innerHTML;
        endPublicationBtn.disabled = true;
        
          const loadingIcon = this.getIcon('x', 'w-3 h-3 animate-spin inline-block mr-1');
        
        endPublicationBtn.innerHTML = `
        ${loadingIcon}
        公開終了中...
      `;
      }

      try {
        Logger.debug('🔄 公開終了処理を開始します...');

        // サーバーに公開終了リクエストを送信
        const result = await this.runGas('clearActiveSheet');

        Logger.debug('✅ 公開終了処理が完了しました:', result);

        // 成功メッセージを表示
        const successMessage = result.message || '公開を終了しました。非公開画面に移動します。';
        if (window.sharedModals) {
          window.sharedModals.showAlert('公開終了', successMessage, 'success');
        } else {
          alert(successMessage);
        }

        // 少し遅延してからUnpublished.htmlに移動（ユーザーがメッセージを確認できるように）
        setTimeout(() => {
          this.redirectToUnpublishedPage();
        }, 1500);
      } catch (error) {
        console.error('❌ 公開終了に失敗しました:', error);

        // エラーメッセージを構成
        let errorMsg = '公開終了に失敗しました';
        if (error && error.message) {
          errorMsg += ': ' + error.message;
        } else if (typeof error === 'string') {
          errorMsg += ': ' + error;
        }

        // エラーメッセージを表示
        if (window.sharedModals) {
          window.sharedModals.showAlert('エラー', errorMsg, 'error');
        } else {
          alert(errorMsg);
        }

        // ボタンを元の状態に戻す
        if (endPublicationBtn && originalButtonContent) {
          endPublicationBtn.disabled = false;
          endPublicationBtn.innerHTML = originalButtonContent;
        }
      }
    }
    redirectToUnpublishedPage() {
      Logger.debug('🚫 Redirecting to unpublished page (legacy function)');

      // キャッシュクリア処理（新機能と統合）
      this.clearAllCachesForUnpublished();

      // 公開停止時は次回管理パネルを開いたときに全セクションをオープンにする
      try {
        localStorage.setItem('expandAllSections', 'true');
        Logger.debug('✅ アコーディオン全展開フラグを設定しました');
      } catch (error) {
        console.warn('⚠️ localStorage設定に失敗:', error);
      }

      // 新しいキャッシュバスティング機能を使用したリダイレクト
      const unpublishedUrl = new URL(window.location.href);
      unpublishedUrl.searchParams.delete('mode'); // mode=viewを削除
      unpublishedUrl.searchParams.set('_cb', Date.now()); // キャッシュバスティング
      unpublishedUrl.searchParams.set('_redirect', 'unpublished'); // リダイレクト理由

      Logger.debug('🔄 Redirecting to unpublished URL:', unpublishedUrl.toString());
      window.location.href = unpublishedUrl.toString();
    }

    endAdminMode() {
      google.script.run
        .withSuccessHandler(function (adminUrl) {
          const url = new URL(adminUrl);
          url.searchParams.set('mode', 'admin');
          window.location.href = url.toString();
        })
        .getWebAppUrl();
    }

    /**
     * リアクション状態をlocalStorageに保存
     * @param {number} rowIndex - 行インデックス
     * @param {object} reactions - リアクション状態オブジェクト
     */
    saveReactionState(rowIndex, reactions) {
      try {
        // 既存の保存データを取得
        const existingData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');

        // 現在のリアクション状態を保存
        existingData[rowIndex] = {};
        Object.keys(reactions).forEach((reactionType) => {
          const reaction = reactions[reactionType];
          if (reaction && reaction.reacted) {
            existingData[rowIndex][reactionType] = {
              reacted: true,
              timestamp: new Date().toISOString(),
            };
          }
        });

        // 空のオブジェクトの場合は削除
        if (Object.keys(existingData[rowIndex]).length === 0) {
          delete existingData[rowIndex];
        }

        localStorage.setItem(this.reactionStorageKey, JSON.stringify(existingData));
        Logger.perf('リアクション状態を保存:', { rowIndex, reactions: existingData[rowIndex] });
      } catch (error) {
        console.warn('リアクション状態の保存に失敗:', error);
      }
    }

    /**
     * localStorageからリアクション状態を読み込み
     * @returns {object} 保存されたリアクション状態
     */
    loadReactionState() {
      try {
        const savedData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
        Logger.perf('リアクション状態を読み込み:', savedData);
        return savedData;
      } catch (error) {
        console.warn('リアクション状態の読み込みに失敗:', error);
        return {};
      }
    }

    /**
     * 保存されたリアクション状態を現在のデータに適用
     * @param {array} answers - 回答データ配列
     */
    applyReactionState(answers) {
      const savedReactions = this.loadReactionState();
      let modified = false;

      answers.forEach((answer) => {
        if (!savedReactions[answer.rowIndex]) {
          savedReactions[answer.rowIndex] = {};
        }
        const savedReaction = savedReactions[answer.rowIndex];

        if (answer.reactions) {
          Object.keys(answer.reactions).forEach((reactionType) => {
            const info = answer.reactions[reactionType];
            if (!info) return;

            const serverReacted = !!info.reacted;
            const localReacted = !!savedReaction[reactionType];

            info.reacted = serverReacted;

            if (serverReacted) {
              if (!localReacted) {
                if (!savedReactions[answer.rowIndex]) {
                  savedReactions[answer.rowIndex] = {};
                }
                savedReactions[answer.rowIndex][reactionType] = {
                  reacted: true,
                  timestamp: new Date().toISOString(),
                };
                modified = true;
              }
            } else if (localReacted) {
              delete savedReaction[reactionType];
              modified = true;
            }

            if (Object.keys(savedReaction).length === 0) {
              delete savedReactions[answer.rowIndex];
            }

            Logger.perf(`✅ リアクション状態同期 [行${answer.rowIndex}][${reactionType}]:`, {
              serverReacted,
              localReacted,
              finalReacted: info.reacted,
              timestamp: new Date().toISOString(),
            });
          });
        }
      });

      if (modified) {
        localStorage.setItem(this.reactionStorageKey, JSON.stringify(savedReactions));
      }

      Logger.perf('サーバーとローカルのリアクション状態同期完了');
    }

    updateModalReactionButtons(item) {
      if (!this.elements.modalReactionContainer) return;

      this.reactionTypes.forEach((rt) => {
        const info = item.reactions?.[rt.key] || { count: 0, reacted: false };
        const modalBtn = this.elements.modalReactionContainer.querySelector(
          `[data-reaction="${rt.key}"]`
        );

        if (modalBtn) {
          // カウント表示更新
          const countEl = modalBtn.querySelector('.reaction-count');
          if (countEl && this.state.showCounts) {
            countEl.textContent = info.count;
          }

          // アイコン更新
          const svgEl = modalBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);
          }

          // スタイル更新
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          modalBtn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
          modalBtn.classList.add(colorClass);
          modalBtn.classList.toggle('liked', info.reacted);
          modalBtn.setAttribute('aria-pressed', info.reacted.toString());

          // aria-label更新
          const reactionName = SYSTEM_CONSTANTS.REACTIONS.LABELS[rt.key] || rt.key;
          const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count}件)` : ''}`;
          modalBtn.setAttribute('aria-label', ariaLabel);
        }
      });
    }
    applyUpdates(items) {
      // パフォーマンス最適化: 変更が必要なアイテムのみ処理
      const itemsToUpdate = items.filter((item) => {
        const updateKey = `apply_update_${item.rowIndex}`;
        const currentHash = this.calculateStateHash(item);
        const lastHash = this.lastApplyStates?.get(updateKey);

        if (lastHash === currentHash) {
          return false; // 変更なし - スキップ
        }

        // 状態を記録
        if (!this.lastApplyStates) this.lastApplyStates = new Map();
        this.lastApplyStates.set(updateKey, currentHash);
        return true; // 変更あり - 更新対象
      });

      if (itemsToUpdate.length === 0) {
        Logger.debug('⚡ applyUpdates: 全アイテムスキップ (変更なし)');
        return;
      }

      Logger.debug(`⚡ applyUpdates: ${itemsToUpdate.length}/${items.length}件を更新`);

      // バッチ処理用にリアクション更新データを蓄積
      const reactionUpdates = [];

      itemsToUpdate.forEach((item) => {
        this.reactionTypes.forEach((rt) => {
          if (item.reactions && item.reactions[rt.key]) {
            reactionUpdates.push({
              rowIndex: item.rowIndex,
              reaction: rt.key,
              count: item.reactions[rt.key].count,
              reacted: item.reactions[rt.key].reacted,
              shouldDisplay: item.reactions[rt.key].count > 0,
            });
          }
        });
        const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
        if (card) {
          card.classList.toggle('highlighted', item.highlight);
          this.applyReactionStyles(card, item);
          const highlightBtn = card.querySelector('.highlight-btn');
          if (highlightBtn) {
            highlightBtn.classList.toggle('liked', item.highlight);
            highlightBtn.setAttribute('aria-pressed', String(item.highlight));
            const label = item.highlight ? 'ハイライトを解除する' : 'ハイライトする';
            highlightBtn.setAttribute('aria-label', label);
            const svgEl = highlightBtn.querySelector('svg');
            if (svgEl) {
              svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
            }
          }
          let badge = card.querySelector('.highlight-badge');
          if (item.highlight && !badge) {
            badge = document.createElement('span');
            badge.className = 'highlight-badge';
            badge.innerHTML = this.getIcon('star', '', true);
            card.appendChild(badge);
          } else if (!item.highlight && badge) {
            badge.remove();
          }
        }
      });

      // バッチ処理でリアクション更新を実行
      if (reactionUpdates.length > 0) {
        this.batchUpdateReactionButtons(reactionUpdates);
      }
    }
    showAnswerModal(rowIndex) {
      Logger.debug('📱 [MODAL DEBUG] showAnswerModal called:', {
        rowIndex: rowIndex,
        rowIndexType: typeof rowIndex,
        timestamp: new Date().toISOString(),
      });

      // Show answer modal called

      // Data search context

      // 最新データを取得（filteredDataとcurrentAnswersの両方から）
      let data = this.state.currentAnswers?.find((r) => r.rowIndex == rowIndex);
      // Data search in currentAnswers

      if (!data && this.state.filteredData) {
        data = this.state.filteredData?.find((r) => r.rowIndex == rowIndex);
        Logger.perf('Data search in filteredData:', {
          found: !!data,
          searchRowIndex: rowIndex,
          availableRowIndexes: this.state.filteredData?.map((r) => r.rowIndex) || [],
        });
      }

      if (!data) {
        Logger.perf('ERROR: No data found for rowIndex:', {
          rowIndex: rowIndex,
          currentAnswers: this.state.currentAnswers,
          filteredData: this.state.filteredData,
        });
        return;
      }

      Logger.perf('Data found for modal:', {
        rowIndex: rowIndex,
        data: data,
        opinion: data.opinion?.substring(0, 50) + '...',
        reason: data.reason?.substring(0, 50) + '...',
      });
      this.state.lastFocusedElement = document.activeElement;
      this.elements.modalAnswer.innerHTML =
        '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' +
        this.escapeHtml(data.opinion || '') +
        '</p>' +
        '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' +
        this.escapeHtml(data.reason || '') +
        '</p>';
      const showName = this.state.displayMode === 'named';
      let modalDisplayName = '';

      // Debug: Log modal display mode state
      Logger.perf('Modal display state:', {
        displayMode: this.state.displayMode,
        showName,
        showAdminFeatures: this.state.showAdminFeatures,
        isAdminUser: this.state.isAdminUser,
        dataName: data.name,
        dataEmail: data.email,
      });

      if (showName) {
        // 名前が利用可能な場合はそれを使用、なければemailから生成
        modalDisplayName = data.name || (data.email ? data.email.split('@')[0] : 'ユーザー');
      }

      this.elements.modalStudentName.textContent = modalDisplayName;
      const footerBase =
        'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
      this.elements.modalFooter.className =
        footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
      const reactionButtonsHtml = this.reactionTypes
        .map((rt) => {
          const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          const countSpan = this.state.showCounts
            ? '<span class="reaction-count font-bold text-2xl text-gray-200">' +
              info.count +
              '</span>'
            : '';
          return (
            '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' +
            colorClass +
            ' ' +
            cls +
            '" ' +
            'data-row-index="' +
            rowIndex +
            '" data-reaction="' +
            rt.key +
            '" aria-label="' +
            rt.key +
            '">' +
            this.getIcon(rt.icon, 'w-5 h-5', info.reacted) +
            countSpan +
            '</button>'
          );
        })
        .join('');

      // ハイライトボタンを追加
      let highlightBtnHtml = '';
      if (this.state.showHighlightToggle) {
        const cls = data.highlight ? 'liked' : '';
        const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
        highlightBtnHtml =
          '<button type="button" class="highlight-btn like-btn text-purple-600 ' +
          cls +
          '" aria-label="' +
          highlightAriaLabel +
          '" aria-pressed="' +
          data.highlight +
          '" data-row-index="' +
          data.rowIndex +
          '">' +
          this.getIcon('star', 'w-5 h-5', data.highlight) +
          '</button>';
      }

      this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;

      // リアクションに基づくカード色の適用
      Logger.perf('モーダルにリアクション装飾適用:', {
        rowIndex: data.rowIndex,
        highlight: data.highlight,
        reactions: data.reactions,
        element: this.elements.answerModalCard.className,
      });
      this.applyReactionStyles(this.elements.answerModalCard, data);
      Logger.perf('モーダル装飾適用後:', {
        className: this.elements.answerModalCard.className,
      });

      this.elements.answerModalContainer.classList.remove('hidden');
      this.elements.answerModalContainer.classList.add('modal-fade');
      this.elements.answerModalCard.classList.add('modal-scale');

      this.elements.answerModalCloseBtn.focus();
    }
    updateModalContent(data) {
      if (!data) return;

      // リアクションボタンを更新
      const reactionButtonsHtml = this.reactionTypes
        .map((rt) => {
          const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          const countSpan = this.state.showCounts
            ? '<span class="reaction-count font-bold text-2xl text-gray-200">' +
              info.count +
              '</span>'
            : '';
          return (
            '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' +
            colorClass +
            ' ' +
            cls +
            '" ' +
            'data-row-index="' +
            data.rowIndex +
            '" data-reaction="' +
            rt.key +
            '" aria-label="' +
            rt.key +
            '">' +
            this.getIcon(rt.icon, 'w-5 h-5', info.reacted) +
            countSpan +
            '</button>'
          );
        })
        .join('');

      // ハイライトボタンを更新
      let highlightBtnHtml = '';
      if (this.state.showHighlightToggle) {
        const cls = data.highlight ? 'liked' : '';
        const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
        highlightBtnHtml =
          '<button type="button" class="highlight-btn like-btn text-purple-600 ' +
          cls +
          '" aria-label="' +
          highlightAriaLabel +
          '" aria-pressed="' +
          data.highlight +
          '" data-row-index="' +
          data.rowIndex +
          '">' +
          this.getIcon('star', 'w-5 h-5', data.highlight) +
          '</button>';
      }

      this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;

      // モーダルカードのスタイルを更新
      Logger.perf('updateModalContent装飾適用:', {
        rowIndex: data.rowIndex,
        highlight: data.highlight,
        reactions: data.reactions,
      });
      this.applyReactionStyles(this.elements.answerModalCard, data);
    }
    hideAnswerModal() {
      this.elements.answerModalContainer.classList.add('hidden');
      this.elements.answerModalContainer.classList.remove('modal-fade');
      this.elements.answerModalCard.classList.remove('modal-scale');
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
    showInfoModal() {
      this.state.lastFocusedElement = document.activeElement;
      this.elements.infoModalContainer.classList.remove('hidden');
      this.elements.infoModalContainer.classList.add('modal-fade');
      this.elements.infoModalCard.classList.add('modal-scale');

      // Ensure modal starts from the top
      this.elements.infoModalCard.scrollTop = 0;

      // Focus on the modal container first, then the button
      setTimeout(() => {
        this.elements.infoModalConfirmBtn.focus();
      }, 100);
    }
    hideInfoModal() {
      this.elements.infoModalContainer.classList.add('hidden');
      this.elements.infoModalContainer.classList.remove('modal-fade');
      this.elements.infoModalCard.classList.remove('modal-scale');

      // Note: localStorage 'introSeen' flag removed to allow modal to show on every board update
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
    getIcon(name, classes = '', solid = false) {
      // Cache icons to avoid repeated string concatenation
      const cacheKey = `icon-${name}-${classes}-${solid}`;
      const cachedIcon = this.cache.get(cacheKey);
      if (cachedIcon) {
        return cachedIcon;
      }

      let key = name;
      if (ICONS[name + '-outline'] || ICONS[name + '-solid']) {
        key = solid ? name + '-solid' : name + '-outline';
      }
      const icon = ICONS[key];
      if (!icon) {
        console.warn('Icon not found:', key);
        const fallback = '<span aria-hidden="true" class="' + classes + '">⭐</span>';
        this.cache.set(cacheKey, fallback);
        return fallback;
      }
      const result = '<span aria-hidden="true" class="' + classes + '">' + icon + '</span>';
      this.cache.set(cacheKey, result);
      return result;
    }
    renderIcons() {
      if (this.elements.infoIconLike) {
        this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
      }
      if (this.elements.infoIconUnderstand) {
        this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
      }
      if (this.elements.infoIconCurious) {
        this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
      }
      if (this.elements.infoIconHighlight) {
        this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
      }
      if (this.elements.iconClose) {
        this.elements.iconClose.innerHTML = this.getIcon('x');
      }
      if (this.elements.iconGrid) {
        this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
      }
    }
    debounce(func, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    // 🚀 CLAUDE.md準拠：throttle関数追加（必須ユーティリティ）
    throttle(func, delay) {
      let lastCall = 0;
      return (...args) => {
        const now = Date.now();
        if (now - lastCall >= delay) {
          lastCall = now;
          return func.apply(this, args);
        }
      };
    }
    updateSortOptions() {
      if (this.elements.scoreOption) {
        if (this.state.showScoreSort) {
          this.elements.scoreOption.style.display = 'block';
        } else {
          this.elements.scoreOption.style.display = 'none';
          if (this.elements.sortOrder.value === 'score') {
            this.elements.sortOrder.value = 'newest';
          }
        }
      }
    }
    updateConfigFromGlobals() {
      Logger.perf('updateConfigFromGlobals前の状態:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        showAdminFeatures: this.state.showAdminFeatures,
        windowShowAdminFeatures: window.showAdminFeatures,
        currentDisplayMode: this.state.displayMode,
      });

      this.state.isStudentMode = window.isStudentMode;
      this.state.showCounts = window.showCounts;
      window.showScoreSort = window.showCounts;
      this.state.showAdminFeatures = window.showAdminFeatures;
      this.state.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
      this.state.showScoreSort = window.showScoreSort;
      this.state.showPublishControls = window.showPublishControls;

      // Only update displayMode if not in admin mode
      if (!this.state.showAdminFeatures) {
        this.state.displayMode = window.displayMode;
      }

      Logger.perf('updateConfigFromGlobals後の状態:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        showAdminFeatures: this.state.showAdminFeatures,
        windowShowAdminFeatures: window.showAdminFeatures,
        finalDisplayMode: this.state.displayMode,
        windowDisplayMode: window.displayMode,
      });
    }
    escapeHtml(str) {
      if (!str) return '';
      return str
        .toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Performance optimization methods
    detectLowPerformanceDevice() {
      const userAgent = navigator.userAgent;
      const platform = navigator.platform;
      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
      const cores = navigator.hardwareConcurrency || 4;

      // Detect low-end devices
      if (memory <= 2 || cores <= 2) return true;
      if (userAgent.includes('Mobile') && !userAgent.includes('iPad')) return true;
      if (platform.includes('Win32') && cores <= 4) return true;

      return false;
    }

    setupPerformanceMonitoring() {
      let frameCount = 0;
      let lastTime = performance.now();

      const measurePerformance = () => {
        const now = performance.now();
        const delta = now - lastTime;

        if (frameCount > 0) {
          this.performanceMetrics.frameTime = delta;

          // If frame time is consistently over 16ms, enable low performance mode
          if (delta > PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
            console.warn('Low performance detected, enabling optimizations');
            this.isLowPerformanceMode = true;
            this.optimizeForLowPerformance();
          }
        }

        lastTime = now;
        frameCount++;

        if (frameCount < 60) {
          // Monitor first 60 frames
          requestAnimationFrame(measurePerformance);
        }
      };

      requestAnimationFrame(measurePerformance);
    }

    optimizeForLowPerformance() {
      Logger.perf('Enabling low performance optimizations');

      // Reduce animation and transition durations
      document.documentElement.style.setProperty('--transition-duration', '0.1s');
      document.documentElement.style.setProperty('--animation-duration', '0.1s');
      document.documentElement.style.setProperty('--backdrop-blur', '4px');

      // Create comprehensive low-performance stylesheet
      const style = document.createElement('style');
      style.id = 'low-performance-optimizations';
      style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        -webkit-backdrop-filter: blur(4px) !important;
        backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover {
        transform: scale(1.02) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        border: 3px solid #9333ea !important;
        border-image: none !important;
        box-shadow: 0 0 12px rgba(147, 51, 234, 0.5) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
      document.head.appendChild(style);

      // Add low-performance class to body for CSS targeting
      document.body.classList.add('low-performance');

      // Reduce polling frequency
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = setInterval(() => this.loadSheetData({ showLoading: false }), 30000); // 30s instead of 15s
      }
    }

    setupObservers() {
      // Intersection Observer for virtual scrolling - optimized for performance
      if ('IntersectionObserver' in window) {
        // Enhanced debounce visibility changes with batching to reduce excessive firing
        const debouncedVisibilityHandler = this.debounce((entries) => {
          // Batch entries by card to prevent rapid state changes on the same element
          const cardChanges = new Map();

          entries.forEach((entry) => {
            const card = entry.target;
            const rowIndex = card.dataset.rowIndex;

            // Keep only the latest change for each card
            cardChanges.set(rowIndex, { card, entry });
          });

          // Process batched changes
          cardChanges.forEach(({ card, entry }) => {
            // Only log significant visibility changes for debugging
            if (DEBUG_MODE && (entry.intersectionRatio === 0 || entry.intersectionRatio === 1)) {
              Logger.perf('IntersectionObserver visibility change:', {
                rowIndex: card.dataset.rowIndex,
                isIntersecting: entry.isIntersecting,
                intersectionRatio: entry.intersectionRatio,
              });
            }

            if (entry.isIntersecting) {
              // Card is becoming visible
              if (!card.classList.contains('visible')) {
                card.classList.add('visible');
                card.classList.remove('hidden-card');
                // Restore visibility and display if it was hidden
                if (card.style.visibility === 'hidden') {
                  card.style.visibility = 'visible';
                }
                if (card.style.display === 'none') {
                  card.style.display = '';
                }
              }
            } else {
              // MODIFIED: Do not hide cards for virtual scrolling - keep them in DOM
              // This prevents cards from disappearing when scrolling back up
              // Only mark as not visible for optimization purposes
              if (entry.intersectionRatio === 0 && card.classList.contains('visible')) {
                card.classList.remove('visible');
                card.classList.add('hidden-card');
                // Do NOT hide or remove from DOM - just mark as not visible
              }
            }
          });
        }, 50); // Increased debounce to 50ms for better stability

        this.visibilityObserver = new IntersectionObserver(debouncedVisibilityHandler, {
          rootMargin: `${VIEWPORT_BUFFER}px`,
          threshold: [0, 1.0], // Simplified thresholds: fully out vs fully in
        });
      }

      // ResizeObserver for responsive adjustments
      if ('ResizeObserver' in window) {
        this.resizeObserver = new ResizeObserver(
          this.debounce(() => {
            this.adjustLayout();
          }, 100)
        );
        this.resizeObserver.observe(this.elements.answersContainer);
      }
    }

    deferredRender(callback, priority = 'normal') {
      if (this.isLowPerformanceMode) {
        // Use requestIdleCallback for low priority updates
        this.idleCallbackId = requestIdleCallback(callback, { timeout: IDLE_TIMEOUT });
      } else {
        // Use requestAnimationFrame for normal updates
        this.animationFrameId = requestAnimationFrame(callback);
      }
    }

    batchDOMUpdates(updates) {
      const startTime = performance.now();
      let processedCount = 0;

      const processBatch = () => {
        while (
          processedCount < updates.length &&
          performance.now() - startTime < PERFORMANCE_BUDGET
        ) {
          updates[processedCount]();
          processedCount++;
        }

        if (processedCount < updates.length) {
          // Continue in next frame
          requestAnimationFrame(processBatch);
        }
      };

      processBatch();
    }

    getReusableFragment() {
      if (this.domFragmentPool.length > 0) {
        return this.domFragmentPool.pop();
      }
      return document.createDocumentFragment();
    }

    recycleFragment(fragment) {
      // Clear fragment content and reuse
      while (fragment.firstChild) {
        fragment.removeChild(fragment.firstChild);
      }
      if (this.domFragmentPool.length < 10) {
        // Limit pool size
        this.domFragmentPool.push(fragment);
      }
    }

    throttledUpdate(key, callback, delay = 100) {
      if (this.deferredUpdates.has(key)) {
        return;
      }

      this.deferredUpdates.add(key);
      setTimeout(() => {
        callback();
        this.deferredUpdates.delete(key);
      }, delay);
    }

    cleanup() {
      // Consolidated cache cleanup
      this.cache.cleanup();

      // Clear DOM fragment pool
      this.domFragmentPool.length = 0;

      Logger.perf('Cache cleanup completed', {
        cacheSize: this.cache.size,
      });
    }

    // Enhanced cache methods with timestamp tracking

    // ===== Virtual Scrolling Methods =====

    setupScrollObserver() {
      if (!this.elements.answersContainer) {
        console.warn('setupScrollObserver: answersContainer not found');
        return;
      }

      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      if (cards.length === 0) {
        Logger.perf('setupScrollObserver: No cards found, skipping setup');
        return;
      }

      // Clear existing scroll observer if it exists
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
      }

      // Create scroll observer for dynamic loading with debouncing
      const debouncedScrollHandler = this.debounce((entries) => {
        // Only process the first intersecting entry to prevent multiple simultaneous loads
        const intersectingEntry = entries.find((entry) => entry.isIntersecting);
        if (intersectingEntry) {
          Logger.perf(
            'setupScrollObserver: Trigger card intersecting:',
            intersectingEntry.target.dataset.rowIndex
          );
          this.handleVirtualScroll(intersectingEntry.target);
        }
      }, 150); // 150ms debounce for scroll triggers to prevent rapid firing

      this.scrollObserver = new IntersectionObserver(debouncedScrollHandler, {
        root: null,
        rootMargin: '300px', // Increased buffer for even smoother loading
        threshold: 0.1,
      });

      // Observe the last few elements for dynamic loading trigger
      const observeCount = Math.min(3, cards.length); // Reduced to last 3 cards for better performance
      const observedCards = [];

      for (let i = cards.length - observeCount; i < cards.length; i++) {
        if (cards[i] && cards[i].dataset.rowIndex) {
          this.scrollObserver.observe(cards[i]);
          observedCards.push(cards[i].dataset.rowIndex);
        }
      }

      Logger.perf('setupScrollObserver: Observing cards for dynamic loading:', {
        totalCards: cards.length,
        observedCount: observedCards.length,
        observedRowIndexes: observedCards,
        totalItems: this.virtualScrollState?.totalItems || 0,
        renderedItems: this.virtualScrollState?.renderedItems || 0,
      });
    }

    handleVirtualScroll(triggerElement) {
      if (!triggerElement || !this.virtualScrollState) {
        return;
      }

      if (this.virtualScrollState.isLoading) {
        Logger.perf('handleVirtualScroll: Already loading, skipping');
        return;
      }

      const currentCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const totalAvailable = this.state.currentAnswers?.length || 0;
      const currentRendered = currentCards.length;

      Logger.perf('handleVirtualScroll triggered:', {
        currentRendered,
        totalAvailable,
        triggerRowIndex: triggerElement.dataset.rowIndex,
      });

      // Check if we need to load more items
      if (currentRendered < totalAvailable) {
        this.loadMoreItems();
      } else {
        // Optimize visible elements when we've rendered everything
        this.optimizeVisibleElements();
      }
    }

    loadMoreItems() {
      if (this.virtualScrollState.isLoading) {
        return;
      }

      this.virtualScrollState.isLoading = true;

      // Enhanced item tracking - use Set instead of relying on DOM count
      if (!this.virtualScrollState.renderedRowIndexes) {
        this.virtualScrollState.renderedRowIndexes = new Set();
        // Initialize with existing cards in DOM
        const existingCards = this.elements.answersContainer.querySelectorAll('.answer-card');
        existingCards.forEach((card) => {
          if (card.dataset.rowIndex) {
            this.virtualScrollState.renderedRowIndexes.add(card.dataset.rowIndex);
          }
        });
      }

      // Use dynamic batch sizing for better performance adaptation
      const dynamicBatchSize = getDynamicBatchSize(this.performanceMetrics);
      const batchSize = this.isLowPerformanceMode
        ? Math.min(CHUNK_SIZE, dynamicBatchSize)
        : dynamicBatchSize;

      // Find items that haven't been rendered yet
      const unrenderedItems = this.state.currentAnswers.filter(
        (item) => !this.virtualScrollState.renderedRowIndexes.has(String(item.rowIndex))
      );

      // Take next batch of unrendered items
      const remainingItems = unrenderedItems.slice(0, batchSize);

      if (remainingItems.length === 0) {
        this.virtualScrollState.isLoading = false;
        Logger.perf('loadMoreItems: No more items to load - all items rendered');
        return;
      }

      Logger.perf(
        'loadMoreItems: Loading',
        remainingItems.length,
        'additional items with batch size',
        batchSize,
        'Total rendered:',
        this.virtualScrollState.renderedRowIndexes.size,
        'Total available:',
        this.state.currentAnswers?.length || 0
      );

      // Use deferred rendering for performance
      this.deferredRender(() => {
        this.renderAdditionalItems(remainingItems);
      });
    }

    renderAdditionalItems(items) {
      if (!items || items.length === 0) {
        this.virtualScrollState.isLoading = false;
        Logger.perf('renderAdditionalItems: No items to render');
        return;
      }

      const fragment = this.getReusableFragment();
      const changedItems = [];
      let successfullyCreated = 0;

      // Ensure renderedRowIndexes exists
      if (!this.virtualScrollState.renderedRowIndexes) {
        this.virtualScrollState.renderedRowIndexes = new Set();
      }

      items.forEach((item) => {
        const rowIndexStr = String(item.rowIndex);

        // Skip if already rendered (defensive check)
        if (this.virtualScrollState.renderedRowIndexes.has(rowIndexStr)) {
          Logger.perf('renderAdditionalItems: Item', rowIndexStr, 'already rendered, skipping');
          return;
        }

        const card = this.createAnswerCard(item);
        if (card) {
          card.classList.add('new-card');

          // Track this item as rendered
          this.virtualScrollState.renderedRowIndexes.add(rowIndexStr);

          // Add to visibility observer
          if (this.visibilityObserver) {
            this.visibilityObserver.observe(card);
          }

          // Add to scroll observer for the last few items
          const isLastFew = items.indexOf(item) >= items.length - 3;
          if (isLastFew && this.scrollObserver) {
            this.scrollObserver.observe(card);
          }

          fragment.appendChild(card);
          changedItems.push(item);
          successfullyCreated++;
        } else {
          console.warn('renderAdditionalItems: Failed to create card for item:', item.rowIndex);
        }
      });

      // Append new items to container
      if (fragment.children.length > 0) {
        this.elements.answersContainer.appendChild(fragment);

        // Update virtual scroll state with actual counts
        this.virtualScrollState.renderedItems = this.elements.answersContainer.children.length;

        Logger.perf(
          'renderAdditionalItems: Added',
          fragment.children.length,
          'new cards. Total rendered:',
          this.virtualScrollState.renderedRowIndexes.size,
          'DOM children:',
          this.virtualScrollState.renderedItems
        );
      } else {
        Logger.perf(
          'renderAdditionalItems: No cards were successfully created from',
          items.length,
          'items'
        );
      }

      // Apply updates if needed
      if (changedItems.length > 0) {
        this.deferredRender(() => this.applyUpdates(changedItems));
      }

      // Recycle fragment
      this.recycleFragment(fragment);

      // Reset loading state
      this.virtualScrollState.isLoading = false;

      // Validate state consistency
      this.validateVirtualScrollState();
    }

    validateVirtualScrollState() {
      if (!this.virtualScrollState || !this.virtualScrollState.renderedRowIndexes) {
        return;
      }

      const domCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const domRowIndexes = new Set();

      domCards.forEach((card) => {
        if (card.dataset.rowIndex) {
          domRowIndexes.add(card.dataset.rowIndex);
        }
      });

      const trackedCount = this.virtualScrollState.renderedRowIndexes.size;
      const domCount = domRowIndexes.size;
      const totalAvailable = this.state.currentAnswers?.length || 0;

      // Check for inconsistencies
      const missingInDOM = [...this.virtualScrollState.renderedRowIndexes].filter(
        (x) => !domRowIndexes.has(x)
      );
      const extraInDOM = [...domRowIndexes].filter(
        (x) => !this.virtualScrollState.renderedRowIndexes.has(x)
      );

      if (missingInDOM.length > 0 || extraInDOM.length > 0 || trackedCount !== domCount) {
        console.warn('Virtual scroll state inconsistency detected:', {
          trackedCount,
          domCount,
          totalAvailable,
          missingInDOM: missingInDOM.slice(0, 5),
          extraInDOM: extraInDOM.slice(0, 5),
        });

        // Auto-repair: sync tracked state with DOM reality
        this.virtualScrollState.renderedRowIndexes = domRowIndexes;
        this.virtualScrollState.renderedItems = domCount;

        Logger.perf(
          'validateVirtualScrollState: Auto-repaired state. New tracked count:',
          domCount
        );
      }
    }

    optimizeVisibleElements() {
      if (!this.elements.answersContainer || this.virtualScrollState.isLoading) {
        return;
      }

      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      let hiddenCount = 0;
      let restoredCount = 0;
      const viewportHeight = window.innerHeight;
      const hideThreshold = viewportHeight * 3; // Increased threshold for better UX

      // Track hidden cards for better restoration
      if (!this.virtualScrollState.hiddenCards) {
        this.virtualScrollState.hiddenCards = new Set();
      }

      cards.forEach((card) => {
        const rect = card.getBoundingClientRect();
        const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
        const rowIndex = card.dataset.rowIndex;
        const isCurrentlyHidden = this.virtualScrollState.hiddenCards.has(rowIndex);

        if (!isInViewport && !isCurrentlyHidden) {
          // Calculate distance from viewport
          const distanceFromViewport =
            rect.top > viewportHeight
              ? rect.top - viewportHeight // Below viewport
              : -rect.bottom; // Above viewport

          // Only hide cards that are really far away
          if (distanceFromViewport > hideThreshold) {
            this.hideCard(card, rowIndex);
            hiddenCount++;
          }
        } else if (isInViewport && isCurrentlyHidden) {
          // Restore cards that are back in viewport
          this.restoreCard(card, rowIndex);
          restoredCount++;
        }
      });

      if (hiddenCount > 0 || restoredCount > 0) {
        Logger.perf(
          'optimizeVisibleElements: Hidden',
          hiddenCount,
          'cards, restored',
          restoredCount,
          'cards'
        );
      }
    }

    hideCard(card, rowIndex) {
      // Use CSS transform instead of visibility for better performance
      card.style.transform = 'translateZ(0) scale(0.01)';
      card.style.opacity = '0';
      card.style.pointerEvents = 'none';
      card.classList.add('hidden-card');
      this.virtualScrollState.hiddenCards.add(rowIndex);

      // Temporarily unobserve from intersection observers to prevent state confusion
      if (this.visibilityObserver) {
        this.visibilityObserver.unobserve(card);
      }
      if (this.scrollObserver) {
        this.scrollObserver.unobserve(card);
      }
    }

    restoreCard(card, rowIndex) {
      // Restore card to full visibility
      card.style.transform = '';
      card.style.opacity = '';
      card.style.pointerEvents = '';
      card.classList.remove('hidden-card');
      card.classList.add('visible');
      this.virtualScrollState.hiddenCards.delete(rowIndex);

      // Re-add to intersection observers
      if (this.visibilityObserver) {
        this.visibilityObserver.observe(card);
      }

      // Only re-add to scroll observer if it's one of the last few cards
      const allCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const cardIndex = Array.from(allCards).indexOf(card);
      const isLastFew = cardIndex >= allCards.length - 3;

      if (isLastFew && this.scrollObserver) {
        this.scrollObserver.observe(card);
      }
    }

    // Reset virtual scrolling state for debugging and recovery
    resetVirtualScrollState() {
      Logger.perf('resetVirtualScrollState: Resetting virtual scroll state');

      // Clear state
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: this.state.currentAnswers?.length || 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        hiddenCards: new Set(),
      };

      // Clear all observers
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
        this.scrollObserver = null;
      }

      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
        this.visibilityObserver = null;
      }

      // Restore all cards to visible state
      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      cards.forEach((card) => {
        card.style.transform = '';
        card.style.opacity = '';
        card.style.pointerEvents = '';
        card.style.visibility = '';
        card.classList.remove('hidden-card');
        card.classList.add('visible');
      });

      // Re-setup observers
      this.setupObservers();

      Logger.perf('resetVirtualScrollState: Virtual scroll state reset complete');
    }

    /**
     * 理由テキストの堅牢化検証
     * @param {any} reason - 理由データ
     * @returns {string} 検証済み理由テキスト
     */
    validateReasonText(reason) {
      try {
        Logger.debug('🔍 validateReasonText デバッグ:', {
          input: reason,
          inputType: typeof reason,
          inputIsNull: reason === null,
          inputIsUndefined: reason === undefined,
          inputLength: reason?.length,
        });

        // null, undefined, 空文字列チェック
        if (!reason && reason !== 0) {
          Logger.debug('🔍 validateReasonText: 空の理由データ検出 - 空文字列を返します');
          return '';
        }

        // 文字列変換と基本検証
        const reasonStr = String(reason).trim();

        Logger.debug('🔍 validateReasonText 処理結果:', {
          reasonStr: reasonStr,
          reasonStrLength: reasonStr.length,
          willBeEmpty: reasonStr.length === 0,
        });

        // 長すぎる理由テキストの制限（10000文字まで）
        if (reasonStr.length > 10000) {
          console.warn('validateReasonText: Reason text too long, truncating:', reasonStr.length);
          return reasonStr.substring(0, 10000) + '...';
        }

        // HTMLエスケープが必要な文字をチェック
        if (reasonStr.includes('<') || reasonStr.includes('>') || reasonStr.includes('&')) {
          // HTMLが含まれている可能性がある場合は警告
          console.warn('validateReasonText: Potentially unsafe HTML content detected');
        }

        return reasonStr;
      } catch (error) {
        console.error('validateReasonText: Error validating reason text:', error);
        return ''; // エラー時は空文字列を返す
      }
    }

    /**
     * ボードデータの整合性をリアルタイムで検証
     * @returns {Promise<Object>} 検証結果
     */
    async validateBoardDataIntegrity() {
      try {
        Logger.debug('🔍 Starting real-time board data integrity validation...');

        const validationResults = {
          timestamp: new Date().toISOString(),
          totalCards: 0,
          validCards: 0,
          invalidCards: 0,
          reasonFieldIssues: 0,
          headerIssues: 0,
          errors: [],
        };

        // DOM内のカードを検証
        const cards = this.elements.answersContainer?.querySelectorAll('.answer-card') || [];
        validationResults.totalCards = cards.length;

        cards.forEach((card, index) => {
          try {
            const rowIndex = card.dataset.rowIndex;
            const opinionElement = card.querySelector('.opinion-text');
            const reasonElement = card.querySelector('.answer-preview p');

            // 基本要素の存在チェック
            if (!opinionElement || !rowIndex) {
              validationResults.invalidCards++;
              validationResults.errors.push(`Card ${index}: Missing essential elements`);
              return;
            }

            // 理由列の状態チェック
            const hasReasonData = this.state.currentAnswers.find(
              (a) => a.rowIndex == rowIndex
            )?.reason;
            const hasReasonElement = reasonElement && reasonElement.textContent.trim();

            if (hasReasonData && !hasReasonElement) {
              validationResults.reasonFieldIssues++;
              validationResults.errors.push(
                `Card ${index} (row ${rowIndex}): Reason data exists but not displayed`
              );
            }

            validationResults.validCards++;
          } catch (cardError) {
            validationResults.invalidCards++;
            validationResults.errors.push(`Card ${index}: Validation error - ${cardError.message}`);
          }
        });

        // ヘッダー情報の検証
        try {
          const headerValidation = await this.runGas(
            'validateHeaderIntegrity',
            this.state.tenantId
          );
          if (!headerValidation.success) {
            validationResults.headerIssues++;
            validationResults.errors.push(`Header validation failed: ${headerValidation.error}`);
          }
        } catch (headerError) {
          validationResults.headerIssues++;
          validationResults.errors.push(`Header validation error: ${headerError.message}`);
        }

        // 検証結果のログ出力
        const issueCount =
          validationResults.invalidCards +
          validationResults.reasonFieldIssues +
          validationResults.headerIssues;
        if (issueCount > 0) {
          console.warn('⚠️ Board data integrity issues detected:', validationResults);

          // 自動修復の試行（理由列の問題のみ）
          if (validationResults.reasonFieldIssues > 0) {
            Logger.debug('🔧 Attempting automatic reason field recovery...');
            await this.autoRecoverReasonFields();
          }
        } else {
          Logger.debug('✅ Board data integrity validation passed');
        }

        return validationResults;
      } catch (error) {
        console.error('❌ Board data integrity validation failed:', error);
        return {
          timestamp: new Date().toISOString(),
          error: error.message,
          success: false,
        };
      }
    }

    /**
     * 理由列の自動修復処理
     */
    async autoRecoverReasonFields() {
      try {
        Logger.debug('🔧 Starting automatic reason field recovery...');

        // キャッシュクリアして最新データを取得
        await this.gas.clearCache();

        // データを再取得してカードを更新
        await this.loadBoardData();

        Logger.debug('✅ Reason field recovery completed');
      } catch (error) {
        console.error('❌ Automatic reason field recovery failed:', error);
      }
    }
  }
  // ===== 共通ドメイン情報処理関数 =====
  // AdminPanel.html と Login.html で共通使用

  /**
   * ドメイン情報を取得して表示する共通関数
   * @param {Function} onSuccess - 成功時のコールバック（オプション）
   * @param {Function} onError - エラー時のコールバック（オプション）
   */
  function loadDomainInfo(onSuccess, onError) {
    google.script.run
      .withSuccessHandler((info) => {
        displayDomainInfo(info);
        if (onSuccess) onSuccess(info);
      })
      .withFailureHandler((error) => {
        console.error('ドメイン情報の取得に失敗しました:', error);
        displayDomainInfo({ error: error.message || error });
        if (onError) onError(error);
      })
      .getSystemDomainInfo();
  }

  /**
   * ドメイン情報を表示する共通関数
   * @param {Object} info - ドメイン情報オブジェクト
   */
  function displayDomainInfo(info) {
    const headerDomainMatch = this._getCachedElement('header-domain-match');
    const headerDomainMismatch = this._getCachedElement('header-domain-mismatch');
    const headerDomainInitial = this._getCachedElement('header-domain-initial');
    const headerDomainMatchText = this._getCachedElement('header-domain-match-text');
    const headerDomainMismatchText = this._getCachedElement('header-domain-mismatch-text');

    // 全ての表示を一旦非表示にする
    if (headerDomainMatch) headerDomainMatch.classList.add('hidden');
    if (headerDomainMismatch) headerDomainMismatch.classList.add('hidden');
    if (headerDomainInitial) headerDomainInitial.classList.add('hidden');

    if (!info || info.error) {
      console.warn('ドメイン情報エラー:', info?.error);
      if (headerDomainInitial) headerDomainInitial.classList.remove('hidden');
      return;
    }

    if (info.isDomainMatch) {
      // ドメインが一致している場合
      if (headerDomainMatch && headerDomainMatchText) {
        headerDomainMatch.classList.remove('hidden');
        if (info.deployDomain) {
          headerDomainMatchText.textContent = `${info.deployDomain} ドメイン`;
        } else {
          headerDomainMatchText.textContent = 'グローバルアクセス';
        }
      }
    } else {
      // ドメイン不一致の場合
      if (headerDomainMismatch && headerDomainMismatchText) {
        headerDomainMismatch.classList.remove('hidden');
        headerDomainMismatchText.textContent = info.currentDomain;
      }
    }
  }

  /**
   * フォームリンクを取得して表示する関数
   */
  function loadFormLink() {
    google.script.run
      .withSuccessHandler((formInfo) => {
        if (formInfo && formInfo.formUrl) {
          const formLinkBtn = this._getCachedElement('form-link-btn');
          if (formLinkBtn) {
            formLinkBtn.href = formInfo.formUrl;
            formLinkBtn.classList.remove('hidden');
          }
        }
      })
      .withFailureHandler((error) => {
        console.warn('フォーム情報の取得に失敗しました:', error);
      })
      .getActiveFormInfo(CONFIG.userId);
  }

  // システムフロー表示関数の定義
  function showSystemFlow() {
    Logger.debug('🔄 システムフロー初期化開始');
    try {
      // 基本的なシステムフロー初期化処理
      if (window.answerBoardApp && typeof window.answerBoardApp.destroy === 'function') {
        window.answerBoardApp.destroy();
      }
      Logger.debug('✅ システムフロー初期化完了');
    } catch (error) {
      console.warn('⚠️ システムフロー初期化中にエラー:', error);
    }
  }

  try {
    // システムフロー表示
    showSystemFlow();


    // Expose debug functions globally for console access
    window.debugAnswerCards = () => {
      if (window.answerBoardApp && window.answerBoardApp.debugAnswerCards) {
        window.answerBoardApp.debugAnswerCards();
      } else {
        Logger.debug('AnswerBoardApp not available or debug function not found');
      }
    };

    // Enhanced global debug function with additional utility methods
    window.debugClickAnswerCard = (cardIndex = 0, options = {}) => {
      if (window.answerBoardApp && window.answerBoardApp.debugClickAnswerCard) {
        return window.answerBoardApp.debugClickAnswerCard(cardIndex, options);
      } else {
        Logger.debug('AnswerBoardApp not available or debug function not found');
        return { success: false, error: 'AnswerBoardApp not available' };
      }
    };

    // システムフロー表示をグローバルで利用可能にする
    window.showSystemFlow = showSystemFlow;

    // デバッグ用：データ構造確認機能
    window.debugCurrentData = () => {
      if (window.answerBoardApp && window.answerBoardApp.state) {
        Logger.debug('現在のデータ構造:', {
          currentAnswers: window.answerBoardApp.state.currentAnswers,
          currentAnswersLength: window.answerBoardApp.state.currentAnswers?.length,
          firstItem: window.answerBoardApp.state.currentAnswers?.[0],
          header: window.answerBoardApp.elements?.headingLabel?.textContent,
        });
      } else {
        Logger.debug('AnswerBoardApp not available');
      }
    };

    // Additional global debug utilities
    window.debugClickAllAnswerCards = async (options = {}) => {
      if (!window.answerBoardApp) {
        Logger.debug('AnswerBoardApp not available');
        return { success: false, error: 'AnswerBoardApp not available' };
      }

      const container = window.answerBoardApp.elements?.answersContainer;
      if (!container) {
        Logger.debug('No answers container found');
        return { success: false, error: 'No answers container found' };
      }

      const answerCards = container.querySelectorAll('.answer-card');
      const results = [];

      Logger.debug(`Found ${answerCards.length} answer cards, clicking all...`);

      for (let i = 0; i < answerCards.length; i++) {
        try {
          const result = await window.answerBoardApp.debugClickAnswerCard(i, {
            ...options,
            logDetails: false, // Reduce noise when clicking all cards
          });
          results.push(result);

          if (options.delay && i < answerCards.length - 1) {
            // Add proper delay between clicks if specified
            await new Promise((resolve) => setTimeout(resolve, options.delay));
          }
        } catch (error) {
          console.error(`Error clicking card ${i}:`, error);
          results.push({ success: false, error: error.message, cardIndex: i });
        }
      }

      return {
        success: true,
        totalCards: answerCards.length,
        results,
      };
    };

    // バッチ処理制御関数（デバッグ/運用制御用）
    window.toggleBatchProcessing = (enable = null) => {
      const app = window.answerBoardApp;
      if (!app) {
        console.error('AnswerBoardApp not found');
        return;
      }

      if (enable === null) {
        // 現在の状態をトグル
        app.enableBatchProcessing = !app.enableBatchProcessing;
      } else {
        app.enableBatchProcessing = Boolean(enable);
      }

      Logger.debug('🔧 バッチ処理:', app.enableBatchProcessing ? '有効' : '無効');
      Logger.debug('💡 個別処理システムは常に動作します（フォールバック保証）');
      return app.enableBatchProcessing;
    };

    // ✅ CLAUDE.md準拠: configJSON中心設定の初期化
    initializeConfig()
      .then(() => {
        debugInfo('✅ Config初期化完了');
        
        // AnswerBoardApp インスタンス初期化
        window.answerBoardApp = new AnswerBoardApp();
        debugInfo('✅ AnswerBoardApp初期化完了');
      })
      .catch((error) => {
        console.error('❌ 初期化エラー:', error);
        throw error;
      });

    window.addEventListener('beforeunload', () => {
      if (window.answerBoardApp && typeof window.answerBoardApp.destroy === 'function') {
        window.answerBoardApp.destroy();
      }
    });
  } catch (error) {
    console.error('Error creating AnswerBoardApp instance:', error);
    const container = this._getCachedElement('answers');
    if (container) {
      const msg = AnswerBoardApp.prototype.escapeHtml(error.message || '');
      container.innerHTML =
        '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + msg + '</div>';
    }
  }
</script>
