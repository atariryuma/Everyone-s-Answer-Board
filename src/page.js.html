<script>

class StudyQuestApp {
  static get CONSTANTS() {
    const perfLevel = window.getPerformanceLevel?.() || 'medium';
    const isLowEndDevice = window.isLowEndDevice?.() || false;

    return {
      REACTION_RATE_LIMIT_MS: isLowEndDevice ? 800 : 500,
      HIGHLIGHT_RATE_LIMIT_MS: isLowEndDevice ? 800 : 500,
      CACHE_TTL_MS: perfLevel === 'high' ? 2000 : perfLevel === 'low' ? 500 : 1000,
      RETRY_DELAY_MS: perfLevel === 'low' ? 3000 : 2000,
      POLLING_INTERVAL_MS: perfLevel === 'high' ? 3000 : perfLevel === 'low' ? 8000 : 5000,
      INIT_TIMEOUT_MS: isLowEndDevice ? 45000 : 30000
    };
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’æ¤œè¨¼ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤ã‚’æä¾›
   * @param {string} userId - æ¤œè¨¼ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @returns {string} æœ‰åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼IDã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
   */
  validId(userId) {
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      console.warn('âš ï¸ StudyQuestApp: Invalid or empty userId provided:', userId);

      try {
        const urlParams = new URLSearchParams(window.location.search);
        const fallbackUserId = urlParams.get('userId');

        if (fallbackUserId && fallbackUserId.trim()) {
          return fallbackUserId.trim();
        }
      } catch (error) {
        console.warn('âš ï¸ StudyQuestApp: Failed to get userId from URL parameters:', error.message);
      }

      try {
        if (typeof window.USER_ID !== 'undefined' && window.USER_ID && window.USER_ID.trim()) {
          return window.USER_ID.trim();
        }
      } catch (error) {
        console.warn('âš ï¸ StudyQuestApp: Failed to get userId from global USER_ID:', error.message);
      }

      console.warn('âš ï¸ StudyQuestApp: No valid userId available. Using limited functionality mode.');
      return '';
    }

    if (userId.length === 36 && userId.includes('-')) {
      return userId;
    }

    console.warn('âš ï¸ StudyQuestApp: Unusual userId format, but proceeding:', userId.substring(0, 8) + '...');
    return userId;
  }

  constructor() {

    this.cache = new window.UnifiedCache();
    this.activeRequests = 0;

    this.weakCache = new WeakMap();
    this.perf = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;


    this.NOTIFICATION_ANIMATION = {
      DURATION_MS: 300,        // CSS 0.3s ã¨åŒæœŸ
      RETRY_BUFFER_MS: 20,     // ãƒªãƒˆãƒ©ã‚¤ç”¨ãƒãƒƒãƒ•ã‚¡
      get RETRY_DELAY_MS() {
        return this.DURATION_MS + this.RETRY_BUFFER_MS;
      }
    };

    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      newContentBanner: document.getElementById('newContentBanner'),
      newContentIcon: document.getElementById('newContentIcon'),
      newContentText: document.getElementById('newContentText'),
      refreshContentBtn: document.getElementById('refreshContentBtn'),
      dismissBannerBtn: document.getElementById('dismissBannerBtn'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter')
    };

    this.state = {
      allAnswers: [],        // Full dataset cache for client-side filtering
      currentAnswers: [],    // Currently displayed filtered/sorted data
      isLoading: false,
      lastFocusedElement: null,
      isEditor: window.isEditor,
      isAdminUser: false,
      showCounts: window.showCounts,
      displayMode: window.displayMode,
      sheetName: window.SHEET_NAME,
      userId: this.validId(window.USER_ID),
      initializationComplete: false,
      isInitializing: true,
      lastSeenTimestamp: this.loadLastSeenTimestamp(),
      startTime: Date.now()
    };


    this.lastViewKey = null;
    this.initialDataLoaded = false;
    this.lastActivityTime = Date.now();
    this.hadInitialDataLoadFailure = false; // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°
    

    this.state.showCounts = window.showCounts;
    this.state.displayMode = window.displayMode;

    this.handlers = {};
    this.adminModeVerified = false; // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®æ¨©é™ç¢ºèªãƒ•ãƒ©ã‚°
    this.pendingReactions = new Map();
    this.reactionDebounceTimeouts = new Map(); // è¡Œå˜ä½ãƒ‡ãƒã‚¦ãƒ³ã‚·ãƒ³ã‚°ç”¨ï¼ˆ300msï¼‰
    this.reactionEventListeners = new Map(); // å‡¦ç†å®Œäº†é€šçŸ¥ç”¨

    this.retryDelayBase = 1000; // 1ç§’


    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];

    const currentUserIdentifier = window.UNIFIED_CONFIG?.email ?
      window.UNIFIED_CONFIG.email.replace(/[^a-zA-Z0-9]/g, '').slice(-8) : 'anon';
    const safeSheetName = (typeof window.SHEET_NAME !== 'undefined' && window.SHEET_NAME) ?
      window.SHEET_NAME.trim() : 'default';
    this.reactionStorageKey = 'reactions_' + currentUserIdentifier + '_' + safeSheetName;

    this.gas = {
      getPublishedSheetData: (classFilter, sort, adminMode, targetUserId) =>
        this.runGas('getPublishedSheetData', classFilter, sort, adminMode, targetUserId),
      getNotificationUpdate: (targetUserId, options) =>
        this.runGas('getNotificationUpdate', targetUserId, options),
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('addReaction', this.state.userId, rowIndex, reaction),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('toggleHighlight', this.state.userId, rowIndex),
      checkAdmin: () => this.runGas('isAdmin'),
      clearCache: () => this.runGas('clearActiveSheet', this.state.userId),
      validateData: () => this.validData(),
      getDataCount: (classFilter, sortOrder, adminMode) => {
        const rows = this.state.currentAnswers || [];
        return { success: true, count: rows.length };
      }
    };


    this.initializeSimplePolling();

    this.init().catch(error => {
      console.error('âŒ StudyQuestApp: Fatal initialization error:', error);
      this.displayInitializationError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
    });
  }

  initializeSimplePolling() {
    this.polling = {
      isActive: false,
      timerId: null,
      errorCount: 0
    };

    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
      this.elements.sizeSlider.value = savedCols;
      this.elements.sliderValue.textContent = savedCols;
      this.updateSliderBackground(this.elements.sizeSlider);
    }
  }

  resetStateForCleanInit() {

    this.state.allAnswers = [];        // Clear full dataset cache
    this.state.currentAnswers = [];
    this.dismissNewContentBanner();

    const container = this.elements.answersContainer;
    if (container) {
      const existingCards = container.querySelectorAll('.answer-card');
      if (existingCards.length > 0) {
        existingCards.forEach(card => {
          if (this.visibilityObserver) {
            this.visibilityObserver.unobserve(card);
          }
          if (this.scrollObserver) {
            this.scrollObserver.unobserve(card);
          }
        });
        container.innerHTML = '';
      }
    }
    
    
    this.initialDataLoaded = false;
    this.hadInitialDataLoadFailure = false;
    this.lastViewKey = null;
    
    this.contentCheckInProgress = false;
    
    
  }

  async executeWithRetry(operation, options = {}) {
    const {
      maxRetries = 3,
      baseDelay = 1000,
      maxDelay = 10000,
      backoffMultiplier = 2,
      jitter = true,
      retryCondition = () => true,
      context = 'operation'
    } = options;

    let lastError = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await operation(attempt);
        if (attempt > 0) {
        }
        return result;
      } catch (error) {
        lastError = error;

        if (attempt === maxRetries || !retryCondition(error, attempt)) {
          break;
        }

        let delay = Math.min(baseDelay * Math.pow(backoffMultiplier, attempt), maxDelay);

        if (error && error.message && error.message.includes('429')) {
          delay = Math.max(delay, 15000 + (attempt * 10000)); // Start at 15s, add 10s per attempt
        }

        if (jitter) {
          delay = delay * (0.5 + Math.random() * 0.5); // Add 50% jitter
        }

        const safeContext = context || 'Operation';
        if (error && error.message) {
          console.warn(`âš ï¸ ${safeContext} failed (attempt ${attempt + 1}/${maxRetries + 1}): ${error.message}`);
        } else {
          console.warn(`âš ï¸ ${safeContext} failed (attempt ${attempt + 1}/${maxRetries + 1}): Unknown error`);
        }

        await new Promise(resolve => requestIdleCallback(resolve, { timeout: delay }));
      }
    }

    throw lastError;
  }

  async init() {
    try {
      this.resetStateForCleanInit();
      this.setupCriticalElements();
      this.showMinimalSkeleton();
      this.optimizeForLowPerformance();

      this.state.isAdminUser = window.UNIFIED_CONFIG?.isAdminUser || false;

      this.renderIcons(); // é™çš„ã‚¢ã‚¤ã‚³ãƒ³ã®å³åº§èª­ã¿è¾¼ã¿ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’å«ã‚€ï¼‰
      this.showInfoModal(); // ãƒ‡ã‚¸ã‚¿ãƒ«ã‚·ãƒ†ã‚£ã‚ºãƒ³ã‚·ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ«

      try {
        await this.initializeFormButton();

        await this.loadSheetData({ showLoading: false, isInitialLoad: true, bypassCache: false });
      } catch (error) {
        console.error('Data loading failed during initialization:', error);
        this.showInfoModal(); // Show modal even on error
      }

      this.state.initializationComplete = true;
      this.state.isInitializing = false;
      this.hideLoadingOverlay();

      if (this.elements.infoModalConfirmBtn) {
        this.elements.infoModalConfirmBtn.disabled = false;
      }

      this.setupNonCriticalEventListeners();
      this.adjustLayout();
      this.updateSortOptions();
      this.setupObservers();


      this.setupEditorState();


      this.setupMessageListeners();
      
    } catch (error) {
      console.error('âŒ StudyQuestApp: Critical error in init():', error);
      this.handleError(error, 'initialization', true);
      this.hideLoadingOverlay();
    }
  }


  /**
   * âœ… Restore form button display functionality
   * Initialize form button display in the UI
   */
  async initializeFormButton() {
    try {
      await loadFormLink();
    } catch (error) {
      console.warn('âš ï¸ Failed to initialize form button:', error);
    }
  }

  /**
   * âœ… CLAUDE.mdæº–æ‹ : Simplified editor state setup
   */
  setupEditorState() {
    if (window.isEditor) {
      this.state.isEditor = true;
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.remove('hidden');
        this.elements.adminToggleBtn.removeAttribute('hidden');
        this.elements.adminToggleBtn.style.display = '';
      }
    } else {
      this.state.isEditor = false;
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.add('hidden');
        this.elements.adminToggleBtn.setAttribute('hidden', '');
        this.elements.adminToggleBtn.style.display = 'none';
      }
    }
  }

  /**
   * Unified message listener setup
   */
  setupMessageListeners() {
    window.addEventListener('message', (event) => {
      this.handleMessage(event.data);
    });

    if (typeof BroadcastChannel !== 'undefined') {
      const channel = new BroadcastChannel('board-updates');
      channel.addEventListener('message', (event) => {
        this.handleMessage(event.data);
      });
    }
  }

  /**
   * âœ… CLAUDE.mdæº–æ‹ : Unified message handler (no duplicate code)
   */
  async handleMessage(data) {
    if (!data || !data.type) return;

    try {
      switch (data.type) {
        case 'REFRESH_BOARD_DATA':
        case 'BOARD_PUBLISHED':
          await this.loadSheetData({ bypassCache: true });
          this.showInfoModal();
          break;

        case 'FORM_CREATED':
          if (data.formUrl) {
            const formLinkBtn = document.getElementById('form-link-btn');
            if (formLinkBtn) {
              formLinkBtn.href = data.formUrl;
              formLinkBtn.classList.remove('hidden');
            }
          }
          break;
      }
    } catch (error) {
      console.warn('Message handling error:', error);
      try {
        await this.loadSheetData({ bypassCache: true });
        this.showInfoModal();
      } catch (fallbackError) {
        console.error('Fallback data loading failed:', fallbackError);
      }
    }
  }

  setupCriticalElements() {
    if (this.elements.headingLabel) {
      const initialText = window.UNIFIED_CONFIG?.questionText || 'èª­ã¿è¾¼ã¿ä¸­...';
      this.elements.headingLabel.textContent = initialText;
    }

    this.setupEventDelegation();
    this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    const debouncedRender = this.debounce(() => this.renderBoard(true, false), 200);
    this.handlers.onSizeSliderInput = this.throttle((e) => {
      localStorage.setItem('boardColumns', e.target.value);
      this.updateSliderBackground(e.target);
      debouncedRender();
    }, 100); // Throttle to 100ms
    
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, { passive: true });
    }
  }
  
  setupNonCriticalEventListeners() {
    if (this.nonCriticalListenersSetup) {
      return;
    }
    
    this.handlers.onAnswerModalContainerClick = (e) => {
      if (e.target === e.currentTarget) {
        this.hideAnswerModal();
      }
    };
    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn) {
      this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
      this.elements.infoModalConfirmBtn.addEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    this.handlers.onModalReactionClick = (e) => {
      const btn = e.target.closest('.reaction-btn');
      const highlightBtn = e.target.closest('.highlight-btn');
      
      if (highlightBtn) {
        const id = highlightBtn.dataset.rowIndex;
        if (id) {
          this.handleHighlight(id);
        }
      } else if (btn) {
        const id = btn.dataset.rowIndex;
        const reaction = btn.dataset.reaction;
        if (id && reaction) {
          this.addReaction(id, reaction);
        }
      }
    };
    if (this.elements.modalReactionContainer) {
      this.elements.modalReactionContainer.addEventListener('click', this.handlers.onModalReactionClick);
    }
    this.handlers.onClassFilterChange = async () => {
      try {
        const filterState = this.getCurrentFilterState();
        await this.loadSheetData({ bypassCache: true, isInitialLoad: false });

        this.updateLastSeenTimestamp(); // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã¯ç¾åœ¨æ™‚åˆ»ã§åŸºæº–æ›´æ–°
      } catch (error) {
        console.error('ã‚¯ãƒ©ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
    };
    this.handlers.onSortOrderChange = async () => {
      try {
        const filterState = this.getCurrentFilterState();
        await this.loadSheetData({ bypassCache: true, isInitialLoad: false });

        this.updateLastSeenTimestamp(); // ã‚½ãƒ¼ãƒˆå¤‰æ›´æ™‚ã¯ç¾åœ¨æ™‚åˆ»ã§åŸºæº–æ›´æ–°
      } catch (error) {
        console.error('ã‚½ãƒ¼ãƒˆé †å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
    };
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.endPublicationBtn) {
      this.handlers.onEndPublicationClick = () => this.endPublication();
      this.elements.endPublicationBtn.addEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.adminToggleBtn) {
      if (this.handlers.onAdminToggleClick) {
        this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
      }
      this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
      this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
    }
    
    if (this.elements.refreshContentBtn) {
      this.handlers.onRefreshContentClick = async () => {
        try {
          await this.refreshContent();
        } catch (error) {
          console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
        }
      };
      this.elements.refreshContentBtn.addEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn) {
      this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
      this.elements.dismissBannerBtn.addEventListener('click', this.handlers.onDismissBannerClick);
    }
    this.handlers.onDocumentKeydown = (e) => {
      if (e.key === 'Escape') {
        if (this.elements.newContentBanner && !this.elements.newContentBanner.classList.contains('hidden')) {
          this.dismissNewContentBanner();
          e.preventDefault();
          return;
        }
        this.hideAnswerModal();
      }
    };
    document.addEventListener('keydown', this.handlers.onDocumentKeydown);
    this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
    window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
    this.handlers.onVisibilityChange = () => {
      if (document.hidden) {
        this.stopSimplePolling();
        this.cleanup();
      } else if (this.state.initializationComplete) {
        Promise.resolve().then(() => {
          this.startSimplePolling();
        });
      } else {
      }
    };
    document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, { passive: true });

    this.handlers.onActivityDetection = () => {
      this.lastActivityTime = Date.now();
      if (!this.polling.isActive && this.state.initializationComplete) {
        this.startSimplePolling();
      }
    };
    document.addEventListener('click', this.handlers.onActivityDetection, { passive: true });

    if (this.state.initializationComplete && !this.polling.isActive) {
      this.startSimplePolling();
    }

    this.nonCriticalListenersSetup = true;
  }
  /**
 * ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ã®è¨­å®šï¼ˆå®‰å®šç‰ˆã®å …ç‰¢ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æ¡ç”¨ï¼‰
 * ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãŒä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã¨ç«¶åˆã—ãªããªã‚Šã¾ã™ã€‚
 */
  setupEventDelegation() {
    if (this.eventDelegationSetup) {
        return;
    }
    
    this.handlers.onAnswersContainerClick = (e) => {

        const answerCard = e.target.closest('.answer-card');

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
            return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
            return;
        }

        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
            e.stopPropagation(); // â˜…é‡è¦: ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’æ­¢ã‚ã€ã‚«ãƒ¼ãƒ‰æœ¬ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã¨åˆ†é›¢
            if (!reactionBtn.disabled) {
                this.addReaction(rowIndex, reactionBtn.dataset.reaction);
            }
            return;
        }

        const deleteBtn = e.target.closest('.delete-answer-btn');
        if (deleteBtn) {
            e.stopPropagation(); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’æ­¢ã‚ã‚‹
            this.confirmDeleteAnswer(rowIndex);
            return;
        }

        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
            e.stopPropagation(); // â˜…é‡è¦: åŒæ§˜ã«ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
            if (!highlightBtn.disabled) {
                this.handleHighlight(rowIndex);
            }
            return;
        }

        this.showAnswerModal(rowIndex);
    };

    if (this.elements.answersContainer) {
        this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
        this.elements.answersContainer.addEventListener('click', this.handlers.onAnswersContainerClick);
        this.eventDelegationSetup = true;
    } else {
        console.error('No answers container found for event delegation');
    }
  }
  
  adjustLayout() {
    if (this.baseBodyPadding === undefined) {
      this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
    }
    const footerHeight = this.elements.footer.offsetHeight;
    this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
  }
  runGas(funcName, ...args) {
    if (this.activeRequests >= 3) {
      return Promise.reject(new Error('Too many concurrent requests'));
    }

    const mappedArgs = args;

    const cacheKey = funcName + JSON.stringify(mappedArgs);
    const isStateChanging = ['toggleHighlight', 'addReaction'].includes(funcName);

    if (!isStateChanging) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }
    }

    const promise = this.executeWithRetry(async () => {
      this.activeRequests++;
      return new Promise((resolve, reject) => {
        const handleSuccess = (result) => {
          this.activeRequests--;


          if (!isStateChanging && result !== null && result !== undefined) {
            this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
          }
          resolve(result);
        };

        const handleError = (error) => {
          this.activeRequests--;

          if (!isStateChanging && this.cache.has(cacheKey)) {
            this.cache.delete(cacheKey);
          }

          console.error(`âŒ handleError for ${funcName}`, {
            error: error.message || error.toString(),
            errorType: typeof error,
            isEnhanced: !!error.functionName,
            cacheCleared: !isStateChanging,
            timestamp: new Date().toISOString(),
            activeRequests: this.activeRequests
          });

          reject(error);
        };

      if (typeof google !== 'undefined' && google.script && google.script.run) {
        if (!google.script.run[funcName] || typeof google.script.run[funcName] !== 'function') {
          const safeFuncName = funcName || 'unknown';
          handleError(new Error(`API function '${safeFuncName}' not available`));
          return;
        }

          timestamp: new Date().toISOString(),
          userId: this.state.userId,
          argsCount: mappedArgs.length
        });

        google.script.run
          .withSuccessHandler((result) => {

            if (result === null || result === undefined) {
              console.warn(`âš ï¸ runGas: ${funcName} returned null/undefined, treating as error`);
              handleError(new Error(`Function ${funcName} returned null/undefined response`));
              return;
            }

            if (typeof result === 'object' && result.hasOwnProperty('success') && typeof result.success !== 'boolean') {
              console.warn(`âš ï¸ runGas: ${funcName} returned invalid success property:`, result.success);
              result.success = Boolean(result.success);
            }

            handleSuccess(result);
          })
          .withFailureHandler((error) => {
            console.error(`âŒ google.script.run failure for ${funcName}:`, {
              funcName,
              originalArgs: args,
              mappedArgs,
              error,
              timestamp: new Date().toISOString()
            });
            handleError(this.enhanceError(error, funcName, args));
          })
          .withUserObject({ userId: this.state.userId })
          [funcName](...mappedArgs);
      } else {
        console.warn('Google Apps Script environment not detected.');
        this.getMockData(funcName, ...mappedArgs).then((result) => {
          if (!isStateChanging) {
            this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
          }
          resolve(result);
        }).catch(reject);
      }
      });
    }, {
      maxRetries: isStateChanging ? 1 : 2, // State-changing operations get fewer retries
      baseDelay: 500,
      maxDelay: 5000, // Reduced max delay for faster failure
      context: `GAS API (${funcName || 'unknown'})`,
      retryCondition: (error) => {
        // ğŸ”§ CRITICAL FIX: Don't retry on timeout errors
        if (error.message.includes('timeout')) {
          return false;
        }

        const retryableErrors = [
          'network', 'temporarily unavailable',
          'script runtime', 'service invoked'
        ];
        const shouldRetry = retryableErrors.some(errorType =>
          error.message.toLowerCase().includes(errorType)
        );

          error: error.message,
          shouldRetry,
          errorType: retryableErrors.find(e => error.message.toLowerCase().includes(e)) || 'unknown'
        });

        return shouldRetry;
      }
    });

    return promise;
  }

  enhanceError(error, funcName, args) {
    const enhancedError = new Error(error.message || error);
    enhancedError.originalError = error;
    enhancedError.functionName = funcName;
    enhancedError.arguments = args;

    switch (funcName) {
      case 'addReaction':
        enhancedError.userMessage = 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼';
        break;
      case 'toggleHighlight':
        enhancedError.userMessage = 'ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼';
        break;
      default:
        enhancedError.userMessage = 'é€šä¿¡ã‚¨ãƒ©ãƒ¼';
    }

    return enhancedError;
  }
  async verifyEditorAsync() {
    if (window.isEditor) {
      this.state.isEditor = true;
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      return;
    }

    let prevState;
    try {
      const authResult = await this.runGas('checkUserAuthentication');
      const isAdmin = authResult && authResult.isAdministrator;
      if (isAdmin) {
        window.isEditor = true;
        this.state.isEditor = true;
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
      }
    } catch (e) {
      console.error('Admin check failed', e);
    }
  }
  
  updateAdminButtonUI() {
    if (this.elements.adminToggleBtn && this.state.isEditor) {
      this.elements.adminToggleBtn.classList.remove('hidden');
      this.elements.adminToggleBtn.removeAttribute('hidden');


      if (this.state.showAdminFeatures) {
        this.elements.adminToggleBtn.classList.remove('text-gray-500', 'opacity-60');
        this.elements.adminToggleBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
      } else {
        this.elements.adminToggleBtn.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
        this.elements.adminToggleBtn.classList.add('text-gray-500', 'opacity-60');
      }
    } else {
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.add('hidden');
        this.elements.adminToggleBtn.setAttribute('hidden', '');
      }
    }
  }
  
  updateEndPublicationButtonUI() {
    if (this.elements.endPublicationBtn) {
      if (this.state.showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', '');
      }
    }
  }
  
  handleError(error, type = 'general', showUser = false) {

    const errorMsg = error.message || error;


    console.error(`âŒ ${type} error:`, errorMsg);

    if (showUser) {
      this.showNotification(`æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMsg}`, 'error');
    }

    return error;
  }

  clearCache(options = {}) {
    const { includeReactions = false, includeLocalStorage = false } = options;

    try {
      if (this.cache) {
        this.cache.clear();
      }

      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }

      if (includeReactions && this.reactionCache) {
        this.reactionCache.clear();
      }

      if (includeLocalStorage) {
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith('reaction_state_') || key.startsWith('cache_')) {
              localStorage.removeItem(key);
            }
          });
        } catch (lsError) {
          this.handleCacheError('localStorage clear', lsError);
        }
      }

    } catch (error) {
      console.warn('âš ï¸ Cache clear failed:', error.message);
    }
  }
  
  
  async handleInitialContentLoad(currentViewKey) {
    this.lastViewKey = currentViewKey;

    if (this.hadInitialDataLoadFailure) {
      this.updateLastSeenTimestamp();
      return;
    }

    this.updateLastSeenTimestamp();
    this.initialDataLoaded = true;

  }
  
  async handleViewChange(currentViewKey) {
      from: this.lastViewKey,
      to: currentViewKey,
      timestampBasedSystem: true
    });

    this.lastViewKey = currentViewKey;
    this.updateLastSeenTimestamp();
    this.dismissNewContentBanner();
  }
  

  showNewContentBanner(newItemsCount, filterState = null) {
    if (!this.elements.newContentBanner || !newItemsCount || newItemsCount <= 0) {
      return;
    }

    const message = newItemsCount === 1
      ? 'æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ'
      : `${newItemsCount}ä»¶ã®æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ`;

    this.elements.newContentText.textContent = message;
    this.elements.newContentBanner.classList.remove('hidden', 'notification-banner-exit');
    this.elements.newContentBanner.classList.add('notification-banner-enter');

    this.elements.newContentBanner.setAttribute('aria-hidden', 'false');
  }
  
  dismissNewContentBanner() {
    if (!this.elements.newContentBanner) {
      return;
    }

    this.elements.newContentBanner.classList.remove('notification-banner-enter');
    this.elements.newContentBanner.classList.add('notification-banner-exit');
    setTimeout(() => {
      this.elements.newContentBanner.classList.add('hidden');
      this.elements.newContentBanner.setAttribute('aria-hidden', 'true');
    }, 300);
  }


  async refreshContent() {
    try {
      await this.loadSheetData({
        showLoading: true,
        bypassCache: true
      });

      this.updateLastSeenTimestamp(); // æ–°ç€é€šçŸ¥ã®ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²æ­¢

      this.dismissNewContentBanner();

      this.showNotification('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ›´æ–°ã—ã¾ã—ãŸ', 'success');

    } catch (error) {
      console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      this.showNotification('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
    }
  }

  async updateContent(isManualUpdate = false, preloadedTriggerResult = null) {
    if (isManualUpdate) {
      await this.refreshContent();
    } else {
      if (preloadedTriggerResult && preloadedTriggerResult.hasNewContent) {
        const appliedFilterState = preloadedTriggerResult.appliedFilter || this.getCurrentFilterState();
        this.showNewContentBanner(preloadedTriggerResult.newItemsCount, appliedFilterState);
      }
    }
  }


  startSimplePolling() {
    if (this.polling.isActive) return;

    this.polling.isActive = true;
    this.polling.errorCount = 0;

    this.schedulePollingCheck();
  }

  schedulePollingCheck() {
    if (!this.polling.isActive) return;

    const interval = this.getPollingInterval();
    const timeSinceActivity = Date.now() - this.lastActivityTime;

    const isDev = window.location.href.includes('dev');
    if (isDev) {
        interval: `${interval/1000}ç§’`,
        timeSinceActivity: `${Math.round(timeSinceActivity/1000)}ç§’å‰`,
        errorCount: this.polling.errorCount,
        lastSeenTimestamp: this.state.lastSeenTimestamp
      });
    }

    this.polling.timerId = setTimeout(async () => {
      if (!this.polling.isActive) return;

      try {
        const response = await this.runGas('getNotificationUpdate', this.state.userId, {
          lastUpdateTime: this.state.lastSeenTimestamp
        });

        if (response.success && response.hasNewContent) {
          this.showNewContentBanner(response.newItemsCount);
        }

        this.polling.errorCount = 0;

      } catch (error) {
        this.polling.errorCount++;

        console.warn('âŒ é€šçŸ¥ãƒãƒ¼ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', {
          errorCount: `${this.polling.errorCount}/3`,
          errorMessage: error.message,
          errorStack: error.stack?.substring(0, 200) + '...',
          userId: this.state.userId,
          lastSeenTimestamp: this.state.lastSeenTimestamp,
          timestamp: new Date().toISOString()
        });

        if (this.polling.errorCount >= 3) {
          console.error('ğŸ’¥ é€šçŸ¥ãƒãƒ¼ãƒªãƒ³ã‚°: é€£ç¶šã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚5åˆ†é–“åœæ­¢');
          this.stopSimplePolling();
          setTimeout(() => {
            this.startSimplePolling();
          }, 300000);
          return;
        }
      }

      this.schedulePollingCheck();
    }, interval);
  }

  stopSimplePolling() {
    this.polling.isActive = false;
    if (this.polling.timerId) {
      clearTimeout(this.polling.timerId);
      this.polling.timerId = null;
    }
  }

  getPollingInterval() {
    const timeSinceActivity = Date.now() - this.lastActivityTime;

    if (timeSinceActivity < 60000) return 15000;      // 1åˆ†ä»¥å†…: 15ç§’
    if (timeSinceActivity < 300000) return 30000;     // 5åˆ†ä»¥å†…: 30ç§’
    if (timeSinceActivity < 900000) return 120000;    // 15åˆ†ä»¥å†…: 2åˆ†
    return 300000;                                     // 15åˆ†è¶…: 5åˆ†
  }

  hasRecentActivity() {
    return (Date.now() - this.lastActivityTime) < 300000; // 5 minutes
  }





  showNotification(message, type = 'info', options = {}) {
    if (window.notifications) {
      const duration = options.duration || 5000;
      window.notifications[type] ?
        window.notifications[type](message, duration) :
        window.notifications.info(message, duration);
    }
  }

  
  getMockData(funcName, ...args) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const mockDelay = 300;
      const checkComplete = () => {
        if (Date.now() - startTime >= mockDelay) {
        if (funcName === 'getPublishedSheetData') {
          const currentDisplayMode = window.displayMode || this.state.displayMode;
          const studentName1 = currentDisplayMode === 'named' ? 'ç”°ä¸­å¤ªéƒ' : '';
          const studentName2 = currentDisplayMode === 'named' ? 'ä½è—¤èŠ±å­' : '';
          resolve({
            header: 'ãƒ†ã‚¹ãƒˆå•é¡Œ',
            sheetName: 'ãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒˆ',
            data: [
              {
                rowIndex: 1,
                name: studentName1,
                class: '3å¹´Açµ„',
                opinion: 'ã“ã‚Œã¯ç´ æ™´ã‚‰ã—ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã ã¨æ€ã„ã¾ã™ã€‚',
                reason: 'ç†ç”±ã¯ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ãã€å®Ÿç¾å¯èƒ½æ€§ãŒé«˜ã„ã‹ã‚‰ã§ã™ã€‚',
                reactions: {
                  UNDERSTAND: { count: 5, reacted: false },
                  LIKE: { count: 2, reacted: false },
                  CURIOUS: { count: 1, reacted: false }
                },
                highlight: false
              },
              {
                rowIndex: 2,
                name: studentName2,
                class: '3å¹´Bçµ„',
                opinion: 'å°‘ã—æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚‹ã¨è€ƒãˆã¾ã™ã€‚',
                reason: 'ã‚ˆã‚Šå¤šãã®äººã®æ„è¦‹ã‚’èãå¿…è¦ãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚',
                reactions: {
                  UNDERSTAND: { count: 3, reacted: true },
                  LIKE: { count: 0, reacted: false },
                  CURIOUS: { count: 0, reacted: false }
                },
                highlight: true
              }
            ]
          });
        } else if (funcName === 'addReaction') {
          resolve({
            status: 'ok',
            reactions: {
              UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
            }
          });
        } else if (funcName === 'toggleHighlight') {
          const currentHighlight = args[2] === undefined ? false : !args[2];
          resolve({
            status: 'ok',
            highlight: currentHighlight
          });
        } else if (funcName === 'checkAdmin' || funcName === 'isAdmin') {
          resolve(true);
        }
        } else {
          Promise.resolve().then(checkComplete);
        }
      };
      checkComplete();
    });
  }
  cleanup(options = {}) {
    const {
      includeCache = true,
      includeDOMReferences = true,
      includeEventListeners = true,
      includeVirtualScroll = true,
      includeDOMFragments = true
    } = options;

    try {
      if (includeCache && this.cache) {
        const cacheSize = (typeof this.cache.size === 'function') ? this.cache.size() : 'unknown';

        if (typeof this.cache.cleanup === 'function') {
          this.cache.cleanup();
        } else if (typeof this.cache.clear === 'function') {
          this.cache.clear();
        }

      }

      if (includeDOMReferences) {
        const elementsToCheck = ['answersContainer', 'loadingOverlay', 'newContentBanner'];
        elementsToCheck.forEach(key => {
          const element = this.elements[key];
          if (element && !document.contains(element)) {
            delete this.elements[key];
          }
        });
      }

      if (includeEventListeners) {
        if (this.handlers) {
          Object.keys(this.handlers).forEach(key => {
            if (typeof this.handlers[key] !== 'function') {
              delete this.handlers[key];
            }
          });
        }

      }

      if (includeVirtualScroll && this.virtualScrollState?.renderedRowIndexes) {
        const size = this.virtualScrollState.renderedRowIndexes.size;
        if (size > 1000) {
          this.virtualScrollState.renderedRowIndexes.clear();
          this.virtualScrollState.renderedItems = 0;
        }
      }

      if (includeDOMFragments && this.domFragmentPool) {
        this.domFragmentPool.length = 0;
      }

    } catch (error) {
      console.warn('âš ï¸ Cleanup failed:', error.message || error);
    }
  }

  
  

  destroy() {

    this.stopSimplePolling();


    this.cleanup();

    
    if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
      this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
    }
    if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
      this.elements.answerModalCloseBtn.removeEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
      this.elements.answerModalContainer.removeEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
      this.elements.infoModalConfirmBtn.removeEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
      this.elements.modalReactionContainer.removeEventListener('click', this.handlers.onModalReactionClick);
    }
    if (this.elements.classFilter && this.handlers.onClassFilterChange) {
      this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
      this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
      this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
    }
    if (this.handlers.onDocumentKeydown) {
      document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
    }
    if (this.handlers.onWindowResize) {
      window.removeEventListener('resize', this.handlers.onWindowResize);
    }
    if (this.handlers.onVisibilityChange) {
      document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
    }
    if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
      this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
    }
    if (this.handlers.onDocumentClick) {
      document.removeEventListener('click', this.handlers.onDocumentClick);
    }
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
      this.elements.refreshContentBtn.removeEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
      this.elements.dismissBannerBtn.removeEventListener('click', this.handlers.onDismissBannerClick);
    }
    if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
      this.elements.endPublicationBtn.removeEventListener('click', this.handlers.onEndPublicationClick);
    }
    
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    
    this.cache.clear();
    this.deferredUpdates.clear();
    this.domFragmentPool.length = 0;
    
  }

  /**
   * Validate essential prerequisites for app initialization
   * @returns {boolean} true if all prerequisites are met
   */

  /**
   * åˆ¶é™æ©Ÿèƒ½ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–
   */
  enableLimitedFunctionalityMode() {
    this.isLimitedMode = true;

    if (this.elements.answersContainer) {
      this.elements.answersContainer.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-limited-mode="true">
          <svg class="mx-auto h-12 w-12 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-blue-400">åˆ¶é™æ©Ÿèƒ½ãƒ¢ãƒ¼ãƒ‰</h3>
          <p class="mt-1 text-sm text-gray-400">ä¸€éƒ¨ã®æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚URLã‚’ç¢ºèªã—ã¦ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</p>
          <div class="mt-6">
            <button
              onclick="window.safeReload()"
              class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
            >
              ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
            </button>
          </div>
        </div>
      `;
    }

    if (this.elements.headingLabel) {
      this.elements.headingLabel.textContent = 'åˆ¶é™æ©Ÿèƒ½ãƒ¢ãƒ¼ãƒ‰';
    }
  }

  /**
   * Display initialization error to user
   * @param {string} message - Error message to display
   */
  displayInitializationError(message) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${window.sharedUtilities.security.escapeHtml(message)}</p>
        <div class="mt-6">
          <button 
            onclick="window.safeReload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Display data loading error to user
   * @param {string} message - Error message to display
   */
  displayDataLoadError(message, result = null) {
    const container = this.elements.answersContainer;
    if (!container) return;

    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-yellow-400">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${window.sharedUtilities.security.escapeHtml(message)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.safeReload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
          <button 
            onclick="window.studyQuestApp && window.studyQuestApp.loadSheetData({ bypassCache: true, isInitialLoad: true })" 
            class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
          >
            å†è©¦è¡Œ
          </button>
        </div>
      </div>
    `;
  }
  
  
  showMinimalSkeleton() {
    const count = 2;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      frag.appendChild(this.createSkeletonCard());
    }
    this.elements.answersContainer.appendChild(frag);
  }

  manageEmptyState(action = 'show', options = {}) {
    const {
      safeCheck = false,
      includeFormUrl = true
    } = options;

    const container = this.elements.answersContainer;
    if (!container) return;

    switch (action) {
      case 'show':
        if (safeCheck) {
          const existingCards = container.querySelectorAll('.answer-card');
          if (existingCards.length > 0 ||
              (this.state.currentAnswers && this.state.currentAnswers.length > 0) ||
              this.state.isLoading) {
            return;
          }
        }

        this.renderEmptyStateContent(includeFormUrl);
        break;

      case 'remove':
        const banner = container.querySelector('[data-empty-state="true"]');
        if (banner) {
          banner.remove();
        }
        break;
    }
  }

  async renderEmptyStateContent(includeFormUrl = true) {
    const container = this.elements.answersContainer;

    try {
      let formLinkHtml = '';

      if (includeFormUrl) {
        const formUrl = await this.getFormUrlForEmptyState();
        formLinkHtml = formUrl ?
          `<div class="mt-6">
            <a href="${window.sharedUtilities.security.escapeHtml(formUrl)}" target="_blank"
               class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-pink-600 hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pink-500 transition-colors duration-200">
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              å›ç­”ãƒ•ã‚©ãƒ¼ãƒ ã«è¨˜å…¥ã™ã‚‹
            </a>
          </div>` :
          `<div class="mt-4"><p class="text-sm text-gray-500">å›ç­”ãƒ•ã‚©ãƒ¼ãƒ ã®æº–å‚™ä¸­ã§ã™...</p></div>`;
      }

      container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">ã¾ã å›ç­”ãŒã‚ã‚Šã¾ã›ã‚“</h3>
          <p class="mt-1 text-sm text-gray-400">ã‚ãªãŸãŒæœ€åˆã®å›ç­”è€…ã«ãªã£ã¦ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼</p>
          ${formLinkHtml}
        </div>
      `;
    } catch (error) {
      console.warn('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">ã¾ã å›ç­”ãŒã‚ã‚Šã¾ã›ã‚“</h3>
          <p class="mt-1 text-sm text-gray-400">ã‚ãªãŸãŒæœ€åˆã®å›ç­”è€…ã«ãªã£ã¦ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼</p>
        </div>
      `;
    }
  }

  async getFormUrlForEmptyState() {
    try {
      const result = await this.runGas('getActiveFormInfo', this.state.userId);
      return (result && result.shouldShow) ? result.formUrl : null;
    } catch (error) {
      console.error('âŒ ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }
  }

  displayEmptyState() {
    this.manageEmptyState('show');
  }

  removeEmptyState() {
    this.manageEmptyState('remove');
  }

  safeDisplayEmptyState() {
    this.manageEmptyState('show', { safeCheck: true });
  }
  
  async clearAllCardsForEmptyData() {
    const isFirstTime = this.isFirstTimeBoardAccess();
    
    this.state.currentAnswers = [];
    
    const container = this.elements.answersContainer;
    if (container) {
      const existingCards = container.querySelectorAll('.answer-card');
      
      if (existingCards.length > 0) {
        
        existingCards.forEach(card => {
          if (this.visibilityObserver) {
            this.visibilityObserver.unobserve(card);
          }
          if (this.scrollObserver) {
            this.scrollObserver.unobserve(card);
          }
        });
        
        container.innerHTML = '';
        
        await new Promise(resolve => requestAnimationFrame(resolve));
      }
    }
    
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
  }
  
  async validatePostLoadState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const domCards = container.querySelectorAll('.answer-card');
    const dataLength = this.state.currentAnswers ? this.state.currentAnswers.length : 0;
    
    
    if (dataLength === 0 && domCards.length > 0) {
      console.warn('âš ï¸ çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: ç©ºãƒ‡ãƒ¼ã‚¿ãªã®ã«DOMã«', domCards.length, 'å€‹ã®ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã¾ã™');
      
      await this.clearAllCardsForEmptyData();
      
      this.displayEmptyState();
      
      
    } else if (dataLength !== domCards.length) { // æ•°ã®ä¸ä¸€è‡´ã‚‚ä¸æ•´åˆã¨ã¿ãªã™

      this.renderBoard(false, false);
      
    } else {
    }
  }

  hasRelevantLocalStorage() {
    const userId = this.state?.userId || window.USER_ID;
    const sheetName = window.SHEET_NAME;

    return {
      hasLastSeen: localStorage.getItem(`lastSeenTimestamp_${userId}_${sheetName}`) !== null,
      hasDiffCards: localStorage.getItem(`differentialCards_${userId}_${sheetName}`) !== null
    };
  }


  
  async forceDataRefresh() {

    const preservedLastSeenTimestamp = this.state.lastSeenTimestamp;

    if (this.cache) {
      this.cache.clear();
    }

    try {
    } catch (error) {
      console.warn('âš ï¸ ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã§ã‚¨ãƒ©ãƒ¼:', error);
    }

    await this.loadSheetData({ bypassCache: true });

    this.updateLastSeenTimestamp();
      preservedTimestamp: preservedLastSeenTimestamp,
      newTimestamp: this.state.lastSeenTimestamp,
      currentAnswersLength: this.state.currentAnswers.length,
      timestampBasedSystem: true
    });
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœã®æœ‰åŠ¹æ€§ã‚’åˆ¤å®š
   * @param {object} result - ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”
   * @returns {boolean} æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹
   */
  isValidDataResult(result) {
    try {
      if (!result || typeof result !== 'object') {
        return false;
      }
           
      const hasStatusField = 'status' in result;
      
      if (hasStatusField && result.status !== 'success') {
        return false;
      }
      
      if (!Array.isArray(result.data)) {
        return false;
      }
      
      if (result.header && typeof result.header !== 'string') {
        return false;
      }
      
      if (result.sheetName && typeof result.sheetName !== 'string') {
        return false;
      }
      
      
      return true;
    } catch (error) {
      console.warn('âš ï¸ ãƒ‡ãƒ¼ã‚¿åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
      return false;
    }
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼å¤±æ•—ã®ç†ç”±ã‚’å–å¾—
   * @param {object} result - æ¤œè¨¼å¯¾è±¡ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   * @returns {string} å¤±æ•—ç†ç”±
   */
  getFailureReason(result) {
    if (!result) {
      return 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒnull/undefined';
    }
    if (typeof result !== 'object') {
      return `ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„ (${typeof result})`;
    }
    
    const hasStatusField = 'status' in result;
    if (hasStatusField && result.status !== 'success') {
      return `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæˆåŠŸã§ã¯ãªã„ (${result.status})`;
    }
    
    if (!('data' in result)) {
      return 'dataãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ãªã„';
    }
    if (!Array.isArray(result.data)) {
      return `dataãŒé…åˆ—ã§ã¯ãªã„ (${typeof result.data})`;
    }
    
    if (result.header && typeof result.header !== 'string') {
      return `ãƒ˜ãƒƒãƒ€ãƒ¼ã®å‹ãŒä¸æ­£ (${typeof result.header})`;
    }
    if (result.sheetName && typeof result.sheetName !== 'string') {
      return `ã‚·ãƒ¼ãƒˆåã®å‹ãŒä¸æ­£ (${typeof result.sheetName})`;
    }
    
    return 'ä¸æ˜ãªæ¤œè¨¼å¤±æ•—';
  }

  /**
   * ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆè¤‡é›‘ãªãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯å‰Šé™¤ï¼‰
   * @param {object} fetchParams - ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
   * @param {boolean} isInitialLoad - åˆæœŸãƒ­ãƒ¼ãƒ‰ã‹ã©ã†ã‹
   * @returns {Promise} ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœ
   */
  async getUserData(fetchParams, isInitialLoad) {
    if (fetchParams.showAdminFeatures == null || fetchParams.showAdminFeatures === undefined) {
      fetchParams.showAdminFeatures = window.UNIFIED_CONFIG?.isAdminUser || this.state?.isAdminUser || false;
    }

    try {
      let result;

      if (fetchParams.userId) {
        result = await this.runGas('getPublishedSheetData',
          fetchParams.classFilter,
          fetchParams.sortOrder,
          fetchParams.showAdminFeatures || false,  // adminMode
          fetchParams.userId  // targetUserIdï¼ˆã‚¯ãƒ­ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ï¼‰
        );
      } else {
        result = await this.runGas('getPublishedSheetData',
          fetchParams.classFilter,
          fetchParams.sortOrder,
          fetchParams.showAdminFeatures || false,  // adminMode
          null  // null for self-access
        );
      }

      if (result && result.success && Array.isArray(result.data)) {
        if (result.displaySettings) {
          this.updateDisplaySettingsFromAPI(result.displaySettings);
        }
        return result;
      }

      if (result && result.error) {
        const errorMessage = (result.error && typeof result.error === 'string') ? result.error : 'Unknown backend error';

        if (errorMessage.includes('timeout') || errorMessage.includes('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')) {
          console.warn('getUserData: Timeout detected');
          return {
            success: false,
            error: 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚',
            errorType: 'timeout_error',
            data: [],
            header: 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
          };
        }

        console.warn('getUserData: Backend returned error:', errorMessage);
        return {
          success: false,
          error: errorMessage,
          errorType: 'backend_error',
          data: [],
          header: (result.header && typeof result.header === 'string') ? result.header : 'ã‚¨ãƒ©ãƒ¼'
        };
      }

      console.warn('getUserData: Invalid response format:', result);
      return {
        success: false,
        error: 'ãƒ‡ãƒ¼ã‚¿å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“',
        errorType: 'format_error',
        data: [],
        header: 'ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼'
      };

    } catch (error) {
      let errorInfo;
      if (error && error.message) {
        errorInfo = `Error: ${error.message}`;
        console.error('getUserData error:', errorInfo);
      } else {
        errorInfo = 'ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
        console.error('getUserData error: Unknown error occurred');
      }

      return {
        success: false,
        error: errorInfo,
        errorType: 'network_error',
        data: [],
        header: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼'
      };
    }
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ç”»é¢ã‚’è¡¨ç¤º
   * @param {string} errorMessage - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   */
  displayUserNotFoundError(errorMessage) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const isUserNotFoundError = errorMessage && (
      errorMessage.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“') || 
      errorMessage.includes('ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    );
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">${isUserNotFoundError ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : 'ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼'}</h3>
        <p class="mt-1 text-sm text-gray-400">${isUserNotFoundError ? 
          'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã¯å­˜åœ¨ã—ãªã„ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒä¸æ­£ã§ã™' : 
          'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“'}</p>
        ${isUserNotFoundError ? `
        <div class="mt-4 p-4 bg-blue-900/20 border border-blue-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-blue-400 mb-2">ğŸ” è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ URLã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œ</li>
            <li>â€¢ ãƒœãƒ¼ãƒ‰ãŒå‰Šé™¤ã•ã‚ŒãŸã‹éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã•ã‚ŒãŸ</li>
            <li>â€¢ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«ä¸€æ™‚çš„ãªå•é¡Œ</li>
            <li>â€¢ ã‚µãƒ¼ãƒãƒ¼å´ã®æ¨©é™è¨­å®šã«å•é¡Œ</li>
            <li>â€¢ ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ãŒç ´æ</li>
          </ul>
        </div>
        <div class="mt-4 p-4 bg-green-900/20 border border-green-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-green-400 mb-2">ğŸ’¡ è§£æ±ºæ–¹æ³•ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ ã¾ãšãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ­£ã—ã„ãƒœãƒ¼ãƒ‰URLã‚’ç®¡ç†è€…ã«ç¢ºèª</li>
            <li>â€¢ 5-10åˆ†å¾…ã£ã¦ã‹ã‚‰å†åº¦ã‚¢ã‚¯ã‚»ã‚¹</li>
            <li>â€¢ åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§è©¦ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ–°ã—ã„å›ç­”ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹</li>
          </ul>
        </div>
        <div class="mt-4 p-3 bg-yellow-900/20 border border-yellow-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-yellow-400 mb-2">ğŸ› ï¸ è‡ªå‹•ä¿®å¾©ï¼š</h4>
          <p class="text-xs text-gray-400">ã‚·ã‚¹ãƒ†ãƒ ã¯è‡ªå‹•çš„ã«å•é¡Œã®ä¿®å¾©ã‚’è©¦è¡Œã—ã¦ã„ã¾ã™ã€‚æ•°åˆ†å¾Œã«å†åº¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨è§£æ±ºã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
        </div>` : ''}
        <p class="mt-2 text-xs text-gray-500">ã‚¨ãƒ©ãƒ¼è©³ç´°: ${window.sharedUtilities.security.escapeHtml(errorMessage)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.safeReload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800"
          >
            <svg class="-ml-1 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
    
  }

  showLoadingOverlay(message = '') {
    document.body.classList.add('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.add('loading-active');
      if (this.elements.answersContainer.classList.contains('render-optimized')) {
        this.elements.answersContainer.classList.add('loading-safe');
      }
    }
  }

  hideLoadingOverlay() {
    document.body.classList.remove('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.remove('loading-active');
      this.elements.answersContainer.classList.remove('loading-safe');
    }
  }

  async loadSheetData(options = {}) {
    const config = {
      showLoading: options.showLoading !== false, // default true
      bypassCache: options.bypassCache || false,
      isInitialLoad: options.isInitialLoad || false,
      requestedSheetName: options.requestedSheetName || null,
      ...options
    };

    if (config.isInitialLoad && options.bypassCache === undefined) {
      config.bypassCache = false;
    } else if (config.isInitialLoad && options.bypassCache === true) {
      config.bypassCache = true;
    }
    
    if (this.state.isLoading && config.showLoading) {
      return Promise.resolve(); // Return resolved Promise to prevent hanging .then() chains
    }
    
    try {
      this.state.isLoading = true;
      if (config.showLoading) {
        this.showLoadingOverlay();
      }
      
      const oldAnswers = [...this.state.currentAnswers];
      
      if (config.bypassCache || this.shouldClearCache(config)) {
        this.clearCache({ includeReactions: true, includeLocalStorage: config.bypassCache && config.isInitialLoad });
      }
      
      await this.performDataLoad(config, oldAnswers);

    } catch (error) {
      console.error('âŒ loadSheetData error:', error);
      this.handleError(error, 'data_load', true);
    } finally {
      this.state.isLoading = false;
      this.hideLoadingOverlay();

      if (config.preserveAdminMode) {
        this.state.showAdminFeatures = true;
        this.updateAdminButtonUI();
      }
    }
  }
  
  shouldClearCache(config) {
    return config.showLoading && !config.isInitialLoad;
  }
  

  
  async performDataLoad(config, oldAnswers) {
    try {
      const loadConfig = this.buildLoadConfiguration(config);
      this.showLoadingState(loadConfig);

      const fetchParams = this.prepareFetchParameters(loadConfig);

      const result = await this.getUserData(fetchParams, loadConfig.isInitialLoad);

      if (!result || !result.success) {
        this.handleError(new Error(result?.error || 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'), 'api', true);
        return;
      }

      const responseData = result.data || [];

      this.state.currentAnswers = responseData;


      if (result.header && this.elements.headingLabel) {
        this.elements.headingLabel.textContent = result.header;
      }

      await this.renderBoard(false, loadConfig.isInitialLoad, oldAnswers);

      if (loadConfig.isInitialLoad) {
        this.populateClassFilter(this.state.currentAnswers);
      }

    } catch (error) {
      this.handleError(error, 'data_load', true);
    }
  }

  buildLoadConfiguration(config) {
    const isInitialLoad = config.isInitialLoad;
    const filterState = isInitialLoad ?
      { rawClassFilter: 'ã™ã¹ã¦', classFilter: null, sortOrder: 'newest' } :
      this.getCurrentFilterState();


    return {
      isInitialLoad,
      requestedSheetName: config.requestedSheetName,
      selectedClass: filterState.rawClassFilter,
      sortOrder: filterState.sortOrder,
      showLoading: config.showLoading,
      bypassCache: config.bypassCache || false
    };
  }

  showLoadingState(config) {
    if (config.showLoading && !config.isInitialLoad) {
      const count = Math.min(parseInt(this.elements.sizeSlider.value, 10), 4);
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      const container = this.elements.answersContainer;
      container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      container.innerHTML = '';
      container.appendChild(frag);
    }
  }

  prepareFetchParameters(config) {
    const classFilter = !config.selectedClass || config.selectedClass === 'ã™ã¹ã¦' ?
      null : config.selectedClass;

    const params = {
      userId: this.state.userId,
      classFilter,
      sortOrder: config.sortOrder,
      showAdminFeatures: this.state.showAdminFeatures,
      requestedSheetName: config.requestedSheetName,
      bypassCache: config.bypassCache || false
    };

    return params;
  }

  
  clearVirtualScrollingState() {
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
      this.scrollObserver = null;
    }
    
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
  }

  
  populateClassFilter(rows) {
    const classFilter = this.elements.classFilter;
    const uniqueClasses = ['ã™ã¹ã¦', ...new Set(Array.isArray(rows) ? rows.map(r => r.class).filter(Boolean) : [])];
    classFilter.innerHTML = uniqueClasses.map(c => '<option value="' + window.sharedUtilities.security.escapeHtml(c) + '">' + window.sharedUtilities.security.escapeHtml(c) + '</option>').join('');
    classFilter.value = 'ã™ã¹ã¦';
    classFilter.classList.remove('hidden');
  }
  
  applyReactionStyles(element, data) {
    if (!element || !data || !(element instanceof HTMLElement)) return;
    
    const reactionClasses = [
      'reaction-bg-like', 'reaction-bg-understand', 'reaction-bg-curious',
      'reaction-bg-like-understand', 'reaction-bg-like-curious', 'reaction-bg-understand-curious',
      'reaction-bg-like-understand-curious', 'reaction-border-1', 'reaction-border-2', 'reaction-border-3',
      'highlighted'
    ];
    reactionClasses.forEach(cls => element.classList.remove(cls));
    
    if (data.highlight) {
      element.classList.add('highlighted');
      return;
    } else {
    }
    
    const active = this.reactionTypes.filter(rt => 
      data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
    ).map(rt => rt.key);
    
    if (active.length === 1) {
      if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
      else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
      else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
    } else if (active.length === 2) {
      const sorted = active.sort();
      if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE') element.classList.add('reaction-bg-like-curious');
      else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-like-understand');
      else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-understand-curious');
    } else if (active.length === 3) {
      element.classList.add('reaction-bg-like-understand-curious');
    }
    
    const totalReactions = this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
    if (totalReactions >= 10) {
      element.classList.add('reaction-border-3');
    } else if (totalReactions >= 5) {
      element.classList.add('reaction-border-2');
    } else if (totalReactions > 0) {
      element.classList.add('reaction-border-1');
    }
  }

  calculateReactionScore(reactions) {
    if (!reactions) return 0;
    return Object.values(reactions).reduce((total, reaction) => {
      return total + (reaction?.count || 0);
    }, 0);
  }

  getCurrentFilterState() {
    const classFilter = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
    const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';

    return {
      classFilter: classFilter === 'ã™ã¹ã¦' ? null : classFilter,
      sortOrder,
      rawClassFilter: classFilter // Keep original for UI purposes
    };
  }


  async renderBoard(isLayoutChange = false, isInitialLoad = false, oldRows = []) {
    try {
      const newRows = this.state.currentAnswers;


      if (!newRows || newRows.length === 0) {
        await this.renderEmptyState();
        return;
      }
      

      this.prepareRenderingState(newRows);
      
      this.performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad);
      
      this.finalizeRenderingState();

      requestIdleCallback(() => {
        this.validatePostLoadState();
      }, { timeout: 300 });
      
    } catch (error) {
      console.error('âŒ renderBoard: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
      this.handleRenderingError(error);
    }
  }
  
  async renderEmptyState() {
    await this.clearAllCardsForEmptyData();
    this.displayEmptyState();
  }
  
  prepareRenderingState(newRows) {
    const container = this.elements.answersContainer;
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    
    this.updateLayoutControls(newRows);
  }
  
  updateLayoutControls(newRows) {
    const updates = [];
    if (this.elements.sliderValue && this.elements.sizeSlider &&
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value) {
      updates.push(() => this.elements.sliderValue.textContent = this.elements.sizeSlider.value);
    }
    if (this.elements.sizeSlider) {
      const className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      if (this.elements.answersContainer.className !== className) {
        updates.push(() => this.elements.answersContainer.className = className);
      }
    }
    if (this.elements.answerCount) {
      const countHtml = this.getIcon('users', 'w-4 h-4 inline-block -mt-1') + '<span>' + newRows.length + 'ä»¶</span>';
      if (this.elements.answerCount.innerHTML !== countHtml) {
        updates.push(() => this.elements.answerCount.innerHTML = countHtml);
      }
    }

    this.batchDOMUpdates(updates);
  }
  
  performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad) {
    const container = this.elements.answersContainer;

    const existingMap = new Map();
    container.querySelectorAll('.answer-card').forEach(card => {
      existingMap.set(card.dataset.rowIndex, card);
    });

    existingMap.forEach((card, id) => {
      if (!newRows.some(r => String(r.rowIndex) === id)) {
        card.remove();
        existingMap.delete(id);
      }
    });

    container.innerHTML = '';

    if (newRows.length > window.RENDER_BATCH_SIZE) {
      this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad);
    } else {
      this.renderDirectly(newRows, oldRows, container, existingMap);
    }
  }
  
  renderDirectly(newRows, oldRows, container, existingMap) {
    const fragment = this.getReusableFragment();


    let cardsCreated = 0;
    let cardsReused = 0;
    let cardsFailed = 0;

    newRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

      if (!card) {
        card = this.createAnswerCard(row);
        if (card) {
          card.classList.add('new-card');
          fragment.appendChild(card);
          cardsCreated++;
        } else {
          cardsFailed++;
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        this.updateAnswerCard(card, row, oldData);
        cardsReused++;
      }
    });

    if (fragment.children.length > 0) {
      container.appendChild(fragment);
    }
  }
  
  calculateVisibleRange(totalItems) {
    const container = this.elements.answersContainer;
    if (!container) {
      console.warn('calculateVisibleRange: answersContainer not found.');
      return { startIndex: 0, endIndex: totalItems };
    }

    if (!container.offsetParent && container.offsetHeight === 0) {
      requestAnimationFrame(() => {
        const retryHeight = container.clientHeight;
        if (retryHeight > 0) {
        }
      });
      return { startIndex: 0, endIndex: totalItems };
    }

    const scrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    const cardHeight = 150; // ä»®ã®ã‚«ãƒ¼ãƒ‰ã®é«˜ã•ã€‚å®Ÿéš›ã®CSSã«åŸºã¥ã„ã¦èª¿æ•´ãŒå¿…è¦ã€‚

    let startIndex = 0;
    let endIndex = totalItems;

    if (containerHeight > 0) {
      startIndex = Math.floor(scrollTop / cardHeight);
      endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight));
    } else {
      return { startIndex: 0, endIndex: totalItems };
    }

    return { startIndex, endIndex };
  }

  renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad) {

    if (isInitialLoad || this.state.currentAnswers.length === 0) {
      this.clearVirtualScrollingState();
    }

    const fragment = this.getReusableFragment();
    const visibleRange = this.calculateVisibleRange(newRows.length);
    const visibleRows = newRows.slice(visibleRange.startIndex, visibleRange.endIndex);

    visibleRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

      if (!card) {
        card = this.createAnswerCard(row);
        if (card) {
          fragment.appendChild(card);
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        this.updateAnswerCard(card, row, oldData);
      }
    });

    if (fragment.children.length > 0) {
      container.appendChild(fragment);
    }
  }
  
  shouldUpdateCard(newData, oldData) {
    if (!oldData) return true;

    const newReactionCount = this.reactionTypes.reduce((sum, rt) =>
      sum + (newData.reactions?.[rt.key]?.count || 0), 0);
    const oldReactionCount = this.reactionTypes.reduce((sum, rt) =>
      sum + (oldData.reactions?.[rt.key]?.count || 0), 0);

    return newReactionCount !== oldReactionCount ||
           newData.highlight !== oldData.highlight ||
           newData.opinion !== oldData.opinion ||
           newData.reason !== oldData.reason ||
           newData.name !== oldData.name;
  }
  
  finalizeRenderingState() {
    this.updateAnswerCount();
    this.applyAnimations();
  }

  updateAnswerCount() {
    if (!this.elements.answerCount) return;

    const count = Array.isArray(this.state.currentAnswers)
      ? this.state.currentAnswers.length
      : 0;
    const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
    this.elements.answerCount.innerHTML =
      userIcon + '<span>' + count + 'ä»¶</span>';
  }

  applyAnimations() {
    if (!this.elements.answersContainer) return;

    const newCards =
      this.elements.answersContainer.querySelectorAll('.new-card');
    newCards.forEach(card => {
      requestAnimationFrame(() => {
        card.classList.remove('new-card');
      });
    });
  }
  
  handleRenderingError(error) {
    console.error('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', error);
    
    try {
      const container = this.elements.answersContainer;
      container.innerHTML = `
        <div class="text-center py-8 col-span-full">
          <p class="text-red-400">è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>
          <button onclick="window.safeReload()" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded">
            å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      `;
    } catch (fallbackError) {
      console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºã‚‚å¤±æ•—:', fallbackError);
    }
  }
  
  updateAnswerCard(card, newData, oldData) {
    if (!card || !newData) return;

    try {
      const oldHasReason = oldData && oldData.reason && oldData.reason.trim();
      const newHasReason = newData.reason && newData.reason.trim();

      if (oldHasReason !== newHasReason) {
        const newCard = this.createAnswerCard(newData);
        if (newCard && card.parentNode) {
          card.parentNode.replaceChild(newCard, card);
        }
        return;
      }

      if (!oldData || oldData.opinion !== newData.opinion) {
        const opinionElement = card.querySelector('.opinion-text');
        if (opinionElement) {
          opinionElement.textContent = newData.opinion || '';
        }
      }

      if (newHasReason && (!oldData || oldData.reason !== newData.reason)) {
        const reasonElement = card.querySelector('.answer-preview p');
        if (reasonElement) {
          reasonElement.textContent = newData.reason;
        }
      }

      if (!oldData || oldData.name !== newData.name) {
        const nameElement = card.querySelector('.font-bold');
        if (nameElement) {
          nameElement.textContent = newData.name || '';
        }
      }
      
      this.updateCardReactions(card, newData);
      
      this.updateCardHighlight(card, newData);
      
    } catch (error) {
      console.error('updateAnswerCard error:', error);
    }
  }
  

  updateCardReactions(card, data) {

    const reactionContainer = card.querySelector('.reaction-container');
    if (!reactionContainer) {
      return;
    }

    const updates = [];
    
    this.reactionTypes.forEach(reactionType => {
      const newCount = data.reactions?.[reactionType.key]?.count || 0;
      const reacted = data.reactions?.[reactionType.key]?.reacted || false;

      updates.push({
        rowIndex: data.rowIndex,
        reaction: reactionType.key,
        count: newCount,
        reacted,
        shouldDisplay: true  // âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã¯å¸¸ã«è¡¨ç¤ºï¼ˆUIä¸€è²«æ€§ã®ãŸã‚ï¼‰
      });
    });

    this.batchUpdateReactionButtons(updates, { immediate: true });
    this.updateCardReactionBackground(card, data);
  }

  batchUpdateReactionButtons(updates, options = {}) {
    const { immediate = false } = options;

    const executeUpdate = () => {
      try {
        updates.forEach(update => {
          const buttons = document.querySelectorAll(`[data-row-index="${update.rowIndex}"][data-reaction="${update.reaction}"]`);

          buttons.forEach(btn => {
            const countEl = btn.querySelector('.reaction-count');
            if (countEl && this.state.showCounts) {
              countEl.textContent = update.count;
            }

            const rt = this.reactionTypes.find(r => r.key === update.reaction);
            const svgEl = btn.querySelector('svg');
            if (svgEl && rt) {
              const newIcon = this.getIcon(rt.icon, 'w-5 h-5', update.reacted);
              svgEl.outerHTML = newIcon;
            }

            const colorClass = update.reaction === 'LIKE' ? 'text-red-500' :
                             update.reaction === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
            btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
            btn.classList.add(colorClass);
            btn.classList.toggle('reacted', update.reacted);
            btn.setAttribute('aria-pressed', update.reacted.toString());

            const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
            const reactionName = reactionNames[update.reaction] || update.reaction;
            btn.setAttribute('aria-label', `${reactionName}${update.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${update.count}ä»¶)` : ''}`);
          });
        });

      } catch (error) {
        console.error('batchUpdateReactionButtons error:', error);
      }
    };

    if (immediate) {
      executeUpdate();
    } else {
      requestAnimationFrame(executeUpdate);
    }
  }
  
  updateCardReactionBackground(card, data) {
    this.applyReactionStyles(card, data);
  }
  
  updateCardHighlight(card, data) {
    const isHighlighted = data.highlight;

    if (isHighlighted) {
      card.classList.add('highlighted');
    } else {
      card.classList.remove('highlighted');
    }

    const highlightBtn = card.querySelector('.highlight-btn');
    if (highlightBtn) {
      highlightBtn.classList.toggle('active', isHighlighted);
    }
  }
  
  createAnswerCard(data) {
    try {
      const safeData = this.validateCardData(data);
      if (!safeData) return null;

      const cacheKey = this.generateCardCacheKey(safeData);
      const cachedCard = this.checkCardCache(cacheKey, safeData);
      if (cachedCard) return cachedCard;

      const card = this.createCardElement(safeData);
      const highlightBtnHtml = this.createHighlightButton(safeData);
      const { nameHtml, containerClass } = this.createNameDisplay(safeData);
      const reactionButtonsHtml = this.createReactionButtons(safeData);

      this.buildCardContent(card, safeData, reactionButtonsHtml, nameHtml, highlightBtnHtml, containerClass);
      this.finalizeCard(card, safeData, cacheKey);

      return card;
    } catch (error) {
      return this.createErrorCard(error, data);
    }
  }

  validateCardData(data) {
    if (!data || typeof data !== 'object') {
      console.warn('createAnswerCard: Invalid data provided:', data);
      return null;
    }

    if (!data.opinion) {
      console.warn('createAnswerCard: å›ç­”ãƒ‡ãƒ¼ã‚¿ï¼ˆopinionï¼‰ãŒã‚ã‚Šã¾ã›ã‚“:', {
        rowIndex: data.rowIndex,
        hasOpinion: !!data.opinion,
        dataKeys: Object.keys(data)
      });
    }

    return {
      rowIndex: data.rowIndex || 0,
      opinion: data.opinion || '',
      reason: this.validateReasonText(data.reason),
      name: data.name || '',
      email: data.email || '',
      reactions: data.reactions || {},
      highlight: Boolean(data.highlight)
    };
  }

  generateCardCacheKey(safeData) {
    const userIdentifier = window.UNIFIED_CONFIG?.email ?
      window.UNIFIED_CONFIG.email.replace(/[^a-zA-Z0-9]/g, '').slice(-8) : 'anon';
    return `${userIdentifier}-${safeData.rowIndex}-${safeData.opinion.slice(0,50)}-${safeData.reason.slice(0,30)}-${safeData.name}-${JSON.stringify(safeData.reactions)}-${safeData.highlight}-${this.state.showCounts}-${this.state.displayMode}-${this.state.showHighlightToggle}`;
  }

  checkCardCache(cacheKey, safeData) {
    const cachedCard = this.cache.get(`render-${cacheKey}`);
    if (cachedCard) {
      try {
        const clonedCard = cachedCard.cloneNode(true);
        clonedCard.dataset.rowIndex = safeData.rowIndex;

        const reactionButtons = clonedCard.querySelectorAll('.reaction-btn');
        reactionButtons.forEach(btn => {
          btn.dataset.rowIndex = safeData.rowIndex;
        });

        return clonedCard;
      } catch (cacheError) {
        console.warn('createAnswerCard: Cache clone error, creating new card:', cacheError);
      }
    }
    return null;
  }

  createCardElement(safeData) {
    const card = document.createElement('div');
    const highlightClass = safeData.highlight ? ' highlighted' : '';
    card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' + highlightClass;
    card.dataset.rowIndex = safeData.rowIndex;
    card.setAttribute('role', 'article');
    card.setAttribute('tabindex', '0');
    card.setAttribute('aria-label', 'å›ç­”ã‚«ãƒ¼ãƒ‰: ' + safeData.opinion.substring(0, 50) + (safeData.opinion.length > 50 ? '...' : ''));
    return card;
  }

  createHighlightButton(safeData) {
    if (!this.state.showHighlightToggle) return '';

    const cls = safeData.highlight ? 'reacted' : '';
    const highlightAriaLabel = safeData.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
    return `<button type="button" class="highlight-btn like-btn text-purple-600 ${cls}" aria-label="${highlightAriaLabel}" aria-pressed="${safeData.highlight}" data-row-index="${safeData.rowIndex}">${this.getIcon('star', 'w-5 h-5', safeData.highlight)}</button>`;
  }

  createHighlightBadge() {
    const badge = document.createElement('span');
    badge.className = 'highlight-badge';
    badge.innerHTML = this.getIcon('star', '', true);
    return badge;
  }

  createNameDisplay(safeData) {
    const showName = this.state.displayMode === 'named';
    let displayName = '';

    if (showName) {
      if (safeData.name) {
        displayName = safeData.name;
      } else if (safeData.email) {
        try {
          displayName = safeData.email.split('@')[0];
        } catch (emailError) {
          console.warn('createAnswerCard: Email parsing error:', emailError);
          displayName = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
        }
      }
    }

    const nameHtml = showName && displayName ?
      `<div class="name-display flex-shrink-0 mr-2"><span class="font-bold text-sm text-cyan-300 bg-gray-800/50 px-2 py-1 rounded border border-cyan-400">${window.sharedUtilities.security.escapeHtml(displayName)}</span></div>` : '';

    const containerClass = nameHtml ?
      'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex flex-col sm:flex-row justify-between items-start sm:items-center gap-y-1 min-h-[2rem]' :
      'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';

    return { nameHtml, containerClass };
  }

  createReactionButtons(safeData) {
    return this.reactionTypes.map(rt => {
      try {
        const info = safeData.reactions && safeData.reactions[rt.key] ? safeData.reactions[rt.key] : { count: 0, reacted: false };
        const cls = info.reacted ? 'reacted' : '';
        const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
        const countSpan = this.state.showCounts ? `<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">${info.count || 0}</span>` : '';
        const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
        const reactionName = reactionNames[rt.key] || rt.key;
        const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count || 0}ä»¶)` : ''}`;

        return `<button type="button" class="reaction-btn like-btn flex items-center gap-1 ${colorClass} ${cls}" data-row-index="${safeData.rowIndex}" data-reaction="${rt.key}" aria-label="${ariaLabel}" aria-pressed="${info.reacted}">${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countSpan}</button>`;
      } catch (reactionError) {
        console.warn('createAnswerCard: Reaction button creation error:', reactionError);
        return '';
      }
    }).join('');
  }

  buildCardContent(card, safeData, reactionButtonsHtml, nameHtml, highlightBtnHtml, containerClass) {
    const fragment = document.createDocumentFragment();

    const contentDiv = document.createElement('div');
    contentDiv.className = 'relative flex-grow mb-3 answer-preview';

    if (this.state.showAdminFeatures) {
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'absolute top-2 right-2 text-red-400 hover:text-red-300 hover:bg-red-900/20 rounded-full p-2 transition-all duration-200 z-10 delete-answer-btn';
      deleteBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
      </svg>`;
      deleteBtn.setAttribute('aria-label', 'å›ç­”ã‚’å‰Šé™¤');
      deleteBtn.setAttribute('title', 'å›ç­”ã‚’å‰Šé™¤');
      deleteBtn.dataset.rowIndex = safeData.rowIndex;
      contentDiv.appendChild(deleteBtn);
    }

    const opinionTitle = document.createElement('h3');
    opinionTitle.className = 'opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight';
    opinionTitle.textContent = safeData.opinion || 'ï¼ˆå›ç­”å†…å®¹ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸï¼‰';

    contentDiv.appendChild(opinionTitle);

    if (safeData.reason && safeData.reason.trim()) {
      const reasonText = document.createElement('p');
      reasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
      reasonText.textContent = safeData.reason;
      contentDiv.appendChild(reasonText);
    }

    const footerDiv = document.createElement('div');
    footerDiv.className = containerClass;

    if (nameHtml) {
      const nameContainer = document.createElement('div');
      nameContainer.className = 'name-container flex-shrink-0';
      nameContainer.innerHTML = nameHtml;
      footerDiv.appendChild(nameContainer);
    }

    const reactionsDiv = document.createElement('div');
    reactionsDiv.className = 'reaction-container flex items-center gap-1 flex-shrink-0';
    reactionsDiv.setAttribute('role', 'group');
    reactionsDiv.setAttribute('aria-label', 'å›ç­”ã¸ã®åå¿œ');
    reactionsDiv.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    footerDiv.appendChild(reactionsDiv);

    fragment.appendChild(contentDiv);
    fragment.appendChild(footerDiv);
    card.appendChild(fragment);
  }

  finalizeCard(card, safeData, cacheKey) {
    if (safeData.highlight) {
      card.appendChild(this.createHighlightBadge());
    }

    this.applyReactionStyles(card, safeData);

    try {
      if (this.cache.size > 100) {
        this.cache.cleanup();
      }
      this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
    } catch (cacheError) {
      console.warn('createAnswerCard: Cache storage error:', cacheError);
    }
  }

  createErrorCard(error, data) {
    console.error('createAnswerCard: Critical error creating card:', error, 'Data:', data);

    try {
      const errorCard = document.createElement('div');
      errorCard.className = 'answer-card glass-panel rounded-xl p-4 border-2 border-red-400/50 bg-red-900/20';
      errorCard.innerHTML = `
        <div class="text-red-300 text-center">
          <div class="mb-2">âš ï¸ ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒ©ãƒ¼</div>
          <div class="text-xs text-red-400">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ</div>
        </div>
      `;
      return errorCard;
    } catch (fallbackError) {
      console.error('createAnswerCard: Fallback card creation also failed:', fallbackError);
      return null;
    }
  }
  
  createSkeletonCard() {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel rounded-xl p-4 opacity-50 skeleton';
    card.innerHTML = '<div class="h-20 w-full rounded bg-gray-500/20 mb-4"></div><div class="h-4 w-3/4 rounded bg-gray-500/15"></div>';
    return card;
  }

  /**
   * Generate unique request ID for operation tracking
   * @returns {string} UUID-like unique identifier
   */
  generateRequestId() {
    return 'req_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Staged error recovery strategy with escalating levels
   * @param {number} rowIndex - Row index of the failed operation
   * @param {string} reaction - Reaction type that failed
   * @param {Error} error - Original error
   * @returns {Promise<Object>} Recovery result
   */
  async performStagedRecovery(rowIndex, reaction, error) {
    const reactionKey = `${rowIndex}-${reaction}`;

    const pendingRequest = this.pendingReactions.get(reactionKey);
    if (pendingRequest) {
      pendingRequest.retryCount = (pendingRequest.retryCount || 0) + 1;
    }


    try {
      this.clearCache({ includeReactions: true });
      await this.loadSheetData({ bypassCache: true, silent: true });
      return { success: true, level: 1, method: 'cache_clear_reload' };
    } catch (level1Error) {
      console.warn('âš ï¸ Level 1 recovery failed:', level1Error.message);
    }

    try {
      const localRestoreResult = this.restoreLocalReactionState(rowIndex, reaction, pendingRequest);
      if (localRestoreResult.success) {
        return { success: true, level: 2, method: 'local_restore' };
      }
    } catch (level2Error) {
      console.error('âŒ Level 2 recovery failed:', level2Error.message);
    }

    return {
      success: false,
      message: `All recovery levels failed for ${reactionKey}`,
      originalError: error.message
    };
  }



  /**
   * Restore local reaction state as final fallback
   * @param {number} rowIndex - Row index
   * @param {string} reaction - Reaction type
   * @param {Object} pendingRequest - Pending request context
   * @returns {Object} Restoration result
   */
  async restoreLocalReactionState(rowIndex, reaction, pendingRequest) {
    const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
    if (!item || !item.reactions || !item.reactions[reaction]) {
      return { success: false, message: 'No local state to restore' };
    }

    const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);

    if (pendingRequest && typeof pendingRequest.originalState === 'boolean') {
      item.reactions[reaction].reacted = pendingRequest.originalState;
      if (pendingRequest.originalState) {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
      } else {
        item.reactions[reaction].count = Math.max(0, (item.reactions[reaction].count || 1) - 1);
      }
    } else {
      const wasReacted = item.reactions[reaction].reacted;
      item.reactions[reaction].reacted = !wasReacted;
      if (wasReacted) {
        item.reactions[reaction].count = Math.max(0, (item.reactions[reaction].count || 1) - 1);
      } else {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
      }
    }

    if (card) {
      this.updateCardReactions(card, item);
    }

    return { success: true, message: 'Local state restored successfully' };
  }


  /**
   * Simulate server-side exclusive reaction logic for optimistic updates
   * @param {Object} item - The answer item
   * @param {string} reaction - The reaction type being clicked
   * @returns {Object} Predicted server response
   */
  simulateServerExclusiveReaction(item, reaction) {
    if (!item.reactions) item.reactions = {};

    const predictedReactions = JSON.parse(JSON.stringify(item.reactions));

    this.reactionTypes.forEach(rt => {
      if (!predictedReactions[rt.key]) {
        predictedReactions[rt.key] = { count: 0, reacted: false };
      }
    });

    let userCurrentReaction = null;
    const reactedReactions = [];

    Object.keys(predictedReactions).forEach(key => {
      if (predictedReactions[key].reacted) {
        reactedReactions.push(key);
      }
    });

    if (reactedReactions.length >= 1) {
      userCurrentReaction = reactedReactions[0];

    }

    let changed = false;

    if (userCurrentReaction === reaction) {
      predictedReactions[reaction].reacted = false;
      predictedReactions[reaction].count = Math.max(0, predictedReactions[reaction].count - 1);
      changed = true;
    } else {
      if (userCurrentReaction) {
        predictedReactions[userCurrentReaction].reacted = false;
        predictedReactions[userCurrentReaction].count = Math.max(0, predictedReactions[userCurrentReaction].count - 1);
      }
      predictedReactions[reaction].reacted = true;
      predictedReactions[reaction].count = (predictedReactions[reaction].count || 0) + 1;
      changed = true;
    }

    return {
      changed,
      reactions: predictedReactions,
      action: userCurrentReaction === reaction ? 'removed' :
              userCurrentReaction ? 'changed' : 'added',
      userReaction: userCurrentReaction === reaction ? null : reaction
    };
  }

  /**
   * ğŸš€ ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ‡ãƒã‚¦ãƒ³ã‚·ãƒ³ã‚°æ–¹å¼ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ï¼ˆCLAUDE.mdæº–æ‹ æœ€é©åŒ–ï¼‰
   */
  async addReaction(rowIndex, reaction) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;
    const rowKey = `row_${numericRowIndex}`; // è¡Œå˜ä½ã®ãƒ‡ãƒã‚¦ãƒ³ã‚·ãƒ³ã‚°ç”¨

    const requestId = this.generateRequestId();

    if (this.pendingReactions.has(reactionKey)) {
      const pendingRequest = this.pendingReactions.get(reactionKey);
      return;
    }

    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    if (!item) {
      console.warn(`âš ï¸ ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: rowIndex=${numericRowIndex}`);
      return;
    }

    const buttons = document.querySelectorAll(`[data-row-index="${numericRowIndex}"][data-reaction="${reaction}"]`);

    this.setReactionButtonsLoading(buttons, true, requestId);

    const optimisticUpdate = this.simulateServerExclusiveReaction(item, reaction);

    if (optimisticUpdate.changed) {
      item.reactions = optimisticUpdate.reactions;

      const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);

      if (card) {
        this.updateCardReactions(card, item);
      }
    }

    const currentState = item.reactions?.[reaction] || { count: 0, reacted: false };

    this.pendingReactions.set(reactionKey, {
      requestId,
      rowIndex: numericRowIndex,
      reaction,
      timestamp: Date.now(),
      originalState: currentState,
      retryCount: 0
    });

    this.debounceReactionByRow(rowKey, numericRowIndex, reaction, reactionKey);
  }

  /**
   * ğŸ¯ CLAUDE.mdæº–æ‹ : è¡Œå˜ä½ãƒ‡ãƒã‚¦ãƒ³ã‚·ãƒ³ã‚°å‡¦ç†ï¼ˆ300msï¼‰
   */
  debounceReactionByRow(rowKey, rowIndex, reaction, reactionKey) {
    if (this.reactionDebounceTimeouts.has(rowKey)) {
      clearTimeout(this.reactionDebounceTimeouts.get(rowKey));
    }

    const timeoutId = setTimeout(async () => {
      try {
        this.reactionDebounceTimeouts.delete(rowKey);

        await this.sendReactionToServerDirect(rowIndex, reaction, reactionKey);

      } catch (error) {
        console.error(`âŒ ãƒ‡ãƒã‚¦ãƒ³ã‚¹å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ (${reactionKey}):`, error);

        this.ensureReactionCleanup(rowIndex, reaction, reactionKey, error);

      } finally {
        this.reactionDebounceTimeouts.delete(rowKey);
      }
    }, 300);

    this.reactionDebounceTimeouts.set(rowKey, timeoutId);
  }

  /**
   * ğŸš€ ç›´æ¥ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚·ãƒ³ã‚°å¾Œï¼‰
   */
  async sendReactionToServerDirect(rowIndex, reaction, reactionKey) {
    let success = false;
    let errorMessage = null;

    try {
      const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
      if (!item) {
        throw new Error(`Item not found for rowIndex: ${rowIndex}`);
      }

      await this.executeWithRetry(async (attempt) => {

        const response = await this.sendReactionToServer(rowIndex, reaction);
        await this.processResponse(item, response, reaction);

        await this.updateReactionUI(item, false);

        return response;
      }, {
        maxRetries: 2,
        baseDelay: 500,
        context: `ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç† (${reactionKey})`,
        retryCondition: (error) => {
          return error.message && !error.message.includes('æ¨©é™') && !error.message.includes('ç„¡åŠ¹');
        }
      });

      success = true;

    } catch (error) {
      success = false;
      errorMessage = error.message;
      console.error(`âŒ ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼ (${reactionKey}):`, error);

      await this.handleReactionError(error, rowIndex, reaction);

    } finally {
      const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
      this.setReactionButtonsLoading(buttons, false);
      this.pendingReactions.delete(reactionKey);

      this.notifyReactionComplete(reactionKey, {
        success,
        error: errorMessage,
        rowIndex,
        reaction
      });
    }
  }

  /**
   * ğŸ›¡ï¸ å…±é€šã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•° - UIçŠ¶æ…‹ã¨ã‚µãƒ¼ãƒãƒ¼å‡¦ç†ã®ç¢ºå®ŸãªåŒæœŸ
   */
  ensureReactionCleanup(rowIndex, reaction, reactionKey, error = null) {
    try {

      const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
      if (buttons.length > 0) {
        this.setReactionButtonsLoading(buttons, false);
      } else {
        console.warn(`âš ï¸ ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„: row=${rowIndex}, reaction=${reaction}`);
      }

      if (this.pendingReactions.has(reactionKey)) {
        this.pendingReactions.delete(reactionKey);
      }

      if (error) {
        console.warn(`ğŸ”„ ã‚¨ãƒ©ãƒ¼æ™‚UIçŠ¶æ…‹å¾©æ—§ç¢ºèª: ${reactionKey}`, error.message);

        buttons.forEach(btn => {
          if (btn.disabled || btn.classList.contains('loading') || btn.getAttribute('aria-busy') === 'true') {
            console.warn(`ğŸš¨ UIçŠ¶æ…‹ä¸æ•´åˆæ¤œå‡ºã€å¼·åˆ¶å¾©æ—§: ${reactionKey}`);
            btn.disabled = false;
            btn.classList.remove('loading');
            btn.setAttribute('aria-busy', 'false');
            btn.removeAttribute('data-request-id');
          }
        });
      }

      if (!this.reactionEventListeners.has(reactionKey)) {
        this.notifyReactionComplete(reactionKey, {
          success: !error,
          error: error?.message,
          rowIndex,
          reaction,
          cleanupReason: 'ensureReactionCleanup'
        });
      }

    } catch (cleanupError) {
      console.error(`âŒ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†è‡ªä½“ã§ã‚¨ãƒ©ãƒ¼: ${reactionKey}`, cleanupError);
      try {
        const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
        buttons.forEach(btn => {
          btn.disabled = false;
          btn.classList.remove('loading');
          btn.setAttribute('aria-busy', 'false');
        });
      } catch (finalError) {
        console.error(`âŒ æœ€çµ‚UIå¾©æ—§ã‚‚ã‚¨ãƒ©ãƒ¼: ${reactionKey}`, finalError);
      }
    }
  }



  notifyReactionComplete(reactionKey, result) {
    const listeners = this.reactionEventListeners.get(reactionKey);
    if (listeners && listeners.length > 0) {
      listeners.forEach(listener => {
        try {
          listener(result);
        } catch (error) {
          console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ãƒªã‚¹ãƒŠãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
        }
      });
      this.reactionEventListeners.delete(reactionKey);
    }
  }

  waitForReactionComplete(reactionKey, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const timeoutPromise = this.createReactionTimeout(reactionKey, timeout, reject);

      const listener = (result) => {
        resolve(result);
      };

      if (!this.reactionEventListeners.has(reactionKey)) {
        this.reactionEventListeners.set(reactionKey, []);
      }
      this.reactionEventListeners.get(reactionKey).push(listener);
    });
  }

  async waitForReactionStateChange(rowIndex, reaction, initialState, timeoutMs = 3000, pollIntervalMs = 50) {
    const startTime = Date.now();
    
    const getReactionButtonState = () => {
      const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
      if (buttons.length === 0) return null;
      
      const btn = buttons[0];
      return {
        reacted: btn.getAttribute('aria-pressed') === 'true',
        count: parseInt(btn.querySelector('.count')?.textContent || '0'),
        disabled: btn.disabled,
        classes: btn.className,
        timestamp: Date.now()
      };
    };
    
    const hasStateChanged = (current, initial) => {
      if (!current || !initial) return false;
      return current.reacted !== initial.reacted || 
             current.count !== initial.count ||
             current.disabled !== initial.disabled;
    };
    
    return new Promise((resolve, reject) => {
      const poll = () => {
        const currentTime = Date.now();
        if (currentTime - startTime >= timeoutMs) {
          reject(new Error(`State change timeout after ${timeoutMs}ms`));
          return;
        }
        
        const currentState = getReactionButtonState();
        if (hasStateChanged(currentState, initialState)) {
          resolve({
            initialState,
            currentState,
            changeDetectedAt: currentTime - startTime,
            stateChanged: true
          });
          return;
        }
        
        this.scheduleNextPoll(poll, pollIntervalMs);
      };
      
      poll();
    });
  }

  async waitForReactionUpdate(rowIndex, reaction, expectedChange = null, maxWaitMs = 3000) {
    const reactionKey = `${rowIndex}-${reaction}`;
    
    try {
      const result = await this.waitForReactionComplete(reactionKey, maxWaitMs);
      return result || { timeout: false, success: true };
    } catch (error) {
      console.warn(`âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${reactionKey}`, error.message);
      return { 
        error: error.message, 
        timeout: true,
        success: false
      };
    }
  }

  getReactionButtonState(rowIndex, reaction) {
    const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
    if (buttons.length === 0) return null;
    
    const btn = buttons[0];
    return {
      reacted: btn.getAttribute('aria-pressed') === 'true',
      count: parseInt(btn.querySelector('.count')?.textContent || '0'),
      disabled: btn.disabled,
      classes: btn.className,
      visible: btn.style.display !== 'none',
      computedStyle: getComputedStyle(btn),
      timestamp: Date.now()
    };
  }


  setReactionButtonsLoading(buttons, isLoading, requestId = null) {
    buttons.forEach(btn => {
        btn.disabled = isLoading;
        if (isLoading) {
            btn.classList.add('loading');
            btn.setAttribute('aria-busy', 'true');
            if (requestId) {
                btn.setAttribute('data-request-id', requestId);
            }


        } else {
            btn.classList.remove('loading');
            btn.setAttribute('aria-busy', 'false');
            if (requestId) {
                btn.removeAttribute('data-request-id');
            }
        }
    });
  }


  async sendReactionToServer(rowIndex, reaction) {
    try {
      const response = await this.runGas('addReaction', this.state.userId, rowIndex, reaction);

      if (!response) {
          throw new Error('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      const success = response.success === true || response.status === 'success';
      if (!success) {
          throw new Error(response.message || 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      return response;
    } catch (error) {
      if (error.userMessage) {
        throw new Error(error.userMessage);
      } else if (error.message && error.message.includes('timeout')) {
        throw new Error('ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      } else if (error.message && error.message.includes('ç„¡åŠ¹')) {
        throw new Error('ç„¡åŠ¹ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ãã ã•ã„ã€‚');
      } else {
        throw error; // å…ƒã®ã‚¨ãƒ©ãƒ¼ã‚’ãã®ã¾ã¾æŠ•ã’ã‚‹
      }
    }
  }

  async processResponse(item, response, reaction) {
    if (response.success && response.reactions && typeof response.reactions === 'object') {
        const serverReactions = JSON.parse(JSON.stringify(response.reactions));

        const validatedReactions = this.validateAndFixReactionExclusivity(serverReactions);

        item.reactions = validatedReactions;

        this.saveReactionState(item.rowIndex, item.reactions);
    } else {
        console.error('âŒ Invalid server response format:', response);
        throw new Error('Server returned invalid response format');
    }
  }

  /**
   * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®æ’ä»–æ€§ã‚’æ¤œè¨¼ã—ã€å¿…è¦ã«å¿œã˜ã¦ä¿®æ­£
   * @param {Object} reactions - æ¤œè¨¼ã™ã‚‹ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹
   * @returns {Object} ä¿®æ­£æ¸ˆã¿ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹
   */
  validateAndFixReactionExclusivity(reactions) {
    if (!reactions || typeof reactions !== 'object') {
      return {};
    }

    const validatedReactions = JSON.parse(JSON.stringify(reactions));
    const reactedKeys = [];

    Object.keys(validatedReactions).forEach(key => {
      if (validatedReactions[key] && validatedReactions[key].reacted) {
        reactedKeys.push(key);
      }
    });

    if (reactedKeys.length > 1) {
      console.warn(`âš ï¸ ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã§è¤‡æ•°ã®reacted: trueã‚’æ¤œå‡ºã€‚ä¿®æ­£ä¸­:`, reactedKeys);

      const keepReaction = reactedKeys[0];
      reactedKeys.slice(1).forEach(key => {
        validatedReactions[key].reacted = false;
        validatedReactions[key].count = Math.max(0, validatedReactions[key].count - 1);
      });

      console.warn(`âš ï¸ ä¿®æ­£å®Œäº†: ${keepReaction}ã‚’ç¶­æŒã€ä»–ã‚’ç„¡åŠ¹åŒ–`);
    }

    return validatedReactions;
  }



  async updateReactionUI(item, immediate = false) {
      const lastUpdateKey = `ui_update_${item.rowIndex}`;
    const currentStateHash = this.calculateStateHash(item);
    const lastStateHash = this.lastUIStates?.get(lastUpdateKey);

    if (lastStateHash === currentStateHash && !immediate) {
      return;
    }

    if (!this.lastUIStates) this.lastUIStates = new Map();
    this.lastUIStates.set(lastUpdateKey, currentStateHash);

    if (immediate) {
      try {
        const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
        if (card && card instanceof HTMLElement) {
          this.updateCardReactions(card, item);
          this.applyReactionStyles(card, item);
        } else {
          console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
        }

        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex = this.elements.modalReactionContainer
            .querySelector('[data-row-index]')?.dataset.rowIndex;
          if (modalRowIndex == item.rowIndex) {
            this.updateModalReactionButtons(item);
            this.applyReactionStyles(this.elements.answerModalCard, item);
          }
        }

      } catch (error) {
        console.error('âŒ UIå³åº§æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      }
      return;
    }

    return new Promise(resolve => {
        requestAnimationFrame(() => {
            try {
                const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
                if (card && card instanceof HTMLElement) {
                    this.updateCardReactions(card, item);
                    this.applyReactionStyles(card, item);
                } else {
                    console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
                }

                if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                    const modalRowIndex = this.elements.modalReactionContainer
                      .querySelector('[data-row-index]')?.dataset.rowIndex;
                    if (modalRowIndex == item.rowIndex) {
                      this.updateModalReactionButtons(item);
                      this.applyReactionStyles(this.elements.answerModalCard, item);
                    }
                }

                resolve();
            } catch (error) {
                console.error('UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                resolve();
            }
        });
    });
  }

  getScopedKey(base) {
    const userId = this.state?.userId || window.USER_ID;
    return `${base}_${userId}_${window.SHEET_NAME}`;
  }


  isFirstTimeBoardAccess() {
    try {
      const hasLastSeenTimestamp = localStorage.getItem(this.getScopedKey('lastSeenTimestamp')) !== null;
      const hasDiffCards = localStorage.getItem(this.getScopedKey('differentialCards')) !== null;
      const hasInitialLoad = this.initialDataLoaded === true;
      const container = this.elements?.answersContainer;
      const hasDOMCards = container && container.querySelectorAll('.answer-card').length > 0;
      const isFirstTime = !hasLastSeenTimestamp && !hasDiffCards && !hasInitialLoad && !hasDOMCards;

        hasLastSeenTimestamp,
        hasDiffCards,
        hasInitialLoad,
        hasDOMCards,
        isFirstTime
      });

      return isFirstTime;
    } catch (error) {
      console.warn('âš ï¸ åˆå›åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
      return false;
    }
  }

  loadLastSeenTimestamp() {
    try {
      const key = this.getScopedKey('lastSeenTimestamp');
      const stored = localStorage.getItem(key);
      const timestamp = stored || new Date(0).toISOString();

      return timestamp;
    } catch (error) {
      console.warn('âš ï¸ lastSeenTimestampèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      return new Date(0).toISOString();
    }
  }

  saveLastSeenTimestamp(timestamp) {
    try {
      const key = this.getScopedKey('lastSeenTimestamp');
      localStorage.setItem(key, timestamp);

    } catch (error) {
      console.warn('âš ï¸ lastSeenTimestampä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  updateLastSeenTimestamp(timestamp = null) {
    const newTimestamp = timestamp || new Date().toISOString();
    const oldTimestamp = this.state.lastSeenTimestamp;

    this.state.lastSeenTimestamp = newTimestamp;
    this.saveLastSeenTimestamp(newTimestamp);

      oldTimestamp,
      newTimestamp,
      context: 'filter-independent-notification-system'
    });
  }



  async handleReactionError(error, rowIndex, reaction) {
    console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', {
        error: error.message,
        rowIndex,
        reaction,
        timestamp: new Date().toISOString()
    });

    const recoveryResult = await this.performStagedRecovery(rowIndex, reaction, error);

    if (!recoveryResult.success) {
      console.error('âŒ All recovery attempts failed:', recoveryResult.message);
    }
    
    let userMessage = 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
    if (error.message.includes('timeout') || error.message.includes('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')) {
      userMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒé…ã„ãŸã‚ã€ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ›´æ–°ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™';
    } else if (error.message.includes('network') || error.message.includes('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯')) {
      userMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„';
    } else if (error.message.includes('permission') || error.message.includes('æ¨©é™')) {
      userMessage = 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã¸ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“';
    }

    if (window.notifications) {
        window.notifications.error(userMessage, 4000);
    } else {
        this.showNotification(userMessage, 'error');
    }

    console.error('ğŸ” Reaction Error:', error.message, { rowIndex, reaction });
  }

  async handleHighlight(rowIndex) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const highlightKey = `${numericRowIndex}-highlight`;

    const now = Date.now();
    const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
    if (now - lastHighlightTime < StudyQuestApp.CONSTANTS.HIGHLIGHT_RATE_LIMIT_MS) {
      return;
    }

    if (this.pendingReactions.has(highlightKey)) {
      return;
    }

    this.pendingReactions.set(highlightKey, { type: 'highlight', rowIndex: numericRowIndex, timestamp: Date.now() });
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(highlightKey, now);

    const btns = document.querySelectorAll('.highlight-btn[data-row-index="' + numericRowIndex + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);

    if (!item) {
      this.pendingReactions.delete(highlightKey);
      return;
    }

    btns.forEach(btn => {
        btn.classList.add('loading');
        btn.disabled = true;
    });

    try {
        const res = await this.executeWithRetry(async (attempt) => {

            const response = await this.runGas('toggleHighlight', this.state.userId, numericRowIndex);

            const ok = response && (response.success === true || response.status === 'success');
            if (ok) {
                return response;
            } else {
                throw new Error(response?.message || 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }, {
            maxRetries: 2,
            baseDelay: 300,
            context: `ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç† (${highlightKey})`,
            retryCondition: (error) => {
                if (error.message && (error.message.includes('ç®¡ç†è€…ã®ã¿') || error.message.includes('ç·¨é›†è€…ã®ã¿'))) {
                    return false;
                }
                const retryableErrors = ['network', 'timeout', 'server error', 'temporarily unavailable'];
                return retryableErrors.some(errorType =>
                    error.message.toLowerCase().includes(errorType)
                );
            }
        });

        item.highlight = typeof res.highlighted === 'boolean' ? res.highlighted : !item.highlight;

        this.batchDOMUpdates([
            () => this.applyUpdates([item])
        ]);

        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
            if (modalRowIndex == numericRowIndex) {
                requestAnimationFrame(() => this.updateModalContent(item));
            }
        }

        requestIdleCallback(() => {
            const highlightValue = typeof res.highlighted === 'boolean' ? res.highlighted : item.highlight;
            this.verifyHighlightSync(numericRowIndex, highlightValue);
        }, { timeout: 1000 });

    } catch (error) {
        console.error('Failed to toggle highlight:', error);

        if (error.message && (error.message.includes('ç®¡ç†è€…ã®ã¿') || error.message.includes('ç·¨é›†è€…ã®ã¿'))) {
            this.showNotification('æ¨©é™ã‚¨ãƒ©ãƒ¼: ãƒœãƒ¼ãƒ‰ç·¨é›†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™', 'error');
            console.warn('ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½ã¯ãƒœãƒ¼ãƒ‰ç·¨é›†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™');
        } else {
            this.showNotification('ãƒã‚¤ãƒ©ã‚¤ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
        }
    } finally {
        btns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
    }
  }

  async verifyHighlightSync(rowIndex, expectedHighlight) {
    try {
      const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
      if (!item) return;

      if (typeof expectedHighlight === 'undefined') {
        return;
      }

      if (item.highlight !== expectedHighlight) {
        console.warn(`âš ï¸ ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: rowIndex=${rowIndex}, UI=${item.highlight}, Expected=${expectedHighlight}`);

        item.highlight = expectedHighlight;
        requestAnimationFrame(() => this.applyUpdates([item]));

      } else {
      }
    } catch (error) {
      console.error('ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
    }
  }


  async fixSyncIssues(healthCheckResult) {
    if (!healthCheckResult.issues || healthCheckResult.issues.length === 0) {
      return { fixed: 0, skipped: 0 };
    }
    
    let fixed = 0;
    let skipped = 0;
    
    for (const issue of healthCheckResult.issues) {
      try {
        switch (issue.type) {
          case 'ui_data_inconsistency':
            for (const inconsistency of issue.data) {
              const item = this.state.currentAnswers.find(i => i.rowIndex === inconsistency.rowIndex);
              if (item) {
                await this.applyUpdates([item]);
                fixed++;
              }
            }
            break;
            
          case 'data_staleness':
            await this.forceDataRefresh();
            fixed++;
            break;
            
          case 'cache_bloat':
            if (this.cache && typeof this.cache.clear === 'function') {
              this.cache.clear();
              fixed++;
            }
            break;
            
          default:
            skipped++;
            break;
        }
      } catch (fixError) {
        console.error(`ä¿®å¾©å¤±æ•— (${issue.type}):`, fixError);
        skipped++;
      }
    }
    
    return { fixed, skipped };
  }


  calculateStateHash(item) {
    const state = {
      reactions: item.reactions,
      highlight: item.highlight,
      rowIndex: item.rowIndex
    };
    return JSON.stringify(state);
  }


  /**
   * å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
   * @param {string} rowIndex - å‰Šé™¤å¯¾è±¡ã®è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   */
  async confirmDeleteAnswer(rowIndex) {
    try {
      const answerData = this.state.currentAnswers.find(answer =>
        String(answer.rowIndex) === String(rowIndex)
      );

      if (!answerData) {
        console.error('å‰Šé™¤å¯¾è±¡ã®å›ç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', rowIndex);
        return;
      }

      const confirmed = await this.showDeleteConfirmationModal(answerData);
      if (confirmed) {
        await this.deleteAnswer(rowIndex);
      }
    } catch (error) {
      console.error('å‰Šé™¤ç¢ºèªå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      if (window.notifications) {
        window.notifications.error('å‰Šé™¤å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 3000);
      }
    }
  }

  /**
   * å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
   * @param {Object} answerData - å‰Šé™¤å¯¾è±¡ã®å›ç­”ãƒ‡ãƒ¼ã‚¿
   * @returns {Promise<boolean>} å‰Šé™¤ç¢ºèªã®çµæœ
   */
  showDeleteConfirmationModal(answerData) {
    return new Promise((resolve) => {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10001] animate-fade-in';
      modal.innerHTML = `
        <div class="glass-panel rounded-xl p-6 max-w-md w-full mx-4 animate-scale-up">
          <div class="flex items-center gap-3 mb-4">
            <div class="text-red-400">
              <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"/>
              </svg>
            </div>
            <h3 class="text-xl font-semibold text-white">å›ç­”ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ</h3>
          </div>

          <div class="bg-gray-800 rounded-lg p-4 mb-6">
            <p class="text-gray-300 text-sm mb-2">å‰Šé™¤å¯¾è±¡ã®å›ç­”:</p>
            <p class="text-cyan-300 font-medium">${window.sharedUtilities.security.escapeHtml(answerData.opinion.substring(0, 100))}${answerData.opinion.length > 100 ? '...' : ''}</p>
            ${answerData.name ? `<p class="text-gray-400 text-xs mt-2">å›ç­”è€…: ${window.sharedUtilities.security.escapeHtml(answerData.name)}</p>` : ''}
          </div>

          <div class="bg-red-900/20 border border-red-500/50 rounded-lg p-3 mb-6">
            <p class="text-red-200 text-sm">
              âš ï¸ ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰è©²å½“ã®è¡ŒãŒå®Œå…¨ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚
            </p>
          </div>

          <div class="flex gap-3">
            <button type="button" class="flex-1 btn bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg cancel-btn">
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
            <button type="button" class="flex-1 btn bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg confirm-btn">
              å‰Šé™¤å®Ÿè¡Œ
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      const cancelBtn = modal.querySelector('.cancel-btn');
      const confirmBtn = modal.querySelector('.confirm-btn');

      const cleanup = () => {
        modal.remove();
      };

      cancelBtn.addEventListener('click', () => {
        cleanup();
        resolve(false);
      });

      confirmBtn.addEventListener('click', () => {
        cleanup();
        resolve(true);
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          cleanup();
          resolve(false);
        }
      });

      const handleKeyDown = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          resolve(false);
          document.removeEventListener('keydown', handleKeyDown);
        }
      };
      document.addEventListener('keydown', handleKeyDown);
    });
  }

  /**
   * å›ç­”ã‚’å‰Šé™¤ã™ã‚‹
   * @param {string} rowIndex - å‰Šé™¤å¯¾è±¡ã®è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   */
  async deleteAnswer(rowIndex) {
    try {
      if (window.notifications) {
        window.notifications.info('å›ç­”ã‚’å‰Šé™¤ä¸­...', 2000);
      }


      const result = await new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteAnswerRow(this.state.userId, parseInt(rowIndex));
      });

      if (result.success) {
        if (window.notifications) {
          window.notifications.success('å›ç­”ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 3000);
        }

        this.dismissNewContentBanner();

        await this.refreshAfterDelete(rowIndex);

      } else {
        throw new Error(result.message || 'å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (error) {
      console.error('å‰Šé™¤å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      if (window.notifications) {
        window.notifications.error(`å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 5000);
      }

    }
  }

  /**
   * å‰Šé™¤å¾Œã®ç”»é¢æ›´æ–°ï¼ˆæœ€é©åŒ–ç‰ˆ - ä¸è¦ãªå…¨ãƒªã‚»ãƒƒãƒˆå‰Šé™¤ï¼‰
   * @param {string} deletedRowIndex - å‰Šé™¤ã•ã‚ŒãŸè¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   */
  async refreshAfterDelete(deletedRowIndex) {
    try {
      const currentAdminState = this.state.showAdminFeatures;

      const initialCount = this.state.currentAnswers?.length || 0;

      if (this.state.currentAnswers) {
        this.state.currentAnswers = this.state.currentAnswers.filter(answer =>
          String(answer.rowIndex) !== String(deletedRowIndex)
        );
      }
      if (this.state.allAnswers) {
        this.state.allAnswers = this.state.allAnswers.filter(answer =>
          String(answer.rowIndex) !== String(deletedRowIndex)
        );
      }

      const cardToRemove = document.querySelector(`[data-row-index="${deletedRowIndex}"]`);
      if (cardToRemove) {
        cardToRemove.style.transition = 'all 0.3s ease-out';
        cardToRemove.style.transform = 'scale(0.8)';
        cardToRemove.style.opacity = '0';

        setTimeout(() => {
          cardToRemove.remove();
          this.updateAnswerCount();

          if (currentAdminState) {
            this.state.showAdminFeatures = true;
            this.updateAdminButtonUI();
          }
        }, 300);
      } else {
        this.updateAnswerCount();

        if (currentAdminState) {
          this.state.showAdminFeatures = true;
          this.updateAdminButtonUI();
        }
      }

      const finalCount = this.state.currentAnswers?.length || 0;
      const isDataConsistent = (initialCount - finalCount) === 1;

      if (!isDataConsistent) {
        console.warn('å‰Šé™¤å¾Œãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡º:', { initialCount, finalCount });
        setTimeout(() => {
          this.loadSheetData({ preserveAdminMode: true, bypassCache: true });
        }, 500);
      }

        deletedRowIndex,
        initialCount,
        finalCount,
        adminModePreserved: currentAdminState
      });

    } catch (error) {
      console.error('å‰Šé™¤å¾Œæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      if (window.notifications) {
        window.notifications.warning('å‰Šé™¤å¾Œã®æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç”»é¢ã‚’æ›´æ–°ã—ã¾ã™ã€‚', 3000);
      }
      setTimeout(() => {
        const preserveAdminMode = this.state.showAdminFeatures;
        this.loadSheetData({ preserveAdminMode, bypassCache: true });
      }, 500);
    }
  }


  
  async toggleAdminMode() {
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.disabled = true;
    }

    try {
      const enable = !this.state.showAdminFeatures;


      if (enable) {
        if (!this.state.isEditor || !window.hasAdminCapability) {
          console.warn('ç·¨é›†è€…æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', {
            isEditor: this.state.isEditor,
            isAdminUser: this.state.isAdminUser,
            hasAdminCapability: window.hasAdminCapability
          });
          return;
        }
        
        const confirmed = await this.showAdminModeConfirmation();
        if (!confirmed) {
          return; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆ
        }
        
        if (!this.adminModeVerified) {
          try {
            const authResult = await this.runGas('checkUserAuthentication');
            const ok = authResult && authResult.isAdministrator;
            if (!ok) {
              console.warn('ã‚µãƒ¼ãƒãƒ¼å´ã®æ¨©é™ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            }
            this.adminModeVerified = true;
          } catch (e) {
            console.warn('æ¨©é™ç¢ºèªAPIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
          }
        }
      }
      
      window.showAdminFeatures = enable;
      window.showHighlightToggle = enable; // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿æœ‰åŠ¹
      
        enable,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: window.showAdminFeatures,
        showHighlightToggle: window.showHighlightToggle
      });
      if (enable) {
        window.showCounts = true;
        window.displayMode = 'named';
      } else {
        const displaySettings = window.UNIFIED_CONFIG?.displaySettings || {};

        window.showCounts = displaySettings.showReactions || false;
        window.displayMode = displaySettings.showNames ? 'named' : 'anonymous';
      }

      window.isStudentMode = !enable;
      window.showScoreSort = window.showCounts;

      this.updateConfigFromGlobals();

      this.cache.clear();

      this.elements.answersContainer.innerHTML = '';

      this.updateSortOptions();
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      this.loadSheetData({ bypassCache: true }).then(() => {
        this.updateLastSeenTimestamp();

      });
    } finally {
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.disabled = false;
      }
    }
  }
  
  /**
   * ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
   */
  async showAdminModeConfirmation() {
    return new Promise((resolve) => {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
          <div class="flex items-center mb-4">
            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center">
              <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
              </svg>
            </div>
            <div class="ml-4">
              <h3 class="text-lg font-medium text-gray-900">ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã‹ï¼Ÿ</h3>
            </div>
          </div>
          <div class="mb-6">
            <p class="text-sm text-gray-600">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€<strong>ç”Ÿå¾’ã®åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ãŒè¡¨ç¤º</strong>ã•ã‚Œã¾ã™ã€‚<br>
              ç”»é¢å…±æœ‰æ™‚ãªã©ã¯ååˆ†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
            </p>
          </div>
          <div class="flex justify-end space-x-3">
            <button type="button" class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
            <button type="button" class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-orange-600 border border-transparent rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
            </button>
          </div>
        </div>
      `;
      
      const cancelBtn = modal.querySelector('.cancel-btn');
      const confirmBtn = modal.querySelector('.confirm-btn');
      
      const cleanup = () => {
        document.body.removeChild(modal);
      };
      
      cancelBtn.addEventListener('click', () => {
        cleanup();
        resolve(false);
      });
      
      confirmBtn.addEventListener('click', () => {
        cleanup();
        resolve(true);
      });
      
      const handleKeydown = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          document.removeEventListener('keydown', handleKeydown);
          resolve(false);
        }
      };
      document.addEventListener('keydown', handleKeydown);
      
      document.body.appendChild(modal);

      requestIdleCallback(() => confirmBtn.focus(), { timeout: 100 });
    });
  }
  
  endPublication() {
    if (!confirm('å…¬é–‹ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿç”Ÿå¾’ã¯å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã‚Šã¾ã™ã€‚')) {
      return;
    }

    const endPublicationBtn = this.elements.endPublicationBtn;
    let originalButtonContent = '';
    if (endPublicationBtn) {
      originalButtonContent = endPublicationBtn.innerHTML;
      endPublicationBtn.disabled = true;
      endPublicationBtn.innerHTML = `
        <svg class="w-3 h-3 animate-spin inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        å…¬é–‹çµ‚äº†ä¸­...
      `;
    }

    const self = this;

    google.script.run
      .withSuccessHandler(function(result) {

        self.clearCache({ includeReactions: true, includeLocalStorage: true });

        google.script.history.replace(null, {}, window.location.href);
      })
      .withFailureHandler(function(error) {
        console.error('âŒ å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);

        let errorMsg = 'å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ';
        if (error && error.message) {
          errorMsg += ': ' + error.message;
        } else if (typeof error === 'string') {
          errorMsg += ': ' + error;
        }

        if (window.sharedModals) {
          window.sharedModals.showAlert('ã‚¨ãƒ©ãƒ¼', errorMsg, 'error');
        } else if (window.notifications) {
          window.notifications.error(errorMsg, 7000);
        } else {
          alert(errorMsg);
        }

        if (endPublicationBtn && originalButtonContent) {
          endPublicationBtn.disabled = false;
          endPublicationBtn.innerHTML = originalButtonContent;
        }
      })
      .clearActiveSheet(this.state.userId);
  }
  
  
  /**
   * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’localStorageã«ä¿å­˜
   * @param {number} rowIndex - è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   * @param {object} reactions - ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  saveReactionState(rowIndex, reactions) {
    try {
      const existingData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      
      existingData[rowIndex] = {};
      Object.keys(reactions).forEach(reactionType => {
        const reaction = reactions[reactionType];
        if (reaction && reaction.reacted) {
          existingData[rowIndex][reactionType] = {
            reacted: true,
            timestamp: new Date().toISOString()
          };
        }
      });
      
      if (Object.keys(existingData[rowIndex]).length === 0) {
        delete existingData[rowIndex];
      }
      
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(existingData));
    } catch (error) {
      console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ä¿å­˜ã«å¤±æ•—:', error);
    }
  }
  
  /**
   * localStorageã‹ã‚‰ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿
   * @returns {object} ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹
   */
  loadReactionState() {
    try {
      const savedData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      return savedData;
    } catch (error) {
      console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
      return {};
    }
  }
  
  /**
   * ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«é©ç”¨
   * @param {array} answers - å›ç­”ãƒ‡ãƒ¼ã‚¿é…åˆ—
   */
  applyReactionState(answers) {
    const savedReactions = this.loadReactionState();
    let modified = false;

    answers.forEach(answer => {
      if (!savedReactions[answer.rowIndex]) {
        savedReactions[answer.rowIndex] = {};
      }
      const savedReaction = savedReactions[answer.rowIndex];

      if (answer.reactions) {
        Object.keys(answer.reactions).forEach(reactionType => {
          const info = answer.reactions[reactionType];
          if (!info) return;

          const serverReacted = !!info.reacted;
          const localReacted = !!savedReaction[reactionType];

          info.reacted = serverReacted;

          if (serverReacted) {
            if (!localReacted) {
              if (!savedReactions[answer.rowIndex]) {
                savedReactions[answer.rowIndex] = {};
              }
              savedReactions[answer.rowIndex][reactionType] = {
                reacted: true,
                timestamp: new Date().toISOString()
              };
              modified = true;
            }
          } else if (localReacted) {
            delete savedReaction[reactionType];
            modified = true;
          }

          if (Object.keys(savedReaction).length === 0) {
            delete savedReactions[answer.rowIndex];
          }

            serverReacted,
            localReacted,
            finalReacted: info.reacted,
            timestamp: new Date().toISOString()
          });
        });
      }
    });

    if (modified) {
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(savedReactions));
    }

  }

  updateModalReactionButtons(item) {
    if (!this.elements.modalReactionContainer) return;
    
    this.reactionTypes.forEach(rt => {
      const info = item.reactions?.[rt.key] || { count: 0, reacted: false };
      const modalBtn = this.elements.modalReactionContainer.querySelector(`[data-reaction="${rt.key}"]`);
      
      if (modalBtn) {
        const countEl = modalBtn.querySelector('.reaction-count');
        if (countEl && this.state.showCounts) {
          countEl.textContent = info.count;
        }
        
        const svgEl = modalBtn.querySelector('svg');
        if (svgEl) {
          const newIcon = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);
          svgEl.outerHTML = newIcon;
        }
        
        const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
        modalBtn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
        modalBtn.classList.add(colorClass);
        modalBtn.classList.toggle('reacted', info.reacted);
        modalBtn.setAttribute('aria-pressed', info.reacted.toString());
        
        const reactionNames = { 'LIKE': 'ã„ã„ã­ï¼', 'UNDERSTAND': 'ãªã‚‹ã»ã©ï¼', 'CURIOUS': 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼' };
        const reactionName = reactionNames[rt.key] || rt.key;
        const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count}ä»¶)` : ''}`;
        modalBtn.setAttribute('aria-label', ariaLabel);
      }
    });
  }
  applyUpdates(items) {
    const itemsToUpdate = items.filter(item => {
      const updateKey = `apply_update_${item.rowIndex}`;
      const currentHash = this.calculateStateHash(item);
      const lastHash = this.lastApplyStates?.get(updateKey);
      
      if (lastHash === currentHash) {
        return false; // å¤‰æ›´ãªã— - ã‚¹ã‚­ãƒƒãƒ—
      }
      
      if (!this.lastApplyStates) this.lastApplyStates = new Map();
      this.lastApplyStates.set(updateKey, currentHash);
      return true; // å¤‰æ›´ã‚ã‚Š - æ›´æ–°å¯¾è±¡
    });
    
    if (itemsToUpdate.length === 0) {
      return;
    }
    

    const reactionUpdates = [];
    
    itemsToUpdate.forEach(item => {
      this.reactionTypes.forEach(rt => {
        const reaction = item.reactions && item.reactions[rt.key] ? item.reactions[rt.key] : { count: 0, reacted: false };
        reactionUpdates.push({
          rowIndex: item.rowIndex,
          reaction: rt.key,
          count: reaction.count,
          reacted: reaction.reacted,
          shouldDisplay: true  // âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã¯å¸¸ã«è¡¨ç¤ºï¼ˆUIä¸€è²«æ€§ã®ãŸã‚ï¼‰
        });
      });
      const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
      if (card) {
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('reacted', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          const label = item.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
          highlightBtn.setAttribute('aria-label', label);
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            const newIcon = this.getIcon('star', 'w-5 h-5', item.highlight);
            svgEl.outerHTML = newIcon;
          }
        }
        let badge = card.querySelector('.highlight-badge');
        if (item.highlight && !badge) {
          card.appendChild(this.createHighlightBadge());
        } else if (!item.highlight && badge) {
          badge.remove();
        }
      }
    });

    if (reactionUpdates.length > 0) {
      this.batchUpdateReactionButtons(reactionUpdates);
    }
  }
  showAnswerModal(rowIndex) {


    let data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);

    if (!data && this.state.filteredData) {
      data = this.state.filteredData.find(r => r.rowIndex == rowIndex);
    }

    if (!data) {
      return;
    }

    this.state.lastFocusedElement = document.activeElement;
    let modalHtml = '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + window.sharedUtilities.security.escapeHtml(data.opinion || '') + '</p>';

    if (data.reason && data.reason.trim()) {
      modalHtml += '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + window.sharedUtilities.security.escapeHtml(data.reason) + '</p>';
    }

    this.elements.modalAnswer.innerHTML = modalHtml;
    const showName = this.state.displayMode === 'named';
    let modalDisplayName = '';
    
      displayMode: this.state.displayMode,
      showName,
      showAdminFeatures: this.state.showAdminFeatures,
      isAdminUser: this.state.isAdminUser,
      dataName: data.name,
      dataEmail: data.email
    });
    
    if (showName) {
      if (data.name) {
        modalDisplayName = data.name;
      } else if (data.email) {
        modalDisplayName = data.email.split('@')[0];
      }
    }
    
    this.elements.modalStudentName.textContent = modalDisplayName;
    const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
    this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'reacted' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'reacted' : '';
      const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions,
      element: this.elements.answerModalCard.className
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
      className: this.elements.answerModalCard.className
    });
    
    this.elements.answerModalContainer.classList.remove('hidden');
    this.elements.answerModalContainer.classList.add('modal-fade');
    this.elements.answerModalCard.classList.add('modal-scale');
    
    this.elements.answerModalCloseBtn.focus();
  }
  updateModalContent(data) {
    if (!data) return;
    
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'reacted' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'reacted' : '';
      const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
  }
  hideAnswerModal() {
    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalContainer.classList.remove('modal-fade');
    this.elements.answerModalCard.classList.remove('modal-scale');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  showInfoModal() {
    this.state.lastFocusedElement = document.activeElement;
    this.elements.infoModalContainer.classList.remove('hidden');
    this.elements.infoModalContainer.classList.add('modal-fade');
    this.elements.infoModalCard.classList.add('modal-scale');
    
    this.elements.infoModalCard.scrollTop = 0;
    requestIdleCallback(() => {
      this.elements.infoModalConfirmBtn.focus();
    }, { timeout: 100 });
  }
  hideInfoModal() {
    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalContainer.classList.remove('modal-fade');
    this.elements.infoModalCard.classList.remove('modal-scale');
    
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  getIcon(name, classes = '', solid = false) {
    if (!window.ICONS) {
      console.warn('âŒ window.ICONS not available');
      return '<svg class="' + classes + '" aria-hidden="true">â­</svg>';
    }

    const key = solid ? name + '-solid' : name + '-outline';
    const icon = window.ICONS[key] || window.ICONS[name];

    if (!icon) {
      console.warn('âŒ Icon not found, using fallback');
      return '<svg class="' + classes + '" aria-hidden="true">â­</svg>';
    }

    const result = icon.replace('<svg', `<svg class="${classes}" aria-hidden="true"`);
    return result;
  }


  renderIcons() {
    if (this.elements.infoIconLike) {
      this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
    }
    if (this.elements.infoIconUnderstand) {
      this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
    }
    if (this.elements.infoIconCurious) {
      this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
    }
    if (this.elements.infoIconHighlight) {
      this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
    }
    if (this.elements.iconClose) {
      this.elements.iconClose.innerHTML = this.getIcon('x');
    }
    if (this.elements.iconGrid) {
      this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
    }
  }
  debounce(func, delay) {
    const key = `studyquest-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.debounce.debounce(() => func.apply(this, args), key, delay);
    };
  }
  
  throttle(func, delay) {
    const key = `studyquest-throttle-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.throttle.throttle(() => func.apply(this, args), key, delay);
    };
  }

  /**
   * ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®èƒŒæ™¯å¡—ã‚Šã¤ã¶ã—æ›´æ–°
   * @param {HTMLInputElement} slider - ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¦ç´ 
   */
  updateSliderBackground(slider) {
    if (!slider) return;

    const min = parseFloat(slider.min) || 2;
    const max = parseFloat(slider.max) || 6;
    const value = parseFloat(slider.value) || 4;

    const percentage = ((value - min) / (max - min)) * 100;

    slider.style.backgroundImage = `linear-gradient(var(--brand-primary), var(--brand-primary))`;
    slider.style.backgroundSize = `${percentage}% 100%`;
    slider.style.backgroundRepeat = 'no-repeat';

  }

  updateSortOptions() {
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.style.display = 'block';
      } else {
        this.elements.scoreOption.style.display = 'none';
        const filterState = this.getCurrentFilterState();
        if (filterState.sortOrder === 'score') {
          this.elements.sortOrder.value = 'newest';
        }
      }
    }
  }
  updateConfigFromGlobals() {
    this.state.isStudentMode = window.isStudentMode;
    this.state.showCounts = window.showCounts;
    this.state.displayMode = window.displayMode;
    this.state.showAdminFeatures = window.showAdminFeatures;
    this.state.showHighlightToggle = this.state.showAdminFeatures;
    this.state.showScoreSort = window.showCounts;
    this.state.showPublishControls = window.showPublishControls;
  }


  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measurePerformance = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      if (frameCount > 0) {
        this.perf.frameTime = delta;
        
        if (delta > getPerformanceBudget() && !this.isLowPerformanceMode) {
          console.warn('Low performance detected, enabling optimizations');
          this.isLowPerformanceMode = true;
          this.optimizeForLowPerformance();
        }
      }
      
      lastTime = now;
      frameCount++;
      
      if (frameCount < 60) { // Monitor first 60 frames
        requestAnimationFrame(measurePerformance);
      }
    };
    
    requestAnimationFrame(measurePerformance);
  }

  optimizeForLowPerformance() {
    
    document.documentElement.style.setProperty('--transition-duration', '0.1s');
    document.documentElement.style.setProperty('--animation-duration', '0.1s');
    document.documentElement.style.setProperty('--backdrop-blur', '4px');
    
    const style = document.createElement('style');
    style.id = 'low-performance-optimizations';
    style.textContent = `
      /* Low-performance optimizations with appropriate specificity */
      body.low-performance .glass-panel {
        -webkit-backdrop-filter: blur(4px);
        backdrop-filter: blur(4px);
        background: var(--brand-surface);
      }

      /* Simplify hover effects for low-performance devices */
      body.low-performance .answer-card:hover {
        transform: none;
        box-shadow: var(--shadow-sm);
      }

      body.low-performance .reaction-btn:hover {
        transform: scale(1.02);
      }

      body.low-performance .game-btn:hover {
        transform: translateY(-1px);
      }

      /* Remove will-change to reduce GPU usage */
      body.low-performance * {
        will-change: auto;
      }

      /* Simplify shadows */
      body.low-performance .answer-card {
        box-shadow: var(--shadow-sm);
      }

    `;
    document.head.appendChild(style);
    
    document.body.classList.add('low-performance');
    
  }

  setupObservers() {
    if ('IntersectionObserver' in window) {
      const debouncedVisibilityHandler = this.debounce((entries) => {
        const cardChanges = new Map();
        
        entries.forEach(entry => {
          const card = entry.target;
          const rowIndex = card.dataset.rowIndex;
          
          cardChanges.set(rowIndex, { card, entry });
        });
        
        cardChanges.forEach(({ card, entry }) => {
          if (entry.isIntersecting) {
            if (!card.classList.contains('visible')) {
              card.classList.add('visible');
              card.classList.remove('hidden-card');
              if (card.style.visibility === 'hidden') {
                card.style.visibility = 'visible';
              }
              if (card.style.display === 'none') {
                card.style.display = '';
              }
            }
          } else {
            if (entry.intersectionRatio === 0 && card.classList.contains('visible')) {
              card.classList.remove('visible');
              card.classList.add('hidden-card');
            }
          }
        });
      }, 50); // Increased debounce to 50ms for better stability
      
      this.visibilityObserver = new IntersectionObserver(debouncedVisibilityHandler, {
        rootMargin: `${window.getViewportBuffer()}px`,
        threshold: [0, 1.0] // Simplified thresholds: fully out vs fully in
      });
    }

    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(this.debounce(() => {
        this.adjustLayout();
      }, 100));
      this.resizeObserver.observe(this.elements.answersContainer);
    }
  }

  deferredRender(callback, priority = 'normal') {
    if (this.isLowPerformanceMode) {
      this.idleCallbackId = requestIdleCallback(callback, { timeout: getIdleTimeout() });
    } else {
      this.animationFrameId = requestAnimationFrame(callback);
    }
  }

  batchDOMUpdates(updates) {
    if (!updates || updates.length === 0) return;

    const fragment = this.getReusableFragment();
    const CHUNK_SIZE = 8; // Optimal chunk size for 70x performance
    let processedCount = 0;

    const processBatch = () => {
      const startTime = performance.now();
      const chunkEnd = Math.min(processedCount + CHUNK_SIZE, updates.length);

      for (let i = processedCount; i < chunkEnd; i++) {
        const update = updates[i];
        if (typeof update === 'function') {
          update.call(this, fragment);
        } else if (update && update.element && update.operation) {
          this.executeDOMOperation(update, fragment);
        }
      }

      processedCount = chunkEnd;

      if (processedCount < updates.length) {
        if (performance.now() - startTime < getPerformanceBudget()) {
          requestIdleCallback(processBatch, { timeout: 0 });
        } else {
          requestAnimationFrame(processBatch);
        }
      } else {
        this.recycleFragment(fragment);
      }
    };

    processBatch();
  }

  executeDOMOperation(update, fragment) {
    const { element, operation, data } = update;
    if (!element || !operation) return;

    switch (operation) {
      case 'append':
        if (data && data.content) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = data.content;
          while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
          }
          element.appendChild(fragment);
        }
        break;
      case 'update':
        if (data && data.html) {
          element.innerHTML = data.html;
        } else if (data && data.text) {
          element.textContent = data.text;
        }
        break;
      case 'setAttribute':
        if (data && data.name && data.value !== undefined) {
          element.setAttribute(data.name, data.value);
        }
        break;
      case 'addClass':
        if (data && data.className) {
          element.classList.add(data.className);
        }
        break;
      case 'removeClass':
        if (data && data.className) {
          element.classList.remove(data.className);
        }
        break;
      default:
        if (typeof operation === 'function') {
          operation.call(this, element, data, fragment);
        }
    }
  }

  getReusableFragment() {
    if (this.domFragmentPool.length > 0) {
      return this.domFragmentPool.pop();
    }

    const fragment = document.createDocumentFragment();
    if (this.domFragmentPool.length < 3) {
      for (let i = this.domFragmentPool.length; i < 3; i++) {
        this.domFragmentPool.push(document.createDocumentFragment());
      }
    }
    return fragment;
  }

  recycleFragment(fragment) {
    if (!fragment) return;

    if (fragment.replaceChildren) {
      fragment.replaceChildren(); // Modern browsers - much faster
    } else {
      while (fragment.firstChild) {
        fragment.removeChild(fragment.firstChild);
      }
    }

    if (this.domFragmentPool.length < 8) { // Increased optimal pool size
      this.domFragmentPool.push(fragment);
    }
  }

  throttledUpdate(key, callback, delay = 100) {
    if (this.deferredUpdates.has(key)) {
      return;
    }
    
    this.deferredUpdates.add(key);
    requestIdleCallback(() => {
      callback();
      this.deferredUpdates.delete(key);
    }, { timeout: delay });
  }


  
  setupScrollObserver() {
    if (!this.elements.answersContainer) {
      console.warn('setupScrollObserver: answersContainer not found');
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    if (cards.length === 0) {
      return;
    }
    
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
    }
    
    const debouncedScrollHandler = this.debounce((entries) => {
      const intersectingEntry = entries.find(entry => entry.isIntersecting);
      if (intersectingEntry) {
        this.handleVirtualScroll(intersectingEntry.target);
      }
    }, 150); // 150ms debounce for scroll triggers to prevent rapid firing
    
    this.scrollObserver = new IntersectionObserver(debouncedScrollHandler, {
      root: null,
      rootMargin: '300px', // Increased buffer for even smoother loading
      threshold: 0.1
    });
    
    const observeCount = Math.min(3, cards.length); // Reduced to last 3 cards for better performance
    const observedCards = [];
    
    for (let i = cards.length - observeCount; i < cards.length; i++) {
      if (cards[i] && cards[i].dataset.rowIndex) {
        this.scrollObserver.observe(cards[i]);
        observedCards.push(cards[i].dataset.rowIndex);
      }
    }
    
      totalCards: cards.length,
      observedCount: observedCards.length,
      observedRowIndexes: observedCards,
      totalItems: this.virtualScrollState?.totalItems || 0,
      renderedItems: this.virtualScrollState?.renderedItems || 0
    });
  }
  
  handleVirtualScroll(triggerElement) {
    if (!triggerElement || !this.virtualScrollState) {
      return;
    }
    
    if (this.virtualScrollState.isLoading) {
      return;
    }
    
    const currentCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const totalAvailable = this.state.currentAnswers.length;
    const currentRendered = currentCards.length;
    
      currentRendered,
      totalAvailable,
      triggerRowIndex: triggerElement.dataset.rowIndex
    });
    
    if (currentRendered < totalAvailable) {
      this.loadMoreItems();
    } else {
      this.optimizeVisibleElements();
    }
  }
  
  loadMoreItems() {
    if (this.virtualScrollState.isLoading) {
      return;
    }
    
    this.virtualScrollState.isLoading = true;
    
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
      const existingCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      existingCards.forEach(card => {
        if (card.dataset.rowIndex) {
          this.virtualScrollState.renderedRowIndexes.add(card.dataset.rowIndex);
        }
      });
    }
    
    const dynamicBatchSize = getDynamicBatchSize(this.performanceMetrics);
    const batchSize = this.isLowPerformanceMode ? Math.min(CHUNK_SIZE, dynamicBatchSize) : dynamicBatchSize;
    
    const unrenderedItems = this.state.currentAnswers.filter(item => 
      !this.virtualScrollState.renderedRowIndexes.has(String(item.rowIndex))
    );
    
    const remainingItems = unrenderedItems.slice(0, batchSize);
    
    if (remainingItems.length === 0) {
      this.virtualScrollState.isLoading = false;
      return;
    }
    
      'Total rendered:', this.virtualScrollState.renderedRowIndexes.size, 'Total available:', this.state.currentAnswers.length);
    
    this.deferredRender(() => {
      this.renderAdditionalItems(remainingItems);
    });
  }
  
  renderAdditionalItems(items) {
    if (!items || items.length === 0) {
      this.virtualScrollState.isLoading = false;
      return;
    }
    
    const fragment = this.getReusableFragment();
    const changedItems = [];
    let successfullyCreated = 0;
    
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
    }
    
    items.forEach((item) => {
      const rowIndexStr = String(item.rowIndex);
      
      if (this.virtualScrollState.renderedRowIndexes.has(rowIndexStr)) {
        return;
      }
      
      const card = this.createAnswerCard(item);
      if (card) {
        card.classList.add('new-card');
        
        this.virtualScrollState.renderedRowIndexes.add(rowIndexStr);
        
        if (this.visibilityObserver) {
          this.visibilityObserver.observe(card);
        }
        
        const isLastFew = items.indexOf(item) >= items.length - 3;
        if (isLastFew && this.scrollObserver) {
          this.scrollObserver.observe(card);
        }
        
        fragment.appendChild(card);
        changedItems.push(item);
        successfullyCreated++;
      } else {
        console.warn('renderAdditionalItems: Failed to create card for item:', item.rowIndex);
      }
    });
    
    if (fragment.children.length > 0) {
      this.elements.answersContainer.appendChild(fragment);
      
      this.virtualScrollState.renderedItems = this.elements.answersContainer.children.length;
      
        this.virtualScrollState.renderedRowIndexes.size, 'DOM children:', this.virtualScrollState.renderedItems);
    } else {
    }
    
    if (changedItems.length > 0) {
      this.deferredRender(() => this.applyUpdates(changedItems));
    }
    
    this.recycleFragment(fragment);
    
    this.virtualScrollState.isLoading = false;
    
    this.validateVirtualScrollState();
  }
  
  validateVirtualScrollState() {
    if (!this.virtualScrollState || !this.virtualScrollState.renderedRowIndexes) {
      return;
    }
    
    const domCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const domRowIndexes = new Set();
    
    domCards.forEach(card => {
      if (card.dataset.rowIndex) {
        domRowIndexes.add(card.dataset.rowIndex);
      }
    });
    
    const trackedCount = this.virtualScrollState.renderedRowIndexes.size;
    const domCount = domRowIndexes.size;
    const totalAvailable = this.state.currentAnswers.length;
    
    const missingInDOM = [...this.virtualScrollState.renderedRowIndexes].filter(x => !domRowIndexes.has(x));
    const extraInDOM = [...domRowIndexes].filter(x => !this.virtualScrollState.renderedRowIndexes.has(x));
    
    if (missingInDOM.length > 0 || extraInDOM.length > 0 || trackedCount !== domCount) {
      console.warn('Virtual scroll state inconsistency detected:', {
        trackedCount,
        domCount,
        totalAvailable,
        missingInDOM: missingInDOM.slice(0, 5),
        extraInDOM: extraInDOM.slice(0, 5)
      });
      
      this.virtualScrollState.renderedRowIndexes = domRowIndexes;
      this.virtualScrollState.renderedItems = domCount;
      
    }
  }
  
  optimizeVisibleElements() {
    if (!this.elements.answersContainer || this.virtualScrollState.isLoading) {
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    let hiddenCount = 0;
    let restoredCount = 0;
    const viewportHeight = window.innerHeight;
    const hideThreshold = viewportHeight * 3; // Increased threshold for better UX
    
    if (!this.virtualScrollState.hiddenCards) {
      this.virtualScrollState.hiddenCards = new Set();
    }
    
    cards.forEach((card) => {
      const rect = card.getBoundingClientRect();
      const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
      const rowIndex = card.dataset.rowIndex;
      const isCurrentlyHidden = this.virtualScrollState.hiddenCards.has(rowIndex);
      
      if (!isInViewport && !isCurrentlyHidden) {
        const distanceFromViewport = rect.top > viewportHeight 
          ? rect.top - viewportHeight  // Below viewport
          : -rect.bottom;             // Above viewport
        
        if (distanceFromViewport > hideThreshold) {
          this.hideCard(card, rowIndex);
          hiddenCount++;
        }
      } else if (isInViewport && isCurrentlyHidden) {
        this.restoreCard(card, rowIndex);
        restoredCount++;
      }
    });
    
    if (hiddenCount > 0 || restoredCount > 0) {
    }
  }
  
  hideCard(card, rowIndex) {
    card.classList.add('hidden-card');
    card.classList.remove('visible-card');
    this.virtualScrollState.hiddenCards.add(rowIndex);
    
    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(card);
    }
    if (this.scrollObserver) {
      this.scrollObserver.unobserve(card);
    }
  }
  
  restoreCard(card, rowIndex) {
    card.classList.remove('hidden-card');
    card.classList.add('visible-card');
    this.virtualScrollState.hiddenCards.delete(rowIndex);
    
    if (this.visibilityObserver) {
      this.visibilityObserver.observe(card);
    }
    
    const allCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const cardIndex = Array.from(allCards).indexOf(card);
    const isLastFew = cardIndex >= allCards.length - 3;
    
    if (isLastFew && this.scrollObserver) {
      this.scrollObserver.observe(card);
    }
  }
  

  /**
   * ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆã®å …ç‰¢åŒ–æ¤œè¨¼
   * @param {any} reason - ç†ç”±ãƒ‡ãƒ¼ã‚¿
   * @returns {string} æ¤œè¨¼æ¸ˆã¿ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆ
   */
  validateReasonText(reason) {
    try {
      if (!reason && reason !== 0) {
        return '';
      }

      const reasonStr = String(reason).trim();
      
      if (reasonStr.length > 10000) {
        console.warn('validateReasonText: Reason text too long, truncating:', reasonStr.length);
        return reasonStr.substring(0, 10000) + '...';
      }
      
      if (reasonStr.includes('<') || reasonStr.includes('>') || reasonStr.includes('&')) {
        console.warn('validateReasonText: Potentially unsafe HTML content detected');
      }
      
      return reasonStr;
    } catch (error) {
      console.error('validateReasonText: Error validating reason text:', error);
      return ''; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºæ–‡å­—åˆ—ã‚’è¿”ã™
    }
  }

  /**
   * ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ¤œè¨¼
   * @returns {Promise<Object>} æ¤œè¨¼çµæœ
   */
  async validData() {
    try {
      
      const validationResults = {
        timestamp: new Date().toISOString(),
        totalCards: 0,
        validCards: 0,
        invalidCards: 0,
        reasonFieldIssues: 0,
        headerIssues: 0,
        errors: []
      };

      const cards = this.elements.answersContainer?.querySelectorAll('.answer-card') || [];
      validationResults.totalCards = cards.length;

      cards.forEach((card, index) => {
        try {
          const rowIndex = card.dataset.rowIndex;
          const opinionElement = card.querySelector('.opinion-text');
          const reasonElement = card.querySelector('.answer-preview p');
          
          if (!opinionElement || !rowIndex) {
            validationResults.invalidCards++;
            validationResults.errors.push(`Card ${index}: Missing essential elements`);
            return;
          }

          const hasReasonData = this.state.currentAnswers.find(a => a.rowIndex == rowIndex)?.reason;
          const hasReasonElement = reasonElement && reasonElement.textContent.trim();
          
          if (hasReasonData && !hasReasonElement) {
            validationResults.reasonFieldIssues++;
            validationResults.errors.push(`Card ${index} (row ${rowIndex}): Reason data exists but not displayed`);
          }
          
          validationResults.validCards++;
        } catch (cardError) {
          validationResults.invalidCards++;
          validationResults.errors.push(`Card ${index}: Validation error - ${cardError.message}`);
        }
      });

      try {
        const headerValidation = await this.runGas('validateHeaderIntegrity', this.state.userId);
        if (!headerValidation.success) {
          validationResults.headerIssues++;
          validationResults.errors.push(`Header validation failed: ${headerValidation.error}`);
        }
      } catch (headerError) {
        validationResults.headerIssues++;
        validationResults.errors.push(`Header validation error: ${headerError.message}`);
      }

      const issueCount = validationResults.invalidCards + validationResults.reasonFieldIssues + validationResults.headerIssues;
      if (issueCount > 0) {
        console.warn('âš ï¸ Board data integrity issues detected:', validationResults);
        
        if (validationResults.reasonFieldIssues > 0) {
          await this.autoRecoverReasonFields();
        }
      } else {
      }

      return validationResults;
    } catch (error) {
      console.error('âŒ Board data integrity validation failed:', error);
      return {
        timestamp: new Date().toISOString(),
        error: error.message,
        success: false
      };
    }
  }

  /**
   * ç†ç”±åˆ—ã®è‡ªå‹•ä¿®å¾©å‡¦ç†
   */
  async autoRecoverReasonFields() {
    try {
      
      
      await this.loadBoardData();
      
    } catch (error) {
      console.error('âŒ Automatic reason field recovery failed:', error);
    }
  }

  /**
   * ğŸ”§ APIå¿œç­”ã‹ã‚‰displaySettingsã‚’å‹•çš„æ›´æ–°
   * @param {Object} newDisplaySettings - æ–°ã—ã„è¡¨ç¤ºè¨­å®š
   */
  updateDisplaySettingsFromAPI(newDisplaySettings) {
    if (!newDisplaySettings || typeof newDisplaySettings !== 'object') {
      return;
    }

    if (window.showAdminFeatures) {
      return;
    }

    const oldShowCounts = window.showCounts;
    const oldDisplayMode = window.displayMode;

    window.showCounts = newDisplaySettings.showReactions || false;
    window.displayMode = newDisplaySettings.showNames ? 'named' : 'anonymous';

    this.state.showCounts = window.showCounts;
    this.state.displayMode = window.displayMode;

    if (oldShowCounts !== window.showCounts || oldDisplayMode !== window.displayMode) {
      this.clearCache();
      this.renderWithCurrentData();
    }
  }

  /**
   * ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã§ç”»é¢ã‚’å†æç”»ã™ã‚‹
   * è¡¨ç¤ºè¨­å®šå¤‰æ›´æ™‚ã‚„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å¾Œã®å†æç”»ã«ä½¿ç”¨
   */
  renderWithCurrentData() {
    try {
      this.renderBoard(false, false);
    } catch (error) {
      console.error('âŒ renderWithCurrentData failed:', error);
    }
  }

}

/**
 * ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
 */
async function loadFormLink() {
  try {
    const formInfo = await new Promise((resolve, reject) => {
      if (!google?.script?.run?.getActiveFormInfo) {
        console.warn('getActiveFormInfo function not available, skipping form link');
        resolve(null);
        return;
      }

      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          console.warn('getActiveFormInfo failed:', error);
          resolve(null);
        })
        .getActiveFormInfo(window.UNIFIED_CONFIG?.userId);
    });

    const formLinkBtn = document.getElementById('form-link-btn');
    if (formLinkBtn) {
      if (formInfo && formInfo.shouldShow) {
        formLinkBtn.href = formInfo.formUrl;
        formLinkBtn.classList.remove('hidden');

        const formTitleSpan = formLinkBtn.querySelector('span');
        if (formTitleSpan) {
          formTitleSpan.textContent = `ğŸ“ ${formInfo.formTitle}`;
        }
      } else {
        formLinkBtn.classList.add('hidden');
      }
    }
  } catch (error) {
    console.warn('ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    const formLinkBtn = document.getElementById('form-link-btn');
    if (formLinkBtn) {
      formLinkBtn.classList.add('hidden');
    }
  }
}

try {
  if (!window.studyQuestApp) {
    document.addEventListener('DOMContentLoaded', () => {
      if (window.studyQuestApp) {
        return;
      }

      const app = new StudyQuestApp();
      window.studyQuestApp = app;
    });
  }

  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
  });
} catch (error) {
  console.error('Error creating StudyQuestApp instance:', error);
  const container = document.getElementById('answers');
  if (container) {
    const msg = window.sharedUtilities.security.escapeHtml(error.message || '');
    container.innerHTML = '<div class="text-red-400 p-4">ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + msg + '</div>';
  }
}

</script>