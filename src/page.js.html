<script>
  // Dynamic performance-based batch sizing
  const PERFORMANCE_CONFIG = Object.freeze({
    BASE_RENDER_BATCH_SIZE: 150, // Base batch size for normal performance (optimized for medium datasets)
    LOW_PERF_BATCH_SIZE: 100, // Reduced batch size for low performance devices
    HIGH_PERF_BATCH_SIZE: 200, // Increased batch size for high performance devices
    VIEWPORT_BUFFER: 200, // Viewport buffer for virtual scrolling
    PERFORMANCE_BUDGET: 16, // Maximum ms per frame (60fps)
    CHUNK_SIZE: 5, // DOM operations per chunk
    IDLE_TIMEOUT: 5000, // Idle timeout for cleanup
  });

  // Dynamic batch size calculation based on device performance
  const getDynamicBatchSize = (performanceMetrics = {}) => {
    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const frameTime = performanceMetrics.frameTime || 16;

    // High performance: plenty of memory, many cores, fast frame time
    if (memory >= 8 && cores >= 8 && frameTime < 12) {
      return PERFORMANCE_CONFIG.HIGH_PERF_BATCH_SIZE;
    }

    // Low performance: limited memory, few cores, slow frame time
    if (memory <= 2 || cores <= 2 || frameTime > 20) {
      return PERFORMANCE_CONFIG.LOW_PERF_BATCH_SIZE;
    }

    // Normal performance
    return PERFORMANCE_CONFIG.BASE_RENDER_BATCH_SIZE;
  };

  // Get optimal batch size for current device
  const RENDER_BATCH_SIZE = getDynamicBatchSize();
  const ICONS = Object.freeze({
    'lightbulb-outline':
      '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5 M5.25 6.75L4.2 5.7 M18.75 6.75l1.05-1.05 M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M9 16.5h6v4H9v-4zm0 1h6zm0 1h6z M10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
    'lightbulb-solid':
      '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5 M5.25 6.75L4.2 5.7 M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
    'hand-thumb-up-outline':
      '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
    'hand-thumb-up-solid':
      '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
    'magnifying-glass-plus-outline':
      '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z M10.5 7.5v6m3-3h-6"/></svg>',
    'magnifying-glass-plus-solid':
      '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    x: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
    'star-outline':
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
    'star-solid':
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
    'grid-2x2':
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
    users:
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>',
    trash:
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c0-1-1-2-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c0 1 1 2 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>',
    loading:
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin"><path d="M21 12a9 9 0 11-6.219-8.56"/></svg>',
    'alert-triangle':
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></svg>',
  });

  class UnifiedCache {
    constructor() {
      this.data = new Map();
      this.timestamps = new Map();
    }

    set(key, value, ttl = 300000) {
      // 5åˆ†ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆTTL
      this.data.set(key, value);
      this.timestamps.set(key, Date.now() + ttl);
    }

    get(key) {
      if (!this.data.has(key)) return undefined;

      const expiry = this.timestamps.get(key);
      if (expiry && Date.now() > expiry) {
        this.delete(key);
        return undefined;
      }

      return this.data.get(key);
    }

    has(key) {
      return this.get(key) !== undefined;
    }

    delete(key) {
      this.data.delete(key);
      this.timestamps.delete(key);
    }

    clear() {
      this.data.clear();
      this.timestamps.clear();
    }

    cleanup() {
      const now = Date.now();
      for (const [key, expiry] of this.timestamps.entries()) {
        if (now > expiry) {
          this.delete(key);
        }
      }
    }

    get size() {
      return this.data.size;
    }
  }

  /**
   * ğŸš€ RequestManager - 429ã‚¨ãƒ©ãƒ¼è§£æ¶ˆã®ãŸã‚ã®é«˜åº¦ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆ¶å¾¡
   * æœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã§æœ€å¤§åŠ¹æœã‚’ç™ºæ®ã™ã‚‹è»½é‡å®Ÿè£…
   */
  class RequestManager {
    constructor() {
      this.queue = [];
      this.processing = false;
      this.delay = 500; // 500msé–“éš”ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Ÿè¡Œ
      this.cache = new Map(); // ãƒªã‚¯ã‚¨ã‚¹ãƒˆçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥
      this.retryConfig = { maxRetries: 3, baseDelay: 1000 }; // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
    }

    /**
     * âš¡ ãƒ¡ã‚¤ãƒ³API - google.script.runå‘¼ã³å‡ºã—ã‚’åˆ¶å¾¡
     * @param {Function} apiCall - google.script.runé–¢æ•°
     * @param {string} cacheKey - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ï¼ˆçœç•¥å¯ï¼‰
     * @param {number} cacheTTL - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç”Ÿå­˜æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ5åˆ†ï¼‰
     */
    async execute(apiCall, cacheKey = null, cacheTTL = 300000) {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ï¼ˆé«˜é€ŸåŒ–ï¼‰
      if (cacheKey && this.cache.has(cacheKey)) {
        const cached = this.cache.get(cacheKey);
        if (Date.now() < cached.expiry) {
          console.log('ğŸš€ RequestManager: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ', cacheKey);
          return cached.data;
        }
        this.cache.delete(cacheKey);
      }

      return new Promise((resolve, reject) => {
        this.queue.push({
          apiCall,
          resolve,
          reject,
          cacheKey,
          cacheTTL,
          retries: 0,
          timestamp: Date.now(),
        });
        this.processQueue();
      });
    }

    /**
     * ğŸ”„ ã‚­ãƒ¥ãƒ¼å‡¦ç† - 500msé–“éš”ã§é †æ¬¡å®Ÿè¡Œ
     */
    async processQueue() {
      if (this.processing || this.queue.length === 0) return;

      this.processing = true;

      try {
        const request = this.queue.shift();

        try {
          const result = await request.apiCall();

          // ğŸ›¡ï¸ æœ‰åŠ¹ãªçµæœã®ã¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
          if (request.cacheKey && this.shouldCacheResult(result)) {
            this.cache.set(request.cacheKey, {
              data: result,
              expiry: Date.now() + request.cacheTTL,
            });
            console.log('ğŸ’¾ RequestManager: çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥', request.cacheKey);
          } else if (request.cacheKey) {
            console.warn('âš ï¸ RequestManager: ç„¡åŠ¹ãªçµæœã®ãŸã‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¾ã›ã‚“', {
              cacheKey: request.cacheKey,
              resultType: typeof result,
              isNull: result === null,
            });
          }

          request.resolve(result);
        } catch (error) {
          // 429ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
          if (this.shouldRetry(error, request)) {
            await this.retryRequest(request);
          } else {
            console.error('âŒ RequestManager: APIå‘¼ã³å‡ºã—å¤±æ•—', error.message);
            request.reject(error);
          }
        }

        // 429ã‚¨ãƒ©ãƒ¼å¯¾ç­–: 500mså¾…æ©Ÿ
        await new Promise((resolve) => setTimeout(resolve, this.delay));
      } finally {
        this.processing = false;

        // æ¬¡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
        if (this.queue.length > 0) {
          this.processQueue();
        }
      }
    }

    /**
     * ğŸ” ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š
     */
    shouldRetry(error, request) {
      if (request.retries >= this.retryConfig.maxRetries) return false;

      // 429, 502, 503ã‚¨ãƒ©ãƒ¼ã¯ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡
      const retryableErrors = ['429', '502', '503', 'timeout', 'network'];
      return retryableErrors.some((errorType) => error.message?.toLowerCase().includes(errorType));
    }

    /**
     * â° æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§ãƒªãƒˆãƒ©ã‚¤
     */
    async retryRequest(request) {
      request.retries++;
      const retryDelay = this.retryConfig.baseDelay * Math.pow(2, request.retries - 1);

      console.log(
        `ğŸ”„ RequestManager: ãƒªãƒˆãƒ©ã‚¤ ${request.retries}/${this.retryConfig.maxRetries} (${retryDelay}mså¾Œ)`
      );

      setTimeout(() => {
        this.queue.unshift(request); // å„ªå…ˆå‡¦ç†ã®ãŸã‚å…ˆé ­ã«è¿½åŠ 
        this.processQueue();
      }, retryDelay);
    }

    /**
     * ğŸ›¡ï¸ çµæœãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ä¾¡å€¤ãŒã‚ã‚‹ã‹ã‚’åˆ¤å®š
     * @param {*} result - APIå‘¼ã³å‡ºã—ã®çµæœ
     * @returns {boolean} ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã¹ãã‹ã©ã†ã‹
     */
    shouldCacheResult(result) {
      // null ã‚„ undefined ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„
      if (result === null || result === undefined) {
        return false;
      }

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€statusãŒerrorãªã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„
      if (typeof result === 'object' && result.status === 'error') {
        return false;
      }

      // é…åˆ—ã®å ´åˆã€ç©ºé…åˆ—ã§ã‚‚ä¸€æ™‚çš„ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ï¼ˆé »ç¹ãªå†å–å¾—ã‚’é˜²ããŸã‚ï¼‰
      if (Array.isArray(result)) {
        return true;
      }

      // æ–‡å­—åˆ—ã€æ•°å€¤ã€çœŸå½å€¤ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      if (['string', 'number', 'boolean'].includes(typeof result)) {
        return true;
      }

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§æœ‰åŠ¹ãªstatusã‚’æŒã¤å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      if (typeof result === 'object' && result.status === 'success') {
        return true;
      }

      // ãã®ä»–ã®æœ‰åŠ¹ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆstatusãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãªã„å ´åˆï¼‰
      if (typeof result === 'object') {
        return true;
      }

      return false;
    }

    /**
     * ğŸ§¹ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
     */
    cleanup() {
      const now = Date.now();
      for (const [key, cached] of this.cache.entries()) {
        if (now > cached.expiry) {
          this.cache.delete(key);
        }
      }
    }

    /**
     * ğŸ“Š çµ±è¨ˆæƒ…å ±
     */
    getStats() {
      return {
        queueLength: this.queue.length,
        cacheSize: this.cache.size,
        isProcessing: this.processing,
      };
    }
  }

  class StudyQuestApp {
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®šæ•°
    static CONSTANTS = Object.freeze({
      REACTION_RATE_LIMIT_MS: 500,
      HIGHLIGHT_RATE_LIMIT_MS: 500,
      CACHE_TTL_MS: 1000,
      RETRY_DELAY_MS: 2000,
      POLLING_INTERVAL_MS: 5000,
      INIT_TIMEOUT_MS: 30000,
    });

    // ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­å®šã®é™çš„å‚ç…§ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ï¼‰
    static PERFORMANCE_CONFIG = PERFORMANCE_CONFIG;

    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’æ¤œè¨¼ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤ã‚’æä¾›
     * @param {string} userId - æ¤œè¨¼ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
     * @returns {string} æœ‰åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼IDã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
     */
    validateUserId(userId) {
      // åŸºæœ¬çš„ãªæ¤œè¨¼
      if (!userId || typeof userId !== 'string' || userId.trim() === '') {
        console.warn('âš ï¸ StudyQuestApp: Invalid or empty userId provided:', userId);

        // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰userIdã‚’å–å¾—ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const fallbackUserId = urlParams.get('userId');

          if (fallbackUserId) {
            console.log(
              'âœ… StudyQuestApp: Using fallback userId from URL parameters:',
              fallbackUserId
            );
            return fallbackUserId;
          }
        } catch (error) {
          console.warn(
            'âš ï¸ StudyQuestApp: Failed to get userId from URL parameters:',
            error.message
          );
        }

        // æœ€å¾Œã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        console.error('âŒ StudyQuestApp: No valid userId available. Data loading may fail.');
        return '';
      }

      // UUIDå½¢å¼ã®åŸºæœ¬çš„ãªå½¢å¼ãƒã‚§ãƒƒã‚¯ï¼ˆ36æ–‡å­—ã€ãƒã‚¤ãƒ•ãƒ³ä»˜ãï¼‰
      if (userId.length === 36 && userId.includes('-')) {
        console.log(
          'âœ… StudyQuestApp: Valid userId format detected:',
          userId.substring(0, 8) + '...'
        );
        return userId;
      }

      // ãã®ä»–ã®å½¢å¼ã‚‚è¨±å¯ã™ã‚‹ãŒè­¦å‘Šã‚’å‡ºã™
      console.warn(
        'âš ï¸ StudyQuestApp: Unusual userId format, but proceeding:',
        userId.substring(0, 8) + '...'
      );
      return userId;
    }

    /**
     * ğŸ” ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½æ¤œå‡º - ä½æ€§èƒ½ãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š
     * @returns {boolean} ä½æ€§èƒ½ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦ã‹ã©ã†ã‹
     */
    detectLowEndDevice() {
      try {
        // ãƒ¡ãƒ¢ãƒªæƒ…å ±ï¼ˆä½¿ç”¨å¯èƒ½ãªå ´åˆï¼‰
        const memory = navigator.deviceMemory;
        if (memory && memory <= 2) {
          console.log('ğŸ”‹ ä½ãƒ¡ãƒ¢ãƒªãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º:', memory + 'GB');
          return true;
        }

        // CPU ã‚³ã‚¢æ•°ï¼ˆä½¿ç”¨å¯èƒ½ãªå ´åˆï¼‰
        const cores = navigator.hardwareConcurrency;
        if (cores && cores <= 2) {
          console.log('ğŸ”‹ ä½CPUæ€§èƒ½ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º:', cores + 'ã‚³ã‚¢');
          return true;
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ¤œå‡ºï¼ˆãƒ¢ãƒã‚¤ãƒ«ãƒ»ä½æ€§èƒ½ãƒ‡ãƒã‚¤ã‚¹ï¼‰
        const ua = navigator.userAgent.toLowerCase();
        const lowEndPatterns = [
          'android 4',
          'android 5',
          'android 6', // å¤ã„Android
          'webview', // WebView (é€šå¸¸ä½æ€§èƒ½)
          'mobile.*safari.*version/[89]', // å¤ã„iOSãƒ–ãƒ©ã‚¦ã‚¶
        ];

        if (lowEndPatterns.some((pattern) => new RegExp(pattern).test(ua))) {
          console.log('ğŸ”‹ å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶/OSã‚’æ¤œå‡º');
          return true;
        }

        // æ¥ç¶šé€Ÿåº¦ï¼ˆä½¿ç”¨å¯èƒ½ãªå ´åˆï¼‰
        const connection = navigator.connection;
        if (
          connection &&
          (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g')
        ) {
          console.log('ğŸ”‹ ä½é€Ÿãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¤œå‡º:', connection.effectiveType);
          return true;
        }

        console.log('âœ… æ¨™æº–æ€§èƒ½ãƒ‡ãƒã‚¤ã‚¹');
        return false;
      } catch (error) {
        console.warn('âš ï¸ ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error.message);
        return false; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æ¨™æº–ãƒ¢ãƒ¼ãƒ‰
      }
    }

    constructor() {
      this.cache = new UnifiedCache();
      this.requestManager = new RequestManager(); // ğŸš€ 429ã‚¨ãƒ©ãƒ¼å¯¾ç­–
      this.weakCache = new WeakMap(); // For DOM element caching
      this.performanceMetrics = { frameTime: 0, domOperations: 0 };
      this.visibilityObserver = null;
      this.resizeObserver = null;
      this.deferredUpdates = new Set();
      this.animationFrameId = null;
      this.idleCallbackId = null;
      this.domFragmentPool = [];
      this.isLowPerformanceMode = this.detectLowEndDevice();
      this.elements = Object.freeze({
        body: document.body,
        mainContainer: document.getElementById('main-container'),
        answersContainer: document.getElementById('answers'),
        sizeSlider: document.getElementById('sizeSlider'),
        sliderValue: document.getElementById('sliderValue'),
        headingLabel: document.getElementById('headingLabel'),
        sheetNameText: document.getElementById('sheetNameText'),
        endPublicationBtn: document.getElementById('endPublicationBtn'),
        adminToggleBtn: document.getElementById('adminToggleBtn'),
        answerCount: document.getElementById('answerCount'),
        answerModalContainer: document.getElementById('answerModalContainer'),
        answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
        answerModalCard: document.getElementById('answerModalCard'),
        modalAnswer: document.getElementById('modalAnswer'),
        modalStudentName: document.getElementById('modalStudentName'),
        modalReactionContainer: document.getElementById('modalReactions'),
        modalFooter: document.getElementById('modalFooter'),
        infoModalContainer: document.getElementById('infoModalContainer'),
        infoModalCard: document.getElementById('infoModalCard'),
        infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
        infoIconLike: document.getElementById('infoIconLike'),
        infoIconUnderstand: document.getElementById('infoIconUnderstand'),
        infoIconCurious: document.getElementById('infoIconCurious'),
        infoIconHighlight: document.getElementById('infoIconHighlight'),
        newContentBanner: document.getElementById('newContentBanner'),
        newContentText: document.getElementById('newContentText'),
        refreshContentBtn: document.getElementById('refreshContentBtn'),
        dismissBannerBtn: document.getElementById('dismissBannerBtn'),
        iconClose: document.getElementById('iconClose'),
        iconGrid: document.getElementById('iconGrid'),
        classFilter: document.getElementById('classFilter'),
        sortOrder: document.getElementById('sortOrder'),
        scoreOption: document.getElementById('scoreOption'),
        footer: document.getElementById('controlsFooter'),
        loadingOverlay: document.getElementById('loading-overlay'),
      });
      this.state = {
        currentAnswers: [],
        isLoading: false,
        lastFocusedElement: null,
        isStudentMode: window.isStudentMode,
        isAdminUser: window.isOwner,
        showCounts: window.showCounts,
        showAdminFeatures: false, // åˆæœŸçŠ¶æ…‹ã¯å¸¸ã«é–²è¦§ãƒ¢ãƒ¼ãƒ‰
        showHighlightToggle: window.isOwner, // æ‰€æœ‰è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
        showScoreSort: window.showScoreSort,
        displayMode: window.displayMode,
        sheetName: SHEET_NAME,
        userId: this.validateUserId(USER_ID), // Validate and add userId to state
        hasNewContent: false,
        newContentCount: 0,
        lastSeenCount: this.loadLastSeenCount(), // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒ
        pollingFailureCount: 0,
        startTime: Date.now(), // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ç”¨
      };

      // æ–°ç€ãƒã‚§ãƒƒã‚¯ç”¨ã®åˆæœŸåŒ–
      this.lastViewKey = null;
      this.initialDataLoaded = false;
      this.hadInitialDataLoadFailure = false; // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°

      // Initial state setup complete
      this.serverShowCounts = window.showCounts;
      this.serverDisplayMode = window.displayMode;
      this.pollingInterval = null;
      this.handlers = {};
      this.adminModeVerified = false; // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®æ¨©é™ç¢ºèªãƒ•ãƒ©ã‚°
      this.reactionDebounce = new Map(); // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ç”¨
      this.highlightDebounce = new Map(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ç”¨
      this.pendingReactions = new Set(); // å‡¦ç†ä¸­ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
      this.reactionQueue = new Map(); // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œã‚­ãƒ¥ãƒ¼
      this.reactionEventListeners = new Map(); // å‡¦ç†å®Œäº†é€šçŸ¥ç”¨
      this.isProcessingReactionQueue = false; // ã‚­ãƒ¥ãƒ¼å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°

      // ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ã—ãªã„è¿½åŠ æ©Ÿèƒ½ï¼‰
      this.enableBatchProcessing = true; // ãƒãƒƒãƒå‡¦ç†æœ‰åŠ¹ãƒ•ãƒ©ã‚°ï¼ˆç°¡å˜ã«ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
      this.reactionBatchQueue = new Map(); // rowIndex -> reactions[] ã®ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼
      this.batchTimer = null; // ãƒãƒƒãƒå‡¦ç†ã‚¿ã‚¤ãƒãƒ¼
      this.BATCH_TIMEOUT = 500; // 500msä»¥å†…ã®æ“ä½œã‚’ãƒãƒƒãƒåŒ–
      this.BATCH_SIZE_LIMIT = 5; // æœ€å¤§ãƒãƒƒãƒã‚µã‚¤ã‚ºï¼ˆæ§ãˆã‚ã«è¨­å®šï¼‰
      this.batchProcessingActive = false; // ãƒãƒƒãƒå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼é‡è¤‡ç™»éŒ²é˜²æ­¢ãƒ•ãƒ©ã‚°
      this.eventDelegationSetup = false;
      this.nonCriticalListenersSetup = false;
      this.modalOperationPending = false;
      this.reactionTypes = [
        { key: 'LIKE', icon: 'hand-thumb-up' },
        { key: 'UNDERSTAND', icon: 'lightbulb' },
        { key: 'CURIOUS', icon: 'magnifying-glass-plus' },
      ];

      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¿å­˜ç”¨ã®ã‚­ãƒ¼
      this.reactionStorageKey = `reactions_${USER_ID}_${SHEET_NAME}`;
      this.gas = {
        getPublishedSheetData: (classFilter, sort, adminMode, bypassCache) =>
          this.runGas(
            'getPublishedSheetData',
            this.state.userId,
            classFilter,
            sort,
            adminMode,
            bypassCache
          ),
        getIncrementalSheetData: (classFilter, sort, adminMode, sinceRowCount) =>
          this.runGas(
            'getIncrementalSheetData',
            this.state.userId,
            classFilter,
            sort,
            adminMode,
            sinceRowCount
          ),
        getAvailableSheets: () => this.runGas('getAvailableSheets', this.state.userId),
        addReactionBatch: (batchOperations) =>
          this.runGas('addReactionBatch', this.state.userId, batchOperations), // æ–°ã—ã„ãƒãƒƒãƒAPI
        addReaction: (rowIndex, reaction, sheetName) =>
          this.runGas('addReaction', this.state.userId, rowIndex, reaction, sheetName),
        toggleHighlight: (rowIndex, sheetName) =>
          this.runGas('toggleHighlight', this.state.userId, rowIndex, sheetName),
        deleteAnswer: (rowIndex, sheetName) =>
          this.runGas('deleteAnswer', this.state.userId, rowIndex, sheetName),
        checkAdmin: () => this.runGas('checkAdmin', this.state.userId),
        clearCache: () => this.runGas('refreshBoardData', this.state.userId),
        validateData: () => this.validateBoardDataIntegrity(),
        getDataCount: (classFilter, sortOrder, adminMode) =>
          this.runGas('getDataCount', this.state.userId, classFilter, sortOrder, adminMode),
        checkCurrentPublicationStatus: (userId) =>
          this.runGas('checkCurrentPublicationStatus', userId),
      };

      // Polling settings with dynamic interval adjustment
      this.pollingSettings = {
        enabled: true,
        baseInterval: 60000, // ğŸš€ åŸºæœ¬1åˆ†é–“éš”ï¼ˆ429ã‚¨ãƒ©ãƒ¼å¯¾ç­–ã§å»¶é•·ï¼‰
        currentInterval: 60000, // ç¾åœ¨ã®é–“éš”
        minInterval: 30000, // ğŸš€ æœ€å°30ç§’ï¼ˆ429ã‚¨ãƒ©ãƒ¼å¯¾ç­–ã§å»¶é•·ï¼‰
        maxInterval: 600000, // ğŸš€ æœ€å¤§10åˆ†ï¼ˆä½ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ™‚ã®å¤§å¹…å»¶é•·ï¼‰
        maxRetries: 5, // ğŸš€ ãƒªãƒˆãƒ©ã‚¤å›æ•°å¢—åŠ 
        currentRetries: 0,
        successCount: 0, // é€£ç¶šæˆåŠŸå›æ•°
        activityScore: 0, // ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚¹ã‚³ã‚¢
        backoffMultiplier: 2, // ğŸš€ æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•å€ç‡
        last429Error: 0, // ğŸš€ æœ€å¾Œã®429ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚åˆ»
        cooldownPeriod: 300000, // ğŸš€ 429ã‚¨ãƒ©ãƒ¼å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æœŸé–“ï¼ˆ5åˆ†ï¼‰
      };
      const savedCols = localStorage.getItem('boardColumns');
      if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
        this.elements.sizeSlider.value = savedCols;
        this.elements.sliderValue.textContent = savedCols;
      }
      this.init().catch((error) => {
        console.error('âŒ StudyQuestApp: Fatal initialization error:', error);
        this.displayInitializationError(`ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
      });

      // åˆå›å…¬é–‹çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼ˆ5ç§’å¾Œï¼‰
      // åˆå›å…¬é–‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã«ä»»ã›ã‚‹ï¼ˆç°¡ç´ åŒ–ï¼‰
    }

    // Reset state for clean initialization (Phase 1.2)
    resetStateForCleanInit() {
      console.log('ğŸ”„ Resetting state for clean initialization...');

      // Reset core data arrays
      this.state.currentAnswers = [];
      this.state.hasNewContent = false;
      this.state.newContentCount = 0;

      // Clear DOM to prevent inconsistency
      const container = this.elements.answersContainer;
      if (container) {
        const existingCards = container.querySelectorAll('.answer-card');
        if (existingCards.length > 0) {
          console.log('ğŸ§¹ Clearing', existingCards.length, 'existing DOM cards during init reset');
          // Remove observers
          existingCards.forEach((card) => {
            if (this.visibilityObserver) {
              this.visibilityObserver.unobserve(card);
            }
            if (this.scrollObserver) {
              this.scrollObserver.unobserve(card);
            }
          });
          container.innerHTML = '';
        }
      }

      // Clear differential cards to prevent residual data
      this.clearDifferentialCards();

      // Reset initialization flags
      this.initialDataLoaded = false;
      this.hadInitialDataLoadFailure = false;
      this.lastViewKey = null;

      // Clear content check flags
      this.contentCheckInProgress = false;

      // Reset current active sheet state
      this.state.currentActiveSheet = SHEET_NAME;

      console.log('âœ… State reset completed', {
        currentAnswers: this.state.currentAnswers.length,
        initialDataLoaded: this.initialDataLoaded,
        currentActiveSheet: this.state.currentActiveSheet,
      });
    }

    // Unified state management synchronization (Phase 2.3)
    synchronizeStateAfterDataUpdate(newData, context = 'unknown') {
      console.log(`ğŸ”„ Synchronizing state after data update (${context})...`);

      const dataLength = newData ? newData.length : 0;
      const previousLength = this.state.currentAnswers.length;

      // Step 1: Update data
      this.state.currentAnswers = newData || [];

      // Step 2: Update count-related state variables simultaneously
      this.updateLastSeenCount(dataLength);

      // Step 3: Update content flags
      if (dataLength > previousLength) {
        this.state.hasNewContent = true;
        this.state.newContentCount = dataLength - previousLength;
      } else {
        this.state.hasNewContent = false;
        this.state.newContentCount = 0;
      }

      // Step 4: Data update successful

      // Phase 4.1: Enhanced monitoring and logging
      this.logDataConsistencyMetrics(context, dataLength, previousLength);

      console.log('âœ… State synchronization completed:', {
        context,
        dataLength,
        previousLength,
        hasNewContent: this.state.hasNewContent,
        newContentCount: this.state.newContentCount,
        lastSeenCount: this.state.lastSeenCount,
      });

      return {
        dataLength,
        hasChanges: dataLength !== previousLength,
      };
    }

    // Comprehensive data consistency and cache monitoring (Phase 4.1)
    logDataConsistencyMetrics(context, currentDataLength, previousDataLength) {
      const domCardCount = this.elements.answersContainer
        ? this.elements.answersContainer.querySelectorAll('.answer-card').length
        : 0;

      const metrics = {
        timestamp: new Date().toISOString(),
        context,
        dataMetrics: {
          currentLength: currentDataLength,
          previousLength: previousDataLength,
          lastSeenCount: this.state.lastSeenCount,
          changeAmount: currentDataLength - previousDataLength,
        },
        domMetrics: {
          cardCount: domCardCount,
          dataVsDom: currentDataLength - domCardCount,
          isConsistent: currentDataLength === domCardCount,
        },
        stateMetrics: {
          hasNewContent: this.state.hasNewContent,
          newContentCount: this.state.newContentCount,
          initialDataLoaded: this.initialDataLoaded,
        },
        performanceMetrics: {
          timeSinceInit: Date.now() - this.state.startTime,
          isLoadingActive: this.state.isLoading,
        },
      };

      console.log('ğŸ“Š Data Consistency Metrics (Phase 4.1):', metrics);

      // Store metrics for debugging (keep last 10 entries)
      if (!this.debugMetrics) this.debugMetrics = [];
      this.debugMetrics.push(metrics);
      if (this.debugMetrics.length > 10) {
        this.debugMetrics.shift();
      }

      // Alert on significant inconsistencies (åˆæœŸæç”»å®Œäº†å¾Œã®ã¿)
      if (!metrics.domMetrics.isConsistent && this.state.initialDataLoaded) {
        console.warn('âš ï¸ DOM-Data inconsistency detected:', {
          data: currentDataLength,
          dom: domCardCount,
          context,
        });
      }

      return metrics;
    }

    // Cache hit/miss tracking (Phase 4.1)
    logCacheActivity(operation, hit, details = {}) {
      const cacheLog = {
        timestamp: new Date().toISOString(),
        operation,
        hit,
        details,
        context: this.state.currentActiveSheet || 'unknown',
      };

      console.log(`ğŸ—„ï¸ Cache ${hit ? 'HIT' : 'MISS'}:`, cacheLog);

      // Store cache metrics
      if (!this.cacheMetrics) this.cacheMetrics = [];
      this.cacheMetrics.push(cacheLog);
      if (this.cacheMetrics.length > 20) {
        this.cacheMetrics.shift();
      }
    }

    // Enhanced error handling and recovery system (Phase 4.2)
    async handleDataLoadError(error, context, retryOptions = {}) {
      const {
        maxRetries = 2,
        retryDelay = 1000,
        fallbackStrategy = 'clearAndReload',
      } = retryOptions;

      console.error(`âŒ Data load error in ${context}:`, error);

      // Log detailed error information
      this.logErrorDetails(error, context);

      // Error occurred

      // Determine recovery strategy based on error type and failure count
      const recoveryStrategy = this.determineRecoveryStrategy(error, context);

      try {
        switch (recoveryStrategy) {
          case 'retry':
            console.log(`ğŸ”„ Attempting retry for ${context}...`);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return await this.executeRecoveryRetry(context);

          case 'clearAndReload':
            console.log(`ğŸ”„ Executing clear and reload for ${context}...`);
            return await this.executeRecoveryReload();

          case 'fallbackMode':
            console.log(`ğŸ”„ Switching to fallback mode for ${context}...`);
            return await this.executeRecoveryFallback();

          default:
            console.log(`â„¹ï¸ No recovery action taken for ${context}`);
            this.displayUserFriendlyError(error, context);
            return null;
        }
      } catch (recoveryError) {
        console.error('âŒ Recovery strategy failed:', recoveryError);
        this.displayUserFriendlyError(error, context, true);
        return null;
      }
    }

    logErrorDetails(error, context) {
      const errorDetails = {
        timestamp: new Date().toISOString(),
        context,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name,
        },
        state: {
          currentAnswersLength: this.state.currentAnswers?.length || 0,
          lastSeenCount: this.state.lastSeenCount,
          isLoading: this.state.isLoading,
        },
        environment: {
          userAgent: navigator.userAgent,
          currentSheet: this.state.currentActiveSheet,
          timeSinceInit: Date.now() - this.state.startTime,
        },
      };

      console.log('ğŸ“ Error Details (Phase 4.2):', errorDetails);

      // Store error history
      if (!this.errorHistory) this.errorHistory = [];
      this.errorHistory.push(errorDetails);
      if (this.errorHistory.length > 5) {
        this.errorHistory.shift();
      }
    }

    /**
     * ã‚·ãƒ³ãƒ—ãƒ«ãªãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹ï¼ˆ3åˆ†å›ºå®šé–“éš”ï¼‰
     */
    startPolling() {
      // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’åœæ­¢
      this.stopPolling();

      // é«˜åº¦ãªãƒãƒ¼ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’ä½¿ç”¨
      this.startNewAnswerPolling();
    }

    /**
     * ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
     */
    stopPolling() {
      // çµ±åˆã•ã‚ŒãŸãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢å‡¦ç†
      this.stopNewAnswerPolling();
    }

    /**
     * çµ±åˆãƒã‚§ãƒƒã‚¯ï¼ˆå…¬é–‹çŠ¶æ…‹ï¼‹æ–°ç€ï¼‰
     */
    async checkAll() {
      try {
        // çµ±åˆãƒã‚§ãƒƒã‚¯ï¼ˆå…¬é–‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‹æ–°ç€ï¼‰
        const hasNewContent = await this.checkForNewAnswers();

        // æ–°ç€ãƒã‚§ãƒƒã‚¯ï¼ˆäº’æ›æ€§ã®ãŸã‚ç¶­æŒï¼‰
        const count = await this.gas.getDataCount();
        const currentCount = this.state.currentAnswers?.length || 0;
        if (count && count.count > currentCount) {
          const newItems = count.count - currentCount;
          this.showNewContentBanner(newItems);
        }
      } catch (error) {
        console.error('Check error:', error);
      }
    }

    /**
     * ãƒ‘ãƒ–ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®å®Ÿéš›ã®ãƒã‚§ãƒƒã‚¯å‡¦ç†
     * éå…¬é–‹çŠ¶æ…‹ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã€Unpublished.htmlã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
     */
    // æ—§checkPublicationStatusãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‰Šé™¤ï¼ˆcheckForNewAnswersã«çµ±åˆæ¸ˆã¿ï¼‰

    determineRecoveryStrategy(error, context) {
      // Simplified recovery strategy based on error type
      const errorType = error.message || error.toString();

      if (errorType.includes('network') || errorType.includes('timeout')) {
        return 'retry';
      } else if (errorType.includes('permission') || errorType.includes('auth')) {
        return 'clearAndReload';
      } else {
        return 'fallbackMode';
      }
    }

    async executeRecoveryRetry(context) {
      try {
        await this.clearDataCaches(true);
        return await this.loadSheetData({ bypassCache: true, isInitialLoad: false });
      } catch (retryError) {
        throw new Error(`Retry failed: ${retryError.message}`);
      }
    }

    async executeRecoveryReload() {
      try {
        await this.clearAllCardsForEmptyData();
        this.resetStateForCleanInit();
        return await this.loadSheetData({ bypassCache: true, isInitialLoad: true });
      } catch (reloadError) {
        throw new Error(`Reload failed: ${reloadError.message}`);
      }
    }

    async executeRecoveryFallback() {
      // Implement minimal functional state
      this.displayEmptyState();
      this.provideFeedback(
        'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ãã ã•ã„ã€‚',
        'error'
      );

      // Reset polling to longer intervals
      if (this.pollingTimeout) {
        clearTimeout(this.pollingTimeout);
        this.startPolling();
      }

      return { fallbackMode: true };
    }

    displayUserFriendlyError(error, context, isRecoveryFailed = false) {
      let userMessage = 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';

      if (isRecoveryFailed) {
        userMessage = 'å¾©æ—§å‡¦ç†ãŒå¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚';
      } else if (context.includes('polling')) {
        userMessage = 'æ–°ç€ãƒã‚§ãƒƒã‚¯ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚è‡ªå‹•çš„ã«å†è©¦è¡Œã—ã¾ã™ã€‚';
      } else if (context.includes('initial')) {
        userMessage =
          'ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚';
      }

      this.provideFeedback(userMessage, 'error');
    }

    async init() {
      try {
        // åˆå›ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«ãƒ‡ã‚¸ã‚¿ãƒ«ã‚·ãƒ†ã‚£ã‚ºãƒ³ã‚·ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºï¼ˆèª­ã¿è¾¼ã¿ã¨åŒæ™‚é€²è¡Œï¼‰
        const hasSeenDigitalCitizenship = localStorage.getItem('hasSeenDigitalCitizenship');
        const shouldShowModal =
          !hasSeenDigitalCitizenship ||
          (hasSeenDigitalCitizenship && Date.now() > parseInt(hasSeenDigitalCitizenship));

        if (shouldShowModal && window.sharedModals) {
          console.log('ğŸŒ åˆå›ã‚¢ã‚¯ã‚»ã‚¹/æœŸé™åˆ‡ã‚Œ: ãƒ‡ã‚¸ã‚¿ãƒ«ã‚·ãƒ†ã‚£ã‚ºãƒ³ã‚·ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º');
          window.sharedModals.showDigitalCitizenship();
          // è¡¨ç¤ºæ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¨­å®šï¼ˆ24æ™‚é–“æœ‰åŠ¹ï¼‰
          const expiry = Date.now() + 24 * 60 * 60 * 1000;
          localStorage.setItem('hasSeenDigitalCitizenship', expiry.toString());
        }

        // åˆæœŸãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’è¡¨ç¤º
        this.showLoadingOverlay();

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ30ç§’ï¼‰
        this.initTimeoutId = setTimeout(() => {
          this.hideLoadingOverlay();
          console.warn(
            'â° ãƒšãƒ¼ã‚¸ã®åˆæœŸåŒ–ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã¾ãŸã¯ã‚µãƒ¼ãƒãƒ¼ã®å¿œç­”ã‚’ã”ç¢ºèªãã ã•ã„ã€‚'
          );
          this.showErrorMessage(
            'åˆæœŸåŒ–ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚æ¥ç¶šçŠ¶æ³ã‚’ç¢ºèªã—ã¦ã€ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚',
            false
          );
        }, 30000);

        // Reset state for clean initialization
        this.resetStateForCleanInit();

        // Critical path only - non-blocking
        this.setupCriticalElements();
        this.showMinimalSkeleton();

        // Apply performance optimizations if needed
        if (this.isLowPerformanceMode) {
          this.optimizeForLowPerformance();
        }

        // Show info modal while loading sheet data in the background
        this.showInfoModal();

        // Kick off data loading without blocking UI
        this.loadDataImmediate()
          .catch((error) => {
            console.error('âŒ StudyQuestApp: Critical error in loadDataImmediate:', error);
            this.displayInitializationError(
              `ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`
            );
          })
          .finally(() => {
            if (this.initTimeoutId) {
              clearTimeout(this.initTimeoutId);
              this.initTimeoutId = null;
            }
          });

        // Defer all non-critical operations
        requestIdleCallback(
          () => {
            this.setupNonCriticalEventListeners();
            this.renderIcons();
            this.adjustLayout();
            this.updateSortOptions();
            this.setupObservers();
            // Initial admin state setup - ç®¡ç†è€…æ¨©é™ãŒã‚ã£ã¦ã‚‚æœ€åˆã¯é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
            console.log('ğŸ” æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯:', {
              isOwner: window.isOwner,
              adminToggleBtn: !!this.elements.adminToggleBtn,
            });

            if (window.isOwner) {
              this.state.isAdminUser = true;
              this.state.showAdminFeatures = false; // åˆæœŸã¯é–²è¦§ãƒ¢ãƒ¼ãƒ‰
              if (this.elements.adminToggleBtn) {
                console.log('âœ… ç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºä¸­');
                this.elements.adminToggleBtn.classList.remove('hidden');
                this.elements.adminToggleBtn.removeAttribute('hidden');
                this.elements.adminToggleBtn.style.display = 'inline-flex'; // è¡¨ç¤ºã‚’ç¢ºå®Ÿã«
                this.elements.adminToggleBtn.textContent = 'ç®¡ç†ãƒ¢ãƒ¼ãƒ‰';
              } else {
                console.warn('âŒ adminToggleBtnè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
              }
            } else {
              // éç®¡ç†è€…ã®å ´åˆã¯ç®¡ç†æ©Ÿèƒ½ã‚’å®Œå…¨ã«ç„¡åŠ¹åŒ–
              console.log('â„¹ï¸ éç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼ - ç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º');
              this.state.isAdminUser = false;
              this.state.showAdminFeatures = false;
              if (this.elements.adminToggleBtn) {
                this.elements.adminToggleBtn.classList.add('hidden');
                this.elements.adminToggleBtn.setAttribute('hidden', '');
                this.elements.adminToggleBtn.style.display = 'none'; // ç¢ºå®Ÿã«éè¡¨ç¤º
              }
            }

            // Start polling for new answers
            this.startNewAnswerPolling();

            // Start sync monitoring
            this.startSyncMonitoring();
          },
          { timeout: 50 }
        );

        // AdminPanelã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒªãƒƒã‚¹ãƒ³
        window.addEventListener('message', async (event) => {
          if (event.data && event.data.type === 'REFRESH_BOARD_DATA') {
            // Refresh board data message received
            try {
              await this.loadSheetData({ bypassCache: true });
              // Show info modal on board refresh
              this.showInfoModal();
            } catch (error) {
              console.error('ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
            }
          } else if (event.data && event.data.type === 'BOARD_PUBLISHED') {
            // æ–°ã—ã„ãƒœãƒ¼ãƒ‰ãŒå…¬é–‹ã•ã‚ŒãŸæ™‚ã®å³åº§æ›´æ–°
            console.log('æ–°ã—ã„ãƒœãƒ¼ãƒ‰ãŒå…¬é–‹ã•ã‚Œã¾ã—ãŸ:', event.data.sheetName);
            try {
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ‘ã‚¹ã§æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
              await this.checkForNewContentLight(true);
              // å¿…è¦ã«å¿œã˜ã¦ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
              await this.loadSheetData({ bypassCache: true });
              // Show info modal when new board is published
              this.showInfoModal();
            } catch (error) {
              console.warn('æ–°ã—ã„ãƒœãƒ¼ãƒ‰ã®å³åº§æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
              // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’å®Ÿè¡Œ
              try {
                await this.loadSheetData({ bypassCache: true });
              } catch (loadError) {
                console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èª­ã¿è¾¼ã¿ã‚‚ã‚¨ãƒ©ãƒ¼:', loadError);
              }
              // Show info modal even on error
              this.showInfoModal();
            }
          } else if (event.data && event.data.type === 'FORM_CREATED') {
            // ãƒ•ã‚©ãƒ¼ãƒ ãŒä½œæˆã•ã‚ŒãŸæ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯æ›´æ–°
            console.log('ğŸ“ æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒ ãŒä½œæˆã•ã‚Œã¾ã—ãŸ:', event.data.formUrl);
            try {
              const formLinkBtn = document.getElementById('formAnswerBtn');
              if (formLinkBtn && event.data.formUrl) {
                formLinkBtn.href = event.data.formUrl;
                formLinkBtn.classList.remove('hidden');
                console.log('âœ… ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ');
              }
            } catch (error) {
              console.warn('ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
            }
          }
        });

        // BroadcastChannelã§ä»–ã®ã‚¿ãƒ–ã‹ã‚‰ã®æ›´æ–°é€šçŸ¥ã‚‚å—ä¿¡
        if (typeof BroadcastChannel !== 'undefined') {
          const channel = new BroadcastChannel('board-updates');
          channel.addEventListener('message', async (event) => {
            if (event.data && event.data.type === 'BOARD_PUBLISHED') {
              console.log('BroadcastChannelã‹ã‚‰æ–°ã—ã„ãƒœãƒ¼ãƒ‰å…¬é–‹ã‚’å—ä¿¡:', event.data.sheetName);
              try {
                await this.checkForNewContentLight(true);
                await this.loadSheetData({ bypassCache: true });
                // Show info modal when board is updated via BroadcastChannel
                this.showInfoModal();
              } catch (error) {
                console.warn('BroadcastChannelçµŒç”±ã®æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
                try {
                  await this.loadSheetData({ bypassCache: true });
                } catch (loadError) {
                  console.error('BroadcastChannel ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èª­ã¿è¾¼ã¿ã‚‚ã‚¨ãƒ©ãƒ¼:', loadError);
                }
                // Show info modal even on error
                this.showInfoModal();
              }
            } else if (event.data && event.data.type === 'FORM_CREATED') {
              // ãƒ•ã‚©ãƒ¼ãƒ ãŒä½œæˆã•ã‚ŒãŸæ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯æ›´æ–°ï¼ˆBroadcastChannelï¼‰
              console.log('ğŸ“ BroadcastChannelã‹ã‚‰æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆã‚’å—ä¿¡:', event.data.formUrl);
              try {
                const formLinkBtn = document.getElementById('formAnswerBtn');
                if (formLinkBtn && event.data.formUrl) {
                  formLinkBtn.href = event.data.formUrl;
                  formLinkBtn.classList.remove('hidden');
                  console.log('âœ… ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸï¼ˆBroadcastChannelï¼‰');
                }
              } catch (error) {
                console.warn('BroadcastChannel ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯æ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('âŒ StudyQuestApp: Critical error in init():', error);
        this.displayInitializationError(
          `ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`
        );

        // Clear timeout on error
        if (this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }

        // Hide loading overlay on error
        this.hideLoadingOverlay();
        return; // Exit early on initialization failure
      }
    }
    setupCriticalElements() {
      if (this.elements.headingLabel) {
        // å•é¡Œæ–‡ã‚’å¸¸ã«è¡¨ç¤ºï¼ˆèª­ã¿è¾¼ã¿ä¸­ã¯è¡¨ç¤ºã—ãªã„ï¼‰
        const opinionHeader =
          __OPINION_HEADER__.startsWith('<') || __OPINION_HEADER__.includes('èª­ã¿è¾¼ã¿')
            ? 'ãŠé¡Œ' // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ã‚­ã‚¹ãƒˆ
            : this.escapeHtml(__OPINION_HEADER__);
        this.elements.headingLabel.textContent = opinionHeader;
      }

      // Only setup absolutely critical event listeners
      this.setupEventDelegation();
      this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
      if (this.elements.answerModalCloseBtn) {
        this.elements.answerModalCloseBtn.addEventListener(
          'click',
          this.handlers.onAnswerModalCloseClick
        );
      }
      // Size slider for immediate response with throttling
      const debouncedRender = this.debounce(() => this.renderBoard(true, false), 200);
      this.handlers.onSizeSliderInput = this.throttle((e) => {
        const value = e.target.value;
        localStorage.setItem('boardColumns', value);
        
        // Update slider value display immediately
        if (this.elements.sliderValue) {
          this.elements.sliderValue.textContent = value;
        }
        
        // Update grid columns immediately
        const container = this.elements.answersContainer;
        const colsMap = {
          '2': 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-2',
          '3': 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3',
          '4': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4',
          '5': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5',
          '6': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6'
        };
        container.className = colsMap[value] || 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4';
        
        debouncedRender();
      }, 100); // Throttle to 100ms

      if (this.elements.sizeSlider) {
        this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, {
          passive: true,
        });
      }
    }

    setupNonCriticalEventListeners() {
      // é‡è¤‡ç™»éŒ²é˜²æ­¢
      if (this.nonCriticalListenersSetup) {
        // Non-critical event listeners already set up
        return;
      }

      // answersContainer ã®ã‚¯ãƒªãƒƒã‚¯ãƒªã‚¹ãƒŠãƒ¼ã¯ setupEventDelegation() ã§ç™»éŒ²æ¸ˆã¿

      // Modal handlers
      this.handlers.onAnswerModalContainerClick = (e) => {
        if (e.target === e.currentTarget) {
          this.hideAnswerModal();
        }
      };
      if (this.elements.answerModalContainer) {
        this.elements.answerModalContainer.addEventListener(
          'click',
          this.handlers.onAnswerModalContainerClick
        );
      }
      if (this.elements.infoModalConfirmBtn) {
        this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
        this.elements.infoModalConfirmBtn.addEventListener(
          'click',
          this.handlers.onInfoModalConfirmClick
        );
      }
      this.handlers.onModalReactionClick = (e) => {
        const btn = e.target.closest('.reaction-btn');
        const highlightBtn = e.target.closest('.highlight-btn');

        if (highlightBtn) {
          const id = highlightBtn.dataset.rowIndex;
          if (id) {
            this.handleHighlight(id);
          }
        } else if (btn) {
          const id = btn.dataset.rowIndex;
          const reaction = btn.dataset.reaction;
          if (id && reaction) {
            this.handleReaction(id, reaction);
          }
        }
      };
      if (this.elements.modalReactionContainer) {
        this.elements.modalReactionContainer.addEventListener(
          'click',
          this.handlers.onModalReactionClick
        );
      }
      this.handlers.onClassFilterChange = async () => {
        this.dismissNewContentBanner(); // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã¯æ—¢å­˜ã®é€šçŸ¥ã‚’æ¶ˆå»
        try {
          await this.loadSheetData({ bypassCache: true });
          this.updateLastSeenCount(this.state.currentAnswers.length); // æ–°ã—ã„ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è¨­å®š
        } catch (error) {
          console.error('ã‚¯ãƒ©ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        }
      };
      this.handlers.onSortOrderChange = async () => {
        this.dismissNewContentBanner(); // ã‚½ãƒ¼ãƒˆå¤‰æ›´æ™‚ã¯æ—¢å­˜ã®é€šçŸ¥ã‚’æ¶ˆå»
        try {
          await this.loadSheetData({ bypassCache: true });
          this.updateLastSeenCount(this.state.currentAnswers.length); // æ–°ã—ã„ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è¨­å®š
        } catch (error) {
          console.error('ã‚½ãƒ¼ãƒˆé †å¤‰æ›´æ™‚ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        }
      };
      if (this.elements.classFilter) {
        this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
      }
      if (this.elements.sortOrder) {
        this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
      }
      if (this.elements.endPublicationBtn) {
        this.handlers.onEndPublicationClick = () => this.endPublication();
        this.elements.endPublicationBtn.addEventListener(
          'click',
          this.handlers.onEndPublicationClick
        );
      }
      if (this.elements.adminToggleBtn) {
        this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
        this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
      }

      // æ–°ç€é€šçŸ¥ãƒãƒŠãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      if (this.elements.refreshContentBtn) {
        this.handlers.onRefreshContentClick = async () => {
          try {
            await this.refreshContent();
          } catch (error) {
            console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
          }
        };
        this.elements.refreshContentBtn.addEventListener(
          'click',
          this.handlers.onRefreshContentClick
        );
      }
      if (this.elements.dismissBannerBtn) {
        this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
        this.elements.dismissBannerBtn.addEventListener(
          'click',
          this.handlers.onDismissBannerClick
        );
      }
      this.handlers.onDocumentKeydown = (e) => {
        if (e.key === 'Escape') {
          this.hideAnswerModal();
        }
      };
      document.addEventListener('keydown', this.handlers.onDocumentKeydown);
      this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
      window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
      this.handlers.onVisibilityChange = () => {
        if (document.hidden) {
          this.stopPolling();
          // Cleanup when page is hidden
          this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
        } else {
          this.startPolling();
        }
      };
      document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, {
        passive: true,
      });

      this.nonCriticalListenersSetup = true;
      // Non-critical event listener setup complete
    }
    /**
     * ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ã®è¨­å®šï¼ˆå®‰å®šç‰ˆã®å …ç‰¢ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æ¡ç”¨ï¼‰
     * ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãŒä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã¨ç«¶åˆã—ãªããªã‚Šã¾ã™ã€‚
     */
    setupEventDelegation() {
      // é‡è¤‡ç™»éŒ²é˜²æ­¢
      if (this.eventDelegationSetup) {
        // Event delegation already set up
        return;
      }

      this.handlers.onAnswersContainerClick = (e) => {
        const answerCard = e.target.closest('.answer-card');

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
          return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
          return;
        }

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†
        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
          e.stopPropagation(); // â˜…é‡è¦: ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’æ­¢ã‚ã€ã‚«ãƒ¼ãƒ‰æœ¬ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã¨åˆ†é›¢
          if (!reactionBtn.disabled) {
            this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
          }
          return;
        }

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†
        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
          e.stopPropagation(); // â˜…é‡è¦: åŒæ§˜ã«ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
          if (!highlightBtn.disabled) {
            this.handleHighlight(rowIndex);
          }
          return;
        }

        // å‰Šé™¤ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰
        const deleteBtn = e.target.closest('.delete-answer-btn');
        if (deleteBtn) {
          e.stopPropagation(); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
          if (!deleteBtn.disabled) {
            this.handleDeleteAnswer(rowIndex);
          }
          return;
        }

        // ä¸Šè¨˜ä»¥å¤–ã®å ´åˆã¯ã€ã‚«ãƒ¼ãƒ‰æœ¬ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã¨ã—ã¦ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        this.showAnswerModal(rowIndex);
      };

      if (this.elements.answersContainer) {
        // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰è¿½åŠ 
        this.elements.answersContainer.removeEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
        this.elements.answersContainer.addEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
        this.eventDelegationSetup = true;
      } else {
        console.error('No answers container found for event delegation');
      }
    }

    // Debug helper functions removed for production
    adjustLayout() {
      if (this.baseBodyPadding === undefined) {
        this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
      }
      const footerHeight = this.elements.footer.offsetHeight;
      this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
    }
    runGas(funcName, ...args) {
      // ğŸš€ RequestManagerå¯¾å¿œ - 429ã‚¨ãƒ©ãƒ¼å¯¾ç­–ã®é«˜åº¦ãªå®Ÿè£…
      const cacheKey = funcName + JSON.stringify(args);
      const isStateChanging = ['toggleHighlight', 'addReaction', 'endPublication'].includes(
        funcName
      );

      // æ—¢å­˜ã®UnifiedCacheã‚‚ä½µç”¨ï¼ˆäºŒé‡ã‚­ãƒ£ãƒƒã‚·ãƒ¥åŠ¹æœï¼‰
      if (!isStateChanging) {
        const cached = this.cache.get(cacheKey);
        if (cached) {
          console.log(`ğŸš€ UnifiedCache HIT: ${funcName}`);
          return Promise.resolve(cached);
        }
      }

      // RequestManagerçµŒç”±ã§APIå‘¼ã³å‡ºã—ï¼ˆ429ã‚¨ãƒ©ãƒ¼å¯¾ç­–ï¼‹ãƒªãƒˆãƒ©ã‚¤ï¼‰
      return this.requestManager.execute(
        () =>
          new Promise((resolve, reject) => {
            if (typeof google !== 'undefined' && google.script && google.script.run) {
              const userId = USER_ID || '';
              google.script.run
                .withSuccessHandler((result) => {
                  // äºŒé‡ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼šUnifiedCache + RequestManagerã‚­ãƒ£ãƒƒã‚·ãƒ¥
                  if (!isStateChanging) {
                    this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
                  }
                  resolve(result);
                })
                .withFailureHandler((error) => {
                  console.error('ğŸš¨ GAS APIã‚¨ãƒ©ãƒ¼:', { funcName, args, error });
                  reject(error);
                })
                .withUserObject({ userId: userId })
                [funcName](...args);
            } else {
              console.warn('Google Apps Script environment not detected.');
              this.getMockData(funcName, ...args)
                .then((result) => {
                  if (!isStateChanging) {
                    this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
                  }
                  resolve(result);
                })
                .catch(reject);
            }
          }),
        isStateChanging ? null : `gas-${cacheKey}`, // çŠ¶æ…‹å¤‰æ›´ç³»ã¯ RequestManager ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹
        isStateChanging ? 0 : 300000 // çŠ¶æ…‹å¤‰æ›´ç³»ã¯å³æ™‚å®Ÿè¡Œã€ãã®ä»–ã¯5åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      );
    }
    // ã‚·ãƒ³ãƒ—ãƒ«ãªæ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯ - ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å—ã‘å–ã£ãŸå€¤ã‚’ãã®ã¾ã¾ä½¿ç”¨
    verifyOwner() {
      if (window.isOwner) {
        this.state.isAdminUser = true;
        this.state.showHighlightToggle = true;
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
        console.log('âœ… æ‰€æœ‰è€…æ¨©é™ç¢ºèªæ¸ˆã¿');
      } else {
        console.log('â„¹ï¸ éæ‰€æœ‰è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼');
      }
    }

    // ç®¡ç†è€…UIæ›´æ–°ã®å…±é€šãƒ¡ã‚½ãƒƒãƒ‰
    updateAdminButtonUI() {
      console.log('ğŸ”„ updateAdminButtonUIå®Ÿè¡Œä¸­:', {
        isAdminUser: this.state.isAdminUser,
        isOwner: window.isOwner,
        adminToggleBtn: !!this.elements.adminToggleBtn,
      });

      // Only show admin toggle button for administrators, never for viewers
      if (this.elements.adminToggleBtn && this.state.isAdminUser) {
        // Show button for admin users only
        console.log('âœ… ç®¡ç†è€…ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºä¸­ï¼ˆupdateAdminButtonUIï¼‰');
        this.elements.adminToggleBtn.classList.remove('hidden');
        this.elements.adminToggleBtn.removeAttribute('hidden');
        this.elements.adminToggleBtn.style.display = 'inline-flex';

        // Always show "ç®¡ç†ãƒ¢ãƒ¼ãƒ‰" text, never show "é–²è¦§ãƒ¢ãƒ¼ãƒ‰" to avoid confusion
        this.elements.adminToggleBtn.textContent = 'ç®¡ç†ãƒ¢ãƒ¼ãƒ‰';

        // Apply styling based on current admin mode state
        if (this.state.showAdminFeatures) {
          // Active admin mode: highlighted styling
          this.elements.adminToggleBtn.classList.remove('text-gray-500', 'opacity-60');
          this.elements.adminToggleBtn.classList.add(
            'bg-cyan-600',
            'hover:bg-cyan-700',
            'text-white',
            'shadow-lg',
            'ring-2',
            'ring-cyan-400/50'
          );
        } else {
          // Inactive admin mode: subtle gray styling
          this.elements.adminToggleBtn.classList.remove(
            'bg-cyan-600',
            'hover:bg-cyan-700',
            'text-white',
            'shadow-lg',
            'ring-2',
            'ring-cyan-400/50'
          );
          this.elements.adminToggleBtn.classList.add('text-gray-500', 'opacity-60');
        }
      } else {
        // Hide button for non-admin users
        console.log('â„¹ï¸ éç®¡ç†è€… - ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤ºï¼ˆupdateAdminButtonUIï¼‰');
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.add('hidden');
          this.elements.adminToggleBtn.setAttribute('hidden', '');
          this.elements.adminToggleBtn.style.display = 'none';
        }
      }
    }

    updateEndPublicationButtonUI() {
      if (this.elements.endPublicationBtn) {
        if (this.state.showAdminFeatures) {
          this.elements.endPublicationBtn.classList.remove('hidden');
          this.elements.endPublicationBtn.removeAttribute('hidden');
        } else {
          this.elements.endPublicationBtn.classList.add('hidden');
          this.elements.endPublicationBtn.setAttribute('hidden', '');
        }
      }
    }

    // å‰Šé™¤: ã‚µãƒ¼ãƒãƒ¼ç®¡ç†è€…æ¨©é™ç¢ºèª - window.isOwnerã§ååˆ†

    async checkForNewContentLight(bypassCache = false) {
      // ãƒãƒ¼ãƒªãƒ³ã‚°å®Ÿè¡Œä¸­ã®å ´åˆã¯é‡è¤‡å®Ÿè¡Œã‚’é˜²ã
      if (this.contentCheckInProgress) {
        console.log('Content check already in progress, skipping...');
        return;
      }

      try {
        this.contentCheckInProgress = true;

        // åŸºæœ¬çŠ¶æ…‹ã®æ¤œè¨¼
        if (!this.validateContentCheckPrerequisites()) {
          return;
        }

        // æ–°ç€é€šçŸ¥ãƒã‚§ãƒƒã‚¯æ™‚ã«å…¬é–‹çŠ¶æ…‹ã‚‚ç¢ºèª
        // çµ±åˆãƒã‚§ãƒƒã‚¯ï¼ˆå…¬é–‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‹æ–°ç€ï¼‰ã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã§å®Ÿè¡Œæ¸ˆã¿

        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æº–å‚™
        const { selectedClass, sortOrder } = this.prepareContentCheckParams();

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦ãªå ´åˆï¼‰
        if (bypassCache) {
          await this.clearCacheForContentCheck();
        }

        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ä»¶æ•°ã‚’å–å¾—
        const countData = await this.fetchContentCount(selectedClass, sortOrder);

        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‡¦ç†
        await this.processContentCountResponse(countData, selectedClass, sortOrder);
      } catch (error) {
        await this.handleContentCheckError(error);
      } finally {
        this.contentCheckInProgress = false;
      }
    }

    validateContentCheckPrerequisites() {
      // å¿…è¦ãªè¦ç´ ã®å­˜åœ¨ç¢ºèª
      if (!this.elements.classFilter || !this.elements.sortOrder) {
        console.warn('Required UI elements not available for content check');
        return false;
      }

      // åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
      if (!this.state.userId) {
        console.warn('User ID not available for content check');
        return false;
      }

      return true;
    }

    prepareContentCheckParams() {
      let selectedClass = this.elements.classFilter.value || 'ã™ã¹ã¦';
      if (!selectedClass.trim()) {
        selectedClass = 'ã™ã¹ã¦';
      }

      // ã€Œã™ã¹ã¦ã€ã®å ´åˆã¯nullã«å¤‰æ›ã—ã¦ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
      const classFilter = !selectedClass || selectedClass === 'ã™ã¹ã¦' ? null : selectedClass;
      const sortOrder = this.elements.sortOrder.value || 'newest';

      return { selectedClass, classFilter, sortOrder };
    }

    async clearCacheForContentCheck() {
      try {
        await this.gas.clearCache();
        console.log('âœ… Cache cleared for content check');
      } catch (error) {
        console.warn('âš ï¸ Failed to clear cache:', error.message);
        // Continue without cache clearing
      }
    }

    async fetchContentCount(selectedClass, sortOrder) {
      const countData = await this.gas.getDataCount(
        selectedClass,
        sortOrder,
        this.state.showAdminFeatures
      );

      if (!countData) {
        throw new Error('No response from server for content count');
      }

      return countData;
    }

    async processContentCountResponse(countData, selectedClass, sortOrder) {
      const newCount = countData.count || 0;
      const currentCount = this.state.currentAnswers?.length || 0;
      const lastSeen = this.state.lastSeenCount || 0;

      // Enhanced consistency verification (Phase 3.1)
      const consistencyCheck = {
        lightCheckCount: newCount,
        currentDataCount: currentCount,
        lastSeenCount: lastSeen,
        hasInconsistency: Math.abs(newCount - currentCount) > 0 && currentCount > 0,
        significantChange: newCount !== lastSeen,
      };

      console.log('ğŸ“Š Enhanced content count check (Phase 3.1):', {
        newCount,
        currentCount,
        lastSeenCount: lastSeen,
        selectedClass,
        sortOrder,
        hadInitialFailure: this.hadInitialDataLoadFailure,
        consistencyCheck,
      });

      // ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã®ãƒãƒ¼ã‚¯

      // ç¾åœ¨ã®ãƒ“ãƒ¥ãƒ¼ã‚­ãƒ¼
      const currentViewKey = `${selectedClass}-${sortOrder}`;

      // åˆå›ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å®Œäº†ã®å‡¦ç†
      if (!this.initialDataLoaded) {
        await this.handleInitialContentLoad(currentViewKey, newCount);
        return;
      }

      // ãƒ“ãƒ¥ãƒ¼è¨­å®šå¤‰æ›´ã®å‡¦ç†
      if (this.lastViewKey !== currentViewKey) {
        await this.handleViewChange(currentViewKey, newCount);
        return;
      }

      // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ¤œå‡º
      await this.checkForNewItems(newCount);
    }

    // å‰Šé™¤: è¤‡é›‘ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒã‚§ãƒƒã‚¯é–¢é€£é–¢æ•°ï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ã®ãŸã‚å‰Šé™¤ï¼‰

    // æ–°ç€é€šçŸ¥ãƒãƒŠãƒ¼ã‚’è¡¨ç¤º
    showNewContentBanner(newItems) {
      if (!this.elements.newContentBanner) return;

      // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼šçŸ­æ™‚é–“å†…ã®é€£ç¶šé€šçŸ¥ã‚’é˜²ã
      const now = Date.now();
      if (this.lastNotificationTime && now - this.lastNotificationTime < 2000) {
        console.log('ğŸš« é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹: çŸ­æ™‚é–“å†…ã®é€£ç¶šé€šçŸ¥ã‚’ã‚¹ã‚­ãƒƒãƒ—');
        return;
      }
      this.lastNotificationTime = now;

      // æ—¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æ–°ã—ã„æ•°ã§ä¸Šæ›¸ãï¼ˆç´¯ç©ã—ãªã„ï¼‰
      if (!this.elements.newContentBanner.classList.contains('hidden')) {
        console.log('ğŸ“± é€šçŸ¥æ›´æ–°: æ—¢å­˜ãƒãƒŠãƒ¼ã‚’æ–°ã—ã„æ•°ã§æ›´æ–°', {
          oldCount: this.state.newContentCount,
          newCount: newItems,
        });
        this.state.newContentCount = newItems; // ç´¯ç©ã›ãšä¸Šæ›¸ã
      } else {
        this.state.newContentCount = newItems;
      }

      this.state.hasNewContent = true;

      const message =
        this.state.newContentCount === 1
          ? 'æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ'
          : `${this.state.newContentCount}ä»¶ã®æ–°ã—ã„æ„è¦‹ãŒæŠ•ç¨¿ã•ã‚Œã¾ã—ãŸ`;
      this.elements.newContentText.textContent = message;

      this.elements.newContentBanner.classList.remove('hidden');

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰é©ç”¨
      this.elements.newContentBanner.style.animation = '';

      // 3ç§’å¾Œã«ãƒã‚¦ãƒ³ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      setTimeout(() => {
        if (!this.elements.newContentBanner.classList.contains('hidden')) {
          this.elements.newContentBanner.style.animation = 'bounce 1s ease-in-out';
        }
      }, 3000);

      console.log('ğŸ“¢ æ–°ç€é€šçŸ¥è¡¨ç¤º:', {
        count: this.state.newContentCount,
        message: message,
      });
    }

    // æ–°ç€ãƒãƒŠãƒ¼ã‚’é–‰ã˜ã‚‹
    dismissNewContentBanner() {
      if (!this.elements.newContentBanner) return;

      this.elements.newContentBanner.classList.add('hidden');
      this.elements.newContentBanner.style.animation = '';
      this.state.hasNewContent = false;
      this.state.newContentCount = 0;
    }

    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆé€šçŸ¥ãƒãƒŠãƒ¼ã‹ã‚‰ã®å‘¼ã³å‡ºã—ï¼‰
    async refreshContent() {
      try {
        // ã¾ãšå¢—åˆ†æ›´æ–°ã‚’è©¦è¡Œ
        await this.refreshContentIncremental();
      } catch (error) {
        console.error('ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
        // å¢—åˆ†æ›´æ–°ãŒå¤±æ•—ã—ãŸå ´åˆã¯ãƒ•ãƒ«æ›´æ–°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…¨ä½“æ›´æ–°ã‚’å®Ÿè¡Œ');
        await this.refreshContentFull();
      }
    }

    // å¢—åˆ†ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆæ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã®ã¿å–å¾—ãƒ»è¿½åŠ ï¼‰
    async refreshContentIncremental() {
      this.dismissNewContentBanner();

      try {
        const originalText = this.elements.refreshContentBtn
          ? this.elements.refreshContentBtn.textContent
          : '';
        if (this.elements.refreshContentBtn) {
          this.elements.refreshContentBtn.textContent = 'æ›´æ–°ä¸­...';
          this.elements.refreshContentBtn.disabled = true;
        }

        console.log('ğŸ”„ å¢—åˆ†ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹ - åŸºæº–è¡Œæ•°:', this.state.lastSeenCount || 0);

        // ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿è¨­å®šã‚’å–å¾—
        const selectedClass = this.elements.classFilter
          ? this.elements.classFilter.value
          : 'ã™ã¹ã¦';
        const classFilter = !selectedClass || selectedClass === 'ã™ã¹ã¦' ? null : selectedClass;
        const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
        const adminMode = this.state.showAdminFeatures;

        console.log('ğŸ“¤ å¢—åˆ†å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:', {
          originalSelectedClass: selectedClass,
          processedClassFilter: classFilter,
        });

        // å¢—åˆ†ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const incrementalData = await this.gas.getIncrementalSheetData(
          classFilter,
          sortOrder,
          adminMode,
          this.state.lastSeenCount || 0
        );

        // ğŸ›¡ï¸ null/undefined ãƒã‚§ãƒƒã‚¯å¼·åŒ–
        if (!incrementalData || typeof incrementalData !== 'object') {
          console.error('å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹', {
            incrementalData: incrementalData,
            type: typeof incrementalData,
          });
          throw new Error('å¢—åˆ†ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        if (incrementalData.status === 'error') {
          throw new Error(incrementalData.message || 'å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        }

        // Enhanced incremental data analysis (Phase 3.2) - æ”¹å–„ç‰ˆ
        const preUpdateAnalysis = {
          newCount: incrementalData.newCount,
          totalCount: incrementalData.totalCount,
          hasNewData: incrementalData.newCount > 0,
          lastSeenCount: this.state.lastSeenCount,
          serverExpectedCount: incrementalData.totalCount,
          serverNewItems: incrementalData.newCount,
        };

        console.log('ğŸ“¥ Enhanced incremental analysis (Phase 3.2) - æ”¹å–„ç‰ˆ:', preUpdateAnalysis);

        // ã‚µãƒ¼ãƒãƒ¼ãƒ™ãƒ¼ã‚¹ã®ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆDOMæ›´æ–°å‰ã®æœ€å°é™ãƒã‚§ãƒƒã‚¯ï¼‰
        const criticalInconsistency = {
          zeroStateWithServerData:
            preUpdateAnalysis.totalCount > 0 &&
            this.state.currentAnswers.length === 0 &&
            this.state.lastSeenCount > 0,
          significantCountMismatch:
            Math.abs(preUpdateAnalysis.totalCount - this.state.lastSeenCount) > 10,
        };

        // é‡å¤§ãªä¸æ•´åˆã®ã¿ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ï¼ˆfalse positiveã‚’å‰Šæ¸›ï¼‰
        if (
          criticalInconsistency.zeroStateWithServerData ||
          criticalInconsistency.significantCountMismatch
        ) {
          console.warn('ğŸš¨ é‡å¤§ãªã‚µãƒ¼ãƒãƒ¼ãƒ»ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¸æ•´åˆæ¤œå‡º - ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Ÿè¡Œ:', {
            preUpdateAnalysis,
            criticalInconsistency,
            currentAnswersLength: this.state.currentAnswers.length,
          });

          // é‡å¤§ãªä¸æ•´åˆã®å ´åˆã®ã¿å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚’å®Ÿè¡Œ
          await this.refreshContentFull();
          return;
        }

        // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ
        if (incrementalData.newCount === 0) {
          this.provideFeedback('æœ€æ–°ã®çŠ¶æ…‹ã§ã™', 'info');
          // Use unified state management even for no-data updates (Phase 2.3)
          this.synchronizeStateAfterDataUpdate(
            this.state.currentAnswers,
            'incrementalRefresh-noNewData'
          );
          return;
        }

        // Prepare merged data with proper ordering (Phase 3.2)
        let mergedData;
        if (sortOrder === 'newest') {
          mergedData = incrementalData.data.concat(this.state.currentAnswers);
        } else {
          mergedData = this.state.currentAnswers.concat(incrementalData.data);
        }

        // First: DOM update with new cards
        await this.appendNewCards(incrementalData.data, sortOrder);

        // Second: Unified state synchronization (Phase 2.3 + 3.2)
        this.synchronizeStateAfterDataUpdate(mergedData, 'incrementalRefresh');

        // Third: Clear server cache for consistency across sort orders
        this.gas.clearCache().catch((err) => console.warn('Cache clear failed', err));

        console.log('âœ… å¢—åˆ†ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†:', {
          addedCards: incrementalData.newCount,
          totalCards: this.state.currentAnswers.length,
          newBaseline: this.state.lastSeenCount,
        });

        this.provideFeedback(`${incrementalData.newCount}ä»¶ã®æ–°ã—ã„æŠ•ç¨¿ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, 'success');
      } catch (error) {
        console.error('å¢—åˆ†ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã«å¤±æ•—:', error);

        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®å…¨ä½“æ›´æ–°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…¨ä½“æ›´æ–°ã‚’å®Ÿè¡Œ');
        await this.refreshContentFull();
      } finally {
        // ãƒœã‚¿ãƒ³ã‚’å…ƒã«æˆ»ã™
        if (this.elements.refreshContentBtn) {
          this.elements.refreshContentBtn.textContent =
            this.elements.refreshContentBtn.textContent.includes('æ›´æ–°ä¸­')
              ? originalText || 'æ›´æ–°ã—ã¦è¡¨ç¤º'
              : this.elements.refreshContentBtn.textContent;
          this.elements.refreshContentBtn.disabled = false;
        }
      }
    }

    // å…¨ä½“ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ï¼ˆå¾“æ¥ã®æ–¹æ³•ï¼‰
    async refreshContentFull() {
      try {
        // lastSeenCountã‚’ä¿æŒï¼ˆå®‰å®šåŒ–ã®ãŸã‚ï¼‰
        const preservedLastSeenCount = this.state.lastSeenCount;

        // å¾“æ¥ã®æ‰‹å‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        this.cache.clear();
        console.log(
          'ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹ - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å®Œäº†, lastSeenCountä¿æŒ:',
          preservedLastSeenCount
        );

        await this.loadSheetData({ bypassCache: true });

        // æ‰‹å‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã®æ–°ç€ãƒã‚§ãƒƒã‚¯åŸºæº–æ›´æ–°æˆ¦ç•¥ï¼ˆæ”¹å–„ç‰ˆï¼‰
        const currentDataLength = this.state.currentAnswers.length;
        const shouldUpdateLastSeen = currentDataLength > preservedLastSeenCount;

        if (shouldUpdateLastSeen) {
          // ãƒ‡ãƒ¼ã‚¿ãŒå¢—åŠ ã—ã¦ã„ã‚‹å ´åˆã®ã¿æ›´æ–°
          this.updateLastSeenCount(currentDataLength);
          console.log('ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€æ–°ç€åŸºæº–æ›´æ–°ï¼ˆãƒ‡ãƒ¼ã‚¿å¢—åŠ ï¼‰:', {
            newLastSeenCount: this.state.lastSeenCount,
            preservedCount: preservedLastSeenCount,
            currentAnswersLength: currentDataLength,
          });
        } else if (currentDataLength === 0 && preservedLastSeenCount > 0) {
          // ãƒ‡ãƒ¼ã‚¿ãŒ0ä»¶ã§ä»¥å‰ã«è¦‹ãŸã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯ã€æœ€å°å€¤ã¨ã—ã¦1ã‚’ä¿æŒ
          this.state.lastSeenCount = Math.max(1, preservedLastSeenCount);
          console.log('ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€æ–°ç€åŸºæº–ä¿æŒï¼ˆãƒ‡ãƒ¼ã‚¿0ä»¶æ™‚ã®å®‰å®šåŒ–ï¼‰:', {
            adjustedLastSeenCount: this.state.lastSeenCount,
            preservedCount: preservedLastSeenCount,
            currentAnswersLength: currentDataLength,
          });
        } else {
          // ãƒ‡ãƒ¼ã‚¿ãŒæ¸›å°‘ã¾ãŸã¯åŒã˜å ´åˆã¯ä¿æŒ
          this.state.lastSeenCount = preservedLastSeenCount;
          console.log('ğŸ”„ å…¨ä½“ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€æ–°ç€åŸºæº–ä¿æŒï¼ˆãƒ‡ãƒ¼ã‚¿ä¸å¤‰ï¼‰:', {
            preservedLastSeenCount: preservedLastSeenCount,
            currentAnswersLength: currentDataLength,
            maintainedStability: true,
          });
        }

        this.provideFeedback('æ›´æ–°å®Œäº†ï¼', 'success');
      } catch (error) {
        console.error('å…¨ä½“ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°ã«å¤±æ•—:', error);
        this.provideFeedback('æ›´æ–°å¤±æ•—', 'error');
        throw error;
      }
    }

    // Dynamic polling interval adjustment based on activity
    adjustPollingInterval(hasNewContent = false) {
      const settings = this.pollingSettings;

      if (hasNewContent) {
        // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹å ´åˆã¯é–“éš”ã‚’çŸ­ãã—ã¦æ´»æ€§åŒ–
        settings.activityScore = Math.min(settings.activityScore + 10, 100);
        settings.currentInterval = Math.max(
          settings.minInterval,
          settings.baseInterval - settings.activityScore * 150 // æœ€å¤§15ç§’çŸ­ç¸®
        );
      } else {
        // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãªã„å ´åˆã¯å¾ã€…ã«é–“éš”ã‚’é•·ãã—ã¦è² è·è»½æ¸›
        settings.activityScore = Math.max(settings.activityScore - 5, 0);
        settings.currentInterval = Math.min(
          settings.maxInterval,
          settings.baseInterval + settings.activityScore * 900 // æœ€å¤§90ç§’å»¶é•·
        );
      }

      console.log('ğŸ“Š ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”èª¿æ•´:', {
        hasNewContent,
        activityScore: settings.activityScore,
        newInterval: settings.currentInterval,
        intervalChange: settings.currentInterval - settings.baseInterval,
      });
    }

    // ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹ï¼ˆå®‰å…¨ç‰ˆï¼‰
    startNewAnswerPolling() {
      // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’åœæ­¢
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }

      // ãƒãƒ¼ãƒªãƒ³ã‚°ãŒç„¡åŠ¹ãªå ´åˆã¯çµ‚äº†
      if (!this.pollingSettings.enabled) {
        console.log('â¹ï¸ ãƒãƒ¼ãƒªãƒ³ã‚°ãŒç„¡åŠ¹ã®ãŸã‚é–‹å§‹ã—ã¾ã›ã‚“');
        return;
      }

      // ãƒãƒ¼ãƒªãƒ³ã‚°å®Ÿè¡Œé–¢æ•°
      const executePolling = async () => {
        // ãƒãƒ¼ãƒªãƒ³ã‚°ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã¯çµ‚äº†
        if (!this.pollingSettings.enabled) {
          console.log('â¹ï¸ ãƒãƒ¼ãƒªãƒ³ã‚°ãŒç„¡åŠ¹åŒ–ã•ã‚ŒãŸãŸã‚åœæ­¢');
          this.stopNewAnswerPolling();
          return;
        }

        try {
          const hasNewContent = await this.checkForNewAnswers();
          this.pollingSettings.currentRetries = 0;
          this.pollingSettings.successCount++;

          // å‹•çš„é–“éš”èª¿æ•´
          const previousInterval = this.pollingSettings.currentInterval;
          this.adjustPollingInterval(hasNewContent);

          // é–“éš”ãŒå¤§å¹…ã«å¤‰æ›´ã•ã‚ŒãŸå ´åˆã®ã¿ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†èµ·å‹•
          const intervalDiff = Math.abs(this.pollingSettings.currentInterval - previousInterval);
          if (intervalDiff > 10000) {
            // 10ç§’ä»¥ä¸Šã®å¤‰æ›´ã®ã¿å†èµ·å‹•
            console.log(
              `â±ï¸ ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã®å¤§å¹…å¤‰æ›´ã‚’æ¤œå‡º (${previousInterval / 1000}s â†’ ${this.pollingSettings.currentInterval / 1000}s)ã€å†èµ·å‹•ã—ã¾ã™`
            );
            // æ¬¡å›ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å†èµ·å‹•
            setTimeout(() => this.startNewAnswerPolling(), 1000);
            return;
          }
        } catch (error) {
          this.pollingSettings.currentRetries++;
          console.warn(
            `ğŸš¨ ãƒãƒ¼ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ (${this.pollingSettings.currentRetries}/${this.pollingSettings.maxRetries}):`,
            error
          );

          // 429ã‚¨ãƒ©ãƒ¼ç‰¹åˆ¥å‡¦ç†
          if (error.message?.includes('429') || error.status === 429) {
            this.pollingSettings.last429Error = Date.now();
            const cooldownTime = this.pollingSettings.cooldownPeriod || 300000; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼•åˆ†
            console.warn(`ğŸš¨ 429ã‚¨ãƒ©ãƒ¼æ¤œå‡º - ${cooldownTime / 1000}ç§’é–“ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹`);

            // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æœŸé–“ä¸­ã¯ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ã‚’å¤§å¹…å»¶é•·ã€ä¿®æ­£ï¼šMath.minã‚’ä½¿ç”¨
            this.pollingSettings.currentInterval = Math.min(
              this.pollingSettings.currentInterval * (this.pollingSettings.backoffMultiplier || 2),
              this.pollingSettings.maxInterval
            );

            // å³åº§ã«ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†èµ·å‹•ï¼ˆæ–°ã—ã„é–“éš”ã§ï¼‰
            setTimeout(() => this.startNewAnswerPolling(), 2000);
            return;
          }

          // é€šå¸¸ã‚¨ãƒ©ãƒ¼ã®æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
          const backoffDelay = Math.min(
            (this.pollingSettings.baseInterval || 60000) *
              Math.pow(
                this.pollingSettings.backoffMultiplier || 2,
                this.pollingSettings.currentRetries - 1
              ),
            this.pollingSettings.maxInterval || 600000
          );

          if (this.pollingSettings.currentRetries >= (this.pollingSettings.maxRetries || 3)) {
            console.error('ğŸ›‘ ãƒãƒ¼ãƒªãƒ³ã‚°æœ€å¤§ãƒªãƒˆãƒ©ã‚¤æ•°ã«é”ã—ãŸãŸã‚åœæ­¢');
            this.stopNewAnswerPolling();

            // 5åˆ†å¾Œã«è‡ªå‹•å¾©æ—§ã‚’è©¦è¡Œ
            setTimeout(() => {
              if (this.pollingSettings.enabled) {
                // å¾©æ—§æ™‚ã«ã¾ã æœ‰åŠ¹ãªå ´åˆã®ã¿
                console.log('ğŸ”„ ãƒãƒ¼ãƒªãƒ³ã‚°è‡ªå‹•å¾©æ—§ã‚’è©¦è¡Œ');
                this.pollingSettings.currentRetries = 0;
                this.pollingSettings.currentInterval = this.pollingSettings.baseInterval || 60000;
                this.startNewAnswerPolling();
              }
            }, 300000);
            return;
          } else {
            // ãƒãƒƒã‚¯ã‚ªãƒ•é…å»¶ã§æ¬¡ã®ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
            console.log(`â° ã‚¨ãƒ©ãƒ¼å¾Œã®ãƒãƒƒã‚¯ã‚ªãƒ•: ${backoffDelay / 1000}ç§’å¾…æ©Ÿ`);
            this.pollingSettings.currentInterval = backoffDelay;
            setTimeout(() => this.startNewAnswerPolling(), backoffDelay);
            return;
          }
        }
      };

      // åˆå›å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
      const currentInterval = this.pollingSettings.currentInterval || 60000;
      this.pollingInterval = setInterval(executePolling, currentInterval);

      console.log('ğŸ”„ ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹ï¼ˆå®‰å…¨ç‰ˆï¼‰:', {
        currentInterval: currentInterval / 1000 + 'ç§’',
        activityScore: this.pollingSettings.activityScore || 0,
        enabled: this.pollingSettings.enabled,
      });
    }

    // ã‚·ãƒ³ãƒ—ãƒ«ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
    stopNewAnswerPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        console.log('â¹ï¸ ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢');
      }
    }

    // ãƒãƒ¼ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼é€šçŸ¥
    showPollingError() {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’é€šçŸ¥ã—ã€æ‰‹å‹•æ›´æ–°ã‚’ä¿ƒã™
      if (this.elements.refreshContentBtn) {
        this.elements.refreshContentBtn.textContent = 'ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ - ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ›´æ–°';
        this.elements.refreshContentBtn.style.backgroundColor = '#ff6b6b';
        this.elements.refreshContentBtn.style.color = 'white';
      }
    }

    // æ–°ç€å›ç­”ã®ç¢ºèªï¼‹å…¬é–‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆçµ±åˆç‰ˆï¼‰
    async checkForNewAnswers() {
      if (this.state.isLoading) return false; // æ—¢ã«ãƒ­ãƒ¼ãƒ‰ä¸­ã®å ´åˆã¯è·³ã°ã™

      try {
        // 1. å…¬é–‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å…ˆã«ãƒã‚§ãƒƒã‚¯ï¼ˆè»½é‡ï¼‰
        const publicationStatus = await this.gas.checkCurrentPublicationStatus(this.state.userId);

        if (publicationStatus && publicationStatus.isPublished === false) {
          console.log('âš ï¸ ãƒœãƒ¼ãƒ‰ãŒéå…¬é–‹çŠ¶æ…‹ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸ');

          // éå…¬é–‹çŠ¶æ…‹ã®å ´åˆã¯ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
          this.handleUnpublishedState();
          return false;
        }

        // 2. å…¬é–‹çŠ¶æ…‹ã®å ´åˆã®ã¿æ–°ç€ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        const selectedClass = this.elements.classFilter
          ? this.elements.classFilter.value
          : 'ã™ã¹ã¦';
        const classFilter = !selectedClass || selectedClass === 'ã™ã¹ã¦' ? null : selectedClass;
        const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
        const adminMode = this.state.showAdminFeatures;

        console.log('ğŸ“¤ æ–°ç€ç¢ºèªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:', {
          originalSelectedClass: selectedClass,
          processedClassFilter: classFilter,
        });

        const incrementalData = await this.gas.getIncrementalSheetData(
          classFilter,
          sortOrder,
          adminMode,
          this.state.lastSeenCount || 0
        );

        // ğŸ›¡ï¸ null/undefined ãƒã‚§ãƒƒã‚¯å¼·åŒ–
        if (!incrementalData || typeof incrementalData !== 'object') {
          console.error('æ–°ç€ç¢ºèªã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹', {
            incrementalData: incrementalData,
            type: typeof incrementalData,
          });
          return false; // æ–°ç€ãªã—ã¨ã—ã¦å‡¦ç†ã‚’ç¶™ç¶š
        }

        if (incrementalData.status === 'error') {
          throw new Error(incrementalData.message || 'æ–°ç€ãƒ‡ãƒ¼ã‚¿å–å¾—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        }

        // æ–°ç€ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆ
        const newCount = incrementalData.newCount || incrementalData.newDataCount || 0;
        if (newCount > 0) {
          console.log('ğŸ†• æ–°ç€å›ç­”æ¤œå‡º:', {
            newCount: newCount,
            totalCount: incrementalData.totalCount || incrementalData.totalRows || 0,
          });

          this.state.hasNewContent = true;
          this.state.newContentCount = newCount;
          this.showNewContentBanner(newCount);
          return true; // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚ã‚Šã‚’è¿”ã™
        }

        return false; // æ–°ç€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãªã—ã‚’è¿”ã™
      } catch (error) {
        console.error('æ–°ç€ç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
        throw error;
      }
    }

    // éå…¬é–‹çŠ¶æ…‹å‡¦ç†ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
    handleUnpublishedState() {
      // ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
      this.stopNewAnswerPolling();

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
      try {
        Object.keys(localStorage).forEach((key) => {
          if (key.includes('studyquest') || key.includes('board') || key.includes('sheet')) {
            localStorage.removeItem(key);
          }
        });
      } catch (e) {
        console.warn('localStorage clear warning:', e);
      }

      // éå…¬é–‹ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
      const unpublishedUrl = new URL(window.location.href);
      unpublishedUrl.searchParams.delete('mode');
      unpublishedUrl.searchParams.set('_cb', Date.now());

      window.location.href = unpublishedUrl.toString();
    }

    // é‡è¤‡å®šç¾©ã®ãŸã‚å‰Šé™¤ - 1498è¡Œç›®ã®å®šç¾©ã‚’ä½¿ç”¨

    // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
    async appendNewCards(newData, sortOrder = 'newest') {
      if (!newData || newData.length === 0) return;

      console.log('ğŸ“Œ æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ :', newData.length + 'ä»¶');

      const container = this.elements.answersContainer;
      if (!container) return;

      this.removeEmptyState();

      // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
      const fragment = document.createDocumentFragment();
      const addedCardIds = [];

      for (const data of newData) {
        const cardElement = this.createAnswerCard(data);
        if (cardElement) {
          // å·®åˆ†è¿½åŠ ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ãƒãƒ¼ã‚¯
          cardElement.setAttribute('data-differential-card', 'true');
          cardElement.setAttribute('data-added-timestamp', Date.now().toString());

          // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
          cardElement.style.opacity = '0';
          cardElement.style.transform = 'translateY(20px)';
          fragment.appendChild(cardElement);

          // è¿½åŠ ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®IDã‚’è¨˜éŒ²
          if (data.rowIndex !== undefined) {
            addedCardIds.push(data.rowIndex);
          }
        }
      }

      // å·®åˆ†è¿½åŠ ã‚«ãƒ¼ãƒ‰ã®IDã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      if (addedCardIds.length > 0) {
        this.saveDifferentialCards(addedCardIds);
      }

      if (sortOrder === 'newest') {
        container.prepend(fragment);
      } else {
        container.appendChild(fragment);
      }

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
      await new Promise((resolve) => {
        requestAnimationFrame(() => {
          const newCards = container.querySelectorAll('.answer-card[style*="opacity: 0"]');
          newCards.forEach((card, index) => {
            setTimeout(() => {
              card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
              card.style.opacity = '1';
              card.style.transform = 'translateY(0)';
            }, index * 100); // 100msãšã¤é…å»¶ã—ã¦é †æ¬¡è¡¨ç¤º
          });

          // å…¨ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿ
          setTimeout(resolve, newCards.length * 100 + 300);
        });
      });
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º
    provideFeedback(message, type = 'info') {
      if (!this.elements.refreshContentBtn) return;

      const originalText = this.elements.refreshContentBtn.textContent;
      const originalBackground = this.elements.refreshContentBtn.style.background;

      this.elements.refreshContentBtn.textContent = message;

      switch (type) {
        case 'success':
          this.elements.refreshContentBtn.style.background = 'rgba(16, 185, 129, 0.3)';
          break;
        case 'error':
          this.elements.refreshContentBtn.style.background = 'rgba(239, 68, 68, 0.3)';
          break;
        case 'info':
          this.elements.refreshContentBtn.style.background = 'rgba(59, 130, 246, 0.3)';
          break;
      }

      setTimeout(() => {
        this.elements.refreshContentBtn.textContent = originalText;
        this.elements.refreshContentBtn.style.background = originalBackground;
      }, 2000);
    }

    getMockData(funcName, ...args) {
      return new Promise((resolve) => {
        setTimeout(() => {
          if (funcName === 'getPublishedSheetData') {
            const currentDisplayMode = window.displayMode || this.state.displayMode;
            const studentName1 = currentDisplayMode === 'named' ? 'ç”°ä¸­å¤ªéƒ' : '';
            const studentName2 = currentDisplayMode === 'named' ? 'ä½è—¤èŠ±å­' : '';
            resolve({
              header: 'ãƒ†ã‚¹ãƒˆå•é¡Œ',
              sheetName: 'ãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒˆ',
              data: [
                {
                  rowIndex: 1,
                  name: studentName1,
                  class: '3å¹´Açµ„',
                  opinion: 'ã“ã‚Œã¯ç´ æ™´ã‚‰ã—ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã ã¨æ€ã„ã¾ã™ã€‚',
                  reason: 'ç†ç”±ã¯ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ãã€å®Ÿç¾å¯èƒ½æ€§ãŒé«˜ã„ã‹ã‚‰ã§ã™ã€‚',
                  reactions: {
                    UNDERSTAND: { count: 5, reacted: false },
                    LIKE: { count: 2, reacted: false },
                    CURIOUS: { count: 1, reacted: false },
                  },
                  highlight: false,
                },
                {
                  rowIndex: 2,
                  name: studentName2,
                  class: '3å¹´Bçµ„',
                  opinion: 'å°‘ã—æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚‹ã¨è€ƒãˆã¾ã™ã€‚',
                  reason: 'ã‚ˆã‚Šå¤šãã®äººã®æ„è¦‹ã‚’èãå¿…è¦ãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚',
                  reactions: {
                    UNDERSTAND: { count: 3, reacted: true },
                    LIKE: { count: 0, reacted: false },
                    CURIOUS: { count: 0, reacted: false },
                  },
                  highlight: true,
                },
              ],
            });
          } else if (funcName === 'addReaction') {
            resolve({
              status: 'ok',
              reactions: {
                UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
                LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
                CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              },
            });
          } else if (funcName === 'toggleHighlight') {
            const currentHighlight = args[2] === undefined ? false : !args[2];
            resolve({
              status: 'ok',
              highlight: currentHighlight,
            });
          } else if (funcName === 'checkAdmin') {
            resolve(true);
          }
        }, 300);
      });
    }
    // å‰Šé™¤: è¤‡é›‘ãªadaptive pollingãƒ­ã‚¸ãƒƒã‚¯ï¼ˆä¸Šéƒ¨ã§æ–°ã—ã„ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆã‚’å®šç¾©æ¸ˆã¿ï¼‰

    // ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    performMemoryCleanup() {
      try {
        console.log('ğŸ§¹ Performing memory cleanup...');

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if (this.cache) {
          const cacheSize = this.cache.size();
          this.cache.cleanup();
          console.log('ğŸ—‘ï¸ Cache cleanup completed', { cacheSize });
        }

        // å¤ã„DOMè¦ç´ ã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
        this.cleanupDOMReferences();

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®æ•´ç†
        this.cleanupEventListeners();

        // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã®æœ€é©åŒ–
        this.optimizeVirtualScrollState();

        console.log('âœ… Memory cleanup completed');
      } catch (error) {
        console.warn('âš ï¸ Memory cleanup failed:', error);
      }
    }

    // å‰Šé™¤: DOMå‚ç…§ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ç¾¤ï¼ˆé–‹ç™ºæ®µéšã§ã¯ä¸è¦ï¼‰

    // å‰Šé™¤: é•·æ™‚é–“å®Ÿè¡Œç›£è¦–ï¼ˆé–‹ç™ºæ®µéšã§ã¯ä¸è¦ï¼‰

    showWarningMessage(message) {
      // è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆæ—¢å­˜ã®showErrorMessageã‚’å‚è€ƒã«ï¼‰
      const warningDiv = document.createElement('div');
      warningDiv.className =
        'fixed top-4 right-4 z-50 bg-yellow-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md border-l-4 border-yellow-400';
      warningDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13 4c-.77-.833-1.964-.833-2.732 0L3 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
        </svg>
        <span class="text-sm">${this.escapeHtml(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 hover:bg-yellow-700 rounded p-1">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    `;

      document.body.appendChild(warningDiv);

      // 10ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
      setTimeout(() => {
        if (warningDiv.parentNode) {
          warningDiv.parentNode.removeChild(warningDiv);
        }
      }, 10000);
    }

    destroy() {
      console.log('ğŸ§¹ StudyQuestApp: åŒ…æ‹¬çš„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');

      // ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢ï¼ˆæ”¹å–„ç‰ˆï¼‰
      this.stopPolling();
      this.stopNewAnswerPolling();

      // å‹•çš„é–“éš”èª¿æ•´ã®è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
      if (this.pollingSettings) {
        this.pollingSettings.enabled = false;
        this.pollingSettings.activityScore = 0;
        this.pollingSettings.currentInterval = this.pollingSettings.baseInterval;
      }

      // æ—¢å­˜ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      this.cleanup();

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤ï¼ˆæ—¢å­˜ï¼‰
      if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
        this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
      }
      if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
        this.elements.answerModalCloseBtn.removeEventListener(
          'click',
          this.handlers.onAnswerModalCloseClick
        );
      }
      if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
        this.elements.answerModalContainer.removeEventListener(
          'click',
          this.handlers.onAnswerModalContainerClick
        );
      }
      if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
        this.elements.infoModalConfirmBtn.removeEventListener(
          'click',
          this.handlers.onInfoModalConfirmClick
        );
      }
      if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
        this.elements.modalReactionContainer.removeEventListener(
          'click',
          this.handlers.onModalReactionClick
        );
      }
      if (this.elements.classFilter && this.handlers.onClassFilterChange) {
        this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
      }
      if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
        this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
      }
      if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
        this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
      }
      if (this.handlers.onDocumentKeydown) {
        document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
      }
      if (this.handlers.onWindowResize) {
        window.removeEventListener('resize', this.handlers.onWindowResize);
      }
      if (this.handlers.onVisibilityChange) {
        document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
      }
      if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
        this.elements.answersContainer.removeEventListener(
          'click',
          this.handlers.onAnswersContainerClick
        );
      }
      if (this.handlers.onDocumentClick) {
        document.removeEventListener('click', this.handlers.onDocumentClick);
      }
      // Cleanup observers
      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
      // Cancel any pending callbacks
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
      }
      if (this.idleCallbackId) {
        cancelIdleCallback(this.idleCallbackId);
      }
      // æ¼ã‚Œã¦ã„ãŸã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
      if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
        this.elements.refreshContentBtn.removeEventListener(
          'click',
          this.handlers.onRefreshContentClick
        );
      }
      if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
        this.elements.dismissBannerBtn.removeEventListener(
          'click',
          this.handlers.onDismissBannerClick
        );
      }
      if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
        this.elements.endPublicationBtn.removeEventListener(
          'click',
          this.handlers.onEndPublicationClick
        );
      }
      if (this.elements.sheetSelector && this.handlers.onSheetSelectorChange) {
        this.elements.sheetSelector.removeEventListener(
          'change',
          this.handlers.onSheetSelectorChange
        );
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šãƒ•ãƒ©ã‚°ã®ãƒªã‚»ãƒƒãƒˆ
      this.eventDelegationSetup = false;
      this.nonCriticalListenersSetup = false;
      this.modalOperationPending = false;

      // Clear caches
      this.cache.clear();
      this.deferredUpdates.clear();
      this.domFragmentPool.length = 0;
    }
    async loadDataImmediate() {
      try {
        console.log('ğŸš€ StudyQuestApp: Starting immediate data loading...');

        // 1. Validate essential prerequisites
        if (!this.validatePrerequisites()) {
          console.error(
            'âŒ StudyQuestApp: Prerequisites validation failed, aborting initialization'
          );
          this.displayInitializationError(
            'ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¿…è¦ãªæ¡ä»¶ãŒæº€ãŸã•ã‚Œã¦ã„ã¾ã›ã‚“'
          );
          return;
        }

        // 2. ã‚·ãƒ³ãƒ—ãƒ«ãªæ‰€æœ‰è€…ç¢ºèª
        console.log('ğŸ” StudyQuestApp: æ‰€æœ‰è€…ç¢ºèªä¸­...');
        this.verifyOwner();

        // 3. Start loading immediately without waiting - æœ€é©åŒ–ç‰ˆ
        console.log('ğŸ“Š StudyQuestApp: Starting optimized sheet data loading...');
        try {
          // åˆå›èª­ã¿è¾¼ã¿æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨ã—ã¦é«˜é€ŸåŒ–
          await this.loadSheetData({
            showLoading: false,
            isInitialLoad: true,
            bypassCache: false, // åˆå›èª­ã¿è¾¼ã¿æœ€é©åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨
          });
          console.log('âœ… StudyQuestApp: Sheet data loaded, restoring differential cards...');

          // å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å¾©å…ƒ
          this.restoreDifferentialCards();

          // ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹ã‚’å°‘ã—é…ã‚‰ã›ã¦åˆå›èª­ã¿è¾¼ã¿ã‚’å„ªå…ˆ
          console.log('âœ… StudyQuestApp: Scheduling delayed polling start...');
          setTimeout(() => {
            this.startPolling();
            console.log('âœ… StudyQuestApp: Delayed polling started');
          }, 1000); // 1ç§’é…å»¶ã§ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹
        } catch (error) {
          console.error('âŒ StudyQuestApp: Sheet data loading failed:', error);
          this.displayDataLoadError(error.message || 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        // 4. Load sheets in background only for administrators
        if (this.state.isAdminUser) {
          console.log('ğŸ‘‘ StudyQuestApp: Loading available sheets for admin user...');
          try {
            await this.loadAvailableSheets();
          } catch (error) {
            console.warn('âš ï¸ StudyQuestApp: Available sheets loading failed:', error.message);
          }
        }

        console.log('ğŸ¯ StudyQuestApp: Immediate loading initialization completed');
      } catch (error) {
        console.error('âŒ StudyQuestApp: Critical error in loadDataImmediate:', error);
        this.displayInitializationError(
          `ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`
        );
      }
    }

    /**
     * Validate essential prerequisites for app initialization
     * @returns {boolean} true if all prerequisites are met
     */
    validatePrerequisites() {
      const checks = [
        { name: 'userId', value: this.state.userId, required: true },
        { name: 'answersContainer', value: this.elements.answersContainer, required: true },
        { name: 'sheetName', value: this.state.sheetName, required: false },
        {
          name: 'google.script.run',
          value: typeof google !== 'undefined' && google.script && google.script.run,
          required: true,
        },
      ];

      let allValid = true;
      console.log('ğŸ” StudyQuestApp: Validating prerequisites:');

      checks.forEach((check) => {
        const isValid = check.required ? !!check.value : true;
        const status = isValid ? 'âœ…' : 'âŒ';
        console.log(
          `  ${status} ${check.name}: ${check.required ? 'required' : 'optional'} - ${isValid ? 'OK' : 'MISSING'}`
        );

        if (check.required && !isValid) {
          allValid = false;
        }
      });

      return allValid;
    }

    /**
     * Display initialization error to user
     * @param {string} message - Error message to display
     */
    displayInitializationError(message) {
      const container = this.elements.answersContainer;
      if (!container) return;

      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${this.escapeHtml(message)}</p>
        <div class="mt-6">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
    }

    /**
     * Display data loading error to user
     * @param {string} message - Error message to display
     */
    displayDataLoadError(message) {
      const container = this.elements.answersContainer;
      if (!container) return;

      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-yellow-400">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</h3>
        <p class="mt-1 text-sm text-gray-400">${this.escapeHtml(message)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
          >
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
          <button 
            onclick="window.studyQuestApp && window.studyQuestApp.loadSheetData({ bypassCache: true, isInitialLoad: true })" 
            class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
          >
            å†è©¦è¡Œ
          </button>
        </div>
      </div>
    `;
    }

    showErrorMessage(message, isTemporary = true) {
      // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆãƒˆãƒ¼ã‚¹ãƒˆé¢¨ï¼‰
      const errorDiv = document.createElement('div');
      errorDiv.className =
        'fixed top-4 right-4 z-50 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md';
      errorDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span class="text-sm">${this.escapeHtml(message)}</span>
      </div>
    `;

      document.body.appendChild(errorDiv);

      if (isTemporary) {
        // 5ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 5000);
      }

      return errorDiv;
    }

    showMinimalSkeleton() {
      // Show only 3 skeletons for immediate visual feedback
      const count = 3;
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      this.elements.answersContainer.appendChild(frag);
    }

    displayEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      // ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’éåŒæœŸã§å–å¾—ã—ã¦è¡¨ç¤º
      this.getFormUrlForEmptyState()
        .then((formUrl) => {
          const formLinkHtml = formUrl
            ? `<div class="mt-6">
          <a href="${this.escapeHtml(formUrl)}" target="_blank" 
             class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-pink-600 hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pink-500 transition-colors duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            å›ç­”ãƒ•ã‚©ãƒ¼ãƒ ã«è¨˜å…¥ã™ã‚‹
          </a>
        </div>`
            : `<div class="mt-4">
          <p class="text-sm text-gray-500">å›ç­”ãƒ•ã‚©ãƒ¼ãƒ ã®æº–å‚™ä¸­ã§ã™...</p>
        </div>`;

          container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">ã¾ã å›ç­”ãŒã‚ã‚Šã¾ã›ã‚“</h3>
          <p class="mt-1 text-sm text-gray-400">ã‚ãªãŸãŒæœ€åˆã®å›ç­”è€…ã«ãªã£ã¦ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼</p>
          ${formLinkHtml}
        </div>
      `;
        })
        .catch((error) => {
          console.warn('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
          // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤º
          container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">ã¾ã å›ç­”ãŒã‚ã‚Šã¾ã›ã‚“</h3>
          <p class="mt-1 text-sm text-gray-400">ã‚ãªãŸãŒæœ€åˆã®å›ç­”è€…ã«ãªã£ã¦ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼</p>
        </div>
      `;
        });
    }

    /**
     * ç©ºçŠ¶æ…‹è¡¨ç¤ºç”¨ã®ãƒ•ã‚©ãƒ¼ãƒ URLã‚’å–å¾— - ç°¡ç´ åŒ–ãƒ»é«˜é€ŸåŒ–ç‰ˆ
     * @returns {Promise<string|null>} ãƒ•ã‚©ãƒ¼ãƒ URL
     */
    async getFormUrlForEmptyState() {
      try {
        // getActiveFormInfoã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã‚’å–å¾—
        const result = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (10ç§’)'));
          }, 10000); // 10ç§’ã«å»¶é•·

          google.script.run
            .withSuccessHandler((response) => {
              clearTimeout(timeout);
              console.log('ğŸ” getActiveFormInfo ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', response);
              resolve(response);
            })
            .withFailureHandler((error) => {
              clearTimeout(timeout);
              console.error('âŒ getActiveFormInfo ã‚¨ãƒ©ãƒ¼:', error);
              reject(error);
            })
            .getCurrentBoardInfoAndUrls();
        });

        console.log('ğŸ” ãƒ•ã‚©ãƒ¼ãƒ URLåˆ¤å®š:', {
          hasResult: !!result,
          isActive: result?.isActive,
          hasFormUrl: !!result?.formUrl,
          formUrl: result?.formUrl || 'null',
          resultKeys: result ? Object.keys(result) : [],
        });

        if (result && result.isActive) {
          if (result.formUrl) {
            console.log('âœ… ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—æˆåŠŸ:', result.formUrl);
            return result.formUrl;
          }
        }

        console.warn('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ URLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
        return null;
      } catch (error) {
        console.error('âŒ ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        return null;
      }
    }

    /**
     * ç©ºçŠ¶æ…‹ã®ãƒãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
     */
    removeEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      const banner = container.querySelector('[data-empty-state="true"]');
      if (banner) {
        banner.remove();
      }
    }

    safeDisplayEmptyState() {
      const container = this.elements.answersContainer;
      if (!container) return;

      // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const existingCards = container.querySelectorAll('.answer-card');
      if (existingCards.length > 0) {
        console.log(
          'safeDisplayEmptyState: æ—¢å­˜ã‚«ãƒ¼ãƒ‰ãŒ',
          existingCards.length,
          'å€‹ã‚ã‚‹ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“'
        );
        return; // ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ãªã„
      }

      // currentAnswersã‚‚ãƒã‚§ãƒƒã‚¯
      if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
        console.log(
          'safeDisplayEmptyState: currentAnswersã«',
          this.state.currentAnswers.length,
          'å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“'
        );
        return; // ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã‚‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ãªã„
      }

      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯è¡¨ç¤ºã—ãªã„
      if (this.state.isLoading) {
        console.log('safeDisplayEmptyState: ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®ãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã›ã‚“');
        return;
      }

      console.log('safeDisplayEmptyState: æ¡ä»¶ã‚’æº€ãŸã—ãŸãŸã‚ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã™');
      this.displayEmptyState();
    }

    async clearAllCardsForEmptyData() {
      // çœŸã®åˆå›åˆ¤å®š: localStorageçŠ¶æ…‹ + DOMçŠ¶æ…‹ã‚’ç¢ºèª
      const isFirstTime = this.isFirstTimeBoardAccess();

      // currentAnswersã‚’ç©ºã«ãƒªã‚»ãƒƒãƒˆ
      this.state.currentAnswers = [];

      // DOMå†…ã®å…¨ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
      const container = this.elements.answersContainer;
      if (container) {
        const existingCards = container.querySelectorAll('.answer-card');

        if (existingCards.length > 0) {
          // ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’è§£é™¤
          existingCards.forEach((card) => {
            if (this.visibilityObserver) {
              this.visibilityObserver.unobserve(card);
            }
            if (this.scrollObserver) {
              this.scrollObserver.unobserve(card);
            }
          });

          // DOMã‚’ã‚¯ãƒªã‚¢
          container.innerHTML = '';

          // DOM clearing completion wait (Phase 1.3)
          await new Promise((resolve) => requestAnimationFrame(resolve));
          console.log('âœ… DOMæ¸…é™¤å®Œäº†ã€æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å·®åˆ†å¾©å…ƒæº–å‚™å®Œäº†');
        }
      }

      // ãƒãƒ¼ãƒãƒ£ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      if (this.virtualScrollState) {
        this.virtualScrollState = {
          renderedItems: 0,
          totalItems: 0,
          isLoading: false,
          renderedRowIndexes: new Set(),
          cardRegistry: new Map(),
        };
      }

      console.log('âœ…', isFirstTime ? 'åˆå›åˆæœŸåŒ–å®Œäº†' : 'clearAllCardsForEmptyData: ã‚¯ãƒªã‚¢å®Œäº†');
    }

    async validatePostLoadState() {
      // å†å¸°å‘¼ã³å‡ºã—é˜²æ­¢ãƒ•ãƒ©ã‚°
      if (this._isValidating) return;
      this._isValidating = true;

      try {
        const container = this.elements.answersContainer;
        if (!container) return;

        const domCards = container.querySelectorAll('.answer-card');
        const dataLength = this.state.currentAnswers ? this.state.currentAnswers.length : 0;

        console.log(
          'ğŸ” validatePostLoadState: DOMã‚«ãƒ¼ãƒ‰æ•°:',
          domCards.length,
          'currentAnswersæ•°:',
          dataLength
        );

        // ç©ºãƒ‡ãƒ¼ã‚¿ãªã®ã«DOMã«ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ
        if (dataLength === 0 && domCards.length > 0) {
          console.warn(
            'âš ï¸ çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: ç©ºãƒ‡ãƒ¼ã‚¿ãªã®ã«DOMã«',
            domCards.length,
            'å€‹ã®ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã¾ã™'
          );

          // ç©ºãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
          await this.clearAllCardsForEmptyData();

          // ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
          this.displayEmptyState();

          console.log('âœ… çŠ¶æ…‹ä¸æ•´åˆã‚’ä¿®æ­£ã—ã¾ã—ãŸ');
        } else if (dataLength !== domCards.length) {
          // æ•°ã®ä¸ä¸€è‡´ã‚‚ä¸æ•´åˆã¨ã¿ãªã™
          console.warn(
            'âš ï¸ çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: DOMã‚«ãƒ¼ãƒ‰æ•°ã¨ãƒ‡ãƒ¼ã‚¿æ•°ãŒä¸€è‡´ã—ã¾ã›ã‚“ã€‚DOM:',
            domCards.length,
            'ãƒ‡ãƒ¼ã‚¿:',
            dataLength
          );

          // å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯è¡Œã‚ãªã„ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
          console.log('âš ï¸ çŠ¶æ…‹ä¸æ•´åˆã‚’æ¤œå‡ºã—ã¾ã—ãŸãŒã€è‡ªå‹•ä¿®æ­£ã¯è¡Œã„ã¾ã›ã‚“');
        } else {
          console.log('âœ… çŠ¶æ…‹æ¤œè¨¼: DOMã¨ãƒ‡ãƒ¼ã‚¿ã®çŠ¶æ…‹ãŒä¸€è‡´ã—ã¦ã„ã¾ã™');
        }

        // è¿½åŠ : è¨­å®šã¨è¡¨ç¤ºå†…å®¹ã®ä¸€è‡´æ€§ã‚’æ¤œè¨¼
        this.validateConfigConsistency();
      } finally {
        this._isValidating = false;
      }
    }

    validateConfigConsistency() {
      // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®è¡¨ç¤ºã—ã¦ã„ã‚‹è³ªå•æ–‡ã‚’å–å¾—
      const displayedHeader = this.elements.headingLabel
        ? this.elements.headingLabel.textContent
        : '';

      // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ•°ã¨ãƒãƒ¼ãƒªãƒ³ã‚°ã§å–å¾—ã—ãŸã‚«ã‚¦ãƒ³ãƒˆã‚’æ¯”è¼ƒ
      const currentDataCount = this.state.currentAnswers ? this.state.currentAnswers.length : 0;

      // ãƒãƒ¼ãƒªãƒ³ã‚°çµæœã¨ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ•°ã®ä¸ä¸€è‡´ã‚’æ¤œå‡º
      if (this.lastPollingResult && this.lastPollingResult.newCount !== currentDataCount) {
        // ä¸æ•´åˆãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã®å¯¾å¿œ
        this.handleDataInconsistency();
      }
    }

    async handleDataInconsistency() {
      console.log('ğŸ”„ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã‚’è§£æ±ºã™ã‚‹ãŸã‚è©³ç´°åˆ†æã‚’é–‹å§‹ã—ã¾ã™...');

      try {
        // 1. ç¾åœ¨ã®çŠ¶æ…‹ã‚’è©³ç´°ã«åˆ†æ
        const currentState = await this.analyzeCurrentDataState();

        // 2. ä¸æ•´åˆã®ç¨®é¡ã‚’ç‰¹å®š
        const inconsistencyType = this.classifyInconsistency(currentState);

        // 3. ä¸æ•´åˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸä¿®å¾©æˆ¦ç•¥ã‚’å®Ÿè¡Œ
        await this.executeRepairStrategy(inconsistencyType, currentState);
      } catch (error) {
        console.error('âš ï¸ ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆä¿®å¾©ã§ã‚¨ãƒ©ãƒ¼:', error);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
        this.forceDataRefresh().catch((fallbackError) => {
          console.error('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚‚ã‚¨ãƒ©ãƒ¼:', fallbackError);
        });
      }
    }

    async analyzeCurrentDataState() {
      const container = this.elements.answersContainer;
      const domCards = container ? container.querySelectorAll('.answer-card') : [];

      return {
        domCardCount: domCards.length,
        stateDataCount: this.state.currentAnswers ? this.state.currentAnswers.length : 0,
        lastSeenCount: this.state.lastSeenCount || 0,
        pollingResult: this.lastPollingResult,
        hasLocalStorage: this.hasRelevantLocalStorage(),
        isInitialLoad: !this.initialDataLoaded,
        timestamp: new Date().toISOString(),
      };
    }

    classifyInconsistency(state) {
      if (state.isInitialLoad && state.domCardCount > 0) {
        return 'phantom_cards_on_init';
      } else if (state.stateDataCount === 0 && state.pollingResult?.newCount > 0) {
        return 'empty_state_with_server_data';
      } else if (state.domCardCount !== state.stateDataCount) {
        return 'dom_state_mismatch';
      } else if (state.lastSeenCount > state.stateDataCount) {
        return 'seen_count_ahead';
      } else {
        return 'general_inconsistency';
      }
    }

    async executeRepairStrategy(type, state) {
      console.log('ğŸ”§ ä¸æ•´åˆä¿®å¾©æˆ¦ç•¥:', type, state);

      switch (type) {
        case 'phantom_cards_on_init':
          console.log('ğŸ‘» åˆå›èª­ã¿è¾¼ã¿æ™‚ã®å¹½éœŠã‚«ãƒ¼ãƒ‰ã‚’ä¿®å¾©');
          await this.clearAllCardsForEmptyData();
          await this.loadSheetData({ bypassCache: true });
          break;

        case 'empty_state_with_server_data':
          console.log('ğŸ“¡ ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿å­˜åœ¨æ™‚ã®ç©ºçŠ¶æ…‹ã‚’ä¿®å¾©');
          await this.performServerDataSync();
          break;

        case 'dom_state_mismatch':
          console.log('ğŸ”„ DOM-Stateä¸æ•´åˆã‚’ä¿®å¾©');
          await this.resyncDOMWithState();
          break;

        case 'seen_count_ahead':
          console.log('ğŸ“Š lastSeenCountå…ˆè¡Œå•é¡Œã‚’ä¿®å¾©');
          this.updateLastSeenCount(state.stateDataCount);
          break;

        default:
          console.log('ğŸ”„ ä¸€èˆ¬çš„ãªä¸æ•´åˆä¿®å¾©');
          await this.forceDataRefresh();
      }
    }

    hasRelevantLocalStorage() {
      const userId = this.state?.userId || USER_ID;
      const sheetName = SHEET_NAME;

      return {
        hasLastSeen: localStorage.getItem(`lastSeenCount_${userId}_${sheetName}`) !== null,
        hasDiffCards: localStorage.getItem(`differentialCards_${userId}_${sheetName}`) !== null,
      };
    }

    async performServerDataSync() {
      console.log('ğŸ”„ ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿åŒæœŸé–‹å§‹');

      // è»½é‡ãƒã‚§ãƒƒã‚¯ã§æœ€æ–°ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
      const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'ã™ã¹ã¦';
      const classFilter = !selectedClass || selectedClass === 'ã™ã¹ã¦' ? null : selectedClass;

      // è»½é‡ãƒã‚§ãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

      const countData = await this.gas.getDataCount(
        classFilter,
        'newest',
        this.state.showAdminFeatures
      );

      // APIæ•´åˆæ€§ - è»½é‡ãƒã‚§ãƒƒã‚¯å®Œäº†

      if (countData && countData.count > 0) {
        // ã‚µãƒ¼ãƒãƒ¼ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯å¼·åˆ¶å†èª­ã¿è¾¼ã¿
        await this.loadSheetData({ bypassCache: true });
      } else {
        // ã‚µãƒ¼ãƒãƒ¼ã«ã‚‚ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
        this.displayEmptyState();
      }
    }

    async resyncDOMWithState() {
      console.log('ğŸ”„ DOM-Stateå†åŒæœŸé–‹å§‹');

      // ç¾åœ¨ã®stateãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦DOMã‚’å†æ§‹ç¯‰
      if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
        this.renderBoard(this.state.currentAnswers, []);
      } else {
        await this.clearAllCardsForEmptyData();
        this.displayEmptyState();
      }
    }

    async forceDataRefresh() {
      console.log('ğŸ—‘ï¸ å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹...');

      // lastSeenCountã‚’ä¿æŒï¼ˆå®‰å®šåŒ–ã®ãŸã‚ï¼‰
      const preservedLastSeenCount = this.state.lastSeenCount;

      // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      if (this.cache) {
        this.cache.clear();
        console.log(
          'âœ… ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢, lastSeenCountä¿æŒ:',
          preservedLastSeenCount
        );
      }

      // ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      try {
        await new Promise((resolve, reject) => {
          google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).clearCache();
        });
        console.log('âœ… ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢');
      } catch (error) {
        console.warn('âš ï¸ ã‚µãƒ¼ãƒãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã§ã‚¨ãƒ©ãƒ¼:', error);
      }

      // å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿å†èª­ã¿è¾¼ã¿
      await this.loadSheetData({ bypassCache: true });

      // lastSeenCountå¾©å…ƒï¼ˆå®‰å®šåŒ–ã®ãŸã‚ï¼‰
      const shouldPreserveLastSeen = this.state.currentAnswers.length <= preservedLastSeenCount;
      if (shouldPreserveLastSeen && preservedLastSeenCount > 0) {
        this.state.lastSeenCount = preservedLastSeenCount;
        console.log('âœ… å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€lastSeenCountå¾©å…ƒ:', {
          preservedCount: preservedLastSeenCount,
          currentAnswersLength: this.state.currentAnswers.length,
          stabilityMaintained: true,
        });
      } else {
        console.log('âœ… å¼·åˆ¶ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Œäº†ã€æ–°ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚ŠlastSeenCountæ›´æ–°:', {
          oldCount: preservedLastSeenCount,
          newCount: this.state.lastSeenCount,
          currentAnswersLength: this.state.currentAnswers.length,
        });
      }
    }

    /**
     * ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœã®æœ‰åŠ¹æ€§ã‚’åˆ¤å®š
     * @param {object} result - ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”
     * @returns {boolean} æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹
     */
    isValidDataResult(result) {
      try {
        // åŸºæœ¬æ§‹é€ ã®ç¢ºèª
        if (!result || typeof result !== 'object') {
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: çµæœãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„');
          return false;
        }

        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ã®è©³ç´°ãƒ­ã‚°
        // ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ç¢ºèª

        // 2ã¤ã®å¯èƒ½ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã«å¯¾å¿œ
        // 1. æ–°å½¢å¼: { status: 'success', data: [...], header: '...', sheetName: '...' }
        // 2. æ—§å½¢å¼: { data: [...], header: '...', sheetName: '...' } (statusãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã—)

        const hasStatusField = 'status' in result;

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèªï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
        if (hasStatusField && result.status !== 'success') {
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæˆåŠŸã§ã¯ãªã„ -', result.status);
          return false;
        }

        // ãƒ‡ãƒ¼ã‚¿é…åˆ—ã®å­˜åœ¨ç¢ºèª
        if (!Array.isArray(result.data)) {
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: dataãŒé…åˆ—ã§ã¯ãªã„', typeof result.data);
          return false;
        }

        // ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®ç¢ºèªï¼ˆä»»æ„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
        if (result.header && typeof result.header !== 'string') {
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®å‹ãŒä¸æ­£', typeof result.header);
          return false;
        }

        // ã‚·ãƒ¼ãƒˆåã®ç¢ºèªï¼ˆä»»æ„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
        if (result.sheetName && typeof result.sheetName !== 'string') {
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: ã‚·ãƒ¼ãƒˆåã®å‹ãŒä¸æ­£', typeof result.sheetName);
          return false;
        }

        console.log('âœ… ãƒ‡ãƒ¼ã‚¿åˆ¤å®š: æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿æ§‹é€  -', {
          status: result.status || '(no status field)',
          dataLength: result.data.length,
          hasHeader: !!result.header,
          sheetName: result.sheetName,
        });

        return true;
      } catch (error) {
        console.warn('âš ï¸ ãƒ‡ãƒ¼ã‚¿åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
        return false;
      }
    }

    /**
     * ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼å¤±æ•—ã®ç†ç”±ã‚’å–å¾—
     * @param {object} result - æ¤œè¨¼å¯¾è±¡ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
     * @returns {string} å¤±æ•—ç†ç”±
     */
    getValidationFailureReason(result) {
      if (!result) {
        return 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒnull/undefined';
      }
      if (typeof result !== 'object') {
        return `ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„ (${typeof result})`;
      }

      const hasStatusField = 'status' in result;
      if (hasStatusField && result.status !== 'success') {
        return `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæˆåŠŸã§ã¯ãªã„ (${result.status})`;
      }

      if (!('data' in result)) {
        return 'dataãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ãªã„';
      }
      if (!Array.isArray(result.data)) {
        return `dataãŒé…åˆ—ã§ã¯ãªã„ (${typeof result.data})`;
      }

      if (result.header && typeof result.header !== 'string') {
        return `ãƒ˜ãƒƒãƒ€ãƒ¼ã®å‹ãŒä¸æ­£ (${typeof result.header})`;
      }
      if (result.sheetName && typeof result.sheetName !== 'string') {
        return `ã‚·ãƒ¼ãƒˆåã®å‹ãŒä¸æ­£ (${typeof result.sheetName})`;
      }

      return 'ä¸æ˜ãªæ¤œè¨¼å¤±æ•—';
    }

    /**
     * ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ããƒ‡ãƒ¼ã‚¿å–å¾—
     * @param {object} fetchParams - ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
     * @param {boolean} isInitialLoad - åˆæœŸãƒ­ãƒ¼ãƒ‰ã‹ã©ã†ã‹
     * @returns {Promise} ãƒ‡ãƒ¼ã‚¿å–å¾—çµæœ
     */
    async performDataFetchWithRetry(fetchParams, isInitialLoad) {
      // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰æ™‚ã¯é«˜é€Ÿãƒªãƒˆãƒ©ã‚¤ã€é€šå¸¸æ™‚ã¯å¾“æ¥é€šã‚Š
      const MAX_ATTEMPTS = isInitialLoad ? 2 : 3;
      const retryDelays = isInitialLoad ? [500, 1000] : [1000, 2000, 3000]; // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã¯é«˜é€ŸåŒ–

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        try {
          // ãƒ‡ãƒ¼ã‚¿å–å¾—è©¦è¡Œ

          // ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’ Promise ã§å®Ÿè¡Œ
          const result = await new Promise((resolve, reject) => {
            const timeout = setTimeout(
              () => {
                reject(
                  new Error(`ãƒ‡ãƒ¼ã‚¿å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (${attempt === 0 ? 30 : 20}ç§’)`)
                );
              },
              attempt === 0 ? 30000 : 20000
            ); // åˆå›ã¯30ç§’ã€ä»¥é™ã¯20ç§’

            google.script.run
              .withSuccessHandler((response) => {
                clearTimeout(timeout);
                resolve(response);
              })
              .withFailureHandler((error) => {
                clearTimeout(timeout);
                reject(error);
              })
              .getPublishedSheetData(
                fetchParams.userId,
                fetchParams.classFilter,
                fetchParams.sortOrder,
                fetchParams.showAdminFeatures,
                fetchParams.bypassCache || false
              );
          });

          // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è©³ç´°ãƒ­ã‚°
          // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç¢ºèª

          // æˆåŠŸã—ãŸå ´åˆã¯çµæœã‚’è¿”ã™ - æ”¹å–„ã•ã‚ŒãŸåˆ¤å®šæ¡ä»¶
          if (result && this.isValidDataResult(result)) {
            // ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ
            return result;
          }

          // ãƒ‡ãƒ¼ã‚¿ãŒç©ºã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
          if (result && result.status === 'error') {
            const isUserNotFoundError =
              result.message && result.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');

            if (isUserNotFoundError && attempt < MAX_ATTEMPTS - 1) {
              console.warn(
                `âš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã€ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (è©¦è¡Œ ${attempt + 1}):`,
                result.message
              );

              // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯è¨ºæ–­ãƒ»ä¿®å¾©ã‚’è©¦è¡Œ
              try {
                console.log('ğŸ”§ ã‚µãƒ¼ãƒãƒ¼å´è¨ºæ–­ãƒ»ä¿®å¾©ã‚’è¦æ±‚ä¸­...');
                await new Promise((resolve, reject) => {
                  google.script.run
                    .withSuccessHandler(resolve)
                    .withFailureHandler(reject)
                    .performAutoRepair(fetchParams.userId);
                });
                console.log('âœ… ã‚µãƒ¼ãƒãƒ¼å´ä¿®å¾©å®Œäº†ã€æ¬¡ã®è©¦è¡Œã«é€²ã¿ã¾ã™');
              } catch (repairError) {
                console.warn('âš ï¸ ã‚µãƒ¼ãƒãƒ¼å´ä¿®å¾©å¤±æ•—:', repairError);
              }
            } else {
              // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ä»¥å¤–ã€ã¾ãŸã¯æœ€å¾Œã®è©¦è¡Œ
              throw new Error(result.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼');
            }
          }

          // ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã®å ´åˆï¼ˆè©³ç´°ãªç†ç”±ã‚’è¨˜éŒ²ï¼‰
          const validationReason = this.getValidationFailureReason(result);
          if (attempt < MAX_ATTEMPTS - 1) {
            console.warn(
              `âš ï¸ ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã€ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (è©¦è¡Œ ${attempt + 1}): ${validationReason}`
            );
          } else {
            console.warn(
              `âŒ æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ã¾ã—ãŸã€æœ€å¾Œã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™: ${validationReason}`
            );
            // æœ‰åŠ¹ã§ãªã„ãƒ‡ãƒ¼ã‚¿ã§ã‚‚ã€ä½•ã‚‰ã‹ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ã‚Œã°è¿”ã™
            return result || { status: 'error', message: 'ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', data: [] };
          }
        } catch (error) {
          console.error(`âŒ ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${attempt + 1}):`, error.message);

          // æœ€å¾Œã®è©¦è¡Œã§å¤±æ•—ã—ãŸå ´åˆ
          if (attempt >= MAX_ATTEMPTS - 1) {
            throw error;
          }

          // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒªãƒˆãƒ©ã‚¤
          const isTemporaryError =
            error.message.includes('timeout') ||
            error.message.includes('network') ||
            error.message.includes('script runtime') ||
            error.message.includes('temporarily unavailable');

          if (!isTemporaryError && error.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã¯ç‰¹åˆ¥æ‰±ã„ï¼ˆä¸Šè¨˜ã®å‡¦ç†ã«å§”ã­ã‚‹ï¼‰
            throw error;
          }

          if (isTemporaryError || attempt < MAX_ATTEMPTS - 1) {
            const delay = retryDelays[attempt] || 3000;
            console.log(`â³ ${delay}ms å¾…æ©Ÿå¾Œã«ãƒªãƒˆãƒ©ã‚¤...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } else {
            throw error;
          }
        }
      }

      // ã“ã“ã«åˆ°é”ã™ã‚‹ã“ã¨ã¯ãªã„ã¯ãšã§ã™ãŒã€å®‰å…¨ã®ãŸã‚
      throw new Error('äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: ãƒªãƒˆãƒ©ã‚¤ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã¾ã—ãŸ');
    }

    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ç”»é¢ã‚’è¡¨ç¤º
     * @param {string} errorMessage - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
     */
    displayUserNotFoundError(errorMessage) {
      const container = this.elements.answersContainer;
      if (!container) return;

      const isUserNotFoundError =
        errorMessage &&
        (errorMessage.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“') ||
          errorMessage.includes('ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'));

      container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">${isUserNotFoundError ? 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : 'ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼'}</h3>
        <p class="mt-1 text-sm text-gray-400">${
          isUserNotFoundError
            ? 'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã¯å­˜åœ¨ã—ãªã„ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒä¸æ­£ã§ã™'
            : 'ã“ã®å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“'
        }</p>
        ${
          isUserNotFoundError
            ? `
        <div class="mt-4 p-4 bg-blue-900/20 border border-blue-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-blue-400 mb-2">ğŸ” è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ URLã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œ</li>
            <li>â€¢ ãƒœãƒ¼ãƒ‰ãŒå‰Šé™¤ã•ã‚ŒãŸã‹éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã•ã‚ŒãŸ</li>
            <li>â€¢ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«ä¸€æ™‚çš„ãªå•é¡Œ</li>
            <li>â€¢ ã‚µãƒ¼ãƒãƒ¼å´ã®æ¨©é™è¨­å®šã«å•é¡Œ</li>
            <li>â€¢ ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ãŒç ´æ</li>
          </ul>
        </div>
        <div class="mt-4 p-4 bg-green-900/20 border border-green-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-green-400 mb-2">ğŸ’¡ è§£æ±ºæ–¹æ³•ï¼š</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>â€¢ ã¾ãšãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ­£ã—ã„ãƒœãƒ¼ãƒ‰URLã‚’ç®¡ç†è€…ã«ç¢ºèª</li>
            <li>â€¢ 5-10åˆ†å¾…ã£ã¦ã‹ã‚‰å†åº¦ã‚¢ã‚¯ã‚»ã‚¹</li>
            <li>â€¢ åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§è©¦ã—ã¦ã¿ã‚‹</li>
            <li>â€¢ æ–°ã—ã„å›ç­”ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹</li>
          </ul>
        </div>
        <div class="mt-4 p-3 bg-yellow-900/20 border border-yellow-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-yellow-400 mb-2">ğŸ› ï¸ è‡ªå‹•ä¿®å¾©ï¼š</h4>
          <p class="text-xs text-gray-400">ã‚·ã‚¹ãƒ†ãƒ ã¯è‡ªå‹•çš„ã«å•é¡Œã®ä¿®å¾©ã‚’è©¦è¡Œã—ã¦ã„ã¾ã™ã€‚æ•°åˆ†å¾Œã«å†åº¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨è§£æ±ºã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
        </div>`
            : ''
        }
        <p class="mt-2 text-xs text-gray-500">ã‚¨ãƒ©ãƒ¼è©³ç´°: ${this.escapeHtml(errorMessage)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800"
          >
            <svg class="-ml-1 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582 m15.356 2A8.001 8.001 0 004.582 9 m0 0H9 m11 11v-5h-.581 m0 0a8.003 8.003 0 01-15.357-2 m15.357 2H15" />
            </svg>
            ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      </div>
    `;
    }

    // Add these two methods
    showLoadingOverlay(message = '') {
      if (window.unifiedLoading) {
        window.unifiedLoading.setLoading(true, {
          message: '', // No message for transparent overlay
          type: 'transparent',
          disableInteraction: true,
        });
      }

      // Add loading-active class to body and container to disable render optimizations
      // This prevents stacking context issues with the loading overlay
      document.body.classList.add('loading-active');
      if (this.elements.answersContainer) {
        this.elements.answersContainer.classList.add('loading-active');
        // Replace render-optimized with loading-safe temporarily
        if (this.elements.answersContainer.classList.contains('render-optimized')) {
          this.elements.answersContainer.classList.add('loading-safe');
        }
      }
    }

    hideLoadingOverlay() {
      if (window.unifiedLoading) {
        window.unifiedLoading.setLoading(false);
      }

      // Remove loading-active classes to restore render optimizations
      document.body.classList.remove('loading-active');
      if (this.elements.answersContainer) {
        this.elements.answersContainer.classList.remove('loading-active');
        // Remove loading-safe class to restore normal render optimization
        this.elements.answersContainer.classList.remove('loading-safe');
      }
    }

    async loadSheetData(options = {}) {
      // Normalize options with defaults
      const config = {
        showLoading: options.showLoading !== false, // default true
        bypassCache: options.bypassCache || false,
        isInitialLoad: options.isInitialLoad || false,
        requestedSheetName: options.requestedSheetName || null,
        ...options,
      };

      // åˆå›èª­ã¿è¾¼ã¿æœ€é©åŒ–: bypassCacheãŒæ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ´»ç”¨
      if (config.isInitialLoad && options.bypassCache === undefined) {
        // åˆå›èª­ã¿è¾¼ã¿æ™‚ã¯é©åº¦ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥æ´»ç”¨ã§é«˜é€ŸåŒ–
        config.bypassCache = false;
        console.log('ğŸš€ åˆå›èª­ã¿è¾¼ã¿æœ€é©åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨ã—ã¾ã™');
      } else if (config.isInitialLoad && options.bypassCache === true) {
        config.bypassCache = true;
        console.log('ğŸ”„ åˆå›èª­ã¿è¾¼ã¿: æ˜ç¤ºçš„ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ‘ã‚¹');
      }

      // Prevent concurrent loading
      if (this.state.isLoading && config.showLoading) {
        console.log('loadSheetData: Already loading, skipping...');
        return;
      }

      try {
        this.state.isLoading = true;
        if (config.showLoading) {
          this.showLoadingOverlay();
        }

        // loadSheetData started
        const oldAnswers = [...this.state.currentAnswers];

        // Clear caches if needed
        if (config.bypassCache || this.shouldClearCache(config)) {
          await this.clearDataCaches(config.bypassCache && config.isInitialLoad);
        }

        // Load data with simplified parameters
        await this.performDataLoad(config, oldAnswers);
      } catch (error) {
        console.error('âŒ loadSheetData error:', error);
        this.handleLoadError(error);
      } finally {
        this.state.isLoading = false;
        this.hideLoadingOverlay();
      }
    }

    shouldClearCache(config) {
      // Clear cache on sheet switching or explicit refresh
      return (
        (config.requestedSheetName &&
          config.requestedSheetName !== this.state.currentActiveSheet) ||
        (config.showLoading && !config.isInitialLoad)
      );
    }

    async clearDataCaches(isCompleteBypass = false) {
      console.log('ğŸ§¹ Clearing data caches...', { isCompleteBypass });

      // Clear frontend cache
      if (this.cache) {
        this.cache.clear();
      }

      // Clear UnifiedCache if available
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }

      // Clear localStorage cache entries for complete bypass
      if (isCompleteBypass) {
        try {
          const keys = Object.keys(localStorage);
          const cacheKeys = keys.filter(
            (key) =>
              key.includes('cache_') ||
              key.includes('lastSeenCount_') ||
              key.includes('differentialCards_')
          );
          cacheKeys.forEach((key) => localStorage.removeItem(key));
        } catch (error) {
          console.warn('âš ï¸ Failed to clear localStorage cache:', error);
        }
      }

      // Clear server cache
      try {
        await this.gas.clearCache();
      } catch (error) {
        console.warn('âš ï¸ Failed to clear server cache:', error);
      }
    }

    /**
     * éå…¬é–‹çŠ¶æ…‹é·ç§»ç”¨ã®åŒ…æ‹¬çš„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
     * æ—¢å­˜ã®clearDataCachesã‚’æ‹¡å¼µã—ã€ã‚ˆã‚Šå¼·åŠ›ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã‚’å®Ÿè¡Œ
     */
    clearAllCachesForUnpublished() {
      console.log('ğŸ§¹ éå…¬é–‹çŠ¶æ…‹é·ç§»: åŒ…æ‹¬çš„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢é–‹å§‹');

      try {
        // 1. æ—¢å­˜ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢æ©Ÿèƒ½ã‚’ä½¿ç”¨
        if (this.cache && typeof this.cache.clear === 'function') {
          this.cache.clear();
          console.log('ğŸ—‘ï¸ Frontend cache cleared');
        }

        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
          console.log('ğŸ—‘ï¸ Unified cache cleared');
        }

        // 2. æ‹¡å¼µã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
        const localStorageKeys = Object.keys(localStorage);
        const studyQuestKeys = localStorageKeys.filter(
          (key) =>
            key.includes('studyquest') ||
            key.includes('board') ||
            key.includes('sheet') ||
            key.includes('admin') ||
            key.includes('publication') ||
            key.includes('answer') ||
            key.includes('cache_') ||
            key.includes('lastSeenCount_') ||
            key.includes('differentialCards_')
        );

        studyQuestKeys.forEach((key) => {
          localStorage.removeItem(key);
          console.log('ğŸ—‘ï¸ Removed localStorage key:', key);
        });

        // 3. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
        if (window.sessionStorage) {
          const sessionKeys = Object.keys(sessionStorage);
          const studyQuestSessionKeys = sessionKeys.filter(
            (key) => key.includes('studyquest') || key.includes('board') || key.includes('admin')
          );

          studyQuestSessionKeys.forEach((key) => {
            sessionStorage.removeItem(key);
            console.log('ğŸ—‘ï¸ Removed sessionStorage key:', key);
          });
        }

        // 4. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
        if (this.state) {
          this.state.currentAnswers = [];
          this.state.hasNewContent = false;
          this.state.newContentCount = 0;
          this.state.lastSeenCount = 0;
        }

        // 5. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨­å®š
        localStorage.setItem('lastUnpublishTime', Date.now().toString());
        localStorage.setItem('unpublishedRedirectTimestamp', new Date().toISOString());

        console.log('âœ… éå…¬é–‹çŠ¶æ…‹é·ç§»ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å®Œäº†');
      } catch (error) {
        console.error('âŒ éå…¬é–‹çŠ¶æ…‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã§ã‚¨ãƒ©ãƒ¼:', error);
        // ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ã¦ã‚‚å‡¦ç†ã¯ç¶™ç¶š
      }
    }

    async performDataLoad(config, oldAnswers) {
      // Get current filter and sort settings
      const isInitialLoad = config.isInitialLoad;
      const requestedSheetName = config.requestedSheetName;
      const selectedClass = isInitialLoad
        ? 'ã™ã¹ã¦'
        : this.elements.classFilter
          ? this.elements.classFilter.value
          : 'ã™ã¹ã¦';
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';

      // Show skeleton cards during loading
      if (config.showLoading && !config.isInitialLoad) {
        const count = Math.min(parseInt(this.elements.sizeSlider.value, 10) * 2, 8); // Cap at 8
        const frag = document.createDocumentFragment();
        for (let i = 0; i < count; i++) {
          frag.appendChild(this.createSkeletonCard());
        }
        const container = this.elements.answersContainer;
        container.className = `grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-${this.elements.sizeSlider.value}`;
        container.innerHTML = '';
        container.appendChild(frag);
      }

      // classFilterã€Œã™ã¹ã¦ã€ã¾ãŸã¯ç©ºã®å ´åˆã¯ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã—ãªã„ï¼ˆå…¨ãƒ‡ãƒ¼ã‚¿å–å¾—ã®ãŸã‚ï¼‰
      const classFilter = !selectedClass || selectedClass === 'ã™ã¹ã¦' ? null : selectedClass;

      // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è©³ç´°ãƒ­ã‚°
      const fetchParams = {
        userId: this.state.userId,
        classFilter,
        sortOrder,
        showAdminFeatures: this.state.showAdminFeatures,
        requestedSheetName,
        bypassCache: config.bypassCache || false,
      };

      // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š

      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆã®ãƒ‡ãƒ¼ã‚¿å–å¾—
      try {
        const result = await this.performDataFetchWithRetry(fetchParams, isInitialLoad);
        // åˆæœŸãƒ­ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
        if (isInitialLoad && this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }

        if (!result || !result.data || result.data.length === 0) {
          // è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°å‡ºåŠ›
          if (result && result.status === 'error') {
            console.error('âŒ StudyQuestApp: Data fetch failed with error:', result.message);

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚¨ãƒ©ãƒ¼ã®ç‰¹åˆ¥ãªå‡¦ç†
            if (result.message && result.message.includes('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
              console.error('âŒ StudyQuestApp: User not found. Current userId:', this.state.userId);
              console.error('âŒ StudyQuestApp: URL parameters:', window.location.href);
              console.error('âŒ StudyQuestApp: This may indicate:');
              console.error('  1. Invalid userId parameter in URL');
              console.error('  2. User not registered in the system');
              console.error('  3. Database connectivity issues');
              console.error('  4. Session expired or corrupted');
              console.error('âŒ StudyQuestApp: Possible solutions:');
              console.error('  - Check if the URL parameters are correct');
              console.error('  - Try refreshing the page');
              console.error('  - Contact administrator if the issue persists');

              // UIã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
              this.displayUserNotFoundError(result.message);
              return;
            }
          } else {
            // ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯: ç©ºãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ãªçŠ¶æ…‹ã‹ã‚¨ãƒ©ãƒ¼ã‹ã‚’åˆ¤å®š
            const isValidEmptyData =
              result &&
              result.data &&
              Array.isArray(result.data) &&
              result.data.length === 0 &&
              result.header;

            if (isValidEmptyData) {
              // æ­£å¸¸ãªç©ºãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯é«˜é€Ÿå¾©æ—§æˆ¦ç•¥ã‚’ã‚¹ã‚­ãƒƒãƒ—
              // ç©ºãƒ‡ãƒ¼ã‚¿ã¯æ­£å¸¸ãªçŠ¶æ…‹
            } else {
              console.warn('âš ï¸ StudyQuestApp: Received empty or invalid data:', result);

              try {
                // ç•°å¸¸ãªãƒ‡ãƒ¼ã‚¿ã®å ´åˆã®ã¿é«˜é€Ÿå¾©æ—§æˆ¦ç•¥ã‚’å®Ÿè¡Œ
                if (isInitialLoad) {
                  console.log('ğŸš€ åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•— - é«˜é€Ÿå¾©æ—§æˆ¦ç•¥ã‚’å®Ÿè¡Œ');

                  // è»½é‡ãƒã‚§ãƒƒã‚¯ã§ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ã‚’ç¢ºèª
                  const countData = await this.gas.getDataCount(
                    classFilter,
                    'newest',
                    this.state.showAdminFeatures
                  );

                  if (countData && countData.count > 0) {
                    console.log(
                      `âš¡ è»½é‡ãƒã‚§ãƒƒã‚¯ã§${countData.count}ä»¶æ¤œå‡º - å¾Œç¶šãƒãƒ¼ãƒªãƒ³ã‚°ã§å¾©æ—§äºˆå®š`
                    );
                    // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¦ãƒãƒ¼ãƒªãƒ³ã‚°ã«å§”ã­ã‚‹
                    this.hadInitialDataLoadFailure = true;
                    this.state.lastSeenCount = 0;
                  }
                } else {
                  // é€šå¸¸æ™‚ã¯å¾“æ¥ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰
                  const countData = await this.gas.getDataCount(
                    classFilter,
                    'newest',
                    this.state.showAdminFeatures
                  );
                  // Enhanced consistency check with lastSeenCount (Phase 2.2)
                  const expected = countData?.count || 0;
                  const actual = result?.data ? result.data.length : 0;
                  const lastSeen = this.state.lastSeenCount || 0;

                  console.log('ğŸ” Enhanced data consistency check (Phase 2.2):', {
                    expected,
                    actual,
                    lastSeen,
                    fullDataEmpty: actual === 0,
                    requestedSheet: requestedSheetName,
                    currentSheet: this.state.currentActiveSheet,
                    shouldTriggerRefresh: expected > 0 && actual === 0 && expected !== lastSeen,
                  });

                  // Only trigger fallback if there's significant inconsistency
                  // considering user's previously seen count
                  if (expected > 0 && actual === 0 && expected !== lastSeen) {
                    console.warn(
                      'âš ï¸ Significant data inconsistency detected!',
                      `Expected: ${expected}, Actual: ${actual}, LastSeen: ${lastSeen}`
                    );
                    console.log('ğŸ”„ Attempting simplified fallback...');

                    // ç°¡ç´ åŒ–ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆå¾…æ©Ÿæ™‚é–“çŸ­ç¸®ï¼‰
                    await new Promise((resolve) => setTimeout(resolve, 500));

                    const retryResult = await new Promise((resolve, reject) => {
                      google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .getPublishedSheetData(
                          this.state.userId,
                          classFilter,
                          this.elements.sortOrder ? this.elements.sortOrder.value : 'newest',
                          this.state.showAdminFeatures,
                          true
                        );
                    });

                    if (retryResult && retryResult.data && retryResult.data.length > 0) {
                      console.log(
                        'âœ… Fallback retry successful! Got',
                        retryResult.data.length,
                        'items'
                      );
                      result = retryResult; // æˆåŠŸã—ãŸçµæœã‚’ä½¿ç”¨
                    } else {
                      console.warn('âŒ Fallback retry also returned empty data');
                    }
                  }
                }
              } catch (fallbackError) {
                console.warn('âš ï¸ Fallback data consistency check failed:', fallbackError);
              }
            }
          }

          // å†ãƒã‚§ãƒƒã‚¯å¾Œã‚‚ãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆã®ã¿ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤º
          if (!result || !result.data || result.data.length === 0) {
            // é‡è¦: å•é¡Œæ–‡ã¯ç©ºãƒ‡ãƒ¼ã‚¿ã§ã‚‚è¡¨ç¤ºã™ã‚‹
            if (
              result &&
              result.header &&
              this.elements.headingLabel &&
              result.header !== 'èª­ã¿è¾¼ã¿ä¸­...' &&
              !result.header.includes('èª­ã¿è¾¼ã¿') &&
              result.header.trim() !== ''
            ) {
              this.elements.headingLabel.textContent = result.header;
              // å•é¡Œæ–‡ã‚’è¡¨ç¤º
            }

            // ç©ºãƒ‡ãƒ¼ã‚¿å—ä¿¡æ™‚ã¯å¤ã„ã‚«ãƒ¼ãƒ‰ã‚’å¼·åˆ¶çš„ã«ã‚¯ãƒªã‚¢
            await this.clearAllCardsForEmptyData();

            // ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºï¼ˆå•é¡Œæ–‡è¡¨ç¤ºå¾Œï¼‰
            this.displayEmptyState();
            if (isInitialLoad) {
              this.state.lastSeenCount = 0;
              // ç©ºãƒ‡ãƒ¼ã‚¿ã¯æ­£å¸¸ãªçŠ¶æ…‹ - ã‚¨ãƒ©ãƒ¼ã§ã¯ãªã„
              this.hadInitialDataLoadFailure = false;
            }
            return;
          }
        }

        // APIæ•´åˆæ€§ - ãƒ‡ãƒ¼ã‚¿å—ä¿¡å®Œäº†

        // ===== PHASE 2.1 & 2.3: STRICT PROCESSING ORDER WITH UNIFIED STATE =====
        // Step 1 & 2: Data acquisition and unified state synchronization
        const syncResult = this.synchronizeStateAfterDataUpdate(result.data, 'performDataLoad');
        // Step 1-2: Data acquisition and state synchronization completed

        // ç†ç”±åˆ—ãƒ‡ãƒãƒƒã‚°: å–å¾—ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ã‚’ç¢ºèª
        // Debug data removed for cleaner logs

        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®è³ªå•æ–‡ã¨ç¾åœ¨è¡¨ç¤ºã®ä¸€è‡´æ€§ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ­ã‚°ãªã—ï¼‰

        // Apply saved reaction states to restore user's previous reactions
        this.applyReactionState(result.data);

        // Populate class filter with available classes and make it visible
        this.populateClassFilter(result.data);

        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°ã§ä½¿ç”¨ï¼‰
        this.state.activeSheetInfo = {
          sheetName: result.sheetName || 'ãƒ•ã‚©ãƒ¼ãƒ ã®å›ç­” 1',
          opinionHeader: result.header || 'ãŠé¡Œ',
          lastUpdated: Date.now(),
        };
        console.log('ğŸ“„ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’æ›´æ–°:', this.state.activeSheetInfo);

        this.lastDataLoadTime = Date.now();

        if (isInitialLoad) {
          // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å®Œäº†ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
          this.initialDataLoaded = true;
          const selectedClass = this.elements.classFilter
            ? this.elements.classFilter.value
            : 'ã™ã¹ã¦';
          const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
          this.lastViewKey = `${selectedClass}-${sortOrder}`;
          // Initial data load completed
        }

        // Update heading with the actual question text from server (only if valid)
        if (
          result.header &&
          this.elements.headingLabel &&
          result.header !== 'èª­ã¿è¾¼ã¿ä¸­...' &&
          !result.header.includes('èª­ã¿è¾¼ã¿') &&
          result.header.trim() !== ''
        ) {
          this.elements.headingLabel.textContent = result.header;
        }

        // Step 3: DOM update with proper sequencing (Phase 2.1)
        requestAnimationFrame(async () => {
          console.log('âœ… Step 3: DOM update starting...');
          await this.renderBoard(false, isInitialLoad);
          console.log('âœ… Step 3: DOM update completed');

          // Step 4: Consistency validation after DOM update (Phase 2.1)
          console.log('âœ… Step 4: Consistency validation starting...');
          await this.validatePostLoadState();
          console.log('âœ… Step 4: Consistency validation completed');
        });

        // Post-processing after successful data load
        this.adjustLayout();

        if (!this.state.isAdminUser) {
          this.state.showAdminFeatures = false;
          this.state.showHighlightToggle = false;
          // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’ç¢ºå®Ÿã«éè¡¨ç¤º
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.add('hidden');
            this.elements.adminToggleBtn.setAttribute('hidden', '');
            this.elements.adminToggleBtn.style.display = 'none';
          }
        } else {
          this.state.showHighlightToggle = true;
          // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.style.display = '';
          }
          // Admin settings updated
          this.cache.clear();
          // Cache cleared due to admin highlight settings
        }

        if (isInitialLoad) {
          this.elements.answersContainer.classList.add('render-optimized');
          // If loading is active, also add loading-safe class to prevent stacking context issues
          if (
            document.body.classList.contains('loading-active') ||
            this.elements.answersContainer.classList.contains('loading-active')
          ) {
            this.elements.answersContainer.classList.add('loading-safe');
          }
        }
      } catch (error) {
        console.error('Error loading sheet data:', error);
        const errorMessage = this.escapeHtml(error.message || 'Unknown error');
        this.elements.answersContainer.querySelectorAll('.skeleton').forEach((el) => el.remove());
        this.elements.answersContainer.innerHTML = `<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">
          <p class="font-bold">ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>
          <p class="text-sm mt-2">${errorMessage}</p>
          <button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">å†è©¦è¡Œ</button>
        </div>`;
        // åŒæœŸã‚¨ãƒ©ãƒ¼ã®å ´åˆã«ã‚‚ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
        this.state.isLoading = false;
        this.hideLoadingOverlay();
      }
    }

    async loadAvailableSheets() {
      try {
        const sheetsData = await this.gas.getAvailableSheets();
        this.populateSheetSelector(sheetsData);
      } catch (error) {
        console.error('Failed to load available sheets:', error);
        if (this.elements.sheetSelector) {
          this.elements.sheetSelector.innerHTML =
            '<option value="">ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆèª­ã¿è¾¼ã¿å¤±æ•—</option>';
        }
      }
    }
    populateSheetSelector(sheets) {
      const selector = this.elements.sheetSelector;

      if (!selector) return;

      if (!sheets || sheets.length === 0) {
        selector.innerHTML = '<option value="">åˆ©ç”¨å¯èƒ½ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</option>';
        selector.disabled = true;
        return;
      }

      // ã‚·ãƒ¼ãƒˆé¸æŠè‚¢ã‚’æ§‹ç¯‰
      if (!Array.isArray(sheets)) {
        console.error('Invalid sheets data:', sheets);
        selector.innerHTML = '<option>ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</option>';
        selector.disabled = true;
        return;
      }

      const options = sheets
        .map((sheet) => {
          const selected = sheet.name === this.state.sheetName ? 'selected' : ''; // Use sheet.name for comparison
          const activeLabel =
            sheet.name === this.state.sheetName ? ' (ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ)' : '';
          return `<option value="${this.escapeHtml(sheet.name)}" ${selected}>${this.escapeHtml(sheet.name)}${activeLabel}</option>`;
        })
        .join('');

      selector.innerHTML = options;
      selector.disabled = false;

      // ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã‚’è¨˜éŒ²
      // this.state.currentActiveSheet is already set by loadSheetData
    }
    async switchSheet() {
      const selectedSheet = this.elements.sheetSelector.value;

      // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³: ç„¡åŠ¹ãªé¸æŠã¾ãŸã¯åŒã˜ã‚·ãƒ¼ãƒˆ
      if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
        console.log('Sheet switch skipped - same sheet or invalid selection');
        return;
      }

      // ç¾åœ¨åˆ‡ã‚Šæ›¿ãˆä¸­ã®å ´åˆã¯å‡¦ç†ã‚’æ‹’å¦
      if (this.sheetSwitchInProgress) {
        console.log('Sheet switch already in progress - ignoring request');
        return;
      }

      console.log('ğŸ”„ Starting sheet switch:', {
        from: this.state.currentActiveSheet,
        to: selectedSheet,
        userId: this.state.userId,
      });

      try {
        this.sheetSwitchInProgress = true;

        // å‰å‡¦ç†: çŠ¶æ…‹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        await this.prepareForSheetSwitch(selectedSheet);

        // ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹: ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        await this.performSheetSwitch(selectedSheet);

        // å¾Œå‡¦ç†: çŠ¶æ…‹ã®ç¢ºå®š
        await this.finalizeSheetSwitch(selectedSheet);

        console.log('âœ… Sheet switch completed:', {
          newSheet: selectedSheet,
          dataCount: this.state.currentAnswers?.length || 0,
        });
      } catch (error) {
        console.error('âŒ Sheet switch failed:', error);
        await this.handleSheetSwitchError(error, selectedSheet);
      } finally {
        this.sheetSwitchInProgress = false;
      }
    }

    async prepareForSheetSwitch(targetSheet) {
      // å¿…è¦ãªå‰ææ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
      if (!this.state.userId) {
        throw new Error('User ID is missing - cannot switch sheet');
      }

      // UIçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.dismissNewContentBanner();

      // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
      this.clearVirtualScrollingState();

      // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’ä¸€æ™‚åœæ­¢
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }

      console.log('Sheet switch preparation completed');
    }

    async performSheetSwitch(targetSheet) {
      const maxRetries = 3;
      let lastError = null;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          console.log(`ğŸ”„ Loading sheet data (attempt ${attempt}/${maxRetries}):`, targetSheet);

          await this.loadSheetData({
            bypassCache: true,
            requestedSheetName: targetSheet,
            showLoading: true,
          });

          console.log('âœ… Sheet data loaded successfully on attempt', attempt);
          return; // æˆåŠŸæ™‚ã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
        } catch (error) {
          lastError = error;
          console.warn(`âš ï¸ Sheet load attempt ${attempt} failed:`, error.message);

          if (attempt < maxRetries) {
            const delay = attempt * 1000; // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
            console.log(`â³ Retrying in ${delay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }

      // ã™ã¹ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ãŸå ´åˆ
      throw new Error(
        `Failed to load sheet after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`
      );
    }

    async finalizeSheetSwitch(targetSheet) {
      // çŠ¶æ…‹ã®ç¢ºå®š
      this.state.currentActiveSheet = targetSheet;
      this.state.sheetName = targetSheet;

      // æ–°ç€é€šçŸ¥ã®åŸºæº–ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.state.lastSeenCount = this.state.currentAnswers?.length || 0;

      // UIã®æ›´æ–°
      this.updateSheetSelectorLabels();
      this.updateSheetDisplayName(targetSheet);

      // ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†é–‹
      this.startPolling();

      console.log('Sheet switch finalization completed');
    }

    async handleSheetSwitchError(error, targetSheet) {
      console.error('Sheet switch error details:', {
        error: error.message,
        targetSheet,
        currentSheet: this.state.currentActiveSheet,
        userId: this.state.userId,
      });

      // å…ƒã®ã‚·ãƒ¼ãƒˆã®é¸æŠã«æˆ»ã™
      if (this.elements.sheetSelector) {
        this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
      }

      // ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’å†é–‹ï¼ˆå…ƒã®ã‚·ãƒ¼ãƒˆã§ï¼‰
      this.startPolling();

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’é€šçŸ¥
      if (window.messageManager) {
        window.messageManager.show(
          `ãƒœãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`,
          'error',
          5000
        );
      }

      // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã§UIæ›´æ–°ã‚’è©¦è¡Œ
      try {
        this.renderBoard(false, false);
      } catch (renderError) {
        console.error('Failed to render board after sheet switch error:', renderError);
      }
    }

    updateSheetDisplayName(sheetName) {
      if (this.elements.sheetNameText && sheetName) {
        const sheetIcon = this.getIcon('users', 'w-3 h-3 inline-block mr-1');
        this.elements.sheetNameText.innerHTML = sheetIcon + this.escapeHtml(sheetName);
      }
    }

    clearVirtualScrollingState() {
      // ãƒãƒ¼ãƒãƒ£ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      if (this.virtualScrollState) {
        this.virtualScrollState = {
          renderedItems: 0,
          totalItems: 0,
          isLoading: false,
          renderedRowIndexes: new Set(),
          cardRegistry: new Map(),
        };
      }

      // æ—¢å­˜ã®ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‚’åˆ‡æ–­
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
        this.scrollObserver = null;
      }

      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
        // visibilityObserver ã¯ setupObservers() ã§å†ä½œæˆã•ã‚Œã‚‹ã®ã§ null ã«ã—ãªã„
      }
    }

    updateSheetSelectorLabels() {
      const selector = this.elements.sheetSelector;
      const options = Array.from(selector.options);

      options.forEach((option) => {
        const sheetName = option.value;
        const isActive = sheetName === this.state.currentActiveSheet;
        const cleanName = sheetName.replace(/ \(ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ\)$/, '');

        if (isActive) {
          option.textContent = `${cleanName} (ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆ)`;
        } else {
          option.textContent = cleanName;
        }
      });
    }

    populateClassFilter(rows) {
      const classFilter = this.elements.classFilter;
      // Ensure rows is an array before mapping
      const uniqueClasses = [
        'ã™ã¹ã¦',
        ...new Set(Array.isArray(rows) ? rows.map((r) => r.class).filter(Boolean) : []),
      ];
      classFilter.innerHTML = uniqueClasses
        .map((c) => `<option value="${this.escapeHtml(c)}">${this.escapeHtml(c)}</option>`)
        .join('');
      classFilter.value = 'ã™ã¹ã¦';
      classFilter.classList.remove('hidden');
    }

    applyReactionStyles(element, data) {
      if (!element || !data || !(element instanceof HTMLElement)) return;

      // æ—¢å­˜ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–¢é€£ã‚¯ãƒ©ã‚¹ã‚’ã‚¯ãƒªã‚¢
      const reactionClasses = [
        'reaction-bg-like',
        'reaction-bg-understand',
        'reaction-bg-curious',
        'reaction-bg-like-understand',
        'reaction-bg-like-curious',
        'reaction-bg-understand-curious',
        'reaction-bg-like-understand-curious',
        'reaction-border-1',
        'reaction-border-2',
        'reaction-border-3',
        'highlighted',
      ];
      reactionClasses.forEach((cls) => element.classList.remove(cls));

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’é©ç”¨ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾ã‚ˆã‚Šå„ªå…ˆï¼‰
      if (data.highlight) {
        element.classList.add('highlighted');
        // Highlight decoration applied
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ™‚ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾ã‚’ã‚¹ã‚­ãƒƒãƒ—
        return;
      } else {
        // No highlight decoration
      }

      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç‰¹å®š
      const active = this.reactionTypes
        .filter(
          (rt) => data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
        )
        .map((rt) => rt.key);

      // èƒŒæ™¯è‰²ã‚¯ãƒ©ã‚¹ã‚’é©ç”¨
      if (active.length === 1) {
        if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
        else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
        else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
      } else if (active.length === 2) {
        const sorted = active.sort();
        if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE')
          element.classList.add('reaction-bg-like-curious');
        else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND')
          element.classList.add('reaction-bg-like-understand');
        else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND')
          element.classList.add('reaction-bg-understand-curious');
      } else if (active.length === 3) {
        element.classList.add('reaction-bg-like-understand-curious');
      }

      // ãƒœãƒ¼ãƒ€ãƒ¼å¹…ã‚’é©ç”¨
      const totalReactions = this.reactionTypes.reduce(
        (sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0),
        0
      );
      if (totalReactions >= 10) {
        element.classList.add('reaction-border-3');
      } else if (totalReactions >= 5) {
        element.classList.add('reaction-border-2');
      } else if (totalReactions > 0) {
        element.classList.add('reaction-border-1');
      }
    }
    async renderBoard(isLayoutChange = false, isInitialLoad = false, oldRows = []) {
      try {
        // Define newRows first to avoid TDZ error
        const newRows = this.state.currentAnswers;

        // ç©ºãƒ‡ãƒ¼ã‚¿ã®å ´åˆã®æ—©æœŸå‡¦ç†
        if (!newRows || newRows.length === 0) {
          console.log('renderBoard: ç©ºãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã€DOMã‚’ã‚¯ãƒªã‚¢ã—ã¦ç©ºçŠ¶æ…‹ã‚’è¡¨ç¤ºã—ã¾ã™');
          await this.renderEmptyState();
          return;
        }

        // ç®¡ç†è€…ãƒã‚¤ãƒ©ã‚¤ãƒˆè¨­å®šã®åˆæœŸåŒ–
        this.initializeAdminSettings();

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‰ã®çŠ¶æ…‹æº–å‚™
        this.prepareRenderingState(newRows);

        // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç†
        this.performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad);

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¾Œã®çŠ¶æ…‹æ›´æ–°
        this.finalizeRenderingState();
        this.validatePostLoadState();
      } catch (error) {
        console.error('âŒ renderBoard: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
        this.handleRenderingError(error);
      }
    }

    async renderEmptyState() {
      await this.clearAllCardsForEmptyData();
      this.displayEmptyState();
    }

    initializeAdminSettings() {
      // ç®¡ç†è€…ã®å ´åˆã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒˆã‚°ãƒ«ã‚’ç¢ºå®Ÿã«æœ‰åŠ¹åŒ–
      if (this.state.isAdminUser && !this.state.showHighlightToggle) {
        this.state.showHighlightToggle = true;
        this.cache.clear();
      }
    }

    prepareRenderingState(newRows) {
      const container = this.elements.answersContainer;
      container.querySelectorAll('.skeleton').forEach((el) => el.remove());

      this.updateLayoutControls(newRows);
    }

    updateLayoutControls(newRows) {
      // Batch DOM updates using performance-aware batching
      const updates = [];
      if (
        this.elements.sliderValue &&
        this.elements.sizeSlider &&
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value
      ) {
        updates.push(
          () => (this.elements.sliderValue.textContent = this.elements.sizeSlider.value)
        );
      }
      if (this.elements.sizeSlider) {
        const container = this.elements.answersContainer;
        const colsMap = {
          '2': 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-2',
          '3': 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3',
          '4': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4',
          '5': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5',
          '6': 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6'
        };
        const newClassName = colsMap[this.elements.sizeSlider.value] || 'grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4';
        if (container.className !== newClassName) {
          updates.push(() => (container.className = newClassName));
        }
      }
      if (this.elements.answerCount) {
        const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1 text-blue-400');
        const countHtml = `${userIcon}<span>${newRows.length}ä»¶</span>`;
        if (this.elements.answerCount.innerHTML !== countHtml) {
          updates.push(() => (this.elements.answerCount.innerHTML = countHtml));
        }
      }

      // Apply updates using performance-aware batching
      this.batchDOMUpdates(updates);
    }

    performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad) {
      const container = this.elements.answersContainer;

      // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã®ãƒãƒƒãƒ—ã‚’ä½œæˆï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰ - ã‚¯ãƒªã‚¢å‰ã«å®Ÿè¡Œ
      const existingMap = new Map();
      container.querySelectorAll('.answer-card').forEach((card) => {
        existingMap.set(card.dataset.rowIndex, card);
      });

      // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
      container.innerHTML = '';

      // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸå‹•çš„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æˆ¦ç•¥
      const dataSize = newRows.length;
      const shouldUseVirtualScrolling = this.shouldUseVirtualScrolling(dataSize);

      console.log(
        `ğŸ¯ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æˆ¦ç•¥é¸æŠ: ${dataSize}ä»¶ãƒ‡ãƒ¼ã‚¿ -> ${shouldUseVirtualScrolling ? 'ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«' : 'ç›´æ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°'}`
      );

      // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç†
      if (shouldUseVirtualScrolling) {
        this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad);
      } else {
        this.renderDirectly(newRows, oldRows, container, existingMap);
      }
    }

    shouldUseVirtualScrolling(dataSize) {
      // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸå‹•çš„åˆ¤å®š
      if (dataSize <= 150) {
        // å°ã€œä¸­ãƒ‡ãƒ¼ã‚¿: ç›´æ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è‰¯å¥½ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸è¦ï¼‰
        return false;
      } else if (dataSize <= 500) {
        // ä¸­ã€œå¤§ãƒ‡ãƒ¼ã‚¿: ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆåˆæœŸè¡¨ç¤º75-100ä»¶ï¼‰
        return true;
      } else {
        // å¤§é‡ãƒ‡ãƒ¼ã‚¿: ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆåˆæœŸè¡¨ç¤º50-75ä»¶ï¼‰
        return true;
      }
    }

    renderDirectly(newRows, oldRows, container, existingMap) {
      const startTime = performance.now();
      const totalItems = newRows.length;

      console.log(`ğŸ¯ ç›´æ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹: ${totalItems}ä»¶ãƒ‡ãƒ¼ã‚¿ï¼ˆå…¨ä»¶è¡¨ç¤ºï¼‰`);

      const fragment = this.getReusableFragment();
      let newCardsCount = 0;
      let updatedCardsCount = 0;
      let reusedCardsCount = 0;
      let failedCardsCount = 0;

      newRows.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find((r) => r.rowIndex === row.rowIndex);

        if (!card) {
          // æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’å«ã‚€ï¼‰
          card = this.createAnswerCard(row);
          if (card) {
            card.classList.add('new-card');
            fragment.appendChild(card);
            newCardsCount++;
          } else {
            console.warn('renderBoard: Failed to create card for row:', row.rowIndex);
            failedCardsCount++;
          }
        } else if (this.shouldUpdateCard(row, oldData)) {
          // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰
          this.updateAnswerCard(card, row, oldData);
          updatedCardsCount++;
        } else {
          reusedCardsCount++;
        }
      });

      if (fragment.children.length > 0) {
        container.appendChild(fragment);
      }

      const endTime = performance.now();
      console.log(
        `âœ… ç›´æ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº†: ${(endTime - startTime).toFixed(2)}ms | æ–°è¦: ${newCardsCount}, æ›´æ–°: ${updatedCardsCount}, å†åˆ©ç”¨: ${reusedCardsCount}, å¤±æ•—: ${failedCardsCount}`
      );
    }

    calculateVisibleRange(totalItems) {
      const container = this.elements.answersContainer;
      if (!container) {
        console.warn('calculateVisibleRange: answersContainer not found.');
        const initialDisplay = this.getOptimalInitialDisplay(totalItems);
        return { startIndex: 0, endIndex: Math.min(initialDisplay, totalItems) };
      }

      const scrollTop = container.scrollTop;
      // ğŸš€ ã‚ˆã‚Šå …ç‰¢ãªã‚³ãƒ³ãƒ†ãƒŠé«˜ã•å–å¾—
      let containerHeight =
        container.clientHeight ||
        container.getBoundingClientRect().height ||
        container.offsetHeight;

      const cardHeight = 150; // ä»®ã®ã‚«ãƒ¼ãƒ‰ã®é«˜ã•ã€‚å®Ÿéš›ã®CSSã«åŸºã¥ã„ã¦èª¿æ•´ãŒå¿…è¦ã€‚

      let startIndex = 0;
      let endIndex = totalItems;

      if (containerHeight > 0) {
        startIndex = Math.floor(scrollTop / cardHeight);
        endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight) + 5); // ãƒãƒƒãƒ•ã‚¡è¿½åŠ 
      } else {
        // ğŸš€ DOMæº–å‚™å®Œäº†å¾…ã¡ã®å‡¦ç† - ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåˆæœŸè¡¨ç¤º
        if (this.state.initialDataLoaded) {
          console.warn('calculateVisibleRange: containerHeight is 0, showing initial batch.');
          const initialDisplay = this.getOptimalInitialDisplay(totalItems);
          return { startIndex: 0, endIndex: Math.min(initialDisplay, totalItems) };
        }
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé«˜ã•ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç®—
        containerHeight = 600;
        startIndex = Math.floor(scrollTop / cardHeight);
        endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight) + 5);
      }

      // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸæœ€å°è¡¨ç¤ºä»¶æ•°ã‚’ä¿è¨¼
      const minDisplay = this.getOptimalMinDisplay(totalItems);
      if (endIndex - startIndex < minDisplay && totalItems > minDisplay) {
        endIndex = Math.min(startIndex + minDisplay, totalItems);
      }

      return { startIndex, endIndex };
    }

    getOptimalInitialDisplay(totalItems) {
      // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåˆæœŸè¡¨ç¤ºä»¶æ•°ã®å‹•çš„è¨ˆç®—
      if (totalItems <= 500) {
        // ä¸­ãƒ‡ãƒ¼ã‚¿: ã‚ˆã‚Šå¤šãè¡¨ç¤ºï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£é‡è¦–ï¼‰
        return Math.min(100, totalItems);
      } else if (totalItems <= 1000) {
        // å¤§ãƒ‡ãƒ¼ã‚¿: ãƒãƒ©ãƒ³ã‚¹é‡è¦–
        return 75;
      } else {
        // è¶…å¤§ãƒ‡ãƒ¼ã‚¿: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–
        return 50;
      }
    }

    getOptimalMinDisplay(totalItems) {
      // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ãŸæœ€å°è¡¨ç¤ºä»¶æ•°ã®å‹•çš„è¨ˆç®—
      if (totalItems <= 500) {
        return Math.min(75, totalItems);
      } else if (totalItems <= 1000) {
        return 50;
      } else {
        return 30;
      }
    }

    renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad) {
      const startTime = performance.now();
      const totalItems = newRows.length;

      console.log(`ğŸš€ ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é–‹å§‹: ${totalItems}ä»¶ãƒ‡ãƒ¼ã‚¿ (åˆæœŸãƒ­ãƒ¼ãƒ‰: ${isInitialLoad})`);

      if (isInitialLoad || this.state.currentAnswers.length === 0) {
        this.clearVirtualScrollingState();
      }

      // ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ã‚‚æ—¢å­˜ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒ
      const fragment = this.getReusableFragment();
      const visibleRange = this.calculateVisibleRange(totalItems);
      const visibleRows = newRows.slice(visibleRange.startIndex, visibleRange.endIndex);

      const optimalDisplay = this.getOptimalInitialDisplay(totalItems);
      console.log(
        `ğŸ“Š ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è©³ç´°: ç¯„å›² ${visibleRange.startIndex}-${visibleRange.endIndex} (${visibleRows.length}ä»¶è¡¨ç¤º) / æœ€é©åˆæœŸè¡¨ç¤º ${optimalDisplay}ä»¶`
      );

      let newCardsCount = 0;
      let updatedCardsCount = 0;
      let reusedCardsCount = 0;

      visibleRows.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find((r) => r.rowIndex === row.rowIndex);

        if (!card) {
          card = this.createAnswerCard(row);
          if (card) {
            fragment.appendChild(card);
            newCardsCount++;
          }
        } else if (this.shouldUpdateCard(row, oldData)) {
          // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒï¼‰
          this.updateAnswerCard(card, row, oldData);
          updatedCardsCount++;
        } else {
          reusedCardsCount++;
        }
      });

      if (fragment.children.length > 0) {
        container.appendChild(fragment);
      }

      const endTime = performance.now();
      console.log(
        `âœ… ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†: ${(endTime - startTime).toFixed(2)}ms | æ–°è¦: ${newCardsCount}, æ›´æ–°: ${updatedCardsCount}, å†åˆ©ç”¨: ${reusedCardsCount}`
      );
    }

    shouldUpdateCard(newData, oldData) {
      if (!oldData) return true;

      const newReactionCount = this.reactionTypes.reduce(
        (sum, rt) => sum + (newData.reactions?.[rt.key]?.count || 0),
        0
      );
      const oldReactionCount = this.reactionTypes.reduce(
        (sum, rt) => sum + (oldData.reactions?.[rt.key]?.count || 0),
        0
      );

      return (
        newReactionCount !== oldReactionCount ||
        newData.isHighlighted !== oldData.isHighlighted ||
        newData.opinion !== oldData.opinion ||
        this.validateReasonText(newData.reason) !== this.validateReasonText(oldData.reason) ||
        newData.name !== oldData.name
      );
    }

    finalizeRenderingState() {
      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº†å¾Œã®çŠ¶æ…‹æ›´æ–°
      this.updateAnswerCount();
      this.applyAnimations();
    }

    updateAnswerCount() {
      if (!this.elements.answerCount) return;

      const count = Array.isArray(this.state.currentAnswers) ? this.state.currentAnswers.length : 0;
      const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
      this.elements.answerCount.innerHTML = `${userIcon}<span>${count}ä»¶</span>`;
    }

    applyAnimations() {
      if (!this.elements.answersContainer) return;

      const newCards = this.elements.answersContainer.querySelectorAll('.new-card');
      newCards.forEach((card) => {
        requestAnimationFrame(() => {
          card.classList.remove('new-card');
        });
      });
    }

    handleRenderingError(error) {
      console.error('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', error);

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å°é™ã®è¡¨ç¤ºã‚’è©¦è¡Œ
      try {
        const container = this.elements.answersContainer;
        container.innerHTML = `
        <div class="text-center py-8 col-span-full">
          <p class="text-red-400">è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>
          <button onclick="location.reload()" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded">
            å†èª­ã¿è¾¼ã¿
          </button>
        </div>
      `;
      } catch (fallbackError) {
        console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºã‚‚å¤±æ•—:', fallbackError);
      }
    }

    updateAnswerCard(card, newData, oldData) {
      if (!card || !newData) return;

      try {
        if (!oldData || oldData.opinion !== newData.opinion) {
          const opinionElement = card.querySelector('.opinion-text');
          if (opinionElement) {
            opinionElement.textContent = newData.opinion || '';
          }
        }

        if (
          !oldData ||
          this.validateReasonText(oldData.reason) !== this.validateReasonText(newData.reason)
        ) {
          const reasonElement = card.querySelector('.answer-preview p');
          if (reasonElement) {
            reasonElement.textContent = newData.reason || '';
          }
        }

        if (!oldData || oldData.name !== newData.name) {
          const nameElement = card.querySelector('.font-bold');
          if (nameElement) {
            nameElement.textContent = newData.name || '';
          }
        }

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿æŒã—ã¤ã¤æ›´æ–°
        this.updateCardReactions(card, newData);

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’æ›´æ–°
        this.updateCardHighlight(card, newData);
      } catch (error) {
        console.error('updateAnswerCard error:', error);
      }
    }

    updateCardReactions(card, data) {
      const reactionContainer = card.querySelector('.reaction-container');
      if (!reactionContainer) return;

      // DOMæ“ä½œã‚’ãƒãƒƒãƒåŒ–
      const updates = [];

      this.reactionTypes.forEach((reactionType) => {
        const newCount = data.reactions?.[reactionType.key]?.count || 0;
        const reacted = data.reactions?.[reactionType.key]?.reacted || false;

        // ãƒãƒƒãƒæ›´æ–°ç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©
        updates.push({
          rowIndex: data.rowIndex,
          reaction: reactionType.key,
          count: newCount,
          reacted,
          shouldDisplay: newCount > 0,
        });
      });

      // ãƒãƒƒãƒã§DOMæ›´æ–°ã‚’å®Ÿè¡Œ
      this.batchUpdateReactionButtons(updates);
      this.updateCardReactionBackground(card, data);
    }

    // ãƒãƒƒãƒå‡¦ç†ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
    batchUpdateReactionButtons(updates, options = {}) {
      const { onComplete, immediate = false } = options;
      const fragment = document.createDocumentFragment();
      const updatedElements = new Map();

      const executeUpdate = () => {
        try {
          updates.forEach((update) => {
            const buttons = document.querySelectorAll(
              `[data-row-index="${update.rowIndex}"][data-reaction="${update.reaction}"]`
            );

            buttons.forEach((btn) => {
              if (!updatedElements.has(btn)) {
                // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºæ›´æ–°
                const countEl = btn.querySelector('.reaction-count');
                if (countEl && this.state.showCounts) {
                  countEl.textContent = update.count;
                }

                // ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
                const rt = this.reactionTypes.find((r) => r.key === update.reaction);
                const svgEl = btn.querySelector('svg');
                if (svgEl && rt) {
                  svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', update.reacted);
                }

                // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
                const colorClass =
                  update.reaction === 'LIKE'
                    ? 'text-red-500'
                    : update.reaction === 'UNDERSTAND'
                      ? 'text-yellow-500'
                      : 'text-green-500';
                btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
                btn.classList.add(colorClass);
                btn.classList.toggle('liked', update.reacted);
                btn.setAttribute('aria-pressed', update.reacted.toString());

                // è¡¨ç¤º/éè¡¨ç¤º
                btn.style.display = update.shouldDisplay ? 'flex' : 'none';

                // aria-labelæ›´æ–°
                const reactionNames = {
                  LIKE: 'ã„ã„ã­ï¼',
                  UNDERSTAND: 'ãªã‚‹ã»ã©ï¼',
                  CURIOUS: 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼',
                };
                const reactionName = reactionNames[update.reaction] || update.reaction;
                const ariaLabel = `${reactionName}${update.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${update.count}ä»¶)` : ''}`;
                btn.setAttribute('aria-label', ariaLabel);

                updatedElements.set(btn, true);
              }
            });
          });

          // å®Œäº†ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
          if (onComplete) {
            onComplete(updatedElements);
          }
        } catch (error) {
          console.error('batchUpdateReactionButtons error:', error);
          if (onComplete) {
            onComplete(updatedElements, error);
          }
        }
      };

      // å³åº§å®Ÿè¡Œ or requestAnimationFrame
      if (immediate) {
        executeUpdate();
      } else {
        requestAnimationFrame(executeUpdate);
      }
    }

    updateCardReactionBackground(card, data) {
      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯ã¨ãƒœãƒ¼ãƒ€ãƒ¼ã‚’æ›´æ–°
      this.applyReactionStyles(card, data);
    }

    updateCardHighlight(card, data) {
      const isHighlighted = data.isHighlighted || data.highlight;

      if (isHighlighted) {
        card.classList.add('highlighted-card');
      } else {
        card.classList.remove('highlighted-card');
      }

      // Update highlight button if present
      const highlightBtn = card.querySelector('.highlight-btn');
      if (highlightBtn) {
        highlightBtn.classList.toggle('active', isHighlighted);
      }
    }

    updateExistingCard(card, row, oldData, changedItems) {
      if (oldData) {
        let hasChanges = false;

        if (oldData.opinion !== row.opinion) {
          const t = card.querySelector('.opinion-text');
          if (t) {
            t.textContent = row.opinion;
            hasChanges = true;
          }
        }

        if (oldData.reason !== row.reason) {
          const p = card.querySelector('.answer-preview p');
          if (p) {
            p.textContent = row.reason;
            hasChanges = true;
          }
        }

        if (oldData.name !== row.name) {
          const n = card.querySelector('.font-bold');
          if (n) {
            n.textContent = row.name;
            hasChanges = true;
          }
        }

        if (
          JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) ||
          oldData.highlight !== row.highlight
        ) {
          hasChanges = true;
        }

        if (hasChanges) {
          changedItems.push(row);
        }
      }
    }
    createAnswerCard(data) {
      try {
        // Data validation and sanitization
        if (!data || typeof data !== 'object') {
          console.warn('createAnswerCard: Invalid data provided:', data);
          return null;
        }

        // é‡è¦ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãªã„å ´åˆã®å‡¦ç†
        if (!data.opinion && !data.reason) {
          console.warn('createAnswerCard: ãƒ‡ãƒ¼ã‚¿ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆopinion/reasonï¼‰ãŒã‚ã‚Šã¾ã›ã‚“:', {
            rowIndex: data.rowIndex,
            hasOpinion: !!data.opinion,
            hasReason: !!data.reason,
            dataKeys: Object.keys(data),
          });
          // ç©ºã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ã‚‚ã‚«ãƒ¼ãƒ‰ã¯ä½œæˆã™ã‚‹ï¼ˆã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã¨ã—ã¦è¡¨ç¤ºï¼‰
        }

        // Ensure required properties exist with safe defaultsï¼ˆç†ç”±åˆ—ã®å …ç‰¢åŒ–ï¼‰
        const safeData = {
          rowIndex: data.rowIndex || 0,
          opinion: data.opinion || '',
          reason: this.validateReasonText(data.reason),
          name: data.name || '',
          email: data.email || '',
          reactions: data.reactions || {},
          highlight: Boolean(data.highlight),
        };

        // Optimized cache key generation (faster than JSON.stringify)
        const cacheKey = `${safeData.rowIndex}-${safeData.opinion.slice(0, 50)}-${safeData.reason.slice(0, 30)}-${safeData.name}-${JSON.stringify(safeData.reactions)}-${safeData.highlight}-${this.state.showCounts}-${this.state.displayMode}-${this.state.showHighlightToggle}`;

        // Answer card cache check
        const cachedCard = this.cache.get(`render-${cacheKey}`);
        if (cachedCard) {
          try {
            const clonedCard = cachedCard.cloneNode(true);
            // Ensure cloned card has proper data-row-index
            clonedCard.dataset.rowIndex = safeData.rowIndex;

            // Optimized: Only update elements that need row index (avoid querySelectorAll)
            const reactionButtons = clonedCard.querySelectorAll('.reaction-btn');
            reactionButtons.forEach((btn) => {
              btn.dataset.rowIndex = safeData.rowIndex;
            });

            return clonedCard;
          } catch (cacheError) {
            console.warn('createAnswerCard: Cache clone error, creating new card:', cacheError);
            // Continue to create new card if cache fails
          }
        }

        const card = document.createElement('div');
        const highlightClass = safeData.highlight ? ' highlighted' : '';
        card.className = `relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer${highlightClass}`;
        card.dataset.rowIndex = safeData.rowIndex;
        card.setAttribute('role', 'article');
        card.setAttribute('tabindex', '0');
        card.setAttribute(
          'aria-label',
          `å›ç­”ã‚«ãƒ¼ãƒ‰: ${safeData.opinion.substring(0, 50)}${safeData.opinion.length > 50 ? '...' : ''}`
        );

        // Answer card created
        let highlightBtnHtml = '';
        // Highlight button condition check
        if (this.state.showHighlightToggle) {
          const cls = safeData.highlight ? 'liked' : '';
          const highlightAriaLabel = safeData.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
          highlightBtnHtml = `<button type="button" class="highlight-btn like-btn text-purple-600 ${cls}" aria-label="${highlightAriaLabel}" aria-pressed="${safeData.highlight}" data-row-index="${safeData.rowIndex}">${this.getIcon('star', 'w-5 h-5', safeData.highlight)}</button>`;
        }

        // ğŸ—‘ï¸ å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
        let deleteBtnHtml = '';
        if (this.state.showAdminFeatures) {
          deleteBtnHtml = `
          <button type="button" 
            class="delete-answer-btn text-red-500 hover:text-red-400 transition-colors ml-2"
            aria-label="ã“ã®å›ç­”ã‚’å‰Šé™¤"
            data-row-index="${safeData.rowIndex}"
            title="å‰Šé™¤">
            ${this.getIcon('trash', 'w-5 h-5')}
          </button>`;
        }
        const showName = this.state.displayMode === 'named';
        let displayName = '';

        if (showName) {
          // åå‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°emailã‹ã‚‰ç”Ÿæˆ
          if (safeData.name) {
            displayName = safeData.name;
          } else if (safeData.email) {
            try {
              displayName = safeData.email.split('@')[0];
            } catch (emailError) {
              console.warn('createAnswerCard: Email parsing error:', emailError);
              displayName = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
            }
          }
        }

        const nameHtml =
          showName && displayName
            ? `<div class="name-display flex-shrink-0 mr-2"><span class="font-bold text-sm text-cyan-300 bg-gray-800/50 px-2 py-1 rounded border border-cyan-400">${this.escapeHtml(displayName)}</span></div>`
            : '';
        const containerClass = nameHtml
          ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex flex-col sm:flex-row justify-between items-start sm:items-center gap-y-1 min-h-[2rem]'
          : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';

        // Name display configuration complete
        const reactionButtonsHtml = this.reactionTypes
          .map((rt) => {
            try {
              const info =
                safeData.reactions && safeData.reactions[rt.key]
                  ? safeData.reactions[rt.key]
                  : { count: 0, reacted: false };
              const cls = info.reacted ? 'liked' : '';
              const colorClass =
                rt.key === 'LIKE'
                  ? 'text-red-500'
                  : rt.key === 'UNDERSTAND'
                    ? 'text-yellow-500'
                    : 'text-green-500';
              const countSpan = this.state.showCounts
                ? `<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">${info.count || 0}</span>`
                : '';
              const reactionNames = {
                LIKE: 'ã„ã„ã­ï¼',
                UNDERSTAND: 'ãªã‚‹ã»ã©ï¼',
                CURIOUS: 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼',
              };
              const reactionName = reactionNames[rt.key] || rt.key;
              const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count || 0}ä»¶)` : ''}`;
              return `<button type="button" class="reaction-btn like-btn flex items-center gap-1 ${colorClass} ${cls}" data-row-index="${safeData.rowIndex}" data-reaction="${rt.key}" aria-label="${ariaLabel}" aria-pressed="${info.reacted}">${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countSpan}</button>`;
            } catch (reactionError) {
              console.warn('createAnswerCard: Reaction button creation error:', reactionError);
              return ''; // Skip problematic reaction button
            }
          })
          .join('');
        // Optimized: Use DocumentFragment instead of innerHTML for better performance
        const fragment = document.createDocumentFragment();

        // Create main content div
        const contentDiv = document.createElement('div');
        contentDiv.className = 'relative flex-grow mb-3 answer-preview';

        const opinionTitle = document.createElement('h3');
        opinionTitle.className =
          'opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight';
        opinionTitle.textContent = safeData.opinion || 'ï¼ˆå›ç­”å†…å®¹ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸï¼‰';

        const reasonText = document.createElement('p');
        reasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
        // ç©ºã®å ´åˆã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’å‡ºã•ãšã€è¡¨ç¤ºè‡ªä½“ã‚’ã‚¹ã‚­ãƒƒãƒ—
        reasonText.textContent = (safeData.reason || '').trim();

        contentDiv.appendChild(opinionTitle);

        // ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ãªã„å ´åˆã®ã¿è¿½åŠ 
        const shouldAddReason = !!(reasonText.textContent && reasonText.textContent.trim());
        try {
          // ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆã®æœ‰åŠ¹æ€§ã‚’æ¤œè¨¼
          if (shouldAddReason) {
            contentDiv.appendChild(reasonText);
          }
        } catch (reasonError) {
          // ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®å›å¾©å‡¦ç†
          console.warn(
            'createAnswerCard: Reason text append error, attempting recovery:',
            reasonError
          );
          try {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚ç©ºã®å ´åˆã¯è¿½åŠ ã—ãªã„
            const fallbackText = (safeData.reason || '').trim();
            if (fallbackText) {
              const fallbackReasonText = document.createElement('p');
              fallbackReasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
              fallbackReasonText.textContent = fallbackText;
              contentDiv.appendChild(fallbackReasonText);
              console.log('âœ… ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ å®Œäº†ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰');
            } else {
              console.log('â„¹ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚ç†ç”±ã¯ç©ºã®ãŸã‚è¿½åŠ ã—ã¾ã›ã‚“');
            }
          } catch (fallbackError) {
            console.error(
              'createAnswerCard: Failed to add reason text even with fallback:',
              fallbackError
            );
            // ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆãŒè¿½åŠ ã§ããªã„å ´åˆã§ã‚‚ã‚«ãƒ¼ãƒ‰ç”Ÿæˆã¯ç¶™ç¶š
          }
        }

        // Create footer div
        const footerDiv = document.createElement('div');
        footerDiv.className = containerClass;

        // åå‰è¡¨ç¤ºéƒ¨åˆ†ã‚’è¿½åŠ 
        if (nameHtml) {
          try {
            const nameContainer = document.createElement('div');
            nameContainer.className = 'name-container flex-shrink-0';
            nameContainer.innerHTML = nameHtml;
            footerDiv.appendChild(nameContainer);
          } catch (nameError) {
            console.warn('createAnswerCard: Name container creation error:', nameError);
          }
        }

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³éƒ¨åˆ†ã‚’è¿½åŠ 
        try {
          const reactionsDiv = document.createElement('div');
          reactionsDiv.className = 'flex items-center gap-1 flex-shrink-0';
          reactionsDiv.setAttribute('role', 'group');
          reactionsDiv.setAttribute('aria-label', 'å›ç­”ã¸ã®åå¿œ');
          reactionsDiv.innerHTML = reactionButtonsHtml + highlightBtnHtml + deleteBtnHtml;

          footerDiv.appendChild(reactionsDiv);
        } catch (reactionError) {
          console.warn('createAnswerCard: Reactions div creation error:', reactionError);
        }

        fragment.appendChild(contentDiv);
        fragment.appendChild(footerDiv);
        card.appendChild(fragment);

        if (safeData.highlight) {
          try {
            const badge = document.createElement('span');
            badge.className = 'highlight-badge';
            badge.innerHTML = this.getIcon('star', '', true);
            card.appendChild(badge);
          } catch (badgeError) {
            console.warn('createAnswerCard: Highlight badge creation error:', badgeError);
          }
        }

        // çµ±ä¸€ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
        try {
          this.applyReactionStyles(card, safeData);
        } catch (styleError) {
          console.warn('createAnswerCard: Reaction styles application error:', styleError);
        }

        // Cache the card for reuse (limit cache size)
        try {
          if (this.cache.size > 100) {
            this.cache.cleanup();
          }
          this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
        } catch (cacheError) {
          console.warn('createAnswerCard: Cache storage error:', cacheError);
        }

        return card;
      } catch (error) {
        console.error('createAnswerCard: Critical error creating card:', error, 'Data:', data);

        // Return a minimal error card instead of null
        try {
          const errorCard = document.createElement('div');
          errorCard.className =
            'answer-card glass-panel rounded-xl p-4 border-2 border-red-400/50 bg-red-900/20';
          errorCard.innerHTML = `
          <div class="text-red-300 text-center">
            <div class="mb-2">âš ï¸ ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒ©ãƒ¼</div>
            <div class="text-xs text-red-400">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ</div>
          </div>
        `;
          return errorCard;
        } catch (fallbackError) {
          console.error('createAnswerCard: Fallback card creation also failed:', fallbackError);
          return null;
        }
      }
    }

    createSkeletonCard() {
      const card = document.createElement('div');
      card.className =
        'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
      // Simplified skeleton for faster rendering
      card.innerHTML =
        '<div class="h-20 w-full rounded bg-gray-500/30 mb-4"></div><div class="h-6 w-full rounded bg-gray-500/20"></div>';
      return card;
    }

    /**
     * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ï¼ˆæ—¢å­˜ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼‹ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãƒãƒƒãƒå‡¦ç†ï¼‰
     */
    async handleReaction(rowIndex, reaction) {
      const numericRowIndex = parseInt(rowIndex, 10);
      const reactionKey = `${numericRowIndex}-${reaction}`;

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: çŸ­æ™‚é–“ã§ã®é‡è¤‡æ“ä½œã‚’é˜²ã
      const now = Date.now();
      const lastOperation = this.lastReactionTimes?.get(reactionKey);
      if (lastOperation && now - lastOperation < 1000) {
        // 1ç§’ä»¥å†…ã®é‡è¤‡æ“ä½œã‚’é˜²ã
        console.log(`âš¡ é‡è¤‡æ“ä½œã‚¹ã‚­ãƒƒãƒ—: ${reactionKey}`);
        return;
      }

      // å‡¦ç†ä¸­ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆç«¶åˆçŠ¶æ…‹å›é¿ï¼‰
      if (this.pendingReactions.has(reactionKey)) {
        console.log(`â³ å‡¦ç†ä¸­ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—: ${reactionKey}`);
        return;
      }

      // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
      const item = this.state.currentAnswers.find((i) => i.rowIndex == numericRowIndex);
      if (!item) {
        console.warn(`âš ï¸ ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: rowIndex=${numericRowIndex}`);
        return;
      }

      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’å–å¾—ã—ã¦ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è¨­å®š
      const buttons = document.querySelectorAll(
        `[data-row-index="${numericRowIndex}"][data-reaction="${reaction}"]`
      );
      this.setReactionButtonsLoading(buttons, true);

      // UIçŠ¶æ…‹ã®äº‹å‰æ›´æ–°ï¼ˆæ¥½è¦³çš„æ›´æ–°ï¼‰
      const currentState = item.reactions?.[reaction]?.reacted || false;
      if (item.reactions && item.reactions[reaction]) {
        item.reactions[reaction].reacted = !currentState;
        item.reactions[reaction].count = currentState
          ? Math.max(0, (item.reactions[reaction].count || 1) - 1)
          : (item.reactions[reaction].count || 0) + 1;

        // UIå³åº§æ›´æ–°
        this.updateReactionButtonsForItem(item);
      }

      // æ—¢å­˜ã®å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå¸¸ã«ç¶­æŒï¼‰
      this.reactionQueue.set(reactionKey, {
        rowIndex: numericRowIndex,
        reaction,
        timestamp: now,
        originalState: currentState, // å…ƒã®çŠ¶æ…‹ã‚’è¨˜éŒ²ï¼ˆå¾©æ—§ç”¨ï¼‰
      });

      // æœ€å¾Œã®æ“ä½œæ™‚åˆ»ã‚’è¨˜éŒ²
      if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
      this.lastReactionTimes.set(reactionKey, now);

      // ã‚ªãƒ—ã‚·ãƒ§ãƒ³: ãƒãƒƒãƒå‡¦ç†ã‚‚ä¸¦è¡Œå®Ÿè¡Œï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ãªã—ï¼‰
      if (this.enableBatchProcessing && !this.batchProcessingActive) {
        this.addToBatchQueue(numericRowIndex, reaction);
      }

      // æ—¢å­˜ã®ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚’é–‹å§‹ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã‚’ä¿æŒï¼‰
      this.processReactionQueue();
    }

    async processReactionQueue() {
      if (this.isProcessingReactionQueue) return;
      this.isProcessingReactionQueue = true;

      const processingStart = Date.now();
      let processedCount = 0;
      let errorCount = 0;

      try {
        console.log(`ğŸ”„ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼å‡¦ç†é–‹å§‹ (ã‚­ãƒ¥ãƒ¼ã‚µã‚¤ã‚º: ${this.reactionQueue.size})`);

        // ãƒãƒƒãƒå‡¦ç†ãŒæœ‰åŠ¹ã§ã€ã‚­ãƒ¥ãƒ¼ã«è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹å ´åˆã¯ãƒãƒƒãƒå‡¦ç†ã‚’è©¦è¡Œ
        if (
          this.enableBatchProcessing &&
          this.reactionQueue.size > 1 &&
          !this.batchProcessingActive
        ) {
          const canBatch = await this.tryBatchProcessing();
          if (canBatch) {
            // ãƒãƒƒãƒå‡¦ç†æˆåŠŸæ™‚ã¯å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
            processedCount = this.reactionQueue.size;
            this.reactionQueue.clear();
            console.log(`âœ… ãƒãƒƒãƒå‡¦ç†å®Œäº† (${processedCount}ä»¶å‡¦ç†)`);
            return;
          }
          // ãƒãƒƒãƒå‡¦ç†å¤±æ•—æ™‚ã¯æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          console.log('âš ï¸ ãƒãƒƒãƒå‡¦ç†å¤±æ•—ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
        }

        // æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Œå…¨ã«ä¿æŒï¼‰
        const queueEntries = Array.from(this.reactionQueue.entries());

        for (const [reactionKey, operation] of queueEntries) {
          try {
            this.reactionQueue.delete(reactionKey);
            await this.executeReactionOperation(operation, reactionKey);
            processedCount++;
          } catch (error) {
            errorCount++;
            console.error(`âŒ å€‹åˆ¥ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼ (${reactionKey}):`, error);

            // ã‚¨ãƒ©ãƒ¼æ™‚ã®å¾©æ—§å‡¦ç†
            await this.handleReactionError(error, operation.rowIndex, operation.reaction);
          }
        }
      } catch (error) {
        console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼å‡¦ç†è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼:', error);
        errorCount++;
      } finally {
        this.isProcessingReactionQueue = false;

        const processingTime = Date.now() - processingStart;
        console.log(
          `ğŸ“Š ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼å‡¦ç†å®Œäº†: ${processedCount}ä»¶æˆåŠŸ, ${errorCount}ä»¶ã‚¨ãƒ©ãƒ¼, ${processingTime}ms`
        );

        // æ®‹ã£ã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãŒã‚ã‚‹å ´åˆã®è­¦å‘Š
        if (this.reactionQueue.size > 0) {
          console.warn(`âš ï¸ ã‚­ãƒ¥ãƒ¼å‡¦ç†å¾Œã‚‚${this.reactionQueue.size}ä»¶ãŒæ®‹ã£ã¦ã„ã¾ã™`);
        }

        // ã‚¨ãƒ©ãƒ¼ç‡ãŒé«˜ã„å ´åˆã®å¯¾å‡¦
        if (errorCount > 0 && errorCount / (processedCount + errorCount) > 0.5) {
          console.warn('ğŸš¨ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼ç‡ãŒé«˜ã„ã§ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
          if (typeof this.diagnoseReactionSystemHealth === 'function') {
            this.diagnoseReactionSystemHealth();
          }
        }
      }
    }

    async executeReactionOperation(operation, reactionKey) {
      const { rowIndex, reaction } = operation;

      try {
        this.pendingReactions.add(reactionKey);

        const btns = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã¯ handleReaction ã§æ—¢ã«è¨­å®šæ¸ˆã¿ãªã®ã§ã€ã“ã“ã§ã¯è¨­å®šã—ãªã„

        const item = this.state.currentAnswers.find((i) => i.rowIndex == rowIndex);
        if (!item) {
          throw new Error(`Item not found for rowIndex: ${rowIndex}`);
        }

        console.log('ğŸ“¡ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ (Server-first):', {
          rowIndex,
          reaction,
          sheetName: this.state.sheetName,
        });

        // Server-first approach: ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã—ã¦ã‹ã‚‰çµæœã‚’é©ç”¨
        const response = await this.sendReactionToServer(rowIndex, reaction);
        await this.processReactionResponse(item, response, reaction);

        // UIæ›´æ–°ï¼ˆã‚µãƒ¼ãƒãƒ¼å¿œç­”å¾Œã®ã¿ï¼‰
        await this.updateReactionUI(item, false);

        console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†:', reactionKey);

        // å‡¦ç†å®Œäº†ã‚’é€šçŸ¥
        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: true });
      } catch (error) {
        console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        await this.handleReactionError(error, rowIndex, reaction);

        // ã‚¨ãƒ©ãƒ¼å®Œäº†ã‚’é€šçŸ¥
        this.notifyReactionComplete(reactionKey, {
          rowIndex,
          reaction,
          success: false,
          error: error.message,
        });
      } finally {
        this.pendingReactions.delete(reactionKey);

        const btns = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        this.setReactionButtonsLoading(btns, false);
      }
    }

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
    notifyReactionComplete(reactionKey, result) {
      const listeners = this.reactionEventListeners.get(reactionKey);
      if (listeners && listeners.length > 0) {
        listeners.forEach((listener) => {
          try {
            listener(result);
          } catch (error) {
            console.error('âŒ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ãƒªã‚¹ãƒŠãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
          }
        });
        // ä¸€åº¦å®Ÿè¡Œã—ãŸã‚‰å‰Šé™¤
        this.reactionEventListeners.delete(reactionKey);
      }
    }

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿ
    waitForReactionComplete(reactionKey, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          this.reactionEventListeners.delete(reactionKey);
          reject(new Error(`Reaction timeout: ${reactionKey}`));
        }, timeout);

        const listener = (result) => {
          clearTimeout(timeoutId);
          resolve(result);
        };

        if (!this.reactionEventListeners.has(reactionKey)) {
          this.reactionEventListeners.set(reactionKey, []);
        }
        this.reactionEventListeners.get(reactionKey).push(listener);
      });
    }

    // å‹•çš„çŠ¶æ…‹å¤‰åŒ–å¾…æ©Ÿã‚·ã‚¹ãƒ†ãƒ 
    async waitForReactionStateChange(
      rowIndex,
      reaction,
      initialState,
      timeoutMs = 3000,
      pollIntervalMs = 50
    ) {
      const startTime = Date.now();

      const getReactionButtonState = () => {
        const buttons = document.querySelectorAll(
          `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
        );
        if (buttons.length === 0) return null;

        const btn = buttons[0];
        return {
          reacted: btn.getAttribute('aria-pressed') === 'true',
          count: parseInt(btn.querySelector('.count')?.textContent || '0'),
          disabled: btn.disabled,
          classes: btn.className,
          timestamp: Date.now(),
        };
      };

      const hasStateChanged = (current, initial) => {
        if (!current || !initial) return false;
        return (
          current.reacted !== initial.reacted ||
          current.count !== initial.count ||
          current.disabled !== initial.disabled
        );
      };

      return new Promise((resolve, reject) => {
        const poll = () => {
          const currentTime = Date.now();
          if (currentTime - startTime >= timeoutMs) {
            reject(new Error(`State change timeout after ${timeoutMs}ms`));
            return;
          }

          const currentState = getReactionButtonState();
          if (hasStateChanged(currentState, initialState)) {
            resolve({
              initialState,
              currentState,
              changeDetectedAt: currentTime - startTime,
              stateChanged: true,
            });
            return;
          }

          setTimeout(poll, pollIntervalMs);
        };

        poll();
      });
    }

    // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ç›£è¦–ï¼ˆé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ä¸­å¿ƒï¼‰
    async waitForReactionUpdate(rowIndex, reaction, expectedChange = null, maxWaitMs = 3000) {
      const reactionKey = `${rowIndex}-${reaction}`;

      try {
        // å®Œäº†é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®ã¿ã‚’ä½¿ç”¨ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã§ä¿¡é ¼æ€§ãŒé«˜ã„ï¼‰
        const result = await this.waitForReactionComplete(reactionKey, maxWaitMs);
        return result || { timeout: false, success: true };
      } catch (error) {
        console.warn(`âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${reactionKey}`, error.message);
        return {
          error: error.message,
          timeout: true,
          success: false,
        };
      }
    }

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³çŠ¶æ…‹å–å¾—ãƒ˜ãƒ«ãƒ‘ãƒ¼
    getReactionButtonState(rowIndex, reaction) {
      const buttons = document.querySelectorAll(
        `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`
      );
      if (buttons.length === 0) return null;

      const btn = buttons[0];
      return {
        reacted: btn.getAttribute('aria-pressed') === 'true',
        count: parseInt(btn.querySelector('.count')?.textContent || '0'),
        disabled: btn.disabled,
        classes: btn.className,
        visible: btn.style.display !== 'none',
        computedStyle: getComputedStyle(btn),
        timestamp: Date.now(),
      };
    }

    // ãƒãƒƒãƒå‡¦ç†é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã«å½±éŸ¿ã—ãªã„è¿½åŠ æ©Ÿèƒ½ï¼‰

    addToBatchQueue(rowIndex, reaction) {
      try {
        if (!this.reactionBatchQueue.has(rowIndex)) {
          this.reactionBatchQueue.set(rowIndex, []);
        }

        const batchForRow = this.reactionBatchQueue.get(rowIndex);
        const existingIndex = batchForRow.findIndex((r) => r.reaction === reaction);

        if (existingIndex >= 0) {
          // æ—¢å­˜ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æ›´æ–°
          batchForRow[existingIndex].timestamp = Date.now();
        } else {
          // æ–°ã—ã„ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
          batchForRow.push({
            reaction,
            timestamp: Date.now(),
          });
        }

        // ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶é™ãƒã‚§ãƒƒã‚¯
        const totalBatchSize = Array.from(this.reactionBatchQueue.values()).reduce(
          (sum, reactions) => sum + reactions.length,
          0
        );

        if (totalBatchSize >= this.BATCH_SIZE_LIMIT) {
          console.log('ğŸ“¦ ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶é™åˆ°é”ã€å³åº§å‡¦ç†å®Ÿè¡Œ');
          this.processBatchQueue();
        }
      } catch (error) {
        console.warn('ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼ï¼ˆå€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰:', error);
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ä½•ã‚‚ã—ãªã„ï¼ˆæ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ãŒå‹•ä½œï¼‰
      }
    }

    async tryBatchProcessing() {
      try {
        if (this.batchProcessingActive || this.reactionQueue.size === 0) {
          return false;
        }

        this.batchProcessingActive = true;
        console.log('ğŸ”„ ãƒãƒƒãƒå‡¦ç†è©¦è¡Œé–‹å§‹');

        // ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ãƒãƒƒãƒæ“ä½œã‚’æº–å‚™
        const batchOperations = Array.from(this.reactionQueue.values());

        if (batchOperations.length === 1) {
          // å˜ä¸€æ“ä½œã®å ´åˆã¯ãƒãƒƒãƒå‡¦ç†ã—ãªã„
          this.batchProcessingActive = false;
          return false;
        }

        // ãƒãƒƒãƒã§ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ï¼ˆæ–°ã—ã„APIé–¢æ•°ãŒå¿…è¦ï¼‰
        const result = await this.gas.addReactionBatch(batchOperations);

        if (result && result.success) {
          console.log('âœ… ãƒãƒƒãƒå‡¦ç†æˆåŠŸ:', batchOperations.length + 'ä»¶');

          // ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
          this.processBatchReactionResponse(result.data, batchOperations);

          // å®Œäº†é€šçŸ¥
          batchOperations.forEach((op) => {
            const reactionKey = `${op.rowIndex}-${op.reaction}`;
            this.notifyReactionComplete(reactionKey, { success: true, batch: true });
          });

          return true;
        } else {
          console.warn('ãƒãƒƒãƒå‡¦ç†å¤±æ•—ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
          return false;
        }
      } catch (error) {
        console.warn('ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯:', error);
        return false;
      } finally {
        this.batchProcessingActive = false;
      }
    }

    processBatchReactionResponse(responseData, originalOperations) {
      try {
        if (!responseData || !Array.isArray(responseData)) {
          console.warn('ç„¡åŠ¹ãªãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€å€‹åˆ¥å‡¦ç†ã§ç¶šè¡Œ');
          return;
        }

        // å„è¡Œã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†ï¼ˆæ—¢å­˜ã®ä»•çµ„ã¿ã‚’å†åˆ©ç”¨ï¼‰
        responseData.forEach((rowData) => {
          const item = this.state.currentAnswers.find((i) => i.rowIndex == rowData.rowIndex);
          if (item) {
            // æ—¢å­˜ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨
            this.processReactionResponse(rowData, item);
          }
        });

        console.log('âœ… ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†å®Œäº†');
      } catch (error) {
        console.error('ãƒãƒƒãƒãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æ—¢å­˜ã®å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ãŒå‡¦ç†ã™ã‚‹
      }
    }

    setReactionButtonsLoading(buttons, isLoading) {
      buttons.forEach((btn) => {
        btn.disabled = isLoading;
        if (isLoading) {
          btn.classList.add('loading');
        } else {
          btn.classList.remove('loading');
        }
      });
    }

    async sendReactionToServer(rowIndex, reaction) {
      const response = await this.gas.addReaction(rowIndex, reaction, this.state.sheetName);

      if (!response) {
        throw new Error('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      if (response.status !== 'ok') {
        throw new Error(response.message || 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      return response;
    }

    async processReactionResponse(item, response, reaction) {
      console.log('ğŸ”„ ã‚µãƒ¼ãƒãƒ¼å¿œç­”å‡¦ç†é–‹å§‹:', { rowIndex: item.rowIndex, reaction, response });

      // ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’çµ¶å¯¾çš„ã«é©ç”¨ï¼ˆæ¥½è¦³çš„æ›´æ–°ãªã—ï¼‰
      if (response.reactions && typeof response.reactions === 'object') {
        // ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã§å®Œå…¨ã«ä¸Šæ›¸ã
        const serverState = response.reactions;
        item.reactions = JSON.parse(JSON.stringify(serverState));

        console.log('âœ… ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹é©ç”¨å®Œäº†:', {
          rowIndex: item.rowIndex,
          reaction,
          serverState: item.reactions,
        });
      } else {
        console.warn('âš ï¸ æœŸå¾…ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“:', response);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆã‚µãƒ¼ãƒãƒ¼å¿œç­”ãŒä¸æ­£ãªå ´åˆã®ã¿ï¼‰
        this.applyFallbackReactionUpdate(item, reaction);
        console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Ÿè¡Œ:', item.reactions);
      }

      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ï¼ˆã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’ä¿å­˜ï¼‰
      this.saveReactionState(item.rowIndex, item.reactions);

      console.log('ğŸ¯ ã‚µãƒ¼ãƒãƒ¼å¿œç­”å‡¦ç†å®Œäº†:', {
        rowIndex: item.rowIndex,
        finalState: item.reactions,
      });
    }

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹æ•´åˆæ€§æ¤œè¨¼
    validateReactionConsistency(rowIndex, optimisticState, serverState) {
      const inconsistencies = [];

      // å„ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
      this.reactionTypes.forEach((rt) => {
        const reaction = rt.key;
        const optimistic = optimisticState[reaction] || { count: 0, reacted: false };
        const server = serverState[reaction] || { count: 0, reacted: false };

        if (optimistic.reacted !== server.reacted) {
          inconsistencies.push({
            reaction,
            type: 'reacted_mismatch',
            optimistic: optimistic.reacted,
            server: server.reacted,
          });
        }

        if (Math.abs(optimistic.count - server.count) > 1) {
          inconsistencies.push({
            reaction,
            type: 'count_significant_diff',
            optimistic: optimistic.count,
            server: server.count,
            diff: server.count - optimistic.count,
          });
        }
      });

      if (inconsistencies.length > 0) {
        console.warn('âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º:', {
          rowIndex,
          inconsistencies,
          optimisticState,
          serverState,
        });

        // ä¸æ•´åˆã‚’è¨˜éŒ²ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        this.recordReactionInconsistency(rowIndex, inconsistencies);
      } else {
        console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹æ•´åˆæ€§ç¢ºèª:', { rowIndex });
      }

      return inconsistencies;
    }

    // ä¸æ•´åˆè¨˜éŒ²ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    recordReactionInconsistency(rowIndex, inconsistencies) {
      if (!this.reactionInconsistencies) {
        this.reactionInconsistencies = [];
      }

      this.reactionInconsistencies.push({
        timestamp: new Date().toISOString(),
        rowIndex,
        inconsistencies,
      });

      // æœ€æ–°10ä»¶ã®ã¿ä¿æŒ
      if (this.reactionInconsistencies.length > 10) {
        this.reactionInconsistencies.shift();
      }
    }

    applyFallbackReactionUpdate(item, reaction) {
      if (!item.reactions) {
        item.reactions = {};
      }

      // ä»–ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã¾ãšè§£é™¤
      this.reactionTypes.forEach((rt) => {
        if (rt.key !== reaction && item.reactions[rt.key]?.reacted) {
          item.reactions[rt.key].count = Math.max(0, item.reactions[rt.key].count - 1);
          item.reactions[rt.key].reacted = false;
        }
      });

      if (!item.reactions[reaction]) {
        item.reactions[reaction] = { count: 0, reacted: false };
      }

      // Toggle reaction state
      if (item.reactions[reaction].reacted) {
        item.reactions[reaction].count = Math.max(0, item.reactions[reaction].count - 1);
        item.reactions[reaction].reacted = false;
      } else {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
        item.reactions[reaction].reacted = true;
      }
    }

    // å³åº§UIæ›´æ–°ï¼ˆrequestAnimationFrameã‚’ä½¿ã‚ãªã„åŒæœŸæ›´æ–°ï¼‰
    async immediateUIUpdate(rowIndex, reaction) {
      const item = this.state.currentAnswers.find((i) => i.rowIndex == rowIndex);
      if (!item || !item.reactions || !item.reactions[reaction]) {
        console.warn('âš ï¸ immediateUIUpdate: ã‚¢ã‚¤ãƒ†ãƒ ã¾ãŸã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
      }

      try {
        // ã‚«ãƒ¼ãƒ‰ã®UIæ›´æ–°ï¼ˆåŒæœŸå®Ÿè¡Œï¼‰
        const card = document.querySelector(`[data-row-index="${rowIndex}"]`);
        if (card && card instanceof HTMLElement) {
          this.updateCardReactions(card, item);
          this.applyReactionStyles(card, item);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex =
            this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
              .rowIndex;
          if (modalRowIndex == rowIndex) {
            this.updateModalReactionButtons(item);
          }
        }

        console.log('âš¡ å³åº§UIæ›´æ–°å®Œäº†:', { rowIndex, reaction });
      } catch (error) {
        console.error('âŒ å³åº§UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    async updateReactionUI(item, immediate = false) {
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: å¤‰æ›´ãŒå¿…è¦ãªå ´åˆã®ã¿æ›´æ–°
      const lastUpdateKey = `ui_update_${item.rowIndex}`;
      const currentStateHash = this.calculateStateHash(item);
      const lastStateHash = this.lastUIStates?.get(lastUpdateKey);

      if (lastStateHash === currentStateHash && !immediate) {
        console.log(`âš¡ UIæ›´æ–°ã‚¹ã‚­ãƒƒãƒ— (å¤‰æ›´ãªã—): rowIndex=${item.rowIndex}`);
        return;
      }

      // çŠ¶æ…‹ãƒãƒƒã‚·ãƒ¥ã‚’è¨˜éŒ²
      if (!this.lastUIStates) this.lastUIStates = new Map();
      this.lastUIStates.set(lastUpdateKey, currentStateHash);

      if (immediate) {
        // å³åº§å®Ÿè¡Œï¼ˆrequestAnimationFrameã‚’ä½¿ã‚ãªã„ï¼‰
        try {
          const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
          if (card && card instanceof HTMLElement) {
            this.updateCardReactions(card, item);
            this.applyReactionStyles(card, item);
          } else {
            console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
          }

          // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
          if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex =
              this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                .rowIndex;
            if (modalRowIndex == item.rowIndex) {
              this.updateModalReactionButtons(item);
              this.applyReactionStyles(this.elements.answerModalCard, item);
            }
          }

          console.log('âš¡ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³UIå³åº§æ›´æ–°å®Œäº†:', {
            rowIndex: item.rowIndex,
            reactions: item.reactions,
          });
        } catch (error) {
          console.error('âŒ UIå³åº§æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
        }
        return;
      }

      // é€šå¸¸å®Ÿè¡Œï¼ˆrequestAnimationFrameä½¿ç”¨ï¼‰
      return new Promise((resolve) => {
        requestAnimationFrame(() => {
          try {
            // ã‚«ãƒ¼ãƒ‰ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºã‚’æ›´æ–°
            const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
            if (card && card instanceof HTMLElement) {
              this.updateCardReactions(card, item);
              this.applyReactionStyles(card, item);
            } else {
              console.warn('âš ï¸ ã‚«ãƒ¼ãƒ‰è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', item.rowIndex);
            }

            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚‚æ›´æ–°
            if (!this.elements.answerModalContainer.classList.contains('hidden')) {
              const modalRowIndex =
                this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                  .rowIndex;
              if (modalRowIndex == item.rowIndex) {
                this.updateModalReactionButtons(item);
                this.applyReactionStyles(this.elements.answerModalCard, item);
              }
            }

            console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³UIæ›´æ–°å®Œäº†:', {
              rowIndex: item.rowIndex,
              reactions: item.reactions,
            });
            resolve();
          } catch (error) {
            console.error('UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
            resolve();
          }
        });
      });
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ã‚·ãƒ¼ãƒˆåã«åŸºã¥ããƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚­ãƒ¼ç”Ÿæˆ
    getScopedKey(base) {
      const userId = this.state?.userId || USER_ID;
      return `${base}_${userId}_${SHEET_NAME}`;
    }

    // lastSeenCountæ°¸ç¶šåŒ–æ©Ÿèƒ½
    loadLastSeenCount() {
      try {
        const key = this.getScopedKey('lastSeenCount');
        const stored = localStorage.getItem(key);
        const count = stored ? parseInt(stored, 10) : 0;

        console.log('ğŸ“¥ lastSeenCountå¾©å…ƒ:', { key, count });
        return isNaN(count) ? 0 : count;
      } catch (error) {
        console.warn('âš ï¸ lastSeenCountèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        return 0;
      }
    }

    // çœŸã®åˆå›ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹åˆ¤å®š
    isFirstTimeBoardAccess() {
      try {
        // 1. lastSeenCountã®å­˜åœ¨ç¢ºèª
        const hasLastSeen = localStorage.getItem(this.getScopedKey('lastSeenCount')) !== null;

        // 2. å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å­˜åœ¨ç¢ºèª
        const hasDiffCards = localStorage.getItem(this.getScopedKey('differentialCards')) !== null;

        // 3. åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã®ç¢ºèª
        const hasInitialLoad = this.initialDataLoaded === true;

        // 4. DOMå†…ã®æ—¢å­˜ã‚«ãƒ¼ãƒ‰ç¢ºèª
        const container = this.elements?.answersContainer;
        const hasDOMCards = container && container.querySelectorAll('.answer-card').length > 0;

        // çœŸã®åˆå›åˆ¤å®š: ã™ã¹ã¦ãŒæœªè¨­å®š/åˆæœŸçŠ¶æ…‹ã®å ´åˆ
        const isFirstTime = !hasLastSeen && !hasDiffCards && !hasInitialLoad && !hasDOMCards;

        // åˆå›åˆ¤å®šçµæœç¢ºèª

        return isFirstTime;
      } catch (error) {
        console.warn('âš ï¸ åˆå›åˆ¤å®šã‚¨ãƒ©ãƒ¼:', error);
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨å´ï¼ˆåˆå›ã§ã¯ãªã„ï¼‰ã¨åˆ¤å®š
        return false;
      }
    }

    saveLastSeenCount(count) {
      try {
        const key = this.getScopedKey('lastSeenCount');
        localStorage.setItem(key, count.toString());

        console.log('ğŸ’¾ lastSeenCountä¿å­˜:', { key, count });
      } catch (error) {
        console.warn('âš ï¸ lastSeenCountä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    updateLastSeenCount(newCount) {
      if (typeof newCount === 'number' && newCount >= 0) {
        const oldCount = this.state.lastSeenCount;
        this.state.lastSeenCount = newCount;
        this.saveLastSeenCount(newCount);

        console.log('ğŸ“Š lastSeenCountæ›´æ–°:', {
          oldCount,
          newCount,
          timestamp: new Date().toISOString(),
        });
      }
    }

    // å·®åˆ†ã‚«ãƒ¼ãƒ‰ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
    loadDifferentialCards() {
      try {
        const key = this.getScopedKey('differentialCards');
        const stored = localStorage.getItem(key);
        const cards = stored ? JSON.parse(stored) : [];

        console.log('ğŸ“¥ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒ:', { key, count: cards.length });
        return Array.isArray(cards) ? cards : [];
      } catch (error) {
        console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        return [];
      }
    }

    saveDifferentialCards(cardIds) {
      try {
        const key = this.getScopedKey('differentialCards');
        const existing = this.loadDifferentialCards();
        const merged = [...new Set([...existing, ...cardIds])];
        localStorage.setItem(key, JSON.stringify(merged));

        console.log('ğŸ’¾ å·®åˆ†ã‚«ãƒ¼ãƒ‰ä¿å­˜:', { key, count: merged.length, new: cardIds.length });
      } catch (error) {
        console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    clearDifferentialCards() {
      try {
        const key = this.getScopedKey('differentialCards');
        localStorage.removeItem(key);
        console.log('ğŸ—‘ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªã‚¢:', { key });
      } catch (error) {
        console.warn('âš ï¸ å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªã‚¢ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    // å·®åˆ†ã‚«ãƒ¼ãƒ‰ã®å¾©å…ƒï¼ˆãƒšãƒ¼ã‚¸å†èª­ã¿è¾¼ã¿æ™‚ï¼‰
    restoreDifferentialCards() {
      const differentialCardIds = this.loadDifferentialCards();
      if (differentialCardIds.length === 0) return;

      console.log('ğŸ”„ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒé–‹å§‹:', differentialCardIds.length + 'ä»¶');

      const container = this.elements.answersContainer;
      if (!container) return;

      // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‹ã‚‰å·®åˆ†ã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒ¼ã‚¯
      const allCards = container.querySelectorAll('.answer-card');
      let restoredCount = 0;

      allCards.forEach((card) => {
        const rowIndex = parseInt(card.getAttribute('data-row-index'));
        if (differentialCardIds.includes(rowIndex)) {
          card.setAttribute('data-differential-card', 'true');
          card.setAttribute('data-restored', 'true');
          restoredCount++;
          console.log('ğŸ“Œ å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒ:', rowIndex);
        }
      });

      console.log('âœ… å·®åˆ†ã‚«ãƒ¼ãƒ‰å¾©å…ƒå®Œäº†:', restoredCount + 'ä»¶');
    }

    async handleReactionError(error, rowIndex, reaction) {
      console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', {
        error: error.message,
        rowIndex,
        reaction,
        timestamp: new Date().toISOString(),
      });

      // ã‚¨ãƒ©ãƒ¼å¾©æ—§å‡¦ç†ã‚’è¿½åŠ 
      try {
        // UIçŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™ï¼ˆæ¥½è¦³çš„æ›´æ–°ã®å–ã‚Šæ¶ˆã—ï¼‰
        const item = this.state.currentAnswers.find((i) => i.rowIndex == rowIndex);
        if (item && item.reactions && item.reactions[reaction]) {
          // ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™
          const wasReacted = item.reactions[reaction].reacted;
          item.reactions[reaction].reacted = !wasReacted;
          if (wasReacted) {
            item.reactions[reaction].count = Math.max(0, (item.reactions[reaction].count || 1) - 1);
          } else {
            item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
          }

          // UIå†æç”»ï¼ˆå·®åˆ†æ›´æ–°ã§è»½é‡åŒ–ï¼‰
          this.updateReactionButtonsForItem(item);
          console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³UIçŠ¶æ…‹å¾©æ—§å®Œäº†:', { rowIndex, reaction });
        }
      } catch (recoveryError) {
        console.warn('âš ï¸ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼å¾©æ—§å‡¦ç†ã«å¤±æ•—:', recoveryError);
      }

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      if (window.messageManager) {
        window.messageManager.show(
          'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
          'error',
          3000
        );
      }
    }

    /**
     * ç‰¹å®šã®ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’æ›´æ–°ï¼ˆUIçŠ¶æ…‹åŒæœŸï¼‰
     * @param {Object} item - å›ç­”ã‚¢ã‚¤ãƒ†ãƒ 
     */
    updateReactionButtonsForItem(item) {
      if (!item || !item.reactions) return;

      const buttons = document.querySelectorAll(`[data-row-index="${item.rowIndex}"]`);
      buttons.forEach((btn) => {
        const reaction = btn.dataset.reaction;
        if (reaction && item.reactions[reaction]) {
          const reactionData = item.reactions[reaction];
          const isReacted = reactionData.reacted || false;
          const count = reactionData.count || 0;

          // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
          btn.classList.toggle('reacted', isReacted);

          // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºã‚’æ›´æ–°
          const countElement = btn.querySelector('.reaction-count');
          if (countElement) {
            countElement.textContent = count > 0 ? count : '';
          }

          // ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å±æ€§ã‚’æ›´æ–°
          btn.setAttribute('aria-pressed', isReacted);
          btn.title = `${reaction}: ${count}ä»¶ ${isReacted ? '(ã‚ãªãŸãŒãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿)' : ''}`;
        }
      });
    }

    showErrorFeedback(btn, message) {
      if (!btn) return;

      // å…ƒã®ã‚¯ãƒ©ã‚¹ã‚’ä¿å­˜
      const originalClasses = btn.className;

      // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
      btn.classList.add('bg-red-500');
      btn.title = message;

      // 2ç§’å¾Œã«å…ƒã«æˆ»ã™
      setTimeout(() => {
        btn.className = originalClasses;
        btn.title = '';
      }, 2000);
    }

    async handleHighlight(rowIndex) {
      // Highlight processing started

      // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å´ã§ç®¡ç†è€…æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã§ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å´ã®ãƒã‚§ãƒƒã‚¯ã¯ä¸è¦

      const numericRowIndex = parseInt(rowIndex, 10);
      const highlightKey = `${numericRowIndex}-highlight`;

      // Enhanced debounce for highlight operations
      if (this.highlightDebounce.has(highlightKey)) {
        clearTimeout(this.highlightDebounce.get(highlightKey));
        return; // Ignore rapid highlight clicks
      }

      // Rate limiting for highlights
      const now = Date.now();
      const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
      if (now - lastHighlightTime < StudyQuestApp.CONSTANTS.HIGHLIGHT_RATE_LIMIT_MS) {
        return;
      }

      // æ—¢ã«å‡¦ç†ä¸­ã®å ´åˆã¯ç„¡è¦–
      if (this.pendingReactions.has(highlightKey)) {
        return;
      }

      this.pendingReactions.add(highlightKey);
      if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
      this.lastReactionTimes.set(highlightKey, now);

      const btns = document.querySelectorAll(`.highlight-btn[data-row-index="${numericRowIndex}"]`);
      const item = this.state.currentAnswers.find((i) => i.rowIndex == numericRowIndex);

      if (!item) {
        this.pendingReactions.delete(highlightKey);
        return;
      }

      // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘ ï¼šUIæ›´æ–°ã‚’ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºã®ã¿ã«é™å®š
      btns.forEach((btn) => {
        btn.classList.add('loading');
        btn.disabled = true;
      });

      try {
        // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘¡ï¼šå…ˆã«ã‚µãƒ¼ãƒãƒ¼ã¨é€šä¿¡ã™ã‚‹
        const res = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);

        if (res && res.status === 'ok') {
          // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘¢ï¼šã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”æˆåŠŸå¾Œã«ã€UIã‚’å®Œå…¨ã«æ›´æ–°ã™ã‚‹
          item.highlight = res.highlight;
          requestAnimationFrame(() => this.applyUpdates([item])); // æ¬¡ã®æç”»ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®‰å…¨ã«UIã‚’æ›´æ–°

          // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚Œã°ãã¡ã‚‰ã‚‚æ›´æ–°
          if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex =
              this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                .rowIndex;
            if (modalRowIndex == rowIndex) {
              this.updateModalContent(item);
            }
          }

          // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ“ä½œå¾Œã®çŠ¶æ…‹åŒæœŸç¢ºèªï¼ˆé…å»¶å®Ÿè¡Œï¼‰
          setTimeout(() => {
            this.verifyHighlightSync(numericRowIndex, res.highlight);
          }, 1000);
        } else {
          throw new Error(res?.message || 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
      } catch (error) {
        console.error('Failed to toggle highlight:', error);

        // æ¨©é™ã‚¨ãƒ©ãƒ¼ã®ç‰¹åˆ¥å‡¦ç†
        if (error.message && error.message.includes('ç®¡ç†è€…ã®ã¿')) {
          this.showErrorFeedback(btns[0], 'æ¨©é™ã‚¨ãƒ©ãƒ¼: ç®¡ç†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™');
          console.warn('ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½ã¯ç®¡ç†è€…ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™');
        } else {
          this.showErrorFeedback(btns[0], 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
      } finally {
        // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆâ‘£ï¼šæœ€å¾Œã«ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è§£é™¤
        btns.forEach((btn) => {
          btn.classList.remove('loading');
          btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
      }
    }

    // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèª
    async verifyHighlightSync(rowIndex, expectedHighlight) {
      try {
        const item = this.state.currentAnswers.find((i) => i.rowIndex == rowIndex);
        if (!item) return;

        // UIçŠ¶æ…‹ã¨ã‚µãƒ¼ãƒãƒ¼å¿œç­”ã®ä¸€è‡´ç¢ºèª
        if (item.highlight !== expectedHighlight) {
          console.warn(
            `âš ï¸ ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ä¸æ•´åˆæ¤œå‡º: rowIndex=${rowIndex}, UI=${item.highlight}, Expected=${expectedHighlight}`
          );

          // ä¸æ•´åˆã®å ´åˆã¯å¼·åˆ¶çš„ã«ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã«åˆã‚ã›ã‚‹
          item.highlight = expectedHighlight;
          requestAnimationFrame(() => this.applyUpdates([item]));

          console.log('âœ… ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’ä¿®æ­£ã—ã¾ã—ãŸ');
        } else {
          console.log('âœ… ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèª: æ­£å¸¸');
        }
      } catch (error) {
        console.error('ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹åŒæœŸç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ä»˜ãå‰Šé™¤å‡¦ç†ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰
    async handleDeleteAnswer(rowIndex) {
      const numericRowIndex = parseInt(rowIndex, 10);
      const item = this.state.currentAnswers.find((i) => i.rowIndex == numericRowIndex);

      if (!item) {
        console.warn('å‰Šé™¤å¯¾è±¡ã®å›ç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
      }

      // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
      const confirmed = await this.showDeleteConfirmationDialog(item);
      if (!confirmed) {
        return; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆ
      }

      const deleteKey = `${numericRowIndex}-delete`;

      // é‡è¤‡å‡¦ç†é˜²æ­¢
      if (this.pendingReactions && this.pendingReactions.has(deleteKey)) {
        return;
      }

      if (!this.pendingReactions) this.pendingReactions = new Set();
      this.pendingReactions.add(deleteKey);

      // å‰Šé™¤ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
      const deleteBtn = document.querySelector(
        `.delete-answer-btn[data-row-index="${numericRowIndex}"]`
      );
      if (deleteBtn) {
        deleteBtn.disabled = true;
        deleteBtn.classList.add('loading');
        deleteBtn.innerHTML = this.getIcon('loading', 'w-5 h-5');
      }

      try {
        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®å‰Šé™¤å‡¦ç†ã‚’å‘¼ã³å‡ºã—
        const res = await this.gas.deleteAnswer(numericRowIndex, this.state.sheetName);

        if (res && res.status === 'ok') {
          // æˆåŠŸæ™‚ï¼šUIã‹ã‚‰è©²å½“ã®å›ç­”ã‚’å‰Šé™¤
          this.state.currentAnswers = this.state.currentAnswers.filter(
            (answer) => answer.rowIndex !== numericRowIndex
          );

          // DOMã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœä»˜ãï¼‰
          const answerCard = document.querySelector(
            `.answer-card[data-row-index="${numericRowIndex}"]`
          );
          if (answerCard) {
            answerCard.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
            answerCard.style.opacity = '0';
            answerCard.style.transform = 'scale(0.95)';

            setTimeout(() => {
              answerCard.remove();
              // å›ç­”æ•°ã‚’æ›´æ–°
              if (this.elements.answerCount) {
                const count = this.state.currentAnswers ? this.state.currentAnswers.length : 0;
                const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1 text-blue-400');
                this.elements.answerCount.innerHTML = `${userIcon}<span>${count}ä»¶</span>`;
              }
            }, 300);
          }

          // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã¦è©²å½“ã®å›ç­”ã‚’è¡¨ç¤ºã—ã¦ã„ã‚‹å ´åˆã¯é–‰ã˜ã‚‹
          if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex =
              this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset
                .rowIndex;
            if (modalRowIndex == rowIndex) {
              this.hideAnswerModal();
            }
          }

          console.log(`âœ… å›ç­”ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ (rowIndex: ${numericRowIndex})`);
        } else {
          throw new Error(res?.message || 'å‰Šé™¤å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
      } catch (error) {
        console.error('å›ç­”å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);

        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        let errorMsg = 'å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ';
        if (error.message && error.message.includes('ç®¡ç†è€…ã®ã¿')) {
          errorMsg = 'æ¨©é™ã‚¨ãƒ©ãƒ¼: ç®¡ç†è€…ã®ã¿å‰Šé™¤å¯èƒ½ã§ã™';
        } else if (error.message) {
          errorMsg = error.message;
        }

        this.showErrorMessage(errorMsg, true);
      } finally {
        // å‰Šé™¤ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’å¾©å…ƒ
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.classList.remove('loading');
          deleteBtn.innerHTML = this.getIcon('trash', 'w-5 h-5');
        }

        this.pendingReactions.delete(deleteKey);
      }
    }

    // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    async showDeleteConfirmationDialog(item) {
      return new Promise((resolve) => {
        // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®HTMLä½œæˆ
        const dialogHtml = `
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" id="delete-confirmation-dialog">
          <div class="bg-gray-800 rounded-lg p-6 max-w-md mx-4 border border-gray-600">
            <div class="flex items-center mb-4">
              <div class="text-red-500 mr-3">
                ${this.getIcon('alert-triangle', 'w-6 h-6')}
              </div>
              <h3 class="text-lg font-semibold text-white">å›ç­”ã®å‰Šé™¤ç¢ºèª</h3>
            </div>
            
            <div class="mb-4 p-3 bg-gray-700 rounded border-l-4 border-red-500">
              <p class="text-gray-300 text-sm mb-2"><strong>å‰Šé™¤å¯¾è±¡:</strong></p>
              <p class="text-white text-sm line-clamp-3">${this.escapeHtml(item.answer || '').slice(0, 100)}${item.answer && item.answer.length > 100 ? '...' : ''}</p>
            </div>
            
            <p class="text-gray-300 text-sm mb-6">
              ã“ã®å›ç­”ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ<br>
              <span class="text-red-400 font-semibold">â€»ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“</span>
            </p>
            
            <div class="flex gap-3 justify-end">
              <button type="button" id="delete-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded transition-colors">
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </button>
              <button type="button" id="delete-confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors font-semibold">
                å‰Šé™¤ã™ã‚‹
              </button>
            </div>
          </div>
        </div>
      `;

        // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’DOMã«è¿½åŠ 
        const dialogDiv = document.createElement('div');
        dialogDiv.innerHTML = dialogHtml;
        document.body.appendChild(dialogDiv);

        const dialog = document.getElementById('delete-confirmation-dialog');
        const cancelBtn = document.getElementById('delete-cancel-btn');
        const confirmBtn = document.getElementById('delete-confirm-btn');

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        const cleanup = () => {
          dialog.remove();
        };

        cancelBtn.addEventListener('click', () => {
          cleanup();
          resolve(false);
        });

        confirmBtn.addEventListener('click', () => {
          cleanup();
          resolve(true);
        });

        // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        dialog.addEventListener('click', (e) => {
          if (e.target === dialog) {
            cleanup();
            resolve(false);
          }
        });

        // ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', handleEscape);
            cleanup();
            resolve(false);
          }
        };
        document.addEventListener('keydown', handleEscape);
      });
    }

    // åŒ…æ‹¬çš„åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
    async performSyncHealthCheck() {
      console.log('ğŸ” åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–‹å§‹');
      const issues = [];

      try {
        // 1. ãƒ‡ãƒ¼ã‚¿å–å¾—åŒæœŸãƒã‚§ãƒƒã‚¯
        const lastDataLoad = this.lastDataLoadTime || 0;
        const minutesSinceLastLoad = (Date.now() - lastDataLoad) / (1000 * 60);

        if (minutesSinceLastLoad > 5) {
          issues.push({
            type: 'data_staleness',
            severity: 'warning',
            message: `æœ€å¾Œã®ãƒ‡ãƒ¼ã‚¿å–å¾—ã‹ã‚‰${Math.round(minutesSinceLastLoad)}åˆ†çµŒé`,
            recommendation: 'ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚’å®Ÿè¡Œ',
          });
        }

        // 2. ä¿ç•™ä¸­ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèª
        if (this.pendingReactions.size > 0) {
          issues.push({
            type: 'pending_reactions',
            severity: 'warning',
            message: `${this.pendingReactions.size}ä»¶ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå‡¦ç†ä¸­`,
            data: Array.from(this.pendingReactions),
          });
        }

        // 3. UIçŠ¶æ…‹ã¨ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        const uiButtons = document.querySelectorAll('.reaction-btn, .highlight-btn');
        const inconsistentButtons = [];

        uiButtons.forEach((btn) => {
          const rowIndex = parseInt(btn.dataset.rowIndex);
          const item = this.state.currentAnswers.find((i) => i.rowIndex === rowIndex);

          if (!item) {
            inconsistentButtons.push({
              button: btn,
              issue: 'data_missing',
              rowIndex,
            });
            return;
          }

          if (btn.classList.contains('reaction-btn')) {
            const reaction = btn.dataset.reaction;
            const isPressed = btn.getAttribute('aria-pressed') === 'true';
            const dataState = item.reactions?.[reaction]?.reacted === true;

            if (isPressed !== dataState) {
              inconsistentButtons.push({
                button: btn,
                issue: 'reaction_state_mismatch',
                rowIndex,
                reaction,
                uiState: isPressed,
                dataState,
              });
            }
          }

          if (btn.classList.contains('highlight-btn')) {
            const isHighlighted = btn.classList.contains('highlighted');
            const dataState = item.highlight === true;

            if (isHighlighted !== dataState) {
              inconsistentButtons.push({
                button: btn,
                issue: 'highlight_state_mismatch',
                rowIndex,
                uiState: isHighlighted,
                dataState,
              });
            }
          }
        });

        if (inconsistentButtons.length > 0) {
          issues.push({
            type: 'ui_data_inconsistency',
            severity: 'error',
            message: `${inconsistentButtons.length}ä»¶ã®UIçŠ¶æ…‹ä¸æ•´åˆ`,
            data: inconsistentButtons,
          });
        }

        // 4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
        if (this.cache && typeof this.cache.size === 'number') {
          if (this.cache.size > 100) {
            issues.push({
              type: 'cache_bloat',
              severity: 'info',
              message: `ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºãŒå¤§ãã„: ${this.cache.size}ä»¶`,
              recommendation: 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã‚’æ¤œè¨',
            });
          }
        }

        // 5. çµæœå‡ºåŠ›
        if (issues.length === 0) {
          console.log('âœ… åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: å•é¡Œãªã—');
          return { status: 'healthy', issues: [] };
        } else {
          console.warn('âš ï¸ åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: å•é¡Œæ¤œå‡º', issues);
          return { status: 'issues_detected', issues };
        }
      } catch (error) {
        console.error('âŒ åŒæœŸçŠ¶æ…‹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
        return {
          status: 'check_failed',
          error: error.message,
          issues: [],
        };
      }
    }

    // ä¸æ•´åˆã®è‡ªå‹•ä¿®å¾©
    async fixSyncIssues(healthCheckResult) {
      if (!healthCheckResult.issues || healthCheckResult.issues.length === 0) {
        return { fixed: 0, skipped: 0 };
      }

      let fixed = 0;
      let skipped = 0;

      for (const issue of healthCheckResult.issues) {
        try {
          switch (issue.type) {
            case 'ui_data_inconsistency':
              // UIçŠ¶æ…‹ã‚’ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ã«åˆã‚ã›ã‚‹
              for (const inconsistency of issue.data) {
                const item = this.state.currentAnswers.find(
                  (i) => i.rowIndex === inconsistency.rowIndex
                );
                if (item) {
                  await this.applyUpdates([item]);
                  fixed++;
                }
              }
              break;

            case 'data_staleness':
              // ãƒ‡ãƒ¼ã‚¿ã‚’å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
              console.log('ğŸ”„ å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã€å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å®Ÿè¡Œ');
              await this.forceDataRefresh();
              fixed++;
              break;

            case 'cache_bloat':
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
              if (this.cache && typeof this.cache.clear === 'function') {
                this.cache.clear();
                fixed++;
              }
              break;

            default:
              skipped++;
              break;
          }
        } catch (fixError) {
          console.error(`ä¿®å¾©å¤±æ•— (${issue.type}):`, fixError);
          skipped++;
        }
      }

      console.log(`ğŸ”§ è‡ªå‹•ä¿®å¾©å®Œäº†: ${fixed}ä»¶ä¿®å¾©, ${skipped}ä»¶ã‚¹ã‚­ãƒƒãƒ—`);
      return { fixed, skipped };
    }

    // å®šæœŸçš„ãªåŒæœŸç›£è¦–ã®é–‹å§‹
    startSyncMonitoring() {
      // æ—¢å­˜ã®ç›£è¦–ãŒå‹•ã„ã¦ã„ã‚‹å ´åˆã¯åœæ­¢
      if (this.syncMonitoringInterval) {
        clearInterval(this.syncMonitoringInterval);
      }

      // 5åˆ†é–“éš”ã§åŒæœŸçŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
      this.syncMonitoringInterval = setInterval(
        async () => {
          try {
            const healthCheck = await this.performSyncHealthCheck();

            // é‡è¦ãªå•é¡ŒãŒã‚ã£ãŸå ´åˆã¯è‡ªå‹•ä¿®å¾©ã‚’è©¦è¡Œ
            if (healthCheck.status === 'issues_detected') {
              const criticalIssues = healthCheck.issues.filter(
                (issue) => issue.severity === 'error' || issue.type === 'ui_data_inconsistency'
              );

              if (criticalIssues.length > 0) {
                console.log('ğŸ”§ é‡è¦ãªåŒæœŸå•é¡Œã‚’æ¤œå‡ºã€è‡ªå‹•ä¿®å¾©ã‚’å®Ÿè¡Œ');
                await this.fixSyncIssues({ issues: criticalIssues });
              }
            }
          } catch (error) {
            console.error('åŒæœŸç›£è¦–ã‚¨ãƒ©ãƒ¼:', error);
          }
        },
        5 * 60 * 1000
      ); // 5åˆ†é–“éš”

      console.log('âœ… åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆ5åˆ†é–“éš”ï¼‰');
    }

    // åŒæœŸç›£è¦–ã®åœæ­¢
    stopSyncMonitoring() {
      if (this.syncMonitoringInterval) {
        clearInterval(this.syncMonitoringInterval);
        this.syncMonitoringInterval = null;
        console.log('ğŸ›‘ åŒæœŸçŠ¶æ…‹ç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ');
      }
    }

    // ã‚¢ã‚¤ãƒ†ãƒ çŠ¶æ…‹ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ï¼ˆå¤‰æ›´æ¤œå‡ºç”¨ï¼‰
    calculateStateHash(item) {
      const state = {
        reactions: item.reactions,
        highlight: item.highlight,
        rowIndex: item.rowIndex,
      };
      return JSON.stringify(state);
    }

    // ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆé–‹ç™ºãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    async testBatchPerformance() {
      console.log('ğŸ§ª ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');

      const testResults = {
        batchTest: null,
        individualTest: null,
        comparison: null,
      };

      try {
        // ãƒ†ã‚¹ãƒˆç”¨ã®æ¨¡æ“¬ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œãƒ‡ãƒ¼ã‚¿
        const testOperations = [];
        const testRowCount = Math.min(this.state.currentAnswers.length, 5); // æœ€å¤§5è¡Œã§ãƒ†ã‚¹ãƒˆ

        for (let i = 0; i < testRowCount; i++) {
          const item = this.state.currentAnswers[i];
          if (item) {
            testOperations.push({
              rowIndex: item.rowIndex,
              reaction: 'LIKE',
              timestamp: Date.now(),
            });
          }
        }

        if (testOperations.length === 0) {
          console.warn('âš ï¸ ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
          return { error: 'ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³' };
        }

        console.log(`ğŸ“Š ${testOperations.length}ä»¶ã®æ“ä½œã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ`);

        // 1. ãƒãƒƒãƒå‡¦ç†ã®ãƒ†ã‚¹ãƒˆ
        console.log('ğŸ”„ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
        const batchStartTime = performance.now();

        try {
          // ãƒãƒƒãƒå‡¦ç†ã¯å®Ÿéš›ã«ã‚µãƒ¼ãƒãƒ¼ã‚’å‘¼ã°ãšã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®å‡¦ç†æ™‚é–“ã®ã¿æ¸¬å®š
          this.addToBatchQueue(testOperations[0].rowIndex, testOperations[0].reaction);
          for (let i = 1; i < testOperations.length; i++) {
            this.addToBatchQueue(testOperations[i].rowIndex, testOperations[i].reaction);
          }

          const batchEndTime = performance.now();
          testResults.batchTest = {
            duration: batchEndTime - batchStartTime,
            operationCount: testOperations.length,
            avgTimePerOp: (batchEndTime - batchStartTime) / testOperations.length,
          };

          console.log('âœ… ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.batchTest);
        } catch (error) {
          console.error('âŒ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
          testResults.batchTest = { error: error.message };
        }

        // 2. å€‹åˆ¥å‡¦ç†ã®ãƒ†ã‚¹ãƒˆï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        console.log('ğŸ”„ å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
        const individualStartTime = performance.now();

        try {
          // å€‹åˆ¥å‡¦ç†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®APIå‘¼ã³å‡ºã—ãªã—ï¼‰
          for (const operation of testOperations) {
            // ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã™ã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            this.reactionQueue.set(`${operation.rowIndex}-${operation.reaction}`, operation);
            // å°ã•ãªé…å»¶ã§APIå‘¼ã³å‡ºã—ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
            await new Promise((resolve) => setTimeout(resolve, 1));
          }

          const individualEndTime = performance.now();
          testResults.individualTest = {
            duration: individualEndTime - individualStartTime,
            operationCount: testOperations.length,
            avgTimePerOp: (individualEndTime - individualStartTime) / testOperations.length,
          };

          console.log('âœ… å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.individualTest);
        } catch (error) {
          console.error('âŒ å€‹åˆ¥å‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
          testResults.individualTest = { error: error.message };
        }

        // 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ
        if (
          testResults.batchTest &&
          testResults.individualTest &&
          !testResults.batchTest.error &&
          !testResults.individualTest.error
        ) {
          const speedImprovement =
            testResults.individualTest.duration / testResults.batchTest.duration;
          const efficiencyGain =
            ((testResults.individualTest.avgTimePerOp - testResults.batchTest.avgTimePerOp) /
              testResults.individualTest.avgTimePerOp) *
            100;

          testResults.comparison = {
            speedImprovement: speedImprovement,
            efficiencyGain: efficiencyGain,
            recommendation:
              speedImprovement > 1.2
                ? 'ãƒãƒƒãƒå‡¦ç†æ¨å¥¨'
                : speedImprovement < 0.8
                  ? 'å€‹åˆ¥å‡¦ç†æ¨å¥¨'
                  : 'åŒç¨‹åº¦',
          };

          console.log('ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒçµæœ:', testResults.comparison);
        }

        // 4. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ï¼ˆæ¦‚ç®—ï¼‰
        const memoryInfo = performance.memory
          ? {
              usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
              totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
            }
          : { info: 'ãƒ¡ãƒ¢ãƒªæƒ…å ±ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“' };

        testResults.memoryUsage = memoryInfo;

        console.log('ğŸ§ª ãƒãƒƒãƒå‡¦ç†ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†', testResults);
        return testResults;
      } catch (error) {
        console.error('âŒ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        return { error: error.message, partialResults: testResults };
      }
    }

    // ãƒãƒƒãƒå‡¦ç†ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
    validateBatchSystem() {
      console.log('ğŸ” ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯');

      const issues = [];

      // 1. ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
      if (!this.batchQueue) {
        issues.push('ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      } else if (this.batchQueue.size > 100) {
        issues.push(`ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: ${this.batchQueue.size}`);
      }

      // 2. å€‹åˆ¥ã‚­ãƒ¥ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
      if (!this.reactionQueue) {
        issues.push('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      } else if (this.reactionQueue.size > 50) {
        issues.push(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: ${this.reactionQueue.size}`);
      }

      // 3. å‡¦ç†çŠ¶æ…‹ã®ç¢ºèª
      if (this.isProcessingReactionQueue && this.batchProcessingActive) {
        issues.push('å€‹åˆ¥å‡¦ç†ã¨ãƒãƒƒãƒå‡¦ç†ãŒåŒæ™‚ã«å‹•ä½œä¸­ã§ã™');
      }

      // 4. è¨­å®šã®ç¢ºèª
      if (this.enableBatchProcessing === undefined) {
        issues.push('ãƒãƒƒãƒå‡¦ç†è¨­å®šãŒæœªå®šç¾©ã§ã™');
      }

      // 5. çµæœ
      if (issues.length === 0) {
        console.log('âœ… ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: æ­£å¸¸');
        return { status: 'healthy', issues: [] };
      } else {
        console.warn('âš ï¸ ãƒãƒƒãƒå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: å•é¡Œæ¤œå‡º', issues);
        return { status: 'issues_detected', issues };
      }
    }

    // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆé–‹ç™ºãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    async testNotificationEdgeCases() {
      console.log('ğŸ§ª é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');

      const testResults = {
        tests: [],
        summary: { passed: 0, failed: 0, total: 0 },
      };

      try {
        // ãƒ†ã‚¹ãƒˆ1: åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®é€šçŸ¥
        console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ1: åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—â†’ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã‚·ãƒŠãƒªã‚ª');
        const test1 = await this.testInitialLoadFailureNotification();
        testResults.tests.push(test1);

        // ãƒ†ã‚¹ãƒˆ2: é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª
        console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ2: é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª');
        const test2 = this.testNotificationBannerElements();
        testResults.tests.push(test2);

        // ãƒ†ã‚¹ãƒˆ3: é€šçŸ¥æ¡ä»¶ã®ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèª
        console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ3: é€šçŸ¥æ¡ä»¶ãƒ­ã‚¸ãƒƒã‚¯ã®ç¢ºèª');
        const test3 = this.testNotificationLogic();
        testResults.tests.push(test3);

        // ãƒ†ã‚¹ãƒˆ4: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª
        console.log('ğŸ“‹ ãƒ†ã‚¹ãƒˆ4: é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª');
        const test4 = await this.testNotificationDebounce();
        testResults.tests.push(test4);

        // çµæœé›†è¨ˆ
        testResults.tests.forEach((test) => {
          testResults.summary.total++;
          if (test.passed) {
            testResults.summary.passed++;
          } else {
            testResults.summary.failed++;
          }
        });

        console.log('âœ… é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†:', testResults.summary);
        return testResults;
      } catch (error) {
        console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        return { error: error.message, partialResults: testResults };
      }
    }

    async testInitialLoadFailureNotification() {
      const testName = 'åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—å¾Œã®é€šçŸ¥';
      try {
        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
        const originalInitialDataLoaded = this.initialDataLoaded;
        const originalHadInitialDataLoadFailure = this.hadInitialDataLoadFailure;
        const originalLastSeenCount = this.state.lastSeenCount;

        // ãƒ†ã‚¹ãƒˆçŠ¶æ…‹ã‚’è¨­å®š
        this.initialDataLoaded = false;
        this.hadInitialDataLoadFailure = true;
        this.state.lastSeenCount = 0;

        console.log('ğŸ”§ ãƒ†ã‚¹ãƒˆçŠ¶æ…‹è¨­å®š:', {
          initialDataLoaded: this.initialDataLoaded,
          hadInitialDataLoadFailure: this.hadInitialDataLoadFailure,
          lastSeenCount: this.state.lastSeenCount,
        });

        // ãƒ¢ãƒƒã‚¯é€šçŸ¥é–¢æ•°
        let notificationShown = false;
        const originalShowNewContentBanner = this.showNewContentBanner;
        this.showNewContentBanner = (newItems) => {
          notificationShown = true;
          console.log('ğŸ¯ ãƒ†ã‚¹ãƒˆä¸­ï¼šé€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ -', newItems, 'ä»¶');
          return originalShowNewContentBanner.call(this, newItems);
        };

        // æ¨¡æ“¬çš„ãª handleInitialContentLoad å‘¼ã³å‡ºã—
        await this.handleInitialContentLoad('ã™ã¹ã¦-newest', 1);

        // çµæœæ¤œè¨¼
        const passed =
          notificationShown && this.state.lastSeenCount === 1 && !this.hadInitialDataLoadFailure;

        // çŠ¶æ…‹ã‚’å¾©å…ƒ
        this.initialDataLoaded = originalInitialDataLoaded;
        this.hadInitialDataLoadFailure = originalHadInitialDataLoadFailure;
        this.state.lastSeenCount = originalLastSeenCount;
        this.showNewContentBanner = originalShowNewContentBanner;

        return {
          name: testName,
          passed,
          details: {
            notificationShown,
            finalLastSeenCount: this.state.lastSeenCount,
            failureFlagCleared: !this.hadInitialDataLoadFailure,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    testNotificationBannerElements() {
      const testName = 'é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª';
      try {
        const elements = {
          banner: this.elements.newContentBanner,
          text: this.elements.newContentText,
          refreshBtn: this.elements.refreshContentBtn,
          dismissBtn: this.elements.dismissBannerBtn,
        };

        const missing = [];
        Object.entries(elements).forEach(([key, element]) => {
          if (!element) {
            missing.push(key);
          }
        });

        const passed = missing.length === 0;

        return {
          name: testName,
          passed,
          details: {
            elementsFound: Object.keys(elements).length - missing.length,
            totalElements: Object.keys(elements).length,
            missingElements: missing,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    testNotificationLogic() {
      const testName = 'é€šçŸ¥æ¡ä»¶ãƒ­ã‚¸ãƒƒã‚¯ã®ç¢ºèª';
      try {
        const scenarios = [
          { newCount: 5, lastSeen: 3, shouldNotify: true, expected: 2 },
          { newCount: 3, lastSeen: 3, shouldNotify: false, expected: 0 },
          { newCount: 2, lastSeen: 3, shouldNotify: false, expected: 0 },
          { newCount: 1, lastSeen: 0, shouldNotify: true, expected: 1 },
        ];

        const results = scenarios.map((scenario) => {
          const shouldNotify = scenario.newCount > scenario.lastSeen;
          const newItems = shouldNotify ? scenario.newCount - scenario.lastSeen : 0;

          return {
            scenario,
            actualShouldNotify: shouldNotify,
            actualNewItems: newItems,
            correct: shouldNotify === scenario.shouldNotify && newItems === scenario.expected,
          };
        });

        const passed = results.every((result) => result.correct);

        return {
          name: testName,
          passed,
          details: {
            scenariosTested: scenarios.length,
            scenariosPassed: results.filter((r) => r.correct).length,
            results,
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    async testNotificationDebounce() {
      const testName = 'é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ã®ç¢ºèª';
      try {
        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®ãŸã‚ã«çŸ­æ™‚é–“ã§è¤‡æ•°å›é€šçŸ¥ã‚’è©¦è¡Œ
        const originalLastNotificationTime = this.lastNotificationTime;

        let notificationCount = 0;
        const originalShowNewContentBanner = this.showNewContentBanner;

        this.showNewContentBanner = (newItems) => {
          notificationCount++;
          console.log('ğŸ¯ ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼šé€šçŸ¥å›æ•° =', notificationCount);
          return originalShowNewContentBanner.call(this, newItems);
        };

        // æœ€åˆã®é€šçŸ¥
        this.lastNotificationTime = null;
        await this.checkForNewItems(1);
        const firstNotificationCount = notificationCount;

        // çŸ­æ™‚é–“å†…ã§ã®2å›ç›®ã®é€šçŸ¥ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ã•ã‚Œã‚‹ã¹ãï¼‰
        this.lastNotificationTime = Date.now() - 1500; // 1.5ç§’å‰ã«è¨­å®š
        await this.checkForNewItems(2);
        const secondNotificationCount = notificationCount;

        // ååˆ†ãªæ™‚é–“å¾Œã®3å›ç›®ã®é€šçŸ¥ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ã•ã‚Œãªã„ã¹ãï¼‰
        this.lastNotificationTime = Date.now() - 3000; // 3ç§’å‰ã«è¨­å®š
        await this.checkForNewItems(3);
        const thirdNotificationCount = notificationCount;

        // å¾©å…ƒ
        this.showNewContentBanner = originalShowNewContentBanner;
        this.lastNotificationTime = originalLastNotificationTime;

        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãŒæ­£ã—ãå‹•ä½œã—ã¦ã„ã‚‹å ´åˆ: 1å›ç›®ã¨3å›ç›®ã§é€šçŸ¥ã€2å›ç›®ã¯ã‚¹ã‚­ãƒƒãƒ—
        const passed =
          firstNotificationCount === 1 &&
          secondNotificationCount === 1 &&
          thirdNotificationCount === 2;

        return {
          name: testName,
          passed,
          details: {
            firstNotification: firstNotificationCount,
            secondNotification: secondNotificationCount,
            thirdNotification: thirdNotificationCount,
            expectedBehavior: '1â†’1â†’2 (2å›ç›®ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹)',
          },
        };
      } catch (error) {
        return { name: testName, passed: false, error: error.message };
      }
    }

    // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
    validateNotificationSystem() {
      console.log('ğŸ” é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯');

      const issues = [];

      // 1. é€šçŸ¥ãƒãƒŠãƒ¼è¦ç´ ã®å­˜åœ¨ç¢ºèª
      if (!this.elements.newContentBanner) {
        issues.push('newContentBannerè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      if (!this.elements.newContentText) {
        issues.push('newContentTextè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      if (!this.elements.refreshContentBtn) {
        issues.push('refreshContentBtnè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }

      // 2. åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
      if (this.initialDataLoaded === undefined) {
        issues.push('initialDataLoadedçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
      }
      if (this.hadInitialDataLoadFailure === undefined) {
        issues.push('hadInitialDataLoadFailureçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
      }

      // 3. é€šçŸ¥çŠ¶æ…‹ã®ç¢ºèª
      if (this.state.lastSeenCount === undefined) {
        issues.push('lastSeenCountçŠ¶æ…‹ãŒæœªå®šç¾©ã§ã™');
      }

      // 4. ãƒãƒ¼ãƒªãƒ³ã‚°çŠ¶æ…‹ã®ç¢ºèª
      if (!this.pollingSettings || this.pollingSettings.enabled === undefined) {
        issues.push('ãƒãƒ¼ãƒªãƒ³ã‚°è¨­å®šãŒä¸æ­£ã§ã™');
      }

      // 5. çµæœ
      if (issues.length === 0) {
        console.log('âœ… é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: æ­£å¸¸');
        return { status: 'healthy', issues: [] };
      } else {
        console.warn('âš ï¸ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§: å•é¡Œæ¤œå‡º', issues);
        return { status: 'issues_detected', issues };
      }
    }

    async toggleAdminMode() {
      // Temporarily disable button to prevent duplicate clicks
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.disabled = true;
      }

      try {
        const enable = !this.state.showAdminFeatures;

        // ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯
        if (enable) {
          if (!this.state.isAdminUser) {
            console.warn('æ‰€æœ‰è€…æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
            return;
          }

          // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œæ™‚ã®ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
          const confirmed = await this.showAdminModeConfirmation();
          if (!confirmed) {
            return; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆ
          }

          // å‰Šé™¤: è¤‡é›‘ãªæ¨©é™å†ç¢ºèªãƒ­ã‚¸ãƒƒã‚¯ - window.isOwnerã§ååˆ†
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚’æ›´æ–°
        window.showAdminFeatures = enable;
        window.showHighlightToggle = this.state.isAdminUser; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º

        debugLog('toggleAdminModeçŠ¶æ…‹æ›´æ–°:', {
          enable,
          isAdminUser: this.state.isAdminUser,
          showAdminFeatures: window.showAdminFeatures,
          showHighlightToggle: window.showHighlightToggle,
        });
        if (enable) {
          // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¼·åˆ¶çš„ã«åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã‚’è¡¨ç¤º
          window.showCounts = true;
          window.displayMode = 'named';
          window.isStudentMode = false;
          window.showScoreSort = window.showCounts;
          debugLog('ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–: åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã‚’å¼·åˆ¶è¡¨ç¤º', {
            showCounts: window.showCounts,
            displayMode: window.displayMode,
          });
        } else {
          // é–²è¦§ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ã‚µãƒ¼ãƒãƒ¼è¨­å®šã«æˆ»ã™
          window.showCounts = this.serverShowCounts;
          window.displayMode = this.serverDisplayMode;
          window.isStudentMode = true;
          window.showScoreSort = window.showCounts;
          debugLog('é–²è¦§ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–: ã‚µãƒ¼ãƒãƒ¼è¨­å®šã‚’å¾©å…ƒ', {
            showCounts: window.showCounts,
            displayMode: window.displayMode,
            serverShowCounts: this.serverShowCounts,
            serverDisplayMode: this.serverDisplayMode,
          });
        }

        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹æ™‚ã¯å¼·åˆ¶çš„ã«ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚æ›´æ–°
        if (enable) {
          this.state.displayMode = 'named';
          this.state.showCounts = true;
          this.state.isStudentMode = false;
        } else {
          this.state.displayMode = this.serverDisplayMode;
          this.state.showCounts = this.serverShowCounts;
          this.state.isStudentMode = true;
        }

        // Update local state from global variables (but preserve displayMode if in admin mode)
        this.updateConfigFromGlobals();

        // Re-enforce admin mode settings after updateConfigFromGlobals
        if (enable) {
          this.state.displayMode = 'named';
          this.state.showCounts = true;
        }

        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã®çŠ¶æ…‹ã‚’ç¢ºèª
        debugLog('ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã®çŠ¶æ…‹ç¢ºèª:', {
          enable,
          stateDisplayMode: this.state.displayMode,
          stateShowCounts: this.state.showCounts,
          windowDisplayMode: window.displayMode,
          windowShowCounts: window.showCounts,
        });

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦æ–°ã—ã„è¨­å®šã§å†æç”»
        this.cache.clear();

        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¨ã¦å‰Šé™¤ã—ã¦å¼·åˆ¶å†ç”Ÿæˆ
        this.elements.answersContainer.innerHTML = '';

        // UIçŠ¶æ…‹ã‚’æ›´æ–°
        this.updateSortOptions();
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
        // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯è¨­å®šå¤‰æ›´ã®ãŸã‚å†æç”»ãŒå¿…è¦
        this.loadSheetData({ bypassCache: true }).then(() => {
          // ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã«æ–°ç€ãƒã‚§ãƒƒã‚¯ã®åŸºæº–ã‚’æ›´æ–°
          this.updateLastSeenCount(this.state.currentAnswers.length);
          console.log('ğŸ”„ ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå®Œäº†ã€æ–°ç€ãƒã‚§ãƒƒã‚¯åŸºæº–æ›´æ–°:', {
            newBaselineCount: this.state.lastSeenCount,
            adminMode: this.state.showAdminFeatures,
          });
        });
      } finally {
        // Re-enable button
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.disabled = false;
        }
      }
    }

    /**
     * ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ç§»è¡Œç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
     */
    async showAdminModeConfirmation() {
      return new Promise((resolve) => {
        // ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ã‚’ä½œæˆ
        const modal = document.createElement('div');
        modal.className =
          'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
          <div class="flex items-center mb-4">
            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center">
              <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
              </svg>
            </div>
            <div class="ml-4">
              <h3 class="text-lg font-medium text-gray-900">ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã‹ï¼Ÿ</h3>
            </div>
          </div>
          <div class="mb-6">
            <p class="text-sm text-gray-600">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€<strong>ç”Ÿå¾’ã®åå‰ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ãŒè¡¨ç¤º</strong>ã•ã‚Œã¾ã™ã€‚<br>
              ç”»é¢å…±æœ‰æ™‚ãªã©ã¯ååˆ†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
            </p>
          </div>
          <div class="flex justify-end space-x-3">
            <button type="button" class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
            <button type="button" class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-orange-600 border border-transparent rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
              ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
            </button>
          </div>
        </div>
      `;

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        const cancelBtn = modal.querySelector('.cancel-btn');
        const confirmBtn = modal.querySelector('.confirm-btn');

        const cleanup = () => {
          document.body.removeChild(modal);
        };

        cancelBtn.addEventListener('click', () => {
          cleanup();
          resolve(false);
        });

        confirmBtn.addEventListener('click', () => {
          cleanup();
          resolve(true);
        });

        // Escapeã‚­ãƒ¼ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        const handleKeydown = (e) => {
          if (e.key === 'Escape') {
            cleanup();
            document.removeEventListener('keydown', handleKeydown);
            resolve(false);
          }
        };
        document.addEventListener('keydown', handleKeydown);

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        document.body.appendChild(modal);

        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç¢ºèªãƒœã‚¿ãƒ³ã«ç§»å‹•
        setTimeout(() => confirmBtn.focus(), 100);
      });
    }

    async endPublication() {
      if (!confirm('å…¬é–‹ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿç”Ÿå¾’ã¯å›ç­”ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã‚Šã¾ã™ã€‚')) {
        return;
      }

      // ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è¨­å®š
      const endPublicationBtn = this.elements.endPublicationBtn;
      let originalButtonContent = '';
      if (endPublicationBtn) {
        originalButtonContent = endPublicationBtn.innerHTML;
        endPublicationBtn.disabled = true;
        endPublicationBtn.innerHTML = `
        <svg class="w-3 h-3 animate-spin inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582 m15.356 2A8.001 8.001 0 004.582 9 m0 0H9 m11 11v-5h-.581 m0 0a8.003 8.003 0 01-15.357-2 m15.357 2H15"></path>
        </svg>
        å…¬é–‹çµ‚äº†ä¸­...
      `;
      }

      try {
        console.log('ğŸ”„ å…¬é–‹çµ‚äº†å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...');

        // ã‚µãƒ¼ãƒãƒ¼ã«å…¬é–‹çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
        const result = await this.runGas('clearActiveSheet');

        console.log('âœ… å…¬é–‹çµ‚äº†å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸ:', result);

        // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        const successMessage = result.message || 'å…¬é–‹ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚éå…¬é–‹ç”»é¢ã«ç§»å‹•ã—ã¾ã™ã€‚';
        if (window.sharedModals) {
          window.sharedModals.showAlert('å…¬é–‹çµ‚äº†', successMessage, 'success');
        } else {
          alert(successMessage);
        }

        // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰Unpublished.htmlã«ç§»å‹•ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ï¼‰
        setTimeout(() => {
          this.redirectToUnpublishedPage();
        }, 1500);
      } catch (error) {
        console.error('âŒ å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);

        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ§‹æˆ
        let errorMsg = 'å…¬é–‹çµ‚äº†ã«å¤±æ•—ã—ã¾ã—ãŸ';
        if (error && error.message) {
          errorMsg += `: ${error.message}`;
        } else if (typeof error === 'string') {
          errorMsg += `: ${error}`;
        }

        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        if (window.sharedModals) {
          window.sharedModals.showAlert('ã‚¨ãƒ©ãƒ¼', errorMsg, 'error');
        } else {
          alert(errorMsg);
        }

        // ãƒœã‚¿ãƒ³ã‚’å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
        if (endPublicationBtn && originalButtonContent) {
          endPublicationBtn.disabled = false;
          endPublicationBtn.innerHTML = originalButtonContent;
        }
      }
    }
    redirectToUnpublishedPage() {
      console.log('ğŸš« Redirecting to unpublished page (legacy function)');

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å‡¦ç†ï¼ˆæ–°æ©Ÿèƒ½ã¨çµ±åˆï¼‰
      this.clearAllCachesForUnpublished();

      // å…¬é–‹åœæ­¢æ™‚ã¯æ¬¡å›ç®¡ç†ãƒ‘ãƒãƒ«ã‚’é–‹ã„ãŸã¨ãã«å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ã«ã™ã‚‹
      try {
        localStorage.setItem('expandAllSections', 'true');
        console.log('âœ… ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³å…¨å±•é–‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã—ãŸ');
      } catch (error) {
        console.warn('âš ï¸ localStorageè¨­å®šã«å¤±æ•—:', error);
      }

      // æ–°ã—ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¹ãƒ†ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ãŸãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
      const unpublishedUrl = new URL(window.location.href);
      unpublishedUrl.searchParams.delete('mode'); // mode=viewã‚’å‰Šé™¤
      unpublishedUrl.searchParams.set('_cb', Date.now()); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¹ãƒ†ã‚£ãƒ³ã‚°
      unpublishedUrl.searchParams.set('_redirect', 'unpublished'); // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆç†ç”±

      console.log('ğŸ”„ Redirecting to unpublished URL:', unpublishedUrl.toString());
      window.location.href = unpublishedUrl.toString();
    }

    endAdminMode() {
      google.script.run
        .withSuccessHandler(function (adminUrl) {
          const url = new URL(adminUrl);
          url.searchParams.set('mode', 'admin');
          window.location.href = url.toString();
        })
        .getWebAppUrl();
    }

    /**
     * ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’localStorageã«ä¿å­˜
     * @param {number} rowIndex - è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
     * @param {object} reactions - ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
     */
    saveReactionState(rowIndex, reactions) {
      try {
        // æ—¢å­˜ã®ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');

        // ç¾åœ¨ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿å­˜
        existingData[rowIndex] = {};
        Object.keys(reactions).forEach((reactionType) => {
          const reaction = reactions[reactionType];
          if (reaction && reaction.reacted) {
            existingData[rowIndex][reactionType] = {
              reacted: true,
              timestamp: new Date().toISOString(),
            };
          }
        });

        // ç©ºã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¯å‰Šé™¤
        if (Object.keys(existingData[rowIndex]).length === 0) {
          delete existingData[rowIndex];
        }

        localStorage.setItem(this.reactionStorageKey, JSON.stringify(existingData));
        debugLog('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä¿å­˜:', { rowIndex, reactions: existingData[rowIndex] });
      } catch (error) {
        console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ä¿å­˜ã«å¤±æ•—:', error);
      }
    }

    /**
     * localStorageã‹ã‚‰ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿
     * @returns {object} ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹
     */
    loadReactionState() {
      try {
        const savedData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
        debugLog('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿:', savedData);
        return savedData;
      } catch (error) {
        console.warn('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
        return {};
      }
    }

    /**
     * ä¿å­˜ã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«é©ç”¨
     * @param {array} answers - å›ç­”ãƒ‡ãƒ¼ã‚¿é…åˆ—
     */
    applyReactionState(answers) {
      const savedReactions = this.loadReactionState();
      let modified = false;

      answers.forEach((answer) => {
        if (!savedReactions[answer.rowIndex]) {
          savedReactions[answer.rowIndex] = {};
        }
        const savedReaction = savedReactions[answer.rowIndex];

        if (answer.reactions) {
          Object.keys(answer.reactions).forEach((reactionType) => {
            const info = answer.reactions[reactionType];
            if (!info) return;

            const serverReacted = !!info.reacted;
            const localReacted = !!savedReaction[reactionType];

            info.reacted = serverReacted;

            if (serverReacted) {
              if (!localReacted) {
                if (!savedReactions[answer.rowIndex]) {
                  savedReactions[answer.rowIndex] = {};
                }
                savedReactions[answer.rowIndex][reactionType] = {
                  reacted: true,
                  timestamp: new Date().toISOString(),
                };
                modified = true;
              }
            } else if (localReacted) {
              delete savedReaction[reactionType];
              modified = true;
            }

            if (Object.keys(savedReaction).length === 0) {
              delete savedReactions[answer.rowIndex];
            }

            debugLog(`âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹åŒæœŸ [è¡Œ${answer.rowIndex}][${reactionType}]:`, {
              serverReacted,
              localReacted,
              finalReacted: info.reacted,
              timestamp: new Date().toISOString(),
            });
          });
        }
      });

      if (modified) {
        localStorage.setItem(this.reactionStorageKey, JSON.stringify(savedReactions));
      }

      debugLog('ã‚µãƒ¼ãƒãƒ¼ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹åŒæœŸå®Œäº†');
    }

    updateModalReactionButtons(item) {
      if (!this.elements.modalReactionContainer) return;

      this.reactionTypes.forEach((rt) => {
        const info = item.reactions?.[rt.key] || { count: 0, reacted: false };
        const modalBtn = this.elements.modalReactionContainer.querySelector(
          `[data-reaction="${rt.key}"]`
        );

        if (modalBtn) {
          // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºæ›´æ–°
          const countEl = modalBtn.querySelector('.reaction-count');
          if (countEl && this.state.showCounts) {
            countEl.textContent = info.count;
          }

          // ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
          const svgEl = modalBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);
          }

          // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          modalBtn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
          modalBtn.classList.add(colorClass);
          modalBtn.classList.toggle('liked', info.reacted);
          modalBtn.setAttribute('aria-pressed', info.reacted.toString());

          // aria-labelæ›´æ–°
          const reactionNames = {
            LIKE: 'ã„ã„ã­ï¼',
            UNDERSTAND: 'ãªã‚‹ã»ã©ï¼',
            CURIOUS: 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼',
          };
          const reactionName = reactionNames[rt.key] || rt.key;
          const ariaLabel = `${reactionName}${info.reacted ? 'ã‚’å–ã‚Šæ¶ˆã™' : 'ã™ã‚‹'}${this.state.showCounts ? ` (ç¾åœ¨${info.count}ä»¶)` : ''}`;
          modalBtn.setAttribute('aria-label', ariaLabel);
        }
      });
    }
    applyUpdates(items) {
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: å¤‰æ›´ãŒå¿…è¦ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿å‡¦ç†
      const itemsToUpdate = items.filter((item) => {
        const updateKey = `apply_update_${item.rowIndex}`;
        const currentHash = this.calculateStateHash(item);
        const lastHash = this.lastApplyStates?.get(updateKey);

        if (lastHash === currentHash) {
          return false; // å¤‰æ›´ãªã— - ã‚¹ã‚­ãƒƒãƒ—
        }

        // çŠ¶æ…‹ã‚’è¨˜éŒ²
        if (!this.lastApplyStates) this.lastApplyStates = new Map();
        this.lastApplyStates.set(updateKey, currentHash);
        return true; // å¤‰æ›´ã‚ã‚Š - æ›´æ–°å¯¾è±¡
      });

      if (itemsToUpdate.length === 0) {
        console.log('âš¡ applyUpdates: å…¨ã‚¢ã‚¤ãƒ†ãƒ ã‚¹ã‚­ãƒƒãƒ— (å¤‰æ›´ãªã—)');
        return;
      }

      console.log(`âš¡ applyUpdates: ${itemsToUpdate.length}/${items.length}ä»¶ã‚’æ›´æ–°`);

      // ãƒãƒƒãƒå‡¦ç†ç”¨ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©
      const reactionUpdates = [];

      itemsToUpdate.forEach((item) => {
        this.reactionTypes.forEach((rt) => {
          if (item.reactions && item.reactions[rt.key]) {
            reactionUpdates.push({
              rowIndex: item.rowIndex,
              reaction: rt.key,
              count: item.reactions[rt.key].count,
              reacted: item.reactions[rt.key].reacted,
              shouldDisplay: item.reactions[rt.key].count > 0,
            });
          }
        });
        const card = document.querySelector(`.answer-card[data-row-index="${item.rowIndex}"]`);
        if (card) {
          card.classList.toggle('highlighted', item.highlight);
          this.applyReactionStyles(card, item);
          const highlightBtn = card.querySelector('.highlight-btn');
          if (highlightBtn) {
            highlightBtn.classList.toggle('liked', item.highlight);
            highlightBtn.setAttribute('aria-pressed', String(item.highlight));
            const label = item.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
            highlightBtn.setAttribute('aria-label', label);
            const svgEl = highlightBtn.querySelector('svg');
            if (svgEl) {
              svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
            }
          }
          let badge = card.querySelector('.highlight-badge');
          if (item.highlight && !badge) {
            badge = document.createElement('span');
            badge.className = 'highlight-badge';
            badge.innerHTML = this.getIcon('star', '', true);
            card.appendChild(badge);
          } else if (!item.highlight && badge) {
            badge.remove();
          }
        }
      });

      // ãƒãƒƒãƒå‡¦ç†ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ã‚’å®Ÿè¡Œ
      if (reactionUpdates.length > 0) {
        this.batchUpdateReactionButtons(reactionUpdates);
      }
    }
    showAnswerModal(rowIndex) {
      if (DEBUG_MODE)
        console.log('ğŸ“± [MODAL DEBUG] showAnswerModal called:', {
          rowIndex: rowIndex,
          rowIndexType: typeof rowIndex,
          timestamp: new Date().toISOString(),
        });

      // Show answer modal called

      // Data search context

      // æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆfilteredDataã¨currentAnswersã®ä¸¡æ–¹ã‹ã‚‰ï¼‰
      let data = this.state.currentAnswers.find((r) => r.rowIndex == rowIndex);
      // Data search in currentAnswers

      if (!data && this.state.filteredData) {
        data = this.state.filteredData.find((r) => r.rowIndex == rowIndex);
        debugLog('Data search in filteredData:', {
          found: !!data,
          searchRowIndex: rowIndex,
          availableRowIndexes: this.state.filteredData?.map((r) => r.rowIndex) || [],
        });
      }

      if (!data) {
        debugLog('ERROR: No data found for rowIndex:', {
          rowIndex: rowIndex,
          currentAnswers: this.state.currentAnswers,
          filteredData: this.state.filteredData,
        });
        return;
      }

      debugLog('Data found for modal:', {
        rowIndex: rowIndex,
        data: data,
        opinion: `${data.opinion?.substring(0, 50)}...`,
        reason: `${data.reason?.substring(0, 50)}...`,
      });
      this.state.lastFocusedElement = document.activeElement;
      this.elements.modalAnswer.innerHTML = `<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">${this.escapeHtml(data.opinion || '')}</p><p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">${this.escapeHtml(data.reason || '')}</p>`;
      const showName = this.state.displayMode === 'named';
      let modalDisplayName = '';

      // Debug: Log modal display mode state
      debugLog('Modal display state:', {
        displayMode: this.state.displayMode,
        showName,
        showAdminFeatures: this.state.showAdminFeatures,
        isAdminUser: this.state.isAdminUser,
        dataName: data.name,
        dataEmail: data.email,
      });

      if (showName) {
        // åå‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°emailã‹ã‚‰ç”Ÿæˆ
        if (data.name) {
          modalDisplayName = data.name;
        } else if (data.email) {
          modalDisplayName = data.email.split('@')[0];
        }
      }

      this.elements.modalStudentName.textContent = modalDisplayName;
      const footerBase =
        'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
      this.elements.modalFooter.className = `${footerBase}${showName ? ' justify-between items-center' : ' justify-end items-center'}`;
      const reactionButtonsHtml = this.reactionTypes
        .map((rt) => {
          const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          const countSpan = this.state.showCounts
            ? `<span class="reaction-count font-bold text-2xl text-gray-200">${info.count}</span>`
            : '';
          return `<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ${colorClass} ${cls}" data-row-index="${rowIndex}" data-reaction="${rt.key}" aria-label="${rt.key}">${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countSpan}</button>`;
        })
        .join('');

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
      let highlightBtnHtml = '';
      if (this.state.showHighlightToggle) {
        const cls = data.highlight ? 'liked' : '';
        const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
        highlightBtnHtml = `<button type="button" class="highlight-btn like-btn text-purple-600 ${cls}" aria-label="${highlightAriaLabel}" aria-pressed="${data.highlight}" data-row-index="${data.rowIndex}">${this.getIcon('star', 'w-5 h-5', data.highlight)}</button>`;
      }

      this.elements.modalReactionContainer.innerHTML = `${reactionButtonsHtml}${highlightBtnHtml}`;

      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ãã‚«ãƒ¼ãƒ‰è‰²ã®é©ç”¨
      debugLog('ãƒ¢ãƒ¼ãƒ€ãƒ«ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è£…é£¾é©ç”¨:', {
        rowIndex: data.rowIndex,
        highlight: data.highlight,
        reactions: data.reactions,
        element: this.elements.answerModalCard.className,
      });
      this.applyReactionStyles(this.elements.answerModalCard, data);
      debugLog('ãƒ¢ãƒ¼ãƒ€ãƒ«è£…é£¾é©ç”¨å¾Œ:', {
        className: this.elements.answerModalCard.className,
      });

      this.elements.answerModalContainer.classList.remove('hidden');
      this.elements.answerModalContainer.classList.add('modal-fade');
      this.elements.answerModalCard.classList.add('modal-scale');

      this.elements.answerModalCloseBtn.focus();
    }
    updateModalContent(data) {
      if (!data) return;

      // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
      const reactionButtonsHtml = this.reactionTypes
        .map((rt) => {
          const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass =
            rt.key === 'LIKE'
              ? 'text-red-500'
              : rt.key === 'UNDERSTAND'
                ? 'text-yellow-500'
                : 'text-green-500';
          const countSpan = this.state.showCounts
            ? `<span class="reaction-count font-bold text-2xl text-gray-200">${info.count}</span>`
            : '';
          return `<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ${colorClass} ${cls}" data-row-index="${data.rowIndex}" data-reaction="${rt.key}" aria-label="${rt.key}">${this.getIcon(rt.icon, 'w-5 h-5', info.reacted)}${countSpan}</button>`;
        })
        .join('');

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³ã‚’æ›´æ–°
      let highlightBtnHtml = '';
      if (this.state.showHighlightToggle) {
        const cls = data.highlight ? 'liked' : '';
        const highlightAriaLabel = data.highlight ? 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹' : 'ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹';
        highlightBtnHtml = `<button type="button" class="highlight-btn like-btn text-purple-600 ${cls}" aria-label="${highlightAriaLabel}" aria-pressed="${data.highlight}" data-row-index="${data.rowIndex}">${this.getIcon('star', 'w-5 h-5', data.highlight)}</button>`;
      }

      this.elements.modalReactionContainer.innerHTML = `${reactionButtonsHtml}${highlightBtnHtml}`;

      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
      debugLog('updateModalContentè£…é£¾é©ç”¨:', {
        rowIndex: data.rowIndex,
        highlight: data.highlight,
        reactions: data.reactions,
      });
      this.applyReactionStyles(this.elements.answerModalCard, data);
    }
    hideAnswerModal() {
      this.elements.answerModalContainer.classList.add('hidden');
      this.elements.answerModalContainer.classList.remove('modal-fade');
      this.elements.answerModalCard.classList.remove('modal-scale');
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
    showInfoModal() {
      this.state.lastFocusedElement = document.activeElement;
      this.elements.infoModalContainer.classList.remove('hidden');
      this.elements.infoModalContainer.classList.add('modal-fade');
      this.elements.infoModalCard.classList.add('modal-scale');

      // Ensure modal starts from the top
      this.elements.infoModalCard.scrollTop = 0;

      // Focus on the modal container first, then the button
      setTimeout(() => {
        this.elements.infoModalConfirmBtn.focus();
      }, 100);
    }
    hideInfoModal() {
      this.elements.infoModalContainer.classList.add('hidden');
      this.elements.infoModalContainer.classList.remove('modal-fade');
      this.elements.infoModalCard.classList.remove('modal-scale');

      // Note: localStorage 'introSeen' flag removed to allow modal to show on every board update
      if (this.state.lastFocusedElement) {
        this.state.lastFocusedElement.focus();
      }
    }
    getIcon(name, classes = '', solid = false) {
      // Cache icons to avoid repeated string concatenation
      const cacheKey = `icon-${name}-${classes}-${solid}`;
      const cachedIcon = this.cache.get(cacheKey);
      if (cachedIcon) {
        return cachedIcon;
      }

      let key = name;
      if (ICONS[name + '-outline'] || ICONS[name + '-solid']) {
        key = solid ? `${name}-solid` : `${name}-outline`;
      }
      const icon = ICONS[key];
      if (!icon) {
        console.warn('Icon not found:', key);
        const fallback = `<span aria-hidden="true" class="${classes}">â­</span>`;
        this.cache.set(cacheKey, fallback);
        return fallback;
      }
      const result = `<span aria-hidden="true" class="${classes}">${icon}</span>`;
      this.cache.set(cacheKey, result);
      return result;
    }
    renderIcons() {
      if (this.elements.infoIconLike) {
        this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
      }
      if (this.elements.infoIconUnderstand) {
        this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
      }
      if (this.elements.infoIconCurious) {
        this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
      }
      if (this.elements.infoIconHighlight) {
        this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
      }
      if (this.elements.iconClose) {
        this.elements.iconClose.innerHTML = this.getIcon('x');
      }
      if (this.elements.iconGrid) {
        this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
      }
    }
    debounce(func, delay) {
      // Use SharedUtilities with instance-specific keys
      const key = `studyquest-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
      return (...args) => {
        // Fix: Correct method call - debounce.debounce() is the right pattern
        if (
          window.sharedUtilities &&
          window.sharedUtilities.debounce &&
          window.sharedUtilities.debounce.debounce
        ) {
          window.sharedUtilities.debounce.debounce(() => func.apply(this, args), key, delay);
        } else {
          // Fallback to simple debounce if SharedUtilities not loaded
          this.debounceTimers = this.debounceTimers || {};
          clearTimeout(this.debounceTimers[key]);
          this.debounceTimers[key] = setTimeout(() => func.apply(this, args), delay);
        }
      };
    }

    throttle(func, delay) {
      // Use SharedUtilities with instance-specific keys
      const key = `studyquest-throttle-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
      return (...args) => {
        // Fix: Correct method call - throttle.throttle() is the right pattern
        if (
          window.sharedUtilities &&
          window.sharedUtilities.throttle &&
          window.sharedUtilities.throttle.throttle
        ) {
          window.sharedUtilities.throttle.throttle(() => func.apply(this, args), key, delay);
        } else {
          // Fallback to simple throttle if SharedUtilities not loaded
          const now = Date.now();
          this.throttleLastRun = this.throttleLastRun || {};
          if (now - (this.throttleLastRun[key] || 0) >= delay) {
            this.throttleLastRun[key] = now;
            func.apply(this, args);
          }
        }
      };
    }
    updateSortOptions() {
      if (this.elements.scoreOption) {
        if (this.state.showScoreSort) {
          this.elements.scoreOption.style.display = 'block';
        } else {
          this.elements.scoreOption.style.display = 'none';
          if (this.elements.sortOrder.value === 'score') {
            this.elements.sortOrder.value = 'newest';
          }
        }
      }
    }
    updateConfigFromGlobals() {
      debugLog('updateConfigFromGlobalså‰ã®çŠ¶æ…‹:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        showAdminFeatures: this.state.showAdminFeatures,
        windowShowAdminFeatures: window.showAdminFeatures,
        currentDisplayMode: this.state.displayMode,
      });

      this.state.isStudentMode = window.isStudentMode;
      this.state.showCounts = window.showCounts;
      window.showScoreSort = window.showCounts;
      this.state.showAdminFeatures = window.showAdminFeatures;
      this.state.showHighlightToggle = this.state.isAdminUser; // ç®¡ç†è€…ãªã‚‰å¸¸ã«è¡¨ç¤º
      this.state.showScoreSort = window.showScoreSort;
      this.state.showPublishControls = window.showPublishControls;

      // Only update displayMode if not in admin mode
      if (!this.state.showAdminFeatures) {
        this.state.displayMode = window.displayMode;
      }

      debugLog('updateConfigFromGlobalså¾Œã®çŠ¶æ…‹:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        showAdminFeatures: this.state.showAdminFeatures,
        windowShowAdminFeatures: window.showAdminFeatures,
        finalDisplayMode: this.state.displayMode,
        windowDisplayMode: window.displayMode,
      });
    }
    escapeHtml(str) {
      if (!str) return '';
      return str
        .toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Performance optimization methods
    detectLowPerformanceDevice() {
      const userAgent = navigator.userAgent;
      const platform = navigator.platform;
      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
      const cores = navigator.hardwareConcurrency || 4;

      // Detect low-end devices
      if (memory <= 2 || cores <= 2) return true;
      if (userAgent.includes('Mobile') && !userAgent.includes('iPad')) return true;
      if (platform.includes('Win32') && cores <= 4) return true;

      return false;
    }

    setupPerformanceMonitoring() {
      let frameCount = 0;
      let lastTime = performance.now();

      const measurePerformance = () => {
        const now = performance.now();
        const delta = now - lastTime;

        if (frameCount > 0) {
          this.performanceMetrics.frameTime = delta;

          // If frame time is consistently over 16ms, enable low performance mode
          if (delta > PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
            console.warn('Low performance detected, enabling optimizations');
            this.isLowPerformanceMode = true;
            this.optimizeForLowPerformance();
          }
        }

        lastTime = now;
        frameCount++;

        if (frameCount < 60) {
          // Monitor first 60 frames
          requestAnimationFrame(measurePerformance);
        }
      };

      requestAnimationFrame(measurePerformance);
    }

    optimizeForLowPerformance() {
      debugLog('Enabling low performance optimizations');

      // Reduce animation and transition durations
      document.documentElement.style.setProperty('--transition-duration', '0.1s');
      document.documentElement.style.setProperty('--animation-duration', '0.1s');
      document.documentElement.style.setProperty('--backdrop-blur', '4px');

      // Create comprehensive low-performance stylesheet
      const style = document.createElement('style');
      style.id = 'low-performance-optimizations';
      style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        -webkit-backdrop-filter: blur(4px) !important;
        backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover:not(.loading) {
        transform: scale(1.05) !important;
      }
      
      .reaction-btn.reacted {
        transform: scale(1.02) !important;
      }
      
      .reaction-btn.reacted:hover:not(.loading) {
        transform: scale(1.07) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        border: 3px solid #9333ea !important;
        border-image: none !important;
        box-shadow: 0 0 12px rgba(147, 51, 234, 0.5) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
      document.head.appendChild(style);

      // Add low-performance class to body for CSS targeting
      document.body.classList.add('low-performance');

      // Reduce polling frequency
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = setInterval(() => this.loadSheetData({ showLoading: false }), 30000); // 30s instead of 15s
      }
    }

    setupObservers() {
      // Intersection Observer for virtual scrolling - optimized for performance
      if ('IntersectionObserver' in window) {
        // Enhanced debounce visibility changes with batching to reduce excessive firing
        const debouncedVisibilityHandler = this.debounce((entries) => {
          // Batch entries by card to prevent rapid state changes on the same element
          const cardChanges = new Map();

          entries.forEach((entry) => {
            const card = entry.target;
            const rowIndex = card.dataset.rowIndex;

            // Keep only the latest change for each card
            cardChanges.set(rowIndex, { card, entry });
          });

          // Process batched changes
          cardChanges.forEach(({ card, entry }) => {
            // Only log significant visibility changes for debugging
            if (DEBUG_MODE && (entry.intersectionRatio === 0 || entry.intersectionRatio === 1)) {
              debugLog('IntersectionObserver visibility change:', {
                rowIndex: card.dataset.rowIndex,
                isIntersecting: entry.isIntersecting,
                intersectionRatio: entry.intersectionRatio,
              });
            }

            if (entry.isIntersecting) {
              // Card is becoming visible
              if (!card.classList.contains('visible')) {
                card.classList.add('visible');
                card.classList.remove('hidden-card');
                // Restore visibility and display if it was hidden
                if (card.style.visibility === 'hidden') {
                  card.style.visibility = 'visible';
                }
                if (card.style.display === 'none') {
                  card.style.display = '';
                }
              }
            } else {
              // MODIFIED: Do not hide cards for virtual scrolling - keep them in DOM
              // This prevents cards from disappearing when scrolling back up
              // Only mark as not visible for optimization purposes
              if (entry.intersectionRatio === 0 && card.classList.contains('visible')) {
                card.classList.remove('visible');
                card.classList.add('hidden-card');
                // Do NOT hide or remove from DOM - just mark as not visible
              }
            }
          });
        }, 50); // Increased debounce to 50ms for better stability

        this.visibilityObserver = new IntersectionObserver(debouncedVisibilityHandler, {
          rootMargin: `${StudyQuestApp.PERFORMANCE_CONFIG.VIEWPORT_BUFFER}px`,
          threshold: [0, 1.0], // Simplified thresholds: fully out vs fully in
        });
      }

      // ResizeObserver for responsive adjustments
      if ('ResizeObserver' in window) {
        // Arrow function to preserve 'this' context
        const debouncedResize = (entries) => {
          if (
            window.sharedUtilities &&
            window.sharedUtilities.debounce &&
            window.sharedUtilities.debounce.debounce
          ) {
            // Fix: Call debounce.debounce() method correctly
            window.sharedUtilities.debounce.debounce(
              () => {
                this.adjustLayout();
              },
              'resize-observer',
              100
            );
          } else {
            // Fallback: direct call if debounce is not available
            this.adjustLayout();
          }
        };

        this.resizeObserver = new ResizeObserver(debouncedResize);
        this.resizeObserver.observe(this.elements.answersContainer);
      }
    }

    deferredRender(callback, priority = 'normal') {
      if (this.isLowPerformanceMode) {
        // Use requestIdleCallback for low priority updates
        this.idleCallbackId = requestIdleCallback(callback, { timeout: IDLE_TIMEOUT });
      } else {
        // Use requestAnimationFrame for normal updates
        this.animationFrameId = requestAnimationFrame(callback);
      }
    }

    batchDOMUpdates(updates) {
      const startTime = performance.now();
      let processedCount = 0;

      const processBatch = () => {
        while (
          processedCount < updates.length &&
          performance.now() - startTime < PERFORMANCE_BUDGET
        ) {
          updates[processedCount]();
          processedCount++;
        }

        if (processedCount < updates.length) {
          // Continue in next frame
          requestAnimationFrame(processBatch);
        }
      };

      processBatch();
    }

    getReusableFragment() {
      if (this.domFragmentPool.length > 0) {
        return this.domFragmentPool.pop();
      }
      return document.createDocumentFragment();
    }

    recycleFragment(fragment) {
      // Clear fragment content and reuse
      while (fragment.firstChild) {
        fragment.removeChild(fragment.firstChild);
      }
      if (this.domFragmentPool.length < 10) {
        // Limit pool size
        this.domFragmentPool.push(fragment);
      }
    }

    throttledUpdate(key, callback, delay = 100) {
      if (this.deferredUpdates.has(key)) {
        return;
      }

      this.deferredUpdates.add(key);
      setTimeout(() => {
        callback();
        this.deferredUpdates.delete(key);
      }, delay);
    }

    cleanup() {
      // Consolidated cache cleanup
      this.cache.cleanup();

      // Clear DOM fragment pool
      this.domFragmentPool.length = 0;

      debugLog('Cache cleanup completed', {
        cacheSize: this.cache.size,
      });
    }

    // Enhanced cache methods with timestamp tracking

    // ===== Virtual Scrolling Methods =====

    setupScrollObserver() {
      if (!this.elements.answersContainer) {
        console.warn('setupScrollObserver: answersContainer not found');
        return;
      }

      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      if (cards.length === 0) {
        debugLog('setupScrollObserver: No cards found, skipping setup');
        return;
      }

      // Clear existing scroll observer if it exists
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
      }

      // Create scroll observer for dynamic loading with debouncing
      const debouncedScrollHandler = this.debounce((entries) => {
        // Only process the first intersecting entry to prevent multiple simultaneous loads
        const intersectingEntry = entries.find((entry) => entry.isIntersecting);
        if (intersectingEntry) {
          debugLog(
            'setupScrollObserver: Trigger card intersecting:',
            intersectingEntry.target.dataset.rowIndex
          );
          this.handleVirtualScroll(intersectingEntry.target);
        }
      }, 150); // 150ms debounce for scroll triggers to prevent rapid firing

      this.scrollObserver = new IntersectionObserver(debouncedScrollHandler, {
        root: null,
        rootMargin: '300px', // Increased buffer for even smoother loading
        threshold: 0.1,
      });

      // Observe the last few elements for dynamic loading trigger
      const observeCount = Math.min(3, cards.length); // Reduced to last 3 cards for better performance
      const observedCards = [];

      for (let i = cards.length - observeCount; i < cards.length; i++) {
        if (cards[i] && cards[i].dataset.rowIndex) {
          this.scrollObserver.observe(cards[i]);
          observedCards.push(cards[i].dataset.rowIndex);
        }
      }

      debugLog('setupScrollObserver: Observing cards for dynamic loading:', {
        totalCards: cards.length,
        observedCount: observedCards.length,
        observedRowIndexes: observedCards,
        totalItems: this.virtualScrollState?.totalItems || 0,
        renderedItems: this.virtualScrollState?.renderedItems || 0,
      });
    }

    handleVirtualScroll(triggerElement) {
      if (!triggerElement || !this.virtualScrollState) {
        return;
      }

      if (this.virtualScrollState.isLoading) {
        debugLog('handleVirtualScroll: Already loading, skipping');
        return;
      }

      const currentCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const totalAvailable = this.state.currentAnswers.length;
      const currentRendered = currentCards.length;

      debugLog('handleVirtualScroll triggered:', {
        currentRendered,
        totalAvailable,
        triggerRowIndex: triggerElement.dataset.rowIndex,
      });

      // Check if we need to load more items
      if (currentRendered < totalAvailable) {
        this.loadMoreItems();
      } else {
        // Optimize visible elements when we've rendered everything
        this.optimizeVisibleElements();
      }
    }

    loadMoreItems() {
      if (this.virtualScrollState.isLoading) {
        return;
      }

      this.virtualScrollState.isLoading = true;

      // Enhanced item tracking - use Set instead of relying on DOM count
      if (!this.virtualScrollState.renderedRowIndexes) {
        this.virtualScrollState.renderedRowIndexes = new Set();
        // Initialize with existing cards in DOM
        const existingCards = this.elements.answersContainer.querySelectorAll('.answer-card');
        existingCards.forEach((card) => {
          if (card.dataset.rowIndex) {
            this.virtualScrollState.renderedRowIndexes.add(card.dataset.rowIndex);
          }
        });
      }

      // Use dynamic batch sizing for better performance adaptation
      const dynamicBatchSize = getDynamicBatchSize(this.performanceMetrics);
      const batchSize = this.isLowPerformanceMode
        ? Math.min(CHUNK_SIZE, dynamicBatchSize)
        : dynamicBatchSize;

      // Find items that haven't been rendered yet
      const unrenderedItems = this.state.currentAnswers.filter(
        (item) => !this.virtualScrollState.renderedRowIndexes.has(String(item.rowIndex))
      );

      // Take next batch of unrendered items
      const remainingItems = unrenderedItems.slice(0, batchSize);

      if (remainingItems.length === 0) {
        this.virtualScrollState.isLoading = false;
        debugLog('loadMoreItems: No more items to load - all items rendered');
        return;
      }

      debugLog(
        'loadMoreItems: Loading',
        remainingItems.length,
        'additional items with batch size',
        batchSize,
        'Total rendered:',
        this.virtualScrollState.renderedRowIndexes.size,
        'Total available:',
        this.state.currentAnswers.length
      );

      // Use deferred rendering for performance
      this.deferredRender(() => {
        this.renderAdditionalItems(remainingItems);
      });
    }

    renderAdditionalItems(items) {
      if (!items || items.length === 0) {
        this.virtualScrollState.isLoading = false;
        debugLog('renderAdditionalItems: No items to render');
        return;
      }

      const fragment = this.getReusableFragment();
      const changedItems = [];
      let successfullyCreated = 0;

      // Ensure renderedRowIndexes exists
      if (!this.virtualScrollState.renderedRowIndexes) {
        this.virtualScrollState.renderedRowIndexes = new Set();
      }

      items.forEach((item) => {
        const rowIndexStr = String(item.rowIndex);

        // Skip if already rendered (defensive check)
        if (this.virtualScrollState.renderedRowIndexes.has(rowIndexStr)) {
          debugLog('renderAdditionalItems: Item', rowIndexStr, 'already rendered, skipping');
          return;
        }

        const card = this.createAnswerCard(item);
        if (card) {
          card.classList.add('new-card');

          // Track this item as rendered
          this.virtualScrollState.renderedRowIndexes.add(rowIndexStr);

          // Add to visibility observer
          if (this.visibilityObserver) {
            this.visibilityObserver.observe(card);
          }

          // Add to scroll observer for the last few items
          const isLastFew = items.indexOf(item) >= items.length - 3;
          if (isLastFew && this.scrollObserver) {
            this.scrollObserver.observe(card);
          }

          fragment.appendChild(card);
          changedItems.push(item);
          successfullyCreated++;
        } else {
          console.warn('renderAdditionalItems: Failed to create card for item:', item.rowIndex);
        }
      });

      // Append new items to container
      if (fragment.children.length > 0) {
        this.elements.answersContainer.appendChild(fragment);

        // Update virtual scroll state with actual counts
        this.virtualScrollState.renderedItems = this.elements.answersContainer.children.length;

        debugLog(
          'renderAdditionalItems: Added',
          fragment.children.length,
          'new cards. Total rendered:',
          this.virtualScrollState.renderedRowIndexes.size,
          'DOM children:',
          this.virtualScrollState.renderedItems
        );
      } else {
        debugLog(
          'renderAdditionalItems: No cards were successfully created from',
          items.length,
          'items'
        );
      }

      // Apply updates if needed
      if (changedItems.length > 0) {
        this.deferredRender(() => this.applyUpdates(changedItems));
      }

      // Recycle fragment
      this.recycleFragment(fragment);

      // Reset loading state
      this.virtualScrollState.isLoading = false;

      // Validate state consistency
      this.validateVirtualScrollState();
    }

    validateVirtualScrollState() {
      if (!this.virtualScrollState || !this.virtualScrollState.renderedRowIndexes) {
        return;
      }

      const domCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const domRowIndexes = new Set();

      domCards.forEach((card) => {
        if (card.dataset.rowIndex) {
          domRowIndexes.add(card.dataset.rowIndex);
        }
      });

      const trackedCount = this.virtualScrollState.renderedRowIndexes.size;
      const domCount = domRowIndexes.size;
      const totalAvailable = this.state.currentAnswers.length;

      // Check for inconsistencies
      const missingInDOM = [...this.virtualScrollState.renderedRowIndexes].filter(
        (x) => !domRowIndexes.has(x)
      );
      const extraInDOM = [...domRowIndexes].filter(
        (x) => !this.virtualScrollState.renderedRowIndexes.has(x)
      );

      if (missingInDOM.length > 0 || extraInDOM.length > 0 || trackedCount !== domCount) {
        console.warn('Virtual scroll state inconsistency detected:', {
          trackedCount,
          domCount,
          totalAvailable,
          missingInDOM: missingInDOM.slice(0, 5),
          extraInDOM: extraInDOM.slice(0, 5),
        });

        // Auto-repair: sync tracked state with DOM reality
        this.virtualScrollState.renderedRowIndexes = domRowIndexes;
        this.virtualScrollState.renderedItems = domCount;

        debugLog('validateVirtualScrollState: Auto-repaired state. New tracked count:', domCount);
      }
    }

    optimizeVisibleElements() {
      if (!this.elements.answersContainer || this.virtualScrollState.isLoading) {
        return;
      }

      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      let hiddenCount = 0;
      let restoredCount = 0;
      const viewportHeight = window.innerHeight;
      const hideThreshold = viewportHeight * 3; // Increased threshold for better UX

      // Track hidden cards for better restoration
      if (!this.virtualScrollState.hiddenCards) {
        this.virtualScrollState.hiddenCards = new Set();
      }

      cards.forEach((card) => {
        const rect = card.getBoundingClientRect();
        const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
        const rowIndex = card.dataset.rowIndex;
        const isCurrentlyHidden = this.virtualScrollState.hiddenCards.has(rowIndex);

        if (!isInViewport && !isCurrentlyHidden) {
          // Calculate distance from viewport
          const distanceFromViewport =
            rect.top > viewportHeight
              ? rect.top - viewportHeight // Below viewport
              : -rect.bottom; // Above viewport

          // Only hide cards that are really far away
          if (distanceFromViewport > hideThreshold) {
            this.hideCard(card, rowIndex);
            hiddenCount++;
          }
        } else if (isInViewport && isCurrentlyHidden) {
          // Restore cards that are back in viewport
          this.restoreCard(card, rowIndex);
          restoredCount++;
        }
      });

      if (hiddenCount > 0 || restoredCount > 0) {
        debugLog(
          'optimizeVisibleElements: Hidden',
          hiddenCount,
          'cards, restored',
          restoredCount,
          'cards'
        );
      }
    }

    hideCard(card, rowIndex) {
      // Use CSS transform instead of visibility for better performance
      card.style.transform = 'translateZ(0) scale(0.01)';
      card.style.opacity = '0';
      card.style.pointerEvents = 'none';
      card.classList.add('hidden-card');
      this.virtualScrollState.hiddenCards.add(rowIndex);

      // Temporarily unobserve from intersection observers to prevent state confusion
      if (this.visibilityObserver) {
        this.visibilityObserver.unobserve(card);
      }
      if (this.scrollObserver) {
        this.scrollObserver.unobserve(card);
      }
    }

    restoreCard(card, rowIndex) {
      // Restore card to full visibility
      card.style.transform = '';
      card.style.opacity = '';
      card.style.pointerEvents = '';
      card.classList.remove('hidden-card');
      card.classList.add('visible');
      this.virtualScrollState.hiddenCards.delete(rowIndex);

      // Re-add to intersection observers
      if (this.visibilityObserver) {
        this.visibilityObserver.observe(card);
      }

      // Only re-add to scroll observer if it's one of the last few cards
      const allCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      const cardIndex = Array.from(allCards).indexOf(card);
      const isLastFew = cardIndex >= allCards.length - 3;

      if (isLastFew && this.scrollObserver) {
        this.scrollObserver.observe(card);
      }
    }

    // Reset virtual scrolling state for debugging and recovery
    resetVirtualScrollState() {
      debugLog('resetVirtualScrollState: Resetting virtual scroll state');

      // Clear state
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: this.state.currentAnswers.length,
        isLoading: false,
        renderedRowIndexes: new Set(),
        hiddenCards: new Set(),
      };

      // Clear all observers
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
        this.scrollObserver = null;
      }

      if (this.visibilityObserver) {
        this.visibilityObserver.disconnect();
        this.visibilityObserver = null;
      }

      // Restore all cards to visible state
      const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
      cards.forEach((card) => {
        card.style.transform = '';
        card.style.opacity = '';
        card.style.pointerEvents = '';
        card.style.visibility = '';
        card.classList.remove('hidden-card');
        card.classList.add('visible');
      });

      // Re-setup observers
      this.setupObservers();

      debugLog('resetVirtualScrollState: Virtual scroll state reset complete');
    }

    /**
     * ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆã®å …ç‰¢åŒ–æ¤œè¨¼
     * @param {any} reason - ç†ç”±ãƒ‡ãƒ¼ã‚¿
     * @returns {string} æ¤œè¨¼æ¸ˆã¿ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆ
     */
    validateReasonText(reason) {
      try {
        // null, undefined, ç©ºæ–‡å­—åˆ—ãƒã‚§ãƒƒã‚¯
        if (!reason && reason !== 0) {
          return '';
        }

        // æ–‡å­—åˆ—å¤‰æ›ã¨åŸºæœ¬æ¤œè¨¼
        const reasonStr = String(reason).trim();

        // é•·ã™ãã‚‹ç†ç”±ãƒ†ã‚­ã‚¹ãƒˆã®åˆ¶é™ï¼ˆ10000æ–‡å­—ã¾ã§ï¼‰
        if (reasonStr.length > 10000) {
          console.warn('validateReasonText: Reason text too long, truncating:', reasonStr.length);
          return reasonStr.substring(0, 10000) + '...';
        }

        // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãŒå¿…è¦ãªæ–‡å­—ã‚’ãƒã‚§ãƒƒã‚¯
        if (reasonStr.includes('<') || reasonStr.includes('>') || reasonStr.includes('&')) {
          // HTMLãŒå«ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹å ´åˆã¯è­¦å‘Š
          console.warn('validateReasonText: Potentially unsafe HTML content detected');
        }

        return reasonStr;
      } catch (error) {
        console.error('validateReasonText: Error validating reason text:', error);
        return ''; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºæ–‡å­—åˆ—ã‚’è¿”ã™
      }
    }

    /**
     * ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ¤œè¨¼
     * @returns {Promise<Object>} æ¤œè¨¼çµæœ
     */
    async validateBoardDataIntegrity() {
      try {
        console.log('ğŸ” Starting real-time board data integrity validation...');

        const validationResults = {
          timestamp: new Date().toISOString(),
          totalCards: 0,
          validCards: 0,
          invalidCards: 0,
          reasonFieldIssues: 0,
          headerIssues: 0,
          errors: [],
        };

        // DOMå†…ã®ã‚«ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
        const cards = this.elements.answersContainer?.querySelectorAll('.answer-card') || [];
        validationResults.totalCards = cards.length;

        cards.forEach((card, index) => {
          try {
            const rowIndex = card.dataset.rowIndex;
            const opinionElement = card.querySelector('.opinion-text');
            const reasonElement = card.querySelector('.answer-preview p');

            // åŸºæœ¬è¦ç´ ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            if (!opinionElement || !rowIndex) {
              validationResults.invalidCards++;
              validationResults.errors.push(`Card ${index}: Missing essential elements`);
              return;
            }

            // ç†ç”±åˆ—ã®çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
            const hasReasonData = this.state.currentAnswers.find(
              (a) => a.rowIndex == rowIndex
            )?.reason;
            const hasReasonElement = reasonElement && reasonElement.textContent.trim();

            if (hasReasonData && !hasReasonElement) {
              validationResults.reasonFieldIssues++;
              validationResults.errors.push(
                `Card ${index} (row ${rowIndex}): Reason data exists but not displayed`
              );
            }

            validationResults.validCards++;
          } catch (cardError) {
            validationResults.invalidCards++;
            validationResults.errors.push(`Card ${index}: Validation error - ${cardError.message}`);
          }
        });

        // ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®æ¤œè¨¼
        try {
          const headerValidation = await this.runGas('validateHeaderIntegrity', this.state.userId);
          if (!headerValidation.success) {
            validationResults.headerIssues++;
            validationResults.errors.push(`Header validation failed: ${headerValidation.error}`);
          }
        } catch (headerError) {
          validationResults.headerIssues++;
          validationResults.errors.push(`Header validation error: ${headerError.message}`);
        }

        // æ¤œè¨¼çµæœã®ãƒ­ã‚°å‡ºåŠ›
        const issueCount =
          validationResults.invalidCards +
          validationResults.reasonFieldIssues +
          validationResults.headerIssues;
        if (issueCount > 0) {
          console.warn('âš ï¸ Board data integrity issues detected:', validationResults);

          // è‡ªå‹•ä¿®å¾©ã®è©¦è¡Œï¼ˆç†ç”±åˆ—ã®å•é¡Œã®ã¿ï¼‰
          if (validationResults.reasonFieldIssues > 0) {
            console.log('ğŸ”§ Attempting automatic reason field recovery...');
            await this.autoRecoverReasonFields();
          }
        } else {
          console.log('âœ… Board data integrity validation passed');
        }

        return validationResults;
      } catch (error) {
        console.error('âŒ Board data integrity validation failed:', error);
        return {
          timestamp: new Date().toISOString(),
          error: error.message,
          success: false,
        };
      }
    }

    /**
     * ç†ç”±åˆ—ã®è‡ªå‹•ä¿®å¾©å‡¦ç†
     */
    async autoRecoverReasonFields() {
      try {
        console.log('ğŸ”§ Starting automatic reason field recovery...');

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã—ã¦æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        await this.gas.clearCache();

        // ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—ã—ã¦ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°
        await this.loadBoardData();

        console.log('âœ… Reason field recovery completed');
      } catch (error) {
        console.error('âŒ Automatic reason field recovery failed:', error);
      }
    }
  }
  // ===== å…±é€šãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±å‡¦ç†é–¢æ•° =====
  // AdminPanel.html ã¨ Login.html ã§å…±é€šä½¿ç”¨

  /**
   * ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
   * @param {Function} onSuccess - æˆåŠŸæ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
   * @param {Function} onError - ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
   */
  const loadDomainInfo = (onSuccess, onError) => {
    try {
      // ğŸš€ å®‰å…¨ãªé–¢æ•°å‘¼ã³å‡ºã— - å­˜åœ¨ãƒã‚§ãƒƒã‚¯ä»˜ã
      if (
        typeof google !== 'undefined' &&
        google.script &&
        google.script.run &&
        typeof google.script.run.getSystemDomainInfo === 'function'
      ) {
        google.script.run
          .withSuccessHandler((info) => {
            displayDomainInfo(info);
            if (onSuccess) onSuccess(info);
          })
          .withFailureHandler((error) => {
            console.error('ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
            displayDomainInfo({ error: error.message || error });
            if (onError) onError(error);
          })
          .getSystemDomainInfo();
      } else {
        // é–¢æ•°ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        console.warn('âš ï¸ getSystemDomainInfoé–¢æ•°ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
        const fallbackInfo = {
          domain: 'ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒ',
          note: 'ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ',
          timestamp: new Date().toISOString(),
        };
        displayDomainInfo(fallbackInfo);
        if (onSuccess) onSuccess(fallbackInfo);
      }
    } catch (error) {
      console.error('âŒ loadDomainInfoå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
      const errorInfo = { error: error.message || error };
      displayDomainInfo(errorInfo);
      if (onError) onError(error);
    }
  };

  /**
   * ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
   * @param {Object} info - ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  const displayDomainInfo = (info) => {
    const headerDomainMatch = document.getElementById('header-domain-match');
    const headerDomainMismatch = document.getElementById('header-domain-mismatch');
    const headerDomainInitial = document.getElementById('header-domain-initial');
    const headerDomainMatchText = document.getElementById('header-domain-match-text');
    const headerDomainMismatchText = document.getElementById('header-domain-mismatch-text');

    // å…¨ã¦ã®è¡¨ç¤ºã‚’ä¸€æ—¦éè¡¨ç¤ºã«ã™ã‚‹
    if (headerDomainMatch) headerDomainMatch.classList.add('hidden');
    if (headerDomainMismatch) headerDomainMismatch.classList.add('hidden');
    if (headerDomainInitial) headerDomainInitial.classList.add('hidden');

    if (!info || info.error) {
      console.warn('ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚¨ãƒ©ãƒ¼:', info?.error);
      if (headerDomainInitial) headerDomainInitial.classList.remove('hidden');
      return;
    }

    if (info.isDomainMatch) {
      // ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒä¸€è‡´ã—ã¦ã„ã‚‹å ´åˆ
      if (headerDomainMatch && headerDomainMatchText) {
        headerDomainMatch.classList.remove('hidden');
        if (info.deployDomain) {
          headerDomainMatchText.textContent = `${info.deployDomain} ãƒ‰ãƒ¡ã‚¤ãƒ³`;
        } else {
          headerDomainMatchText.textContent = 'ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹';
        }
      }
    } else {
      // ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸ä¸€è‡´ã®å ´åˆ
      if (headerDomainMismatch && headerDomainMismatchText) {
        headerDomainMismatch.classList.remove('hidden');
        headerDomainMismatchText.textContent = info.currentDomain;
      }
    }
  };

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
   * ğŸš€ RequestManagerå¯¾å¿œ - 429ã‚¨ãƒ©ãƒ¼å¯¾ç­–æ¸ˆã¿
   */
  const loadFormLink = async () => {
    try {
      // RequestManagerã‚’çµŒç”±ã—ã¦APIå‘¼ã³å‡ºã—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰
      const requestManager = window.studyQuestApp?.requestManager || new RequestManager();
      const formInfo = await requestManager.execute(
        () =>
          new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getCurrentBoardInfoAndUrls();
          }),
        `formInfo-${USER_ID}`, // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼
        300000 // 5åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      );

      if (formInfo && formInfo.formUrl) {
        const formLinkBtn = document.getElementById('formAnswerBtn');
        if (formLinkBtn) {
          // buttonã«formUrlã‚’ä¿å­˜
          formLinkBtn.dataset.formUrl = formInfo.formUrl;
          formLinkBtn.classList.remove('hidden');

          // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ 
          formLinkBtn.addEventListener('click', function () {
            if (this.dataset.formUrl) {
              window.open(this.dataset.formUrl, '_blank');
            }
          });
        }
      }
    } catch (error) {
      console.warn('ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    }
  };

  // ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºé–¢æ•°ã®å®šç¾©
  function showSystemFlow() {
    try {
      console.log('ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼åˆæœŸåŒ–é–‹å§‹');
      // åŸºæœ¬çš„ãªã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼åˆæœŸåŒ–
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          console.log('ğŸ“„ DOMèª­ã¿è¾¼ã¿å®Œäº†');
        });
      } else {
        console.log('ğŸ“„ DOMæ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿');
      }
    } catch (error) {
      console.error('âŒ ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  try {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
    // ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼è¡¨ç¤º
    showSystemFlow();

    document.addEventListener('DOMContentLoaded', () => {
      const app = new StudyQuestApp();
    });

    // Expose debug functions globally for console access
    window.debugAnswerCards = () => {
      if (window.studyQuestApp && window.studyQuestApp.debugAnswerCards) {
        window.studyQuestApp.debugAnswerCards();
      } else {
        console.log('StudyQuestApp not available or debug function not found');
      }
    };

    // Enhanced global debug function with additional utility methods
    window.debugClickAnswerCard = (cardIndex = 0, options = {}) => {
      if (window.studyQuestApp && window.studyQuestApp.debugClickAnswerCard) {
        return window.studyQuestApp.debugClickAnswerCard(cardIndex, options);
      } else {
        console.log('StudyQuestApp not available or debug function not found');
        return { success: false, error: 'StudyQuestApp not available' };
      }
    };

    // ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
    window.showSystemFlow = showSystemFlow;

    // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒ‡ãƒ¼ã‚¿æ§‹é€ ç¢ºèªæ©Ÿèƒ½
    window.debugCurrentData = () => {
      if (window.studyQuestApp && window.studyQuestApp.state) {
        console.log('ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ :', {
          currentAnswers: window.studyQuestApp.state.currentAnswers,
          currentAnswersLength: window.studyQuestApp.state.currentAnswers?.length,
          firstItem: window.studyQuestApp.state.currentAnswers?.[0],
          header: window.studyQuestApp.elements?.headingLabel?.textContent,
        });
      } else {
        console.log('StudyQuestApp not available');
      }
    };

    // Additional global debug utilities
    window.debugClickAllAnswerCards = async (options = {}) => {
      if (!window.studyQuestApp) {
        console.log('StudyQuestApp not available');
        return { success: false, error: 'StudyQuestApp not available' };
      }

      const container = window.studyQuestApp.elements?.answersContainer;
      if (!container) {
        console.log('No answers container found');
        return { success: false, error: 'No answers container found' };
      }

      const answerCards = container.querySelectorAll('.answer-card');
      const results = [];

      console.log(`Found ${answerCards.length} answer cards, clicking all...`);

      for (let i = 0; i < answerCards.length; i++) {
        try {
          const result = await window.studyQuestApp.debugClickAnswerCard(i, {
            ...options,
            logDetails: false, // Reduce noise when clicking all cards
          });
          results.push(result);

          if (options.delay && i < answerCards.length - 1) {
            // Add proper delay between clicks if specified
            await new Promise((resolve) => setTimeout(resolve, options.delay));
          }
        } catch (error) {
          console.error(`Error clicking card ${i}:`, error);
          results.push({ success: false, error: error.message, cardIndex: i });
        }
      }

      return {
        success: true,
        totalCards: answerCards.length,
        results,
      };
    };

    // ãƒãƒƒãƒå‡¦ç†åˆ¶å¾¡é–¢æ•°ï¼ˆãƒ‡ãƒãƒƒã‚°/é‹ç”¨åˆ¶å¾¡ç”¨ï¼‰
    window.toggleBatchProcessing = (enable = null) => {
      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return;
      }

      if (enable === null) {
        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒˆã‚°ãƒ«
        app.enableBatchProcessing = !app.enableBatchProcessing;
      } else {
        app.enableBatchProcessing = Boolean(enable);
      }

      console.log('ğŸ”§ ãƒãƒƒãƒå‡¦ç†:', app.enableBatchProcessing ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹');
      console.log('ğŸ’¡ å€‹åˆ¥å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã¯å¸¸ã«å‹•ä½œã—ã¾ã™ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¿è¨¼ï¼‰');
      return app.enableBatchProcessing;
    };

    window.getBatchProcessingStatus = () => {
      const app = window.studyQuestApp;
      if (!app) return null;

      return {
        enabled: app.enableBatchProcessing,
        active: app.batchProcessingActive,
        queueSize: app.reactionQueue.size,
        batchQueueSize: app.reactionBatchQueue.size,
        settings: {
          timeout: app.BATCH_TIMEOUT,
          sizeLimit: app.BATCH_SIZE_LIMIT,
        },
      };
    };

    window.debugGetAnswerCardInfo = (cardIndex = 0) => {
      if (!window.studyQuestApp) {
        console.log('StudyQuestApp not available');
        return { success: false, error: 'StudyQuestApp not available' };
      }

      // Validate cardIndex
      if (typeof cardIndex !== 'number' || cardIndex < 0 || !Number.isInteger(cardIndex)) {
        console.log('Invalid card index:', cardIndex);
        return { success: false, error: 'Invalid card index. Must be a non-negative integer.' };
      }

      const container = window.studyQuestApp.elements?.answersContainer;
      if (!container) {
        console.log('No answers container found');
        return { success: false, error: 'No answers container found' };
      }

      const answerCards = container.querySelectorAll('.answer-card');
      if (answerCards.length === 0) {
        console.log('No answer cards found');
        return { success: false, error: 'No answer cards found' };
      }

      if (cardIndex >= answerCards.length) {
        console.log('Card index out of bounds');
        return {
          success: false,
          error: 'Card index out of bounds',
          totalCards: answerCards.length,
        };
      }

      const card = answerCards[cardIndex];

      try {
        const cardInfo = {
          index: cardIndex,
          className: card.className,
          dataset: { ...card.dataset },
          rowIndex: card.dataset.rowIndex,
          boundingRect: card.getBoundingClientRect(),
          computedStyle: {
            display: getComputedStyle(card).display,
            visibility: getComputedStyle(card).visibility,
            opacity: getComputedStyle(card).opacity,
          },
          textContent: card.textContent?.trim() || '',
          innerHTML: card.innerHTML,
        };

        console.log('Answer card info:', cardInfo);
        return { success: true, cardInfo };
      } catch (error) {
        console.error('Error getting card info:', error);
        return { success: false, error: `Error getting card info: ${error.message}` };
      }
    };

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®å°‚ç”¨ãƒ†ã‚¹ãƒˆé–¢æ•°
    window.testReactionSystem = async (options = {}) => {
      console.log('ğŸ§ª ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹');

      if (!window.studyQuestApp) {
        console.error('âŒ StudyQuestApp not available');
        return { success: false, error: 'StudyQuestApp not available' };
      }

      const { cardIndex = 0, reaction = 'LIKE', verbose = true } = options;

      const testResults = {
        success: false,
        tests: [],
        errors: [],
      };

      try {
        // Test 1: ã‚«ãƒ¼ãƒ‰å­˜åœ¨ç¢ºèª
        const cardInfo = window.debugGetAnswerCardInfo(cardIndex);
        if (!cardInfo.success) {
          testResults.errors.push(`ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${cardInfo.error}`);
          return testResults;
        }

        const rowIndex = cardInfo.cardInfo.rowIndex;
        testResults.tests.push({
          name: 'ã‚«ãƒ¼ãƒ‰å­˜åœ¨ç¢ºèª',
          status: 'passed',
          data: { cardIndex, rowIndex },
        });

        // Test 2: ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³å­˜åœ¨ç¢ºèª
        const container = window.studyQuestApp.elements.answersContainer;
        const card = container.querySelectorAll('.answer-card')[cardIndex];
        const reactionBtn = card.querySelector(`[data-reaction="${reaction}"]`);

        if (!reactionBtn) {
          testResults.errors.push(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${reaction}`);
          return testResults;
        }

        testResults.tests.push({
          name: 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³å­˜åœ¨ç¢ºèª',
          status: 'passed',
          data: { reaction, button: reactionBtn.outerHTML },
        });

        // Test 3: åˆæœŸçŠ¶æ…‹è¨˜éŒ²
        const initialState = {
          reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
          count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
          classes: reactionBtn.className,
        };

        testResults.tests.push({
          name: 'åˆæœŸçŠ¶æ…‹è¨˜éŒ²',
          status: 'passed',
          data: initialState,
        });

        if (verbose) console.log('ğŸ“Š åˆæœŸçŠ¶æ…‹:', initialState);

        // Test 4: ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ãƒ†ã‚¹ãƒˆ
        console.log('ğŸ”„ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ãƒ†ã‚¹ãƒˆé–‹å§‹...');

        const clickEvent = new MouseEvent('click', { bubbles: true });

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…æ©Ÿã™ã‚‹æº–å‚™
        const reactionKey = `${rowIndex}-${reaction}`;
        let reactionCompletePromise = null;

        if (window.studyQuestApp && window.studyQuestApp.waitForReactionComplete) {
          reactionCompletePromise = window.studyQuestApp.waitForReactionComplete(reactionKey, 3000);
        }

        reactionBtn.dispatchEvent(clickEvent);

        // å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿï¼ˆé«˜åº¦ãªå‹•çš„ã‚·ã‚¹ãƒ†ãƒ ï¼‰
        try {
          const updateResult = await window.studyQuestApp.waitForReactionUpdate(
            rowIndex,
            reaction,
            null,
            3000
          );
          if (updateResult.stateChanged || updateResult.changeDetectedAt) {
            console.log('âœ… çŠ¶æ…‹å¤‰åŒ–æ¤œå‡º:', updateResult);
          } else if (updateResult.timeout) {
            console.warn('âš ï¸ å‹•çš„å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿå®Ÿè¡Œ');
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        } catch (error) {
          console.warn('âš ï¸ å‹•çš„å¾…æ©Ÿã‚¨ãƒ©ãƒ¼:', error.message);
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ™‚é–“å¾…æ©Ÿ
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        const afterClickState = {
          reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
          count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
          classes: reactionBtn.className,
        };

        testResults.tests.push({
          name: 'ã‚¯ãƒªãƒƒã‚¯å¾ŒçŠ¶æ…‹',
          status: 'passed',
          data: afterClickState,
        });

        if (verbose) console.log('ğŸ“Š ã‚¯ãƒªãƒƒã‚¯å¾ŒçŠ¶æ…‹:', afterClickState);

        // Test 5: çŠ¶æ…‹å¤‰åŒ–æ¤œè¨¼
        const stateChanged =
          initialState.reacted !== afterClickState.reacted ||
          initialState.count !== afterClickState.count;

        testResults.tests.push({
          name: 'çŠ¶æ…‹å¤‰åŒ–æ¤œè¨¼',
          status: stateChanged ? 'passed' : 'failed',
          data: {
            changed: stateChanged,
            reactedChanged: initialState.reacted !== afterClickState.reacted,
            countChanged: initialState.count !== afterClickState.count,
          },
        });

        // Test 6: å†åº¦ã‚¯ãƒªãƒƒã‚¯ã—ã¦æˆ»ã‚‹ã‹ãƒ†ã‚¹ãƒˆ
        console.log('ğŸ”„ ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å–æ¶ˆãƒ†ã‚¹ãƒˆé–‹å§‹...');

        // 2å›ç›®ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…æ©Ÿ
        let secondReactionPromise = null;
        if (window.studyQuestApp && window.studyQuestApp.waitForReactionComplete) {
          secondReactionPromise = window.studyQuestApp.waitForReactionComplete(reactionKey, 3000);
        }

        reactionBtn.dispatchEvent(clickEvent);

        // 2å›ç›®ã®å‡¦ç†å®Œäº†ã‚’å¾…æ©Ÿï¼ˆé«˜åº¦ãªå‹•çš„ã‚·ã‚¹ãƒ†ãƒ ï¼‰
        try {
          const secondUpdateResult = await window.studyQuestApp.waitForReactionUpdate(
            rowIndex,
            reaction,
            null,
            3000
          );
          if (secondUpdateResult.stateChanged || secondUpdateResult.changeDetectedAt) {
            console.log('âœ… 2å›ç›®çŠ¶æ…‹å¤‰åŒ–æ¤œå‡º:', secondUpdateResult);
          } else if (secondUpdateResult.timeout) {
            console.warn('âš ï¸ 2å›ç›®å‹•çš„å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿå®Ÿè¡Œ');
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        } catch (error) {
          console.warn('âš ï¸ 2å›ç›®å‹•çš„å¾…æ©Ÿã‚¨ãƒ©ãƒ¼:', error.message);
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ™‚é–“å¾…æ©Ÿ
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        const finalState = {
          reacted: reactionBtn.getAttribute('aria-pressed') === 'true',
          count: parseInt(reactionBtn.querySelector('.count')?.textContent || '0'),
          classes: reactionBtn.className,
        };

        testResults.tests.push({
          name: 'ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å–æ¶ˆå¾ŒçŠ¶æ…‹',
          status: 'passed',
          data: finalState,
        });

        if (verbose) console.log('ğŸ“Š å–æ¶ˆå¾ŒçŠ¶æ…‹:', finalState);

        // Test 7: å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«æ¤œè¨¼
        const backToInitial =
          initialState.reacted === finalState.reacted && initialState.count === finalState.count;

        testResults.tests.push({
          name: 'å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«æ¤œè¨¼',
          status: backToInitial ? 'passed' : 'failed',
          data: {
            backToInitial,
            initialState,
            finalState,
          },
        });

        testResults.success = testResults.tests.every((test) => test.status === 'passed');

        console.log('âœ… ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†');
        console.table(
          testResults.tests.map((t) => ({
            ãƒ†ã‚¹ãƒˆå: t.name,
            çµæœ: t.status,
            è©³ç´°: JSON.stringify(t.data),
          }))
        );

        return testResults;
      } catch (error) {
        console.error('âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
        testResults.errors.push(error.message);
        return testResults;
      }
    };

    // è¤‡æ•°ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®ãƒ†ã‚¹ãƒˆ
    window.testAllReactions = async (cardIndex = 0) => {
      console.log('ğŸ§ª å…¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆé–‹å§‹');

      const reactions = ['LIKE', 'UNDERSTAND', 'CURIOUS'];
      const results = [];

      for (const reaction of reactions) {
        console.log(`\n--- ${reaction} ãƒ†ã‚¹ãƒˆ ---`);
        const result = await window.testReactionSystem({
          cardIndex,
          reaction,
          verbose: false,
        });
        results.push({ reaction, ...result });

        // ãƒ†ã‚¹ãƒˆé–“ã®å¾…æ©Ÿ
        await new Promise((resolve) => setTimeout(resolve, 500));
      }

      console.log('\nğŸ“Š å…¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆçµæœ:');
      console.table(
        results.map((r) => ({
          ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³: r.reaction,
          æˆåŠŸ: r.success ? 'âœ…' : 'âŒ',
          ãƒ†ã‚¹ãƒˆæ•°: r.tests.length,
          ã‚¨ãƒ©ãƒ¼æ•°: r.errors.length,
        }))
      );

      return results;
    };

    // === é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•° ===

    // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    window.testNotificationSystem = async () => {
      console.log('ğŸ§ª é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ãƒ†ã‚¹ãƒˆé–‹å§‹');

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      try {
        const results = await app.testNotificationEdgeCases();
        console.log('ğŸ“Š é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆçµæœ:', results);
        return results;
      } catch (error) {
        console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        return { success: false, error: error.message };
      }
    };

    // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
    window.validateNotificationSystem = () => {
      console.log('ğŸ” é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯é–‹å§‹');

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      try {
        const results = app.validateNotificationSystem();
        console.log('ğŸ“Š é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§:', results);
        return results;
      } catch (error) {
        console.error('âŒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
        return { success: false, error: error.message };
      }
    };

    // åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã‚·ãƒŠãƒªã‚ªã®æ‰‹å‹•ãƒ†ã‚¹ãƒˆ
    window.simulateInitialLoadFailure = async () => {
      console.log('ğŸ§ª åˆæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã‚·ãƒŠãƒªã‚ªã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹');

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      try {
        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
        const originalInitialDataLoaded = app.initialDataLoaded;
        const originalHadInitialDataLoadFailure = app.hadInitialDataLoadFailure;
        const originalLastSeenCount = app.state.lastSeenCount;

        // å¤±æ•—çŠ¶æ…‹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        app.initialDataLoaded = false;
        app.hadInitialDataLoadFailure = true;
        app.state.lastSeenCount = 0;

        console.log('ğŸ”§ å¤±æ•—çŠ¶æ…‹è¨­å®š:', {
          initialDataLoaded: app.initialDataLoaded,
          hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
          lastSeenCount: app.state.lastSeenCount,
        });

        // é€šçŸ¥ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’è¨­å®š
        let notificationShown = false;
        const originalShowNewContentBanner = app.showNewContentBanner;
        app.showNewContentBanner = (newItems) => {
          notificationShown = true;
          console.log('ğŸ¯ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ï¼šé€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ -', newItems, 'ä»¶');
          return originalShowNewContentBanner.call(app, newItems);
        };

        // ãƒãƒ¼ãƒªãƒ³ã‚°æˆåŠŸã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        await app.handleInitialContentLoad('ã™ã¹ã¦-newest', 1);

        const result = {
          success: true,
          notificationShown,
          finalState: {
            initialDataLoaded: app.initialDataLoaded,
            hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
            lastSeenCount: app.state.lastSeenCount,
          },
        };

        // çŠ¶æ…‹ã‚’å¾©å…ƒ
        app.initialDataLoaded = originalInitialDataLoaded;
        app.hadInitialDataLoadFailure = originalHadInitialDataLoadFailure;
        app.state.lastSeenCount = originalLastSeenCount;
        app.showNewContentBanner = originalShowNewContentBanner;

        console.log('âœ… ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†:', result);
        return result;
      } catch (error) {
        console.error('âŒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
        return { success: false, error: error.message };
      }
    };

    // ç¾åœ¨ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’å–å¾—
    window.getNotificationSystemStatus = () => {
      const app = window.studyQuestApp;
      if (!app) return null;

      return {
        initialDataLoaded: app.initialDataLoaded,
        hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
        lastSeenCount: app.state.lastSeenCount,
        pollingEnabled: app.pollingSettings?.enabled,
        notificationElements: {
          banner: !!app.elements.newContentBanner,
          text: !!app.elements.newContentText,
          refreshBtn: !!app.elements.refreshContentBtn,
          dismissBtn: !!app.elements.dismissBannerBtn,
        },
        bannerVisible:
          app.elements.newContentBanner &&
          !app.elements.newContentBanner.classList.contains('hidden'),
        lastNotificationTime: app.lastNotificationTime,
        currentAnswersCount: app.state.currentAnswers?.length || 0,
      };
    };

    // é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã®ãƒ†ã‚¹ãƒˆ
    window.testNotificationDebounce = async () => {
      console.log('ğŸ§ª é€šçŸ¥ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      try {
        return await app.testNotificationDebounce();
      } catch (error) {
        console.error('âŒ ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
        return { success: false, error: error.message };
      }
    };

    // === ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­æ©Ÿèƒ½ ===

    // ãƒ‡ãƒ¼ã‚¿å–å¾—çŠ¶æ³ã®è©³ç´°è¨ºæ–­
    window.diagnoseDataFetch = async () => {
      console.log('ğŸ”¬ ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­é–‹å§‹');

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      const diagnosis = {
        timestamp: new Date().toISOString(),
        userState: {
          userId: app.state.userId,
          currentAnswersCount: app.state.currentAnswers?.length || 0,
          lastSeenCount: app.state.lastSeenCount,
          initialDataLoaded: app.initialDataLoaded,
          hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
        },
        uiState: {
          classFilter: app.elements.classFilter?.value || 'unknown',
          sortOrder: app.elements.sortOrder?.value || 'unknown',
          showAdminFeatures: app.state.showAdminFeatures,
        },
        tests: [],
        recommendations: [],
      };

      try {
        // ãƒ†ã‚¹ãƒˆ1: è»½é‡ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ
        console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ1: ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ');
        const startTime = performance.now();
        const countData = await app.gas.getDataCount(
          diagnosis.uiState.classFilter,
          diagnosis.uiState.sortOrder,
          diagnosis.uiState.showAdminFeatures
        );
        const countTime = performance.now() - startTime;

        diagnosis.tests.push({
          name: 'ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ',
          duration: Math.round(countTime),
          result: countData,
          success: !!countData && countData.count !== undefined,
        });

        // ãƒ†ã‚¹ãƒˆ2: ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—
        console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ2: ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—');
        const fullStartTime = performance.now();
        const fullData = await app.gas.getPublishedSheetData(
          app.state.userId,
          diagnosis.uiState.classFilter,
          diagnosis.uiState.sortOrder,
          diagnosis.uiState.showAdminFeatures,
          false
        );
        const fullTime = performance.now() - fullStartTime;

        diagnosis.tests.push({
          name: 'ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—',
          duration: Math.round(fullTime),
          result: {
            status: fullData?.status,
            dataCount: fullData?.data?.length || 0,
            sheetName: fullData?.sheetName,
          },
          success: !!fullData && !!fullData.data,
        });

        // ãƒ†ã‚¹ãƒˆ3: å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—
        if (diagnosis.userState.lastSeenCount > 0) {
          console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆ3: å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—');
          const incrementalStartTime = performance.now();
          const incrementalData = await app.gas.getIncrementalSheetData(
            diagnosis.uiState.classFilter,
            diagnosis.uiState.sortOrder,
            diagnosis.uiState.showAdminFeatures,
            diagnosis.userState.lastSeenCount
          );
          const incrementalTime = performance.now() - incrementalStartTime;

          diagnosis.tests.push({
            name: 'å¢—åˆ†ãƒ‡ãƒ¼ã‚¿å–å¾—',
            duration: Math.round(incrementalTime),
            result: {
              newCount: incrementalData?.newCount || 0,
              totalCount: incrementalData?.totalCount || 0,
              status: incrementalData?.status,
            },
            success: !!incrementalData && incrementalData.status !== 'error',
          });
        }

        // è¨ºæ–­çµæœã®è©•ä¾¡ã¨æ¨å¥¨äº‹é …
        const countResult = diagnosis.tests.find((t) => t.name === 'ãƒ‡ãƒ¼ã‚¿ã‚«ã‚¦ãƒ³ãƒˆ');
        const fullResult = diagnosis.tests.find((t) => t.name === 'ãƒ•ãƒ«ãƒ‡ãƒ¼ã‚¿å–å¾—');

        if (countResult && fullResult) {
          if (countResult.success && fullResult.success) {
            const expectedCount = countResult.result.count || 0;
            const actualCount = fullResult.result.dataCount || 0;

            if (expectedCount !== actualCount) {
              diagnosis.recommendations.push({
                level: 'warning',
                message: `ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡º: ã‚«ã‚¦ãƒ³ãƒˆ=${expectedCount}, å®Ÿéš›=${actualCount}`,
                action: 'ã‚µãƒ¼ãƒãƒ¼å´ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„',
              });
            } else if (expectedCount === 0) {
              diagnosis.recommendations.push({
                level: 'info',
                message: 'ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã›ã‚“',
                action: 'ãƒ•ã‚©ãƒ¼ãƒ ã«æ–°ã—ã„å›ç­”ã‚’æŠ•ç¨¿ã—ã¦ãã ã•ã„',
              });
            } else {
              diagnosis.recommendations.push({
                level: 'success',
                message: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™',
                action: 'å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„',
              });
            }
          } else {
            diagnosis.recommendations.push({
              level: 'error',
              message: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
              action: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„',
            });
          }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡
        const avgTime =
          diagnosis.tests.reduce((sum, test) => sum + test.duration, 0) / diagnosis.tests.length;
        if (avgTime > 3000) {
          diagnosis.recommendations.push({
            level: 'warning',
            message: `å¿œç­”æ™‚é–“ãŒé…ã„ (å¹³å‡${Math.round(avgTime)}ms)`,
            action: 'ã‚µãƒ¼ãƒãƒ¼ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„',
          });
        }

        console.log('ğŸ“Š ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ºæ–­å®Œäº†:', diagnosis);
        return diagnosis;
      } catch (error) {
        console.error('âŒ è¨ºæ–­ã‚¨ãƒ©ãƒ¼:', error);
        diagnosis.tests.push({
          name: 'è¨ºæ–­å®Ÿè¡Œ',
          duration: 0,
          result: null,
          success: false,
          error: error.message,
        });
        return diagnosis;
      }
    };

    // ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
    window.monitorDataFetchPerformance = async (duration = 60000) => {
      console.log(`ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–é–‹å§‹ (${duration / 1000}ç§’é–“)`);

      const app = window.studyQuestApp;
      if (!app) {
        console.error('StudyQuestApp not found');
        return { success: false, error: 'StudyQuestApp not found' };
      }

      const monitor = {
        startTime: Date.now(),
        duration: duration,
        samples: [],
        summary: {},
      };

      const interval = setInterval(async () => {
        try {
          const startTime = performance.now();
          const countData = await app.gas.getDataCount('ã™ã¹ã¦', 'newest', false);
          const endTime = performance.now();

          monitor.samples.push({
            timestamp: Date.now(),
            duration: Math.round(endTime - startTime),
            success: !!countData,
            count: countData?.count || 0,
          });

          console.log(`ğŸ“Š ã‚µãƒ³ãƒ—ãƒ«${monitor.samples.length}: ${Math.round(endTime - startTime)}ms`);
        } catch (error) {
          monitor.samples.push({
            timestamp: Date.now(),
            duration: 0,
            success: false,
            error: error.message,
          });
        }
      }, 5000); // 5ç§’é–“éš”

      // æŒ‡å®šæ™‚é–“å¾Œã«ç›£è¦–çµ‚äº†
      setTimeout(() => {
        clearInterval(interval);

        // çµ±è¨ˆè¨ˆç®—
        const successful = monitor.samples.filter((s) => s.success);
        const failed = monitor.samples.filter((s) => !s.success);

        if (successful.length > 0) {
          const durations = successful.map((s) => s.duration);
          monitor.summary = {
            totalSamples: monitor.samples.length,
            successfulSamples: successful.length,
            failedSamples: failed.length,
            successRate: ((successful.length / monitor.samples.length) * 100).toFixed(1) + '%',
            avgDuration: Math.round(durations.reduce((a, b) => a + b, 0) / durations.length),
            minDuration: Math.min(...durations),
            maxDuration: Math.max(...durations),
            medianDuration: durations.sort((a, b) => a - b)[Math.floor(durations.length / 2)],
          };
        } else {
          monitor.summary = {
            totalSamples: monitor.samples.length,
            successfulSamples: 0,
            failedSamples: failed.length,
            successRate: '0%',
            error: 'å…¨ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ãŒå¤±æ•—ã—ã¾ã—ãŸ',
          };
        }

        console.log('ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–å®Œäº†:', monitor.summary);
      }, duration);

      return monitor;
    };

    // ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®åŒ…æ‹¬çš„ãªãƒ¬ãƒãƒ¼ãƒˆ
    window.getSystemStatusReport = () => {
      const app = window.studyQuestApp;
      if (!app) return null;

      const report = {
        timestamp: new Date().toISOString(),
        application: {
          version: '2.0',
          initialDataLoaded: app.initialDataLoaded,
          hadInitialDataLoadFailure: app.hadInitialDataLoadFailure,
          pollingActive: app.pollingSettings?.enabled,
          batchProcessingEnabled: app.enableBatchProcessing,
        },
        data: {
          currentAnswersCount: app.state.currentAnswers?.length || 0,
          lastSeenCount: app.state.lastSeenCount,
          visibleCardsCount: document.querySelectorAll('.answer-card').length,
          userId: app.state.userId?.substring(0, 8) + '...',
        },
        ui: {
          classFilter: app.elements.classFilter?.value,
          sortOrder: app.elements.sortOrder?.value,
          showAdminFeatures: app.state.showAdminFeatures,
          notificationBannerVisible:
            app.elements.newContentBanner &&
            !app.elements.newContentBanner.classList.contains('hidden'),
        },
        performance: {
          memoryUsage: performance.memory
            ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',
              }
            : 'unavailable',
        },
      };

      console.log('ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ãƒ¬ãƒãƒ¼ãƒˆ:', report);
      return report;
    };

    // ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã¨ãƒ•ã‚©ãƒ¼ãƒ ãƒªãƒ³ã‚¯ã‚’å–å¾—
    loadDomainInfo();
    loadFormLink();

    window.addEventListener('beforeunload', () => {
      if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
        window.studyQuestApp.destroy();
      }
    });
  } catch (error) {
    console.error('Error creating StudyQuestApp instance:', error);
    const container = document.getElementById('answers');
    if (container) {
      const msg = StudyQuestApp.prototype.escapeHtml(error.message || '');
      container.innerHTML = `<div class="text-red-400 p-4">ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ${msg}</div>`;
    }
  }
</script>
