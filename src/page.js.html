<script>
// Constants and utilities now loaded from page.html initialization

// Access global constants from page.html

class StudyQuestApp {
  // アプリケーション定数
  static get CONSTANTS() {
    // Dynamic configuration using SharedUtilities performance functions
    const perfLevel = window.getPerformanceLevel?.() || 'medium';
    const isLowEndDevice = window.isLowEndDevice?.() || false;

    return {
      REACTION_RATE_LIMIT_MS: isLowEndDevice ? 800 : 500,
      HIGHLIGHT_RATE_LIMIT_MS: isLowEndDevice ? 800 : 500,
      CACHE_TTL_MS: perfLevel === 'high' ? 2000 : perfLevel === 'low' ? 500 : 1000,
      RETRY_DELAY_MS: perfLevel === 'low' ? 3000 : 2000,
      POLLING_INTERVAL_MS: perfLevel === 'high' ? 3000 : perfLevel === 'low' ? 8000 : 5000,
      INIT_TIMEOUT_MS: isLowEndDevice ? 45000 : 30000
    };
  }

  // Performance detection functions now provided by SharedUtilities.html

  /**
   * ユーザーIDを検証し、必要に応じてフォールバック値を提供
   * @param {string} userId - 検証するユーザーID
   * @returns {string} 有効なユーザーID、またはフォールバック値
   */
  validId(userId) {
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      warnLog('⚠️ StudyQuestApp: Invalid or empty userId provided:', userId);

      try {
        const urlParams = new URLSearchParams(window.location.search);
        const fallbackUserId = urlParams.get('userId');

        if (fallbackUserId && fallbackUserId.trim()) {
          return fallbackUserId.trim();
        }
      } catch (error) {
        warnLog('⚠️ StudyQuestApp: Failed to get userId from URL parameters:', error.message);
      }

      // グローバル変数からのフォールバック
      try {
        if (typeof USER_ID !== 'undefined' && USER_ID && USER_ID.trim()) {
          return USER_ID.trim();
        }
      } catch (error) {
        warnLog('⚠️ StudyQuestApp: Failed to get userId from global USER_ID:', error.message);
      }

      // 最後のフォールバック: 空文字列を返すが、アプリケーションは続行
      warnLog('⚠️ StudyQuestApp: No valid userId available. Using limited functionality mode.');
      return '';
    }

    // UUID形式の基本的な形式チェック（36文字、ハイフン付き）
    if (userId.length === 36 && userId.includes('-')) {
      return userId;
    }

    // その他の形式も許可するが警告を出す
    warnLog('⚠️ StudyQuestApp: Unusual userId format, but proceeding:', userId.substring(0, 8) + '...');
    return userId;
  }

  constructor() {
    this.cache = new window.UnifiedCache();
    this.weakCache = new WeakMap(); // For DOM element caching
    this.perf = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;
    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      newContentBanner: document.getElementById('newContentBanner'),
      newContentText: document.getElementById('newContentText'),
      refreshContentBtn: document.getElementById('refreshContentBtn'),
      dismissBannerBtn: document.getElementById('dismissBannerBtn'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter'),
      loadingOverlay: document.getElementById('loading-overlay')
    };
    this.state = {
      currentAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      isStudentMode: window.isStudentMode,
      isAdminUser: window.isAdminUser,
      showCounts: window.showCounts,
      showAdminFeatures: false, // 初期状態は常に閲覧モード
      showHighlightToggle: window.isAdminUser, // 管理者なら常に表示
      showScoreSort: window.showScoreSort,
      displayMode: window.displayMode,
      sheetName: SHEET_NAME,
      userId: this.validId(USER_ID),
      hasNewContent: false,
      newContentCount: 0,
      lastSeenCount: this.loadLastSeenCount(), // ローカルストレージから復元
      pollingFailureCount: 0,
      startTime: Date.now()
    };
    
    // 新着チェック用の初期化
    this.lastViewKey = null;
    this.initialDataLoaded = false;
    this.hadInitialDataLoadFailure = false; // 初期データロード失敗フラグ
    
    // Initial state setup complete
    this.serverShowCounts = window.showCounts;
    this.serverDisplayMode = window.displayMode;
    this.pollingInterval = null;
    this.handlers = {};
    this.adminModeVerified = false; // 管理モード切り替え時の権限確認フラグ
    this.reactionDebounce = new Map();
    this.highlightDebounce = new Map(); // ハイライトのデバウンス処理用
    this.pendingReactions = new Set();
    this.reactionQueue = new Map();
    this.reactionEventListeners = new Map(); // 処理完了通知用
    this.isProcessingReactionQueue = false; // キュー処理中フラグ
    
    // バッチ処理システム（既存機能に影響しない追加機能）
    this.enableBatchProcessing = true; // バッチ処理有効フラグ（簡単に無効化可能）
    this.reactionBatchQueue = new Map(); // rowIndex -> reactions[] のバッチキュー
    this.batchTimer = null; // バッチ処理タイマー
    this.BATCH_TIMEOUT = 500; // 500ms以内の操作をバッチ化
    this.BATCH_SIZE_LIMIT = 5; // 最大バッチサイズ（控えめに設定）
    this.batchProcessingActive = false; // バッチ処理中フラグ
    
    // イベントリスナー重複登録防止フラグ
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];
    
    // リアクション状態保存用のキー
    this.reactionStorageKey = `reactions_${USER_ID}_${SHEET_NAME}`;
    this.gas = {
      // サーバ実装に合わせた直接呼び出し（中間関数なし）
      getPublishedSheetData: (classFilter, sort, adminMode, bypassCache) =>
        this.runGas('getPublishedSheetData', classFilter, sort, adminMode, bypassCache),
      getIncrementalSheetData: (classFilter, sort, adminMode, sinceRowCount) =>
        this.runGas('getIncrementalSheetData', this.state.sheetName, { classFilter, sortOrder: sort, lastSeenCount: sinceRowCount }),
      getAvailableSheets: () => this.runGas('getSheets'),
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('dsAddReaction', this.state.userId, rowIndex, reaction),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('dsToggleHighlight', this.state.userId, rowIndex),
      checkAdmin: () => this.runGas('isAdmin'),
      clearCache: () => this.runGas('refreshBoardData', this.state.userId),
      validateData: () => this.validData(),
      // 件数は公開取得から導出
      getDataCount: async (classFilter, sortOrder, adminMode) => {
        const resp = await this.gas.getPublishedSheetData(classFilter, sortOrder, adminMode);
        const rows = resp?.rows || resp?.data || [];
        return { success: true, count: rows.length };
      }
    };
    
    // Polling settings with dynamic interval adjustment
    this.pollingSettings = {
      enabled: true,
      baseInterval: 30000, // 基本30秒間隔
      currentInterval: 30000, // 現在の間隔
      minInterval: 15000, // 最小15秒 (高アクティビティ時)
      maxInterval: 120000, // 最大2分 (低アクティビティ時)
      maxRetries: 3,
      currentRetries: 0,
      successCount: 0, // 連続成功回数
      activityScore: 0 // アクティビティスコア
    };
    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
      this.elements.sizeSlider.value = savedCols;
      this.elements.sliderValue.textContent = savedCols;
    }
    this.init().catch(error => {
      errorLog('❌ StudyQuestApp: Fatal initialization error:', error);
      this.displayInitializationError('アプリケーションの起動に失敗しました: ' + error.message);
    });
    
    // パブリケーション状態監視システムの初期化
    this.initPublicationStatusMonitoring();
  }

  resetStateForCleanInit() {
    
    // Reset core data arrays
    this.state.currentAnswers = [];
    this.state.hasNewContent = false;
    this.state.newContentCount = 0;
    this.state.pollingFailureCount = 0;
    
    // Clear DOM to prevent inconsistency
    const container = this.elements.answersContainer;
    if (container) {
      const existingCards = container.querySelectorAll('.answer-card');
      if (existingCards.length > 0) {
        // Remove observers
        existingCards.forEach(card => {
          if (this.visibilityObserver) {
            this.visibilityObserver.unobserve(card);
          }
          if (this.scrollObserver) {
            this.scrollObserver.unobserve(card);
          }
        });
        container.innerHTML = '';
      }
    }
    
    // Clear differential cards to prevent residual data
    this.clearDifferentialCards();
    
    // Reset initialization flags
    this.initialDataLoaded = false;
    this.hadInitialDataLoadFailure = false;
    this.lastViewKey = null;
    
    // Clear content check flags
    this.contentCheckInProgress = false;
    
    // Reset current active sheet state
    this.state.currentActiveSheet = SHEET_NAME;
    
  }

  synchronizeStateAfterDataUpdate(newData, context = 'unknown') {
    
    const dataLength = newData ? newData.length : 0;
    const previousLength = this.state.currentAnswers.length;
    
    this.state.currentAnswers = newData || [];
    
    this.updateLastSeenCount(dataLength);
    
    if (dataLength > previousLength) {
      this.state.hasNewContent = true;
      this.state.newContentCount = dataLength - previousLength;
    } else {
      this.state.hasNewContent = false;
      this.state.newContentCount = 0;
    }
    
    this.state.pollingFailureCount = 0;
    
    this.logMetrics(context, dataLength, previousLength);
    
    
    return {
      dataLength,
      hasChanges: dataLength !== previousLength
    };
  }

  logMetrics(context, currentDataLength, previousDataLength) {
    const domCardCount = this.elements.answersContainer ? 
      this.elements.answersContainer.querySelectorAll('.answer-card').length : 0;
    
    const metrics = {
      timestamp: new Date().toISOString(),
      context,
      dataMetrics: {
        currentLength: currentDataLength,
        previousLength: previousDataLength,
        lastSeenCount: this.state.lastSeenCount,
        changeAmount: currentDataLength - previousDataLength
      },
      domMetrics: {
        cardCount: domCardCount,
        dataVsDom: currentDataLength - domCardCount,
        isConsistent: currentDataLength === domCardCount
      },
      stateMetrics: {
        hasNewContent: this.state.hasNewContent,
        newContentCount: this.state.newContentCount,
        pollingFailureCount: this.state.pollingFailureCount,
        initialDataLoaded: this.initialDataLoaded
      },
      perf: {
        timeSinceInit: Date.now() - this.state.startTime,
        isLoadingActive: this.state.isLoading
      }
    };
    
    
    
    // Alert on significant inconsistencies (ignore initial loading and minor differences)
    const isInitialLoad = context === 'performDataLoad' && domCardCount <= 3;
    const significantDifference = Math.abs(currentDataLength - domCardCount) > 5;
    if (!metrics.domMetrics.isConsistent && significantDifference && !isInitialLoad) {
      warnLog('⚠️ Significant DOM-Data inconsistency detected:', {
        data: currentDataLength,
        dom: domCardCount,
        context,
        difference: Math.abs(currentDataLength - domCardCount)
      });
    }
    
    return metrics;
  }

  logCacheActivity(operation, hit, details = {}) {
    const cacheLog = {
      timestamp: new Date().toISOString(),
      operation,
      hit,
      details,
      context: this.state.currentActiveSheet || 'unknown'
    };
    
    
    // Store cache metrics
  }

  async executeWithRetry(operation, options = {}) {
    const {
      maxRetries = 3,
      baseDelay = 1000,
      maxDelay = 10000,
      backoffMultiplier = 2,
      jitter = true,
      retryCondition = () => true,
      context = 'operation'
    } = options;

    let lastError = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await operation(attempt);
        if (attempt > 0) {
          debugLog(`${context} succeeded (attempt ${attempt + 1})`);
        }
        return result;
      } catch (error) {
        lastError = error;

        if (attempt === maxRetries || !retryCondition(error, attempt)) {
          break;
        }

        // Calculate exponential backoff delay with jitter
        let delay = Math.min(baseDelay * Math.pow(backoffMultiplier, attempt), maxDelay);
        if (jitter) {
          delay = delay * (0.5 + Math.random() * 0.5); // Add 50% jitter
        }

        warnLog(`⚠️ ${context} failed (attempt ${attempt + 1}/${maxRetries + 1}): ${error.message}`);

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }

  async processLoadError(error, context, retryOptions = {}) {
    const {
      maxRetries = 2,
      retryDelay = 1000,
      fallbackStrategy = 'clearAndReload'
    } = retryOptions;

    errorLog(`❌ Data load error in ${context}:`, error);
    
    // Log detailed error information
    this.logErrorDetails(error, context);
    
    // Increment failure count
    this.state.pollingFailureCount = (this.state.pollingFailureCount || 0) + 1;
    
    // Determine recovery strategy based on error type and failure count
    const recoveryStrategy = this.determineRecoveryStrategy(error, context);
    
    try {
      switch (recoveryStrategy) {
        case 'retry':
          await new Promise(resolve => setTimeout(resolve, retryDelay));
          return await this.executeRecoveryRetry(context);
          
        case 'clearAndReload':
          return await this.executeRecoveryReload();
          
        case 'fallbackMode':
          return await this.executeRecoveryFallback();
          
        default:
          this.displayUserFriendlyError(error, context);
          return null;
      }
    } catch (recoveryError) {
      errorLog('❌ Recovery strategy failed:', recoveryError);
      this.displayUserFriendlyError(error, context, true);
      return null;
    }
  }

  logErrorDetails(error, context) {
    const errorDetails = {
      timestamp: new Date().toISOString(),
      context,
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      },
      state: {
        currentAnswersLength: this.state.currentAnswers?.length || 0,
        lastSeenCount: this.state.lastSeenCount,
        pollingFailureCount: this.state.pollingFailureCount,
        isLoading: this.state.isLoading
      },
      environment: {
        userAgent: navigator.userAgent,
        currentSheet: this.state.currentActiveSheet,
        timeSinceInit: Date.now() - this.state.startTime
      }
    };
    
    
    // Store error history
    if (!this.errorHistory) this.errorHistory = [];
    this.errorHistory.push(errorDetails);
    if (this.errorHistory.length > 5) {
      this.errorHistory.shift();
    }
  }

  /**
   * パブリケーション状態監視システムの初期化 - 最小限版
   */
  initPublicationStatusMonitoring() {
    // ページアクセス時のみチェック（初回のみ）
    setTimeout(() => {
      this.checkPublicationStatus();
    }, 2000); // 初期化完了後に1回のみ実行
  }

  /**
   * パブリケーション状態の実際のチェック処理
   * 非公開状態が検出された場合、Unpublished.htmlにリダイレクト
   */
  async checkPublicationStatus() {
    try {
      // サーバーサイドでのリアルタイム状態確認
      const result = await this.runGas('checkCurrentPublicationStatus', this.state.userId);
      
      // 非公開状態が検出された場合の処理
      if (result && result.isPublished === false) {
        
        // キャッシュをクリア
        if (this.cache && typeof this.cache.clear === 'function') {
          this.cache.clear();
        }
        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
        }
        
        // ローカルストレージのキャッシュもクリア
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.includes('studyquest') || key.includes('board') || key.includes('sheet')) {
              localStorage.removeItem(key);
            }
          });
        } catch (e) {
          warnLog('localStorage clear warning:', e);
        }
        
        // 非公開ページにリダイレクト（キャッシュバスティング付き）
        const unpublishedUrl = new URL(window.location.href);
        unpublishedUrl.searchParams.delete('mode'); // mode=viewを削除
        unpublishedUrl.searchParams.set('_cb', Date.now()); // キャッシュバスティング
        
        window.location.href = unpublishedUrl.toString();
        return;
      }
      
      // 公開状態の場合は正常継続
      
    } catch (error) {
      // Only log non-network errors to reduce noise during temporary connectivity issues
      if (!error.message.includes('NetworkError') && !error.message.includes('ERR_INTERNET_DISCONNECTED')) {
        warnLog('⚠️ パブリケーション状態チェックでエラー:', error.message);
      } else {
        debugLog('🌐 ネットワーク接続エラー (一時的):', error.message);
      }
      // エラーの場合は継続（ネットワーク問題などを考慮）
    }
  }

  determineRecoveryStrategy(error, context) {
    // Determine best recovery strategy based on error characteristics
    if (this.state.pollingFailureCount <= 2) {
      return 'retry';
    } else if (this.state.pollingFailureCount <= 5) {
      return 'clearAndReload';
    } else {
      return 'fallbackMode';
    }
  }

  async executeRecoveryRetry(context) {
    try {
      await this.clearDataCaches(true);
      return await this.loadSheetData({ bypassCache: true, isInitialLoad: false });
    } catch (retryError) {
      throw new Error(`Retry failed: ${retryError.message}`);
    }
  }

  async executeRecoveryReload() {
    try {
      await this.clearAllCardsForEmptyData();
      this.resetStateForCleanInit();
      return await this.loadSheetData({ bypassCache: true, isInitialLoad: true });
    } catch (reloadError) {
      throw new Error(`Reload failed: ${reloadError.message}`);
    }
  }

  async executeRecoveryFallback() {
    // Implement minimal functional state
    this.displayEmptyState();
    this.provideFeedback('データの読み込みに問題が発生しました。ページを更新してください。', 'error');
    
    // Reset polling to longer intervals
    if (this.pollingTimeout) {
      clearTimeout(this.pollingTimeout);
      this.currentPollInterval = 60000; // 1 minute
      this.startNewAnswerPolling();
    }
    
    return { fallbackMode: true };
  }

  displayUserFriendlyError(error, context, isRecoveryFailed = false) {
    let userMessage = 'データの読み込み中に問題が発生しました。';
    
    if (isRecoveryFailed) {
      userMessage = '復旧処理が失敗しました。ページを再読み込みしてください。';
    } else if (context.includes('polling')) {
      userMessage = '新着チェック中に問題が発生しました。自動的に再試行します。';
    } else if (context.includes('initial')) {
      userMessage = 'アプリケーションの初期化中に問題が発生しました。ページを再読み込みしてください。';
    }
    
    this.provideFeedback(userMessage, 'error');
  }

  async init() {
    try {
      // 初回アクセス時にデジタルシティズンシップモーダルを表示（読み込みと同時進行）
      const hasSeenDigitalCitizenship = localStorage.getItem('hasSeenDigitalCitizenship');
      const shouldShowModal = !hasSeenDigitalCitizenship || 
        (hasSeenDigitalCitizenship && Date.now() > parseInt(hasSeenDigitalCitizenship));
      
      if (shouldShowModal && window.sharedModals) {
        window.sharedModals.showDigitalCitizenship();
        // 表示済みフラグを設定（24時間有効）
        const expiry = Date.now() + (24 * 60 * 60 * 1000);
        localStorage.setItem('hasSeenDigitalCitizenship', expiry.toString());
      }
      
      // 初期ロード状態を表示
      this.showLoadingOverlay();
      
      // タイムアウト設定（30秒）
      this.initTimeoutId = setTimeout(() => {
        this.hideLoadingOverlay();
        warnLog('⏰ ページの初期化がタイムアウトしました。ネットワーク接続またはサーバーの応答をご確認ください。');
        this.showErrorMessage('初期化がタイムアウトしました。接続状況を確認して、ページを再読み込みしてください。', false);
      }, 30000);
      
      // Reset state for clean initialization
      this.resetStateForCleanInit();
      
      // Critical path only - non-blocking
      this.setupCriticalElements();
      this.showMinimalSkeleton();
      
      // Apply default low performance tweaks
      this.optimizeForLowPerformance();

      // Show info modal while loading sheet data in the background
      this.showInfoModal();

      // Kick off data loading without blocking UI
      this.loadSheetData({ showLoading: false, isInitialLoad: true, bypassCache: false })
        .catch(error => {
          errorLog('❌ StudyQuestApp: Critical error in loadSheetData:', error);
          this.displayInitializationError('アプリケーションの初期化中にエラーが発生しました: ' + error.message);
        })
        .finally(() => {
          if (this.initTimeoutId) {
            clearTimeout(this.initTimeoutId);
            this.initTimeoutId = null;
          }
        });
      
      // Defer all non-critical operations
      requestIdleCallback(() => {
        this.setupNonCriticalEventListeners();
        this.renderIcons();
        this.adjustLayout();
        this.updateSortOptions();
        this.setupObservers();
        // Initial admin state setup - 管理者権限があっても最初は閲覧モードで起動
        if (window.hasAdminCapability && window.isAdminUser) {
          this.state.isAdminUser = true;
          this.state.showAdminFeatures = false; // 初期は閲覧モード
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.style.display = ''; // 表示を確実に
            this.elements.adminToggleBtn.textContent = '管理モード';
          }
        } else {
          // 非管理者の場合は管理機能を完全に無効化
          this.state.isAdminUser = false;
          this.state.showAdminFeatures = false;
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.add('hidden');
            this.elements.adminToggleBtn.setAttribute('hidden', '');
            this.elements.adminToggleBtn.style.display = 'none'; // 確実に非表示
          }
        }
        
        // Start polling for new answers
        this.startNewAnswerPolling();
        
        // Start polling for new answers
      }, { timeout: 50 });

      // AdminPanelからのメッセージをリッスン  
      window.addEventListener('message', async (event) => {
        if (event.data && event.data.type === 'REFRESH_BOARD_DATA') {
          // Refresh board data message received
          try {
            await this.loadSheetData({ bypassCache: true });
            // Show info modal on board refresh
            this.showInfoModal();
          } catch (error) {
            errorLog('ボードデータ更新エラー:', error);
          }
        } else if (event.data && event.data.type === 'BOARD_PUBLISHED') {
          // 新しいボードが公開された時の即座更新
          try {
            // キャッシュバイパスで新しいデータをチェック
            await this.checkForNewContentLight(true);
            // 必要に応じてフルリフレッシュ
            await this.loadSheetData({ bypassCache: true });
            // Show info modal when new board is published
            this.showInfoModal();
          } catch (error) {
            warnLog('新しいボードの即座更新でエラー:', error);
            // エラー時もフルリフレッシュを実行
            try {
              await this.loadSheetData({ bypassCache: true });
            } catch (loadError) {
              errorLog('フォールバック読み込みもエラー:', loadError);
            }
            // Show info modal even on error
            this.showInfoModal();
          }
        } else if (event.data && event.data.type === 'FORM_CREATED') {
          // フォームが作成された時のフォームリンク更新
          try {
            const formLinkBtn = document.getElementById('form-link-btn');
            if (formLinkBtn && event.data.formUrl) {
              formLinkBtn.href = event.data.formUrl;
              formLinkBtn.classList.remove('hidden');
            }
          } catch (error) {
            warnLog('フォームリンク更新でエラー:', error);
          }
        }
      });
      
      // BroadcastChannelで他のタブからの更新通知も受信
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.addEventListener('message', async (event) => {
          if (event.data && event.data.type === 'BOARD_PUBLISHED') {
            try {
              await this.checkForNewContentLight(true);
              await this.loadSheetData({ bypassCache: true });
              // Show info modal when board is updated via BroadcastChannel
              this.showInfoModal();
            } catch (error) {
              warnLog('BroadcastChannel経由の更新でエラー:', error);
              try {
                await this.loadSheetData({ bypassCache: true });
              } catch (loadError) {
                errorLog('BroadcastChannel フォールバック読み込みもエラー:', loadError);
              }
              // Show info modal even on error
              this.showInfoModal();
            }
          } else if (event.data && event.data.type === 'FORM_CREATED') {
            // フォームが作成された時のフォームリンク更新（BroadcastChannel）
            try {
              const formLinkBtn = document.getElementById('form-link-btn');
              if (formLinkBtn && event.data.formUrl) {
                formLinkBtn.href = event.data.formUrl;
                formLinkBtn.classList.remove('hidden');
              }
            } catch (error) {
              warnLog('BroadcastChannel フォームリンク更新でエラー:', error);
            }
          }
        });
      }
      
    } catch (error) {
      errorLog('❌ StudyQuestApp: Critical error in init():', error);
      this.displayInitializationError('アプリケーションの初期化中にエラーが発生しました: ' + error.message);
      
      // Clear timeout on error
      if (this.initTimeoutId) {
        clearTimeout(this.initTimeoutId);
        this.initTimeoutId = null;
      }
      
      // Hide loading overlay on error
      this.hideLoadingOverlay();
      return; // Exit early on initialization failure
    }
  }
  setupCriticalElements() {
    if (this.elements.headingLabel) {
      // 問題文を常に表示（読み込み中は表示しない）
      const opinionHeader = __OPINION_HEADER__.startsWith('<') || __OPINION_HEADER__.includes('読み込み')
        ? '質問'  // デフォルトテキスト
        : window.sharedUtilities.security.escapeHtml(__OPINION_HEADER__);
      this.elements.headingLabel.textContent = opinionHeader;
    }

    // Only setup absolutely critical event listeners
    this.setupEventDelegation();
    this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    // Size slider for immediate response with throttling
    const debouncedRender = this.debounce(() => this.renderBoard(true, false), 200);
    this.handlers.onSizeSliderInput = this.throttle((e) => {
      localStorage.setItem('boardColumns', e.target.value);
      debouncedRender();
    }, 100); // Throttle to 100ms
    
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, { passive: true });
    }
  }
  
  setupNonCriticalEventListeners() {
    // 重複登録防止
    if (this.nonCriticalListenersSetup) {
      // Non-critical event listeners already set up
      return;
    }
    
    // answersContainer のクリックリスナーは setupEventDelegation() で登録済み
    
    // Modal handlers
    this.handlers.onAnswerModalContainerClick = (e) => {
      if (e.target === e.currentTarget) {
        this.hideAnswerModal();
      }
    };
    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn) {
      this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
      this.elements.infoModalConfirmBtn.addEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    this.handlers.onModalReactionClick = (e) => {
      const btn = e.target.closest('.reaction-btn');
      const highlightBtn = e.target.closest('.highlight-btn');
      
      if (highlightBtn) {
        const id = highlightBtn.dataset.rowIndex;
        if (id) {
          this.handleHighlight(id);
        }
      } else if (btn) {
        const id = btn.dataset.rowIndex;
        const reaction = btn.dataset.reaction;
        if (id && reaction) {
          this.handleReaction(id, reaction);
        }
      }
    };
    if (this.elements.modalReactionContainer) {
      this.elements.modalReactionContainer.addEventListener('click', this.handlers.onModalReactionClick);
    }
    this.handlers.onClassFilterChange = async () => {
      this.dismissNewContentBanner(); // フィルター変更時は既存の通知を消去
      try {
        await this.loadSheetData({ bypassCache: true });
        this.updateLastSeenCount(this.state.currentAnswers.length); // 新しいベースラインを設定
      } catch (error) {
        errorLog('クラスフィルター変更時のデータ読み込みエラー:', error);
      }
    };
    this.handlers.onSortOrderChange = async () => {
      this.dismissNewContentBanner(); // ソート変更時は既存の通知を消去
      try {
        await this.loadSheetData({ bypassCache: true });
        this.updateLastSeenCount(this.state.currentAnswers.length); // 新しいベースラインを設定
      } catch (error) {
        errorLog('ソート順変更時のデータ読み込みエラー:', error);
      }
    };
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.endPublicationBtn) {
      this.handlers.onEndPublicationClick = () => this.endPublication();
      this.elements.endPublicationBtn.addEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.adminToggleBtn) {
      this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
      this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
    }
    
    // 新着通知バナーのイベントハンドラー
    if (this.elements.refreshContentBtn) {
      this.handlers.onRefreshContentClick = async () => {
        try {
          await this.refreshContent();
        } catch (error) {
          errorLog('コンテンツ更新エラー:', error);
        }
      };
      this.elements.refreshContentBtn.addEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn) {
      this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
      this.elements.dismissBannerBtn.addEventListener('click', this.handlers.onDismissBannerClick);
    }
    this.handlers.onDocumentKeydown = (e) => {
      if (e.key === 'Escape') {
        this.hideAnswerModal();
      }
    };
    document.addEventListener('keydown', this.handlers.onDocumentKeydown);
    this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
    window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
    this.handlers.onVisibilityChange = () => {
      if (document.hidden) {
        this.stopNewAnswerPolling();
        // Cleanup when page is hidden
        this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
      } else {
        this.startNewAnswerPolling();
      }
    };
    document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, { passive: true });
    
    this.nonCriticalListenersSetup = true;
    // Non-critical event listener setup complete
  }
  /**
 * イベント委譲の設定（安定版の堅牢なロジックを採用）
 * これにより、クリックイベントが他のイベントと競合しなくなります。
 */
  setupEventDelegation() {
    // 重複登録防止
    if (this.eventDelegationSetup) {
        // Event delegation already set up
        return;
    }
    
    this.handlers.onAnswersContainerClick = (e) => {
        const answerCard = e.target.closest('.answer-card');

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
            return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
            return;
        }

        // リアクションボタンのクリックを処理
        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
            e.stopPropagation(); // ★重要: イベントの伝播を止め、カード本体のクリックと分離
            if (!reactionBtn.disabled) {
                this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
            }
            return;
        }

        // ハイライトボタンのクリックを処理
        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
            e.stopPropagation(); // ★重要: 同様にイベントの伝播を停止
            if (!highlightBtn.disabled) {
                this.handleHighlight(rowIndex);
            }
            return;
        }

        // 上記以外の場合は、カード本体のクリックとしてモーダルを表示
        this.showAnswerModal(rowIndex);
    };

    if (this.elements.answersContainer) {
        // 既存のリスナーをクリアしてから追加
        this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
        this.elements.answersContainer.addEventListener('click', this.handlers.onAnswersContainerClick);
        this.eventDelegationSetup = true;
    } else {
        errorLog('No answers container found for event delegation');
    }
  }
  
  // Layout adjustment functionality
  adjustLayout() {
    if (this.baseBodyPadding === undefined) {
      this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
    }
    const footerHeight = this.elements.footer.offsetHeight;
    this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
  }
  runGas(funcName, ...args) {
    // 直接呼び出し（マッピング層なし）
    const mappedArgs = args;

    // Simple request deduplication for identical calls (except for state-changing operations)
    const cacheKey = funcName + JSON.stringify(mappedArgs);
    const isStateChanging = ['dsToggleHighlight', 'dsAddReaction'].includes(funcName);

    if (!isStateChanging) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }
    }

    // Enhanced GAS API call with retry support
    return this.executeWithRetry(async () => {
      return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        // API関数存在チェック
        if (!google.script.run[funcName] || typeof google.script.run[funcName] !== 'function') {
          reject(new Error(`API function '${funcName}' not available`));
          return;
        }

        google.script.run
          .withSuccessHandler((result) => {
            if (!isStateChanging) {
              this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
            }
            resolve(result);
          })
          .withFailureHandler((error) => {
            errorLog('GAS APIエラー受信:', { funcName, originalArgs: args, mappedArgs, error, success: false });
            reject(this.enhanceError(error, funcName, args));
          })
          .withUserObject({ userId: this.state.userId })
          [funcName](...mappedArgs);
      } else {
        warnLog('Google Apps Script environment not detected.');
        this.getMockData(funcName, ...mappedArgs).then((result) => {
          if (!isStateChanging) {
            this.cache.set(cacheKey, result, StudyQuestApp.CONSTANTS.CACHE_TTL_MS);
          }
          resolve(result);
        }).catch(reject);
      }
      });
    }, {
      maxRetries: isStateChanging ? 1 : 2, // State-changing operations get fewer retries
      baseDelay: 500,
      context: `GAS API (${funcName})`,
      retryCondition: (error) => {
        const retryableErrors = [
          'network', 'timeout', 'temporarily unavailable',
          'script runtime', 'service invoked'
        ];
        return retryableErrors.some(errorType =>
          error.message.toLowerCase().includes(errorType)
        );
      }
    });
  }

  // エラー情報強化
  enhanceError(error, funcName, args) {
    const enhancedError = new Error(error.message || error);
    enhancedError.originalError = error;
    enhancedError.functionName = funcName;
    enhancedError.arguments = args;

    // 関数固有のエラーメッセージ
    switch (funcName) {
      case 'dsAddReaction':
        enhancedError.userMessage = 'リアクションの送信に失敗しました。しばらく待ってから再度お試しください。';
        break;
      case 'dsToggleHighlight':
        enhancedError.userMessage = 'ハイライトの切り替えに失敗しました。しばらく待ってから再度お試しください。';
        break;
      default:
        enhancedError.userMessage = 'サーバーとの通信に失敗しました。しばらく待ってから再度お試しください。';
    }

    return enhancedError;
  }
  async verifyAdminAsync() {
    // Use server-provided flag first (fast)
    if (window.isAdminUser) {
      this.state.isAdminUser = true;
      this.state.showHighlightToggle = true; // 管理者なら常に表示
      // Admin permissions verified
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      return;
    }
    
    // Fallback API call (slower)
    let prevState;
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (isAdmin) {
        window.isAdminUser = true;
        this.state.isAdminUser = true;
        this.state.showHighlightToggle = true; // 管理者なら常に表示
        // API admin permissions verified
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
      }
    } catch (e) {
      errorLog('Admin check failed', e);
    }
  }
  
  // 管理者UI更新の共通メソッド
  updateAdminButtonUI() {
    // Only show admin toggle button for administrators, never for viewers
    if (this.elements.adminToggleBtn && this.state.isAdminUser) {
      // Show button for admin users only
      this.elements.adminToggleBtn.classList.remove('hidden');
      this.elements.adminToggleBtn.removeAttribute('hidden');
      
      // Always show "管理モード" text, never show "閲覧モード" to avoid confusion
      this.elements.adminToggleBtn.textContent = '管理モード';
      
      // Apply styling based on current admin mode state
      if (this.state.showAdminFeatures) {
        // Active admin mode: highlighted styling
        this.elements.adminToggleBtn.classList.remove('text-gray-500', 'opacity-60');
        this.elements.adminToggleBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
      } else {
        // Inactive admin mode: subtle gray styling
        this.elements.adminToggleBtn.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-cyan-400/50');
        this.elements.adminToggleBtn.classList.add('text-gray-500', 'opacity-60');
      }
    } else {
      // Hide button for non-admin users
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.add('hidden');
        this.elements.adminToggleBtn.setAttribute('hidden', '');
      }
    }
  }
  
  updateEndPublicationButtonUI() {
    if (this.elements.endPublicationBtn) {
      if (this.state.showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', '');
      }
    }
  }
  
  // サーバー管理者権限確認の共通メソッド
  async checkServerAdminPermission() {
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (!isAdmin) {
        throw new Error('サーバー側で管理者権限が確認できませんでした');
      }
      return true;
    } catch (error) {
      errorLog('管理者権限確認エラー:', error);
      throw error;
    }
  }
  
  async checkForNewContentLight(bypassCache = false) {
    // ポーリング実行中の場合は重複実行を防ぐ
    if (this.contentCheckInProgress) {
      return;
    }
    
    try {
      this.contentCheckInProgress = true;
      
      // 基本状態の検証
      if (!this.validateContentCheckPrerequisites()) {
        return;
      }
      
      // パラメータの準備
      const { selectedClass, sortOrder } = this.prepareContentCheckParams();
      
      // キャッシュクリア（必要な場合）
      if (bypassCache) {
        await this.clearCacheForContentCheck();
      }
      
      // サーバーから件数を取得
      const countData = await this.fetchContentCount(selectedClass, sortOrder);
      
      // レスポンスの処理
      await this.processContentCountResponse(countData, selectedClass, sortOrder);
      
    } catch (error) {
      await this.handleContentCheckError(error);
    } finally {
      this.contentCheckInProgress = false;
    }
  }
  
  validateContentCheckPrerequisites() {
    // 必要な要素の存在確認
    if (!this.elements.classFilter || !this.elements.sortOrder) {
      warnLog('Required UI elements not available for content check');
      return false;
    }
    
    // 初期化状態の確認
    if (!this.state.userId) {
      warnLog('User ID not available for content check');
      return false;
    }
    
    return true;
  }
  
  prepareContentCheckParams() {
    let selectedClass = this.elements.classFilter.value || 'すべて';
    if (!selectedClass.trim()) {
      selectedClass = 'すべて';
    }
    
    // 「すべて」の場合はnullに変換してサーバーに送信
    const classFilter = !selectedClass || selectedClass === 'すべて'
      ? null
      : selectedClass;
    const sortOrder = this.elements.sortOrder.value || 'newest';
    
    return { selectedClass, classFilter, sortOrder };
  }
  
  async clearCacheForContentCheck() {
    try {
      await this.gas.clearCache();
    } catch (error) {
      warnLog('⚠️ Failed to clear cache:', error.message);
      // Continue without cache clearing
    }
  }
  
  async fetchContentCount(selectedClass, sortOrder) {
    const countData = await this.gas.getDataCount(
      selectedClass, 
      sortOrder, 
      this.state.showAdminFeatures
    );
    
    if (!countData) {
      throw new Error('No response from server for content count');
    }
    
    return countData;
  }
  
  async processContentCountResponse(countData, selectedClass, sortOrder) {
    const newCount = countData.count || 0;
    const currentCount = this.state.currentAnswers?.length || 0;
    const lastSeen = this.state.lastSeenCount || 0;
    
    // Enhanced consistency verification (Phase 3.1)
    const consistencyCheck = {
      lightCheckCount: newCount,
      currentDataCount: currentCount,
      lastSeenCount: lastSeen,
      hasInconsistency: Math.abs(newCount - currentCount) > 0 && currentCount > 0,
      significantChange: newCount !== lastSeen
    };
    
    
    // ポーリング成功のマーク - unified state management (Phase 2.3)
    this.state.pollingFailureCount = 0;
    
    // 現在のビューキー
    const currentViewKey = `${selectedClass}-${sortOrder}`;
    
    // 初回データロード完了の処理
    if (!this.initialDataLoaded) {
      await this.handleInitialContentLoad(currentViewKey, newCount);
      return;
    }
    
    // ビュー設定変更の処理
    if (this.lastViewKey !== currentViewKey) {
      await this.handleViewChange(currentViewKey, newCount);
      return;
    }
    
    // 新着コンテンツの検出
    await this.checkForNewItems(newCount);
  }
  
  async handleInitialContentLoad(currentViewKey, newCount) {
    this.lastViewKey = currentViewKey;
    
    // 初期データロード失敗後の初回成功ポーリング時の特別処理
    if (this.hadInitialDataLoadFailure && newCount > this.state.lastSeenCount) {
      debugLog('🔄 初期データロード失敗後の新着検出:', {
        newCount,
        lastSeenCount: this.state.lastSeenCount,
        difference: newCount - this.state.lastSeenCount
      });

      await this.checkForNewItems(newCount);
      return; // データ取得成功まで基準は更新しない
    }

    this.updateLastSeenCount(newCount);
    this.initialDataLoaded = true;
    
  }
  
  async handleViewChange(currentViewKey, newCount) {
    debugLog('🔄 View settings changed:', {
      from: this.lastViewKey,
      to: currentViewKey,
      newCount
    });
    
    this.lastViewKey = currentViewKey;
    this.updateLastSeenCount(newCount);
    this.dismissNewContentBanner();
  }
  
  async checkForNewItems(newCount) {
    const currentCount = this.state.currentAnswers?.length || 0;
    const lastSeen = this.state.lastSeenCount || 0;
    
    // Enhanced new item detection with consistency validation (Phase 3.1)
    const detectionMetrics = {
      lightCheckCount: newCount,
      currentDataCount: currentCount,
      lastSeenCount: lastSeen,
      expectedNewItems: newCount - lastSeen,
      hasNewItems: newCount > lastSeen,
      dataIsStale: currentCount > 0 && newCount > currentCount
    };
    
    debugLog('📢 Enhanced new content detection (Phase 3.1):', detectionMetrics);
    
    if (detectionMetrics.hasNewItems && detectionMetrics.expectedNewItems > 0) {
      const newItems = detectionMetrics.expectedNewItems;
      
      // 新着通知バナーを表示
      this.showNewContentBanner(newItems);
    }
  }
  
  // 自動リフレッシュ機能は無効化 - 新着時は常に通知バナー表示
  shouldAutoRefresh(newItems) {
    return false;
  }
  
  async handleContentCheckError(error) {
    this.state.pollingFailureCount++;
    
    warnLog('❌ Content check failed:', {
      error: error.message,
      failureCount: this.state.pollingFailureCount
    });
    
    // 連続失敗時の対処
    if (this.state.pollingFailureCount >= 3) {
      debugLog('⏳ Too many polling failures, extending interval...');
      await this.handlePollingFailures();
    }
  }
  
  async handlePollingFailures() {
    this.stopNewAnswerPolling();
    
    // 5秒後にポーリング再開
    setTimeout(() => {
      this.startNewAnswerPolling();
      this.state.pollingFailureCount = 0;
    }, 5000);
  }
  
  // 新着通知バナーを表示
  showNewContentBanner(newItems) {
    if (!this.elements.newContentBanner) return;
    
    // デバウンス：短時間内の連続通知を防ぐ
    const now = Date.now();
    if (this.lastNotificationTime && (now - this.lastNotificationTime) < 2000) {
      return;
    }
    this.lastNotificationTime = now;
    
    // 既に表示されている場合は、新しい数で上書き（累積しない）
    if (!this.elements.newContentBanner.classList.contains('hidden')) {
      debugLog('📱 通知更新: 既存バナーを新しい数で更新', {
        oldCount: this.state.newContentCount,
        newCount: newItems
      });
      this.state.newContentCount = newItems; // 累積せず上書き
    } else {
      this.state.newContentCount = newItems;
    }
    
    this.state.hasNewContent = true;
    
    const message = this.state.newContentCount === 1 ? 
      '新しい意見が投稿されました' : 
      `${this.state.newContentCount}件の新しい意見が投稿されました`;
    this.elements.newContentText.textContent = message;
    
    this.elements.newContentBanner.classList.remove('hidden');
    
    // アニメーションをリセットしてから適用
    this.elements.newContentBanner.style.animation = '';
    
    // 3秒後にバウンスアニメーション
    setTimeout(() => {
      if (!this.elements.newContentBanner.classList.contains('hidden')) {
        this.elements.newContentBanner.style.animation = 'bounce 1s ease-in-out';
      }
    }, 3000);
    
    debugLog('📢 新着通知表示:', {
      count: this.state.newContentCount,
      message: message
    });
  }
  
  // 新着バナーを閉じる
  dismissNewContentBanner() {
    if (!this.elements.newContentBanner) return;
    
    this.elements.newContentBanner.classList.add('hidden');
    this.elements.newContentBanner.style.animation = '';
    this.state.hasNewContent = false;
    this.state.newContentCount = 0;
  }
  
  // コンテンツ更新（通知バナーからの呼び出し）
  async refreshContent() {
    try {
      // まず増分更新を試行
      await this.refreshContentIncremental();
    } catch (error) {
      errorLog('コンテンツ更新エラー:', error);
      // 増分更新が失敗した場合はフル更新にフォールバック
      await this.refreshContentFull();
    }
  }
  
  // 増分コンテンツ更新（新しいカードのみ取得・追加）
  async refreshContentIncremental() {
    this.dismissNewContentBanner();
    
    try {
      const originalText = this.elements.refreshContentBtn ? this.elements.refreshContentBtn.textContent : '';
      if (this.elements.refreshContentBtn) {
        this.elements.refreshContentBtn.textContent = '更新中...';
        this.elements.refreshContentBtn.disabled = true;
      }
      
      
      // 現在のフィルタ設定を取得
      const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
      const classFilter = !selectedClass || selectedClass === 'すべて'
        ? null
        : selectedClass;
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
      const adminMode = this.state.showAdminFeatures;
      
      
      // 増分データを取得
      const incrementalData = await this.gas.getIncrementalSheetData(
        classFilter, 
        sortOrder, 
        adminMode, 
        this.state.lastSeenCount || 0
      );
      
      debugLog(`Incremental data: ${incrementalData.newCount} new/${incrementalData.totalCount} total`);
      
      if (incrementalData.status === 'error') {
        throw new Error(incrementalData.message);
      }
      
      // Enhanced incremental data analysis (Phase 3.2) - 改善版
      const preUpdateAnalysis = {
        newCount: incrementalData.newCount,
        totalCount: incrementalData.totalCount,
        hasNewData: incrementalData.newCount > 0,
        lastSeenCount: this.state.lastSeenCount,
        serverExpectedCount: incrementalData.totalCount,
        serverNewItems: incrementalData.newCount
      };
      
      
      // サーバーベースの一貫性チェック（DOM更新前の最小限チェック）
      const criticalInconsistency = {
        zeroStateWithServerData: preUpdateAnalysis.totalCount > 0 && 
                                this.state.currentAnswers.length === 0 && 
                                this.state.lastSeenCount > 0,
        significantCountMismatch: Math.abs(preUpdateAnalysis.totalCount - this.state.lastSeenCount) > 10
      };
      
      // 重大な不整合のみフルリフレッシュ（false positiveを削減）
      if (criticalInconsistency.zeroStateWithServerData || 
          criticalInconsistency.significantCountMismatch) {
        warnLog('🚨 重大なサーバー・クライアント不整合検出 - フルリフレッシュ実行:', {
          preUpdateAnalysis,
          criticalInconsistency,
          currentAnswersLength: this.state.currentAnswers.length
        });
        
        // 重大な不整合の場合のみ全体リフレッシュを実行
        await this.refreshContentFull();
        return;
      }
      
      // 新しいデータがない場合
      if (incrementalData.newCount === 0) {
        this.provideFeedback('最新の状態です', 'info');
        // Use unified state management even for no-data updates (Phase 2.3)
        this.synchronizeStateAfterDataUpdate(this.state.currentAnswers, 'incrementalRefresh-noNewData');
        return;
      }
      
      // Prepare merged data with proper ordering (Phase 3.2)
      let mergedData;
      if (sortOrder === 'newest') {
        mergedData = incrementalData.data.concat(this.state.currentAnswers);
      } else {
        mergedData = this.state.currentAnswers.concat(incrementalData.data);
      }
      
      // First: DOM update with new cards
      await this.appendNewCards(incrementalData.data, sortOrder);

      // Second: Unified state synchronization (Phase 2.3 + 3.2)
      this.synchronizeStateAfterDataUpdate(mergedData, 'incrementalRefresh');

      // Third: Clear server cache for consistency across sort orders
      this.gas.clearCache().catch(err => warnLog('Cache clear failed', err));
      
      debugLog('✅ 増分リフレッシュ完了:', {
        addedCards: incrementalData.newCount,
        totalCards: this.state.currentAnswers.length,
        newBaseline: this.state.lastSeenCount
      });
      
      this.provideFeedback(`${incrementalData.newCount}件の新しい投稿を追加しました`, 'success');
      
    } catch (error) {
      errorLog('増分コンテンツ更新に失敗:', error);
      
      // エラー時は従来の全体更新にフォールバック
      await this.refreshContentFull();
      
    } finally {
      // ボタンを元に戻す
      if (this.elements.refreshContentBtn) {
        this.elements.refreshContentBtn.textContent = this.elements.refreshContentBtn.textContent.includes('更新中') ? 
          (originalText || '更新して表示') : this.elements.refreshContentBtn.textContent;
        this.elements.refreshContentBtn.disabled = false;
      }
    }
  }
  
  // 全体コンテンツ更新（従来の方法）
  async refreshContentFull() {
    try {
      // lastSeenCountを保持（安定化のため）
      const preservedLastSeenCount = this.state.lastSeenCount;
      
      // 従来の手動リフレッシュ時はキャッシュをクリアして最新データを取得
      this.cache.clear();
      
      await this.loadSheetData({ bypassCache: true });
      
      // 手動リフレッシュ後の新着チェック基準更新戦略（改善版）
      const currentDataLength = this.state.currentAnswers.length;
      const shouldUpdateLastSeen = currentDataLength > preservedLastSeenCount;
      
      if (shouldUpdateLastSeen) {
        // データが増加している場合のみ更新
        this.updateLastSeenCount(currentDataLength);
        debugLog('🔄 全体リフレッシュ完了、新着基準更新（データ増加）:', {
          newLastSeenCount: this.state.lastSeenCount,
          preservedCount: preservedLastSeenCount,
          currentAnswersLength: currentDataLength
        });
      } else if (currentDataLength === 0 && preservedLastSeenCount > 0) {
        // データが0件で以前に見たカードがある場合は、最小値として1を保持
        this.state.lastSeenCount = Math.max(1, preservedLastSeenCount);
        debugLog('🔄 全体リフレッシュ完了、新着基準保持（データ0件時の安定化）:', {
          adjustedLastSeenCount: this.state.lastSeenCount,
          preservedCount: preservedLastSeenCount,
          currentAnswersLength: currentDataLength
        });
      } else {
        // データが減少または同じ場合は保持
        this.state.lastSeenCount = preservedLastSeenCount;
        debugLog('🔄 全体リフレッシュ完了、新着基準保持（データ不変）:', {
          preservedLastSeenCount: preservedLastSeenCount,
          currentAnswersLength: currentDataLength,
          maintainedStability: true
        });
      }
      
      this.provideFeedback('更新完了！', 'success');
      
    } catch (error) {
      errorLog('全体コンテンツ更新に失敗:', error);
      this.provideFeedback('更新失敗', 'error');
      throw error;
    }
  }

  // Dynamic polling interval adjustment based on activity
  adjustPollingInterval(hasNewContent = false) {
    const settings = this.pollingSettings;
    
    if (hasNewContent) {
      // 新着コンテンツがある場合は間隔を短くして活性化
      settings.activityScore = Math.min(settings.activityScore + 10, 100);
      settings.currentInterval = Math.max(
        settings.minInterval,
        settings.baseInterval - (settings.activityScore * 150) // 最大15秒短縮
      );
    } else {
      // 新着コンテンツがない場合は徐々に間隔を長くして負荷軽減
      settings.activityScore = Math.max(settings.activityScore - 5, 0);
      settings.currentInterval = Math.min(
        settings.maxInterval,
        settings.baseInterval + (settings.activityScore * 900) // 最大90秒延長
      );
    }
  }

  // 新着回答のポーリング開始 (最適化版)
  startNewAnswerPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }

    this.pollingInterval = setInterval(async () => {
      if (!this.pollingSettings.enabled) return;

      try {
        const hasNewContent = await this.checkForNewAnswers();
        this.pollingSettings.currentRetries = 0;
        this.pollingSettings.successCount++;
        
        // 動的間隔調整
        this.adjustPollingInterval(hasNewContent);
        
        // 間隔が変更された場合はポーリングを再開
        if (this.pollingSettings.currentInterval !== this.pollingSettings.interval) {
          this.pollingSettings.interval = this.pollingSettings.currentInterval;
          this.startNewAnswerPolling(); // 新しい間隔で再開
          return;
        }
        
      } catch (error) {
        this.pollingSettings.currentRetries++;
        warnLog(`ポーリングエラー (${this.pollingSettings.currentRetries}/${this.pollingSettings.maxRetries}):`, error);
        
        if (this.pollingSettings.currentRetries >= this.pollingSettings.maxRetries) {
          errorLog('ポーリング最大リトライ数に達したため停止');
          this.stopNewAnswerPolling();
        }
      }
    }, this.pollingSettings.currentInterval);
  }

  // 新着回答のポーリング停止
  stopNewAnswerPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }

    if (this.pollingTimeout) {
      clearTimeout(this.pollingTimeout);
      this.pollingTimeout = null;
    }

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    if (this.longRunningCheckInterval) {
      clearInterval(this.longRunningCheckInterval);
      this.longRunningCheckInterval = null;
    }
  }

  // 新着回答の確認
  async checkForNewAnswers() {
    if (this.state.isLoading) return; // 既にロード中の場合は跳ばす

    try {
      const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
      const classFilter = !selectedClass || selectedClass === 'すべて'
        ? null
        : selectedClass;
      const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
      const adminMode = this.state.showAdminFeatures;
      
      
      const incrementalData = await this.gas.getIncrementalSheetData(
        classFilter,
        sortOrder,
        adminMode,
        this.state.lastSeenCount || 0
      );

      debugLog('📡 getIncrementalSheetData response:', incrementalData);

      // Handle empty response or malformed data
      if (!incrementalData || typeof incrementalData !== 'object') {
        throw new Error('Invalid response from server: empty or malformed data');
      }

      // Handle empty object specifically
      if (Object.keys(incrementalData).length === 0) {
        throw new Error('Server returned empty object - API call may have failed');
      }

      if (incrementalData.status === 'error' || incrementalData.success === false) {
        throw new Error(incrementalData.message || incrementalData.error || 'Unknown polling error');
      }
      
      // 新着データがある場合
      if (incrementalData.newCount > 0) {
        debugLog('🆕 新着回答検出:', {
          newCount: incrementalData.newCount,
          totalCount: incrementalData.totalCount
        });
        
        this.state.hasNewContent = true;
        this.state.newContentCount = incrementalData.newCount;
        this.showNewContentBanner(incrementalData.newCount);
      }
      
    } catch (error) {
      // Reduce noise for network errors during polling
      if (error.message.includes('empty object') || error.message.includes('NetworkError')) {
        debugLog('📡 ポーリングエラー (一時的):', error.message);
      } else {
        errorLog('新着確認エラー:', error);
      }
      throw error;
    }
  }
  
  // 重複定義のため削除 - 1498行目の定義を使用
  
  // 新しいカードを既存のカードコンテナに追加
  async appendNewCards(newData, sortOrder = 'newest') {
    if (!newData || newData.length === 0) return;


    const container = this.elements.answersContainer;
    if (!container) return;

    this.removeEmptyState();
    
    // 新しいカードを作成してコンテナに追加
    const fragment = document.createDocumentFragment();
    const addedCardIds = [];
    
    for (const data of newData) {
      const cardElement = this.createAnswerCard(data);
      if (cardElement) {
        // 差分追加カードとしてマーク
        cardElement.setAttribute('data-differential-card', 'true');
        cardElement.setAttribute('data-added-timestamp', Date.now().toString());
        
        // 新しいカードであることを示すアニメーション
        cardElement.style.opacity = '0';
        cardElement.style.transform = 'translateY(20px)';
        fragment.appendChild(cardElement);
        
        // 追加されたカードのIDを記録
        if (data.rowIndex !== undefined) {
          addedCardIds.push(data.rowIndex);
        }
      }
    }
    
    // 差分追加カードのIDをローカルストレージに保存
    if (addedCardIds.length > 0) {
      this.saveDifferentialCards(addedCardIds);
    }
    
    if (sortOrder === 'newest') {
      container.prepend(fragment);
    } else {
      container.appendChild(fragment);
    }
    
    // アニメーションで新しいカードを表示
    await new Promise(resolve => {
      requestAnimationFrame(() => {
        const newCards = container.querySelectorAll('.answer-card[style*="opacity: 0"]');
        newCards.forEach((card, index) => {
          setTimeout(() => {
            card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, index * 100); // 100msずつ遅延して順次表示
        });
        
        // 全てのアニメーションが完了するまで待機
        setTimeout(resolve, newCards.length * 100 + 300);
      });
    });
  }
  
  // ユーザーフィードバック表示
  provideFeedback(message, type = 'info') {
    if (!this.elements.refreshContentBtn) return;
    
    const originalText = this.elements.refreshContentBtn.textContent;
    const originalBackground = this.elements.refreshContentBtn.style.background;
    
    this.elements.refreshContentBtn.textContent = message;
    
    switch (type) {
      case 'success':
        this.elements.refreshContentBtn.style.background = 'rgba(16, 185, 129, 0.3)';
        break;
      case 'error':
        this.elements.refreshContentBtn.style.background = 'rgba(239, 68, 68, 0.3)';
        break;
      case 'info':
        this.elements.refreshContentBtn.style.background = 'rgba(59, 130, 246, 0.3)';
        break;
    }
    
    setTimeout(() => {
      this.elements.refreshContentBtn.textContent = originalText;
      this.elements.refreshContentBtn.style.background = originalBackground;
    }, 2000);
  }
  
  getMockData(funcName, ...args) {
    return new Promise((resolve) => {
      setTimeout(() => {
        if (funcName === 'getPublishedSheetData') {
          const currentDisplayMode = window.displayMode || this.state.displayMode;
          const studentName1 = currentDisplayMode === 'named' ? '田中太郎' : '';
          const studentName2 = currentDisplayMode === 'named' ? '佐藤花子' : '';
          resolve({
            header: 'テスト問題',
            sheetName: 'テストシート',
            data: [
              {
                rowIndex: 1,
                name: studentName1,
                class: '3年A組',
                opinion: 'これは素晴らしいアイデアだと思います。',
                reason: '理由は簡潔で分かりやすく、実現可能性が高いからです。',
                reactions: {
                  UNDERSTAND: { count: 5, reacted: false },
                  LIKE: { count: 2, reacted: false },
                  CURIOUS: { count: 1, reacted: false }
                },
                highlight: false
              },
              {
                rowIndex: 2,
                name: studentName2,
                class: '3年B組',
                opinion: '少し改善の余地があると考えます。',
                reason: 'より多くの人の意見を聞く必要があると思います。',
                reactions: {
                  UNDERSTAND: { count: 3, reacted: true },
                  LIKE: { count: 0, reacted: false },
                  CURIOUS: { count: 0, reacted: false }
                },
                highlight: true
              }
            ]
          });
        } else if (funcName === 'addReaction' || funcName === 'dsAddReaction') {
          resolve({
            status: 'ok',
            reactions: {
              UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
            }
          });
        } else if (funcName === 'toggleHighlight' || funcName === 'dsToggleHighlight') {
          const currentHighlight = args[2] === undefined ? false : !args[2];
          resolve({
            status: 'ok',
            highlight: currentHighlight
          });
        } else if (funcName === 'checkAdmin' || funcName === 'isAdmin') {
          resolve(true);
        }
      }, 300);
    });
  }
  // メモリ管理とクリーンアップ
  performMemoryCleanup() {
    try {
      
      // キャッシュクリーンアップ
      if (this.cache) {
        const cacheSize = this.cache.size();
        this.cache.cleanup();
      }
      
      // 古いDOM要素の参照をクリア
      this.cleanupDOMReferences();
      
      // イベントリスナーの整理
      this.cleanupEventListeners();
      
      // 仮想スクロール状態の最適化
      this.optimizeVirtualScrollState();
      
    } catch (error) {
      warnLog('⚠️ Memory cleanup failed:', error);
    }
  }
  
  cleanupDOMReferences() {
    // 削除されたDOM要素への参照をクリア
    const elementsToCheck = ['answersContainer', 'loadingOverlay', 'newContentBanner'];
    elementsToCheck.forEach(key => {
      const element = this.elements[key];
      if (element && !document.contains(element)) {
        delete this.elements[key];
      }
    });
  }
  
  cleanupEventListeners() {
    // 重複したイベントリスナーの確認とクリーンアップ
    if (this.handlers) {
      Object.keys(this.handlers).forEach(key => {
        if (typeof this.handlers[key] !== 'function') {
          delete this.handlers[key];
        }
      });
    }
  }
  
  optimizeVirtualScrollState() {
    // 仮想スクロール状態の最適化
    if (this.virtualScrollState && this.virtualScrollState.renderedRowIndexes) {
      const size = this.virtualScrollState.renderedRowIndexes.size;
      if (size > 1000) { // 大量のインデックスが蓄積されている場合
        this.virtualScrollState.renderedRowIndexes.clear();
        this.virtualScrollState.renderedItems = 0;
      }
    }
  }
  
  
  showWarningMessage(message) {
    // 警告メッセージを表示（既存のshowErrorMessageを参考に）
    const warningDiv = document.createElement('div');
    warningDiv.className = 'fixed top-4 right-4 z-50 bg-yellow-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md border-l-4 border-yellow-400';
    warningDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13 4c-.77-.833-1.964-.833-2.732 0L3 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
        </svg>
        <span class="text-sm">${window.sharedUtilities.security.escapeHtml(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 hover:bg-yellow-700 rounded p-1">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    `;
    
    document.body.appendChild(warningDiv);
    
    // 10秒後に自動削除
    setTimeout(() => {
      if (warningDiv.parentNode) {
        warningDiv.parentNode.removeChild(warningDiv);
      }
    }, 10000);
  }

  destroy() {
    
    // ポーリング停止（改善版）
    this.stopNewAnswerPolling();
    
    // 動的間隔調整の設定をリセット
    if (this.pollingSettings) {
      this.pollingSettings.enabled = false;
      this.pollingSettings.activityScore = 0;
      this.pollingSettings.currentInterval = this.pollingSettings.baseInterval;
    }
    
    // 既存のクリーンアップ
    this.cleanup();
    
    // イベントリスナーの削除（既存）
    if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
      this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
    }
    if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
      this.elements.answerModalCloseBtn.removeEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
      this.elements.answerModalContainer.removeEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
      this.elements.infoModalConfirmBtn.removeEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
      this.elements.modalReactionContainer.removeEventListener('click', this.handlers.onModalReactionClick);
    }
    if (this.elements.classFilter && this.handlers.onClassFilterChange) {
      this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
      this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
      this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
    }
    if (this.handlers.onDocumentKeydown) {
      document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
    }
    if (this.handlers.onWindowResize) {
      window.removeEventListener('resize', this.handlers.onWindowResize);
    }
    if (this.handlers.onVisibilityChange) {
      document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
    }
    if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
      this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
    }
    if (this.handlers.onDocumentClick) {
      document.removeEventListener('click', this.handlers.onDocumentClick);
    }
    // Cleanup observers
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    // Cancel any pending callbacks
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    // 漏れていたイベントリスナーの削除
    if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
      this.elements.refreshContentBtn.removeEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
      this.elements.dismissBannerBtn.removeEventListener('click', this.handlers.onDismissBannerClick);
    }
    if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
      this.elements.endPublicationBtn.removeEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.sheetSelector && this.handlers.onSheetSelectorChange) {
      this.elements.sheetSelector.removeEventListener('change', this.handlers.onSheetSelectorChange);
    }
    
    // イベントリスナー設定フラグのリセット
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    
    // Clear caches
    this.cache.clear();
    this.deferredUpdates.clear();
    this.domFragmentPool.length = 0;
    
  }

  /**
   * Validate essential prerequisites for app initialization
   * @returns {boolean} true if all prerequisites are met
   */
  validatePrerequisites() {
    const checks = [
      { name: 'userId', value: this.state.userId, required: false }, // 緩和: userIdは必須ではない
      { name: 'answersContainer', value: this.elements.answersContainer, required: true },
      { name: 'sheetName', value: this.state.sheetName, required: false },
      { name: 'google.script.run', value: typeof google !== 'undefined' && google.script && google.script.run, required: true }
    ];

    let criticalIssues = 0;

    checks.forEach(check => {
      const isValid = !!check.value;
      const status = isValid ? '✅' : (check.required ? '❌' : '⚠️');
      const statusText = isValid ? 'OK' : (check.required ? 'MISSING' : 'OPTIONAL');
      debugLog(`  ${status} ${check.name}: ${check.required ? 'required' : 'optional'} - ${statusText}`);

      if (check.required && !isValid) {
        criticalIssues++;
      }
    });

    // 重大な問題のみチェック（DOM要素とGAS API利用可能性）
    return criticalIssues === 0;
  }

  /**
   * 制限機能モードを有効化
   */
  enableLimitedFunctionalityMode() {
    this.isLimitedMode = true;

    // 基本的なUI表示
    if (this.elements.answersContainer) {
      this.elements.answersContainer.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-limited-mode="true">
          <svg class="mx-auto h-12 w-12 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-blue-400">制限機能モード</h3>
          <p class="mt-1 text-sm text-gray-400">一部の機能が制限されています。URLを確認してページを再読み込みしてください。</p>
          <div class="mt-6">
            <button
              onclick="window.location.reload()"
              class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
            >
              ページを再読み込み
            </button>
          </div>
        </div>
      `;
    }

    // タイトル更新
    if (this.elements.headingLabel) {
      this.elements.headingLabel.textContent = '制限機能モード';
    }
  }

  /**
   * Display initialization error to user
   * @param {string} message - Error message to display
   */
  displayInitializationError(message) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">初期化エラー</h3>
        <p class="mt-1 text-sm text-gray-400">${window.sharedUtilities.security.escapeHtml(message)}</p>
        <div class="mt-6">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          >
            ページを再読み込み
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Display data loading error to user
   * @param {string} message - Error message to display
   */
  displayDataLoadError(message) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
        <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-yellow-400">データ読み込みエラー</h3>
        <p class="mt-1 text-sm text-gray-400">${window.sharedUtilities.security.escapeHtml(message)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
          >
            ページを再読み込み
          </button>
          <button 
            onclick="window.studyQuestApp && window.studyQuestApp.loadSheetData({ bypassCache: true, isInitialLoad: true })" 
            class="inline-flex items-center px-4 py-2 border border-blue-600 text-sm font-medium rounded-md text-blue-300 bg-blue-700 hover:bg-blue-600"
          >
            再試行
          </button>
        </div>
      </div>
    `;
  }
  
  showErrorMessage(message, isTemporary = true) {
    // 一時的なエラーメッセージを表示（トースト風）
    const errorDiv = document.createElement('div');
    errorDiv.className = 'fixed top-4 right-4 z-50 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg max-w-md';
    errorDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span class="text-sm">${window.sharedUtilities.security.escapeHtml(message)}</span>
      </div>
    `;
    
    document.body.appendChild(errorDiv);
    
    if (isTemporary) {
      // 5秒後に自動削除
      setTimeout(() => {
        if (errorDiv.parentNode) {
          errorDiv.parentNode.removeChild(errorDiv);
        }
      }, 5000);
    }
    
    return errorDiv;
  }
  
  showMinimalSkeleton() {
    // Show only 3 skeletons for immediate visual feedback
    const count = 3;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      frag.appendChild(this.createSkeletonCard());
    }
    this.elements.answersContainer.appendChild(frag);
  }

  displayEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    // フォームリンクを非同期で取得して表示
    this.getFormUrlForEmptyState().then(formUrl => {
      const formLinkHtml = formUrl ? 
        `<div class="mt-6">
          <a href="${window.sharedUtilities.security.escapeHtml(formUrl)}" target="_blank" 
             class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-pink-600 hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pink-500 transition-colors duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            回答フォームに記入する
          </a>
        </div>` : 
        `<div class="mt-4">
          <p class="text-sm text-gray-500">回答フォームの準備中です...</p>
        </div>`;

      container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">まだ回答がありません</h3>
          <p class="mt-1 text-sm text-gray-400">あなたが最初の回答者になってディスカッションを始めましょう！</p>
          ${formLinkHtml}
        </div>
      `;
    }).catch(error => {
      warnLog('⚠️ フォームURL取得エラー:', error);
      // エラー時はデフォルト表示
      container.innerHTML = `
        <div class="text-center py-16 px-6 col-span-full" data-empty-state="true">
          <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 class="mt-2 text-lg font-medium text-white">まだ回答がありません</h3>
          <p class="mt-1 text-sm text-gray-400">あなたが最初の回答者になってディスカッションを始めましょう！</p>
        </div>
      `;
    });
  }

  /**
   * 空状態表示用のフォームURLを取得 - 簡素化・高速化版
   * @returns {Promise<string|null>} フォームURL
   */
  async getFormUrlForEmptyState() {
    try {
      // getActiveFormInfoを使用してフォーム情報を取得
      const result = await this.runGas('getActiveFormInfo', this.state.userId);

      if (result && result.status === 'success') {
        if (result.formUrl) {
          return result.formUrl;
        }
      }
      
      warnLog('⚠️ フォームURLが見つかりませんでした');
      return null;
      
    } catch (error) {
      errorLog('❌ フォームURL取得エラー:', error);
      return null;
    }
  }

  /**
   * 空状態のバナーを削除します。
   */
  removeEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;

    const banner = container.querySelector('[data-empty-state="true"]');
    if (banner) {
      banner.remove();
    }
  }

  safeDisplayEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    // 既存のカードがあるかチェック
    const existingCards = container.querySelectorAll('.answer-card');
    if (existingCards.length > 0) {
      return; // カードがある場合は空状態を表示しない
    }
    
    // currentAnswersもチェック
    if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
      return; // データがある場合も空状態を表示しない
    }
    
    // ローディング中は表示しない
    if (this.state.isLoading) {
      return;
    }
    
    this.displayEmptyState();
  }
  
  async clearAllCardsForEmptyData() {
    // 真の初回判定: localStorage状態 + DOM状態を確認
    const isFirstTime = this.isFirstTimeBoardAccess();
    
    // currentAnswersを空にリセット
    this.state.currentAnswers = [];
    
    // DOM内の全カードをクリア
    const container = this.elements.answersContainer;
    if (container) {
      const existingCards = container.querySelectorAll('.answer-card');
      
      if (existingCards.length > 0) {
        
        // オブザーバーからカードを解除
        existingCards.forEach(card => {
          if (this.visibilityObserver) {
            this.visibilityObserver.unobserve(card);
          }
          if (this.scrollObserver) {
            this.scrollObserver.unobserve(card);
          }
        });
        
        // DOMをクリア
        container.innerHTML = '';
        
        // DOM clearing completion wait (Phase 1.3)
        await new Promise(resolve => requestAnimationFrame(resolve));
      }
    }
    
    // バーチャルスクロール状態をリセット
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
  }
  
  async validatePostLoadState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const domCards = container.querySelectorAll('.answer-card');
    const dataLength = this.state.currentAnswers ? this.state.currentAnswers.length : 0;
    
    
    // 空データなのにDOMにカードが残っている場合
    if (dataLength === 0 && domCards.length > 0) {
      warnLog('⚠️ 状態不整合検出: 空データなのにDOMに', domCards.length, '個のカードが残っています');
      
      // 空データのためのクリーンアップを実行
      await this.clearAllCardsForEmptyData();
      
      // 空状態を表示
      this.displayEmptyState();
      
      
    } else if (dataLength !== domCards.length) { // 数の不一致も不整合とみなす
      warnLog('⚠️ 状態不整合検出: DOMカード数とデータ数が一致しません。DOM:', domCards.length, 'データ:', dataLength);

      // 不整合がある場合は再レンダリング
      this.renderBoard(false, false);
      
    } else {
    }
    
    // 追加: 設定と表示内容の一致性を検証
    this.validateConfigConsistency();
  }
  
  validateConfigConsistency() {
    // フロントエンドの表示している質問文を取得
    const displayedHeader = this.elements.headingLabel ? this.elements.headingLabel.textContent : '';
    
    // 現在のデータ数とポーリングで取得したカウントを比較
    const currentDataCount = this.state.currentAnswers ? this.state.currentAnswers.length : 0;

    // ポーリング結果と現在のデータ数の不一致を検出
    if (this.lastPollingResult && this.lastPollingResult.newCount !== currentDataCount) {
      warnLog('⚠️ データ不整合検出:', {
        'ポーリングカウント': this.lastPollingResult.newCount,
        '表示データ数': currentDataCount,
        '差分': this.lastPollingResult.newCount - currentDataCount
      });
      
      // 不整合が検出された場合の対応
      this.handleDataInconsistency();
    }
  }
  
  async handleDataInconsistency() {
    
    try {
      // 1. 現在の状態を詳細に分析
      const currentState = await this.analyzeCurrentDataState();
      
      // 2. 不整合の種類を特定
      const inconsistencyType = this.classifyInconsistency(currentState);
      
      // 3. 不整合タイプに応じた修復戦略を実行
      await this.executeRepairStrategy(inconsistencyType, currentState);
      
    } catch (error) {
      errorLog('⚠️ データ不整合修復でエラー:', error);
      // フォールバック: 従来の強制リフレッシュ
      this.forceDataRefresh().catch(fallbackError => {
        errorLog('⚠️ フォールバック強制リフレッシュもエラー:', fallbackError);
      });
    }
  }

  async analyzeCurrentDataState() {
    const container = this.elements.answersContainer;
    const domCards = container ? container.querySelectorAll('.answer-card') : [];
    
    return {
      domCardCount: domCards.length,
      stateDataCount: this.state.currentAnswers ? this.state.currentAnswers.length : 0,
      lastSeenCount: this.state.lastSeenCount || 0,
      pollingResult: this.lastPollingResult,
      hasLocalStorage: this.hasRelevantLocalStorage(),
      isInitialLoad: !this.initialDataLoaded,
      timestamp: new Date().toISOString()
    };
  }

  classifyInconsistency(state) {
    if (state.isInitialLoad && state.domCardCount > 0) {
      return 'phantom_cards_on_init';
    } else if (state.stateDataCount === 0 && state.pollingResult?.newCount > 0) {
      return 'empty_state_with_server_data';
    } else if (state.domCardCount !== state.stateDataCount) {
      return 'dom_state_mismatch';
    } else if (state.lastSeenCount > state.stateDataCount) {
      return 'seen_count_ahead';
    } else {
      return 'general_inconsistency';
    }
  }

  async executeRepairStrategy(type, state) {
    
    switch (type) {
      case 'phantom_cards_on_init':
        await this.clearAllCardsForEmptyData();
        await this.loadSheetData({ bypassCache: true });
        break;
        
      case 'empty_state_with_server_data':
        await this.performServerDataSync();
        break;
        
      case 'dom_state_mismatch':
        await this.resyncDOMWithState();
        break;
        
      case 'seen_count_ahead':
        this.updateLastSeenCount(state.stateDataCount);
        break;
        
      default:
        await this.forceDataRefresh();
    }
  }

  hasRelevantLocalStorage() {
    const userId = this.state?.userId || USER_ID;
    const sheetName = SHEET_NAME;
    
    return {
      hasLastSeen: localStorage.getItem(`lastSeenCount_${userId}_${sheetName}`) !== null,
      hasDiffCards: localStorage.getItem(`differentialCards_${userId}_${sheetName}`) !== null
    };
  }

  async performServerDataSync() {
    
    // 軽量チェックで最新のカウントを取得
    const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
    const classFilter = !selectedClass || selectedClass === 'すべて'
      ? null
      : selectedClass;
    
    
    const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);

    if (countData && countData.count > 0) {
      // サーバーにデータがある場合は強制再読み込み
      await this.loadSheetData({ bypassCache: true });
    } else {
      // サーバーにもデータがない場合は空状態を表示
      this.displayEmptyState();
    }
  }

  async resyncDOMWithState() {
    
    // 現在のstateデータに基づいてDOMを再構築
    if (this.state.currentAnswers && this.state.currentAnswers.length > 0) {
      this.renderBoard(this.state.currentAnswers, []);
    } else {
      await this.clearAllCardsForEmptyData();
      this.displayEmptyState();
    }
  }
  
  async forceDataRefresh() {
    
    // lastSeenCountを保持（安定化のため）
    const preservedLastSeenCount = this.state.lastSeenCount;
    
    // フロントエンドキャッシュをクリア
    if (this.cache) {
      this.cache.clear();
      debugLog('✅ フロントエンドキャッシュをクリア, lastSeenCount保持:', preservedLastSeenCount);
    }
    
    // サーバーキャッシュをクリア
    try {
      await this.gas.clearCache();
      debugLog('✅ サーバーキャッシュをクリア');
    } catch (error) {
      warnLog('⚠️ サーバーキャッシュクリアでエラー:', error);
    }
    
    // 強制データ再読み込み
    await this.loadSheetData({ bypassCache: true });
    
    // lastSeenCount復元（安定化のため）
    const shouldPreserveLastSeen = this.state.currentAnswers.length <= preservedLastSeenCount;
    if (shouldPreserveLastSeen && preservedLastSeenCount > 0) {
      this.state.lastSeenCount = preservedLastSeenCount;
      debugLog('✅ 強制データリフレッシュ完了、lastSeenCount復元:', {
        preservedCount: preservedLastSeenCount,
        currentAnswersLength: this.state.currentAnswers.length,
        stabilityMaintained: true
      });
    } else {
      debugLog('✅ 強制データリフレッシュ完了、新データによりlastSeenCount更新:', {
        oldCount: preservedLastSeenCount,
        newCount: this.state.lastSeenCount,
        currentAnswersLength: this.state.currentAnswers.length
      });
    }
  }

  /**
   * データ取得結果の有効性を判定
   * @param {object} result - サーバーからの応答
   * @returns {boolean} 有効なデータかどうか
   */
  isValidDataResult(result) {
    try {
      // 基本構造の確認
      if (!result || typeof result !== 'object') {
        return false;
      }
      
      // レスポンス構造の詳細ログ
      
      // 2つの可能なレスポンス形式に対応
      // 1. 新形式: { status: 'success', data: [...], header: '...', sheetName: '...' }
      // 2. 旧形式: { data: [...], header: '...', sheetName: '...' } (statusフィールドなし)
      
      const hasStatusField = 'status' in result;
      
      // ステータス確認（存在する場合のみ）
      if (hasStatusField && result.status !== 'success') {
        return false;
      }
      
      // データ配列の存在確認
      if (!Array.isArray(result.data)) {
        return false;
      }
      
      // ヘッダー情報の確認（任意フィールド）
      if (result.header && typeof result.header !== 'string') {
        return false;
      }
      
      // シート名の確認（任意フィールド）
      if (result.sheetName && typeof result.sheetName !== 'string') {
        return false;
      }
      
      
      return true;
    } catch (error) {
      warnLog('⚠️ データ判定エラー:', error);
      return false;
    }
  }

  /**
   * データ検証失敗の理由を取得
   * @param {object} result - 検証対象のレスポンス
   * @returns {string} 失敗理由
   */
  getFailureReason(result) {
    if (!result) {
      return 'レスポンスがnull/undefined';
    }
    if (typeof result !== 'object') {
      return `レスポンスがオブジェクトではない (${typeof result})`;
    }
    
    const hasStatusField = 'status' in result;
    if (hasStatusField && result.status !== 'success') {
      return `ステータスが成功ではない (${result.status})`;
    }
    
    if (!('data' in result)) {
      return 'dataフィールドが存在しない';
    }
    if (!Array.isArray(result.data)) {
      return `dataが配列ではない (${typeof result.data})`;
    }
    
    if (result.header && typeof result.header !== 'string') {
      return `ヘッダーの型が不正 (${typeof result.header})`;
    }
    if (result.sheetName && typeof result.sheetName !== 'string') {
      return `シート名の型が不正 (${typeof result.sheetName})`;
    }
    
    return '不明な検証失敗';
  }

  /**
   * リトライ機能付きデータ取得
   * @param {object} fetchParams - データ取得パラメータ
   * @param {boolean} isInitialLoad - 初期ロードかどうか
   * @returns {Promise} データ取得結果
   */
  async fetchUserData(fetchParams, isInitialLoad) {
    const retryOptions = {
      maxRetries: isInitialLoad ? 1 : 2, // 0-indexed, so 1 = 2 attempts total
      baseDelay: isInitialLoad ? 500 : 1000,
      maxDelay: 5000,
      context: 'データ取得',
      retryCondition: (error, attempt) => {
        const isTemporaryError =
          error.message.includes('timeout') ||
          error.message.includes('network') ||
          error.message.includes('script runtime') ||
          error.message.includes('temporarily unavailable');

        const isUserError = error.message.includes('ユーザー情報が見つかりません');

        // Retry for temporary errors or user errors (for auto-repair)
        return isTemporaryError || isUserError;
      }
    };

    return await this.executeWithRetry(async (attempt) => {
      debugLog(`📡 データ取得試行 ${attempt + 1}:`, fetchParams);

      const result = await this.runGas(
        'getPublishedSheetData',
        fetchParams.classFilter,
        fetchParams.sortOrder,
        fetchParams.showAdminFeatures,
        fetchParams.bypassCache || false
      );

      // Detailed response logging

      // Success case
      if (result && this.isValidDataResult(result)) {
        debugLog(`✅ データ取得成功 (試行 ${attempt + 1}):`, result.data ? result.data.length : 0, '件');
        return result;
      }

      // Handle error responses
      if (result && result.status === 'error') {
        const isUserNotFoundError = result.message && result.message.includes('ユーザー情報が見つかりません');

        if (isUserNotFoundError) {
          // Auto-repair for user errors
          try {
            await this.runGas('performAutoRepair', fetchParams.userId);
          } catch (repairError) {
            warnLog('⚠️ サーバー側修復失敗:', repairError);
          }
        }

        throw new Error(result.message || '不明なエラー');
      }

      // Invalid data case
      const validationReason = this.getFailureReason(result);
      throw new Error(`無効なデータ: ${validationReason}`);

    }, retryOptions).catch(error => {
      // Fallback: return partial results if available
      warnLog(`❌ 最大試行回数に達しました: ${error.message}`);
      return { status: 'error', message: 'データが見つかりませんでした', data: [] };
    });
  }

  /**
   * ユーザー情報が見つからない場合のエラー画面を表示
   * @param {string} errorMessage - エラーメッセージ
   */
  displayUserNotFoundError(errorMessage) {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    const isUserNotFoundError = errorMessage && (
      errorMessage.includes('ユーザー情報が見つかりません') || 
      errorMessage.includes('が見つかりません')
    );
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L5.08 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-red-400">${isUserNotFoundError ? 'ユーザー情報が見つかりません' : 'アクセスエラー'}</h3>
        <p class="mt-1 text-sm text-gray-400">${isUserNotFoundError ? 
          'この回答ボードは存在しないか、アクセス権限が不正です' : 
          'この回答ボードにアクセスする権限がありません'}</p>
        ${isUserNotFoundError ? `
        <div class="mt-4 p-4 bg-blue-900/20 border border-blue-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-blue-400 mb-2">🔍 考えられる原因：</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>• URLのユーザーIDが無効または期限切れ</li>
            <li>• ボードが削除されたか非アクティブ化された</li>
            <li>• データベース接続に一時的な問題</li>
            <li>• サーバー側の権限設定に問題</li>
            <li>• ブラウザのセッション情報が破損</li>
          </ul>
        </div>
        <div class="mt-4 p-4 bg-green-900/20 border border-green-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-green-400 mb-2">💡 解決方法：</h4>
          <ul class="text-xs text-gray-400 space-y-1">
            <li>• まずページを再読み込みしてみる</li>
            <li>• 正しいボードURLを管理者に確認</li>
            <li>• 5-10分待ってから再度アクセス</li>
            <li>• 別のブラウザで試してみる</li>
            <li>• 新しい回答ボードを作成する</li>
          </ul>
        </div>
        <div class="mt-4 p-3 bg-yellow-900/20 border border-yellow-500/50 rounded-lg text-left max-w-md mx-auto">
          <h4 class="text-sm font-medium text-yellow-400 mb-2">🛠️ 自動修復：</h4>
          <p class="text-xs text-gray-400">システムは自動的に問題の修復を試行しています。数分後に再度アクセスすると解決している可能性があります。</p>
        </div>` : ''}
        <p class="mt-2 text-xs text-gray-500">エラー詳細: ${window.sharedUtilities.security.escapeHtml(errorMessage)}</p>
        <div class="mt-6 space-x-3">
          <button 
            onclick="window.location.reload()" 
            class="inline-flex items-center px-4 py-2 border border-gray-600 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800"
          >
            <svg class="-ml-1 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            ページを再読み込み
          </button>
        </div>
      </div>
    `;
    
  }

  // Add these two methods
  showLoadingOverlay(message = '') {
    if (window.unifiedLoading) {
      window.unifiedLoading.setLoading(true, { 
        message: '', // No message for transparent overlay
        type: 'transparent',
        disableInteraction: true 
      });
    }
    
    // Add loading-active class to body and container to disable render optimizations
    // This prevents stacking context issues with the loading overlay
    document.body.classList.add('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.add('loading-active');
      // Replace render-optimized with loading-safe temporarily
      if (this.elements.answersContainer.classList.contains('render-optimized')) {
        this.elements.answersContainer.classList.add('loading-safe');
      }
    }
  }

  hideLoadingOverlay() {
    if (window.unifiedLoading) {
      window.unifiedLoading.setLoading(false);
    }
    
    // Remove loading-active classes to restore render optimizations
    document.body.classList.remove('loading-active');
    if (this.elements.answersContainer) {
      this.elements.answersContainer.classList.remove('loading-active');
      // Remove loading-safe class to restore normal render optimization
      this.elements.answersContainer.classList.remove('loading-safe');
    }
  }

  async loadSheetData(options = {}) {
    // Normalize options with defaults
    const config = {
      showLoading: options.showLoading !== false, // default true
      bypassCache: options.bypassCache || false,
      isInitialLoad: options.isInitialLoad || false,
      requestedSheetName: options.requestedSheetName || null,
      ...options
    };

    // 初回読み込み最適化: bypassCacheが明示的に指定されていない場合のみキャッシュ活用
    if (config.isInitialLoad && options.bypassCache === undefined) {
      // 初回読み込み時は適度なキャッシュ活用で高速化
      config.bypassCache = false;
    } else if (config.isInitialLoad && options.bypassCache === true) {
      config.bypassCache = true;
    }
    
    // Prevent concurrent loading
    if (this.state.isLoading && config.showLoading) {
      return;
    }
    
    try {
      this.state.isLoading = true;
      if (config.showLoading) {
        this.showLoadingOverlay();
      }
      
      const oldAnswers = [...this.state.currentAnswers];
      
      // Clear caches if needed
      if (config.bypassCache || this.shouldClearCache(config)) {
        await this.clearDataCaches(config.bypassCache && config.isInitialLoad);
      }
      
      // Load data with simplified parameters
      await this.performDataLoad(config, oldAnswers);
      
    } catch (error) {
      errorLog('❌ loadSheetData error:', error);
      this.handleLoadError(error);
    } finally {
      this.state.isLoading = false;
      this.hideLoadingOverlay();
    }
  }
  
  shouldClearCache(config) {
    // Clear cache on sheet switching or explicit refresh
    return (config.requestedSheetName && config.requestedSheetName !== this.state.currentActiveSheet) ||
           (config.showLoading && !config.isInitialLoad);
  }
  
  async clearDataCaches(isCompleteBypass = false) {
    
    // Clear frontend cache
    if (this.cache) {
      this.cache.clear();
    }
    
    // Clear UnifiedCache if available
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      window.unifiedCache.clear();
    }
    
    // Clear localStorage cache entries for complete bypass
    if (isCompleteBypass) {
      try {
        const keys = Object.keys(localStorage);
        const cacheKeys = keys.filter(key => 
          key.includes('cache_') || 
          key.includes('lastSeenCount_') ||
          key.includes('differentialCards_')
        );
        cacheKeys.forEach(key => localStorage.removeItem(key));
      } catch (error) {
        warnLog('⚠️ Failed to clear localStorage cache:', error);
      }
    }
    
    // Clear server cache
    try {
      await this.gas.clearCache();
    } catch (error) {
      warnLog('⚠️ Failed to clear server cache:', error);
    }
  }

  /**
   * 非公開状態遷移用の包括的キャッシュクリア
   * 既存のclearDataCachesを拡張し、より強力なキャッシュクリアを実行
   */
  clearAllCachesForUnpublished() {
    
    try {
      // 1. 既存のキャッシュクリア機能を使用
      if (this.cache && typeof this.cache.clear === 'function') {
        this.cache.clear();
      }
      
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      
      // 2. 拡張されたローカルストレージクリア
      const localStorageKeys = Object.keys(localStorage);
      const studyQuestKeys = localStorageKeys.filter(key => 
        key.includes('studyquest') || 
        key.includes('board') || 
        key.includes('sheet') ||
        key.includes('admin') ||
        key.includes('publication') ||
        key.includes('answer') ||
        key.includes('cache_') ||
        key.includes('lastSeenCount_') ||
        key.includes('differentialCards_')
      );
      
      studyQuestKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // 3. セッションストレージクリア
      if (window.sessionStorage) {
        const sessionKeys = Object.keys(sessionStorage);
        const studyQuestSessionKeys = sessionKeys.filter(key => 
          key.includes('studyquest') || 
          key.includes('board') || 
          key.includes('admin')
        );
        
        studyQuestSessionKeys.forEach(key => {
          sessionStorage.removeItem(key);
        });
      }
      
      // 4. アプリケーションの状態リセット
      if (this.state) {
        this.state.currentAnswers = [];
        this.state.hasNewContent = false;
        this.state.newContentCount = 0;
        this.state.lastSeenCount = 0;
      }
      
      // 5. キャッシュ無効化タイムスタンプ設定
      localStorage.setItem('lastUnpublishTime', Date.now().toString());
      localStorage.setItem('unpublishedRedirectTimestamp', new Date().toISOString());
      
      
    } catch (error) {
      errorLog('❌ 非公開状態キャッシュクリアでエラー:', error);
      // エラーがあっても処理は継続
    }
  }
  
  async performDataLoad(config, oldAnswers) {
    // Get current filter and sort settings
    const isInitialLoad = config.isInitialLoad;
    const requestedSheetName = config.requestedSheetName;
    const selectedClass = isInitialLoad ? 'すべて' :
                         (this.elements.classFilter ? this.elements.classFilter.value : 'すべて');
    const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
    
    // Show skeleton cards during loading
    if (config.showLoading && !config.isInitialLoad) {
      const count = Math.min(parseInt(this.elements.sizeSlider.value, 10) * 2, 8); // Cap at 8
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      const container = this.elements.answersContainer;
      container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      container.innerHTML = '';
      container.appendChild(frag);
    }
    
    // classFilter「すべて」または空の場合はサーバーに送信しない（全データ取得のため）
    const classFilter = !selectedClass || selectedClass === 'すべて'
      ? null
      : selectedClass;
      
      // データ取得パラメータの詳細ログ
      const fetchParams = {
        userId: this.state.userId,
        classFilter,
        sortOrder,
        showAdminFeatures: this.state.showAdminFeatures,
        requestedSheetName,
        bypassCache: config.bypassCache || false
      };
      debugLog('📡 Starting data fetch with parameters:', fetchParams);
      
      // エラーハンドリング強化版のデータ取得
      try {
        const result = await this.fetchUserData(
          fetchParams,
          isInitialLoad
        );
        // 初期ロードタイムアウトをクリア
        if (isInitialLoad && this.initTimeoutId) {
          clearTimeout(this.initTimeoutId);
          this.initTimeoutId = null;
        }
        
        if (!result || !result.data || result.data.length === 0) {
          // 詳細なエラーログ出力
          if (result && result.status === 'error') {
            errorLog('❌ StudyQuestApp: Data fetch failed with error:', result.message);
            
            // ユーザー情報エラーの特別な処理
            if (result.message && result.message.includes('ユーザー情報が見つかりません')) {
              errorLog('❌ StudyQuestApp: User not found. Current userId:', this.state.userId);
              errorLog('❌ StudyQuestApp: URL parameters:', window.location.href);
              errorLog('❌ StudyQuestApp: This may indicate:');
              errorLog('  1. Invalid userId parameter in URL');
              errorLog('  2. User not registered in the system');
              errorLog('  3. Database connectivity issues');
              errorLog('  4. Session expired or corrupted');
              errorLog('❌ StudyQuestApp: Possible solutions:');
              errorLog('  - Check if the URL parameters are correct');
              errorLog('  - Try refreshing the page');
              errorLog('  - Contact administrator if the issue persists');
              
              // UIにエラーメッセージを表示
              this.displayUserNotFoundError(result.message);
              return;
            }
          } else {
            // データ状態チェック: 空データが正常な状態かエラーかを判定
            const isValidEmptyData = result && result.data && Array.isArray(result.data) && result.data.length === 0 && result.header;
            
            if (isValidEmptyData) {
              // 正常な空データの場合は高速復旧戦略をスキップ
            } else {
              warnLog('⚠️ StudyQuestApp: Received empty or invalid data:', result);
              
              try {
                // 異常なデータの場合のみ高速復旧戦略を実行
                if (isInitialLoad) {
                  debugLog('🚀 初期データロード失敗 - 高速復旧戦略を実行');
                  
                  // 軽量チェックでデータ存在を確認
                  const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);
                  
                  if (countData && countData.count > 0) {
                    debugLog(`⚡ 軽量チェックで${countData.count}件検出 - 後続ポーリングで復旧予定`);
                    // 初期データロード失敗フラグを設定してポーリングに委ねる
                    this.hadInitialDataLoadFailure = true;
                    this.state.lastSeenCount = 0;
                  }
                } else {
                  // 通常時は従来のフォールバック処理（簡素化版）
                  const countData = await this.gas.getDataCount(classFilter, 'newest', this.state.showAdminFeatures);
                  // Enhanced consistency check with lastSeenCount (Phase 2.2)
                  const expected = countData?.count || 0;
                  const actual = result?.data ? result.data.length : 0;
                  const lastSeen = this.state.lastSeenCount || 0;
                  
                  // Only trigger fallback if there's significant inconsistency
                  // considering user's previously seen count
                  if (expected > 0 && actual === 0 && expected !== lastSeen) {
                    warnLog('⚠️ Significant data inconsistency detected!', 
                      `Expected: ${expected}, Actual: ${actual}, LastSeen: ${lastSeen}`);
                    debugLog('🔄 Attempting simplified fallback...');
                    
                    // 簡素化されたフォールバック（待機時間短縮）
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const retryResult = await this.runGas(
                      'getPublishedSheetData',
                      classFilter,
                      this.elements.sortOrder ? this.elements.sortOrder.value : 'newest',
                      this.state.showAdminFeatures,
                      true
                    );
                    
                    if (retryResult && retryResult.data && retryResult.data.length > 0) {
                      debugLog('✅ Fallback retry successful! Got', retryResult.data.length, 'items');
                      result = retryResult; // 成功した結果を使用
                    } else {
                      warnLog('❌ Fallback retry also returned empty data');
                    }
                  }
                }
              } catch (fallbackError) {
                warnLog('⚠️ Fallback data consistency check failed:', fallbackError);
              }
            }
          }
          
          // 再チェック後もデータが空の場合のみ空状態を表示
          if (!result || !result.data || result.data.length === 0) {
            // 重要: 問題文は空データでも表示する
            if (result && result.header && this.elements.headingLabel && 
                result.header !== '読み込み中...' && 
                !result.header.includes('読み込み') &&
                result.header.trim() !== '') {
              this.elements.headingLabel.textContent = result.header;
              debugLog('✅ 空データ時でも問題文を表示:', result.header);
            }
            
            // 空データ受信時は古いカードを強制的にクリア
            await this.clearAllCardsForEmptyData();
            
            // 空状態を表示（問題文表示後）
            this.displayEmptyState();
            if (isInitialLoad) {
              this.state.lastSeenCount = 0;
              // 初期データロード失敗フラグを設定
              this.hadInitialDataLoadFailure = true;
              debugLog('🚨 初期データロード失敗をマーク（後続ポーリングで通知を有効化）');
            }
            return;
          }
        }

        
        debugLog('Received data:', result.data);
        
        // PHASE 2: データ処理
        // Step 1 & 2: Data acquisition and unified state synchronization
        const syncResult = this.synchronizeStateAfterDataUpdate(result.data, 'performDataLoad');
        
        // 理由列デバッグ: 取得されたデータの詳細を確認
        
        // サーバーからの質問文と現在表示の一致性をチェック
        if (result.header) {
          const currentDisplayed = this.elements.headingLabel ? this.elements.headingLabel.textContent : '';
          if (currentDisplayed && currentDisplayed !== result.header) {
            // 質問文を新しいものに更新
            if (this.elements.headingLabel) {
              this.elements.headingLabel.textContent = result.header;
            }
          }
        }
        
        // Apply saved reaction states to restore user's previous reactions
        this.applyReactionState(result.data);
        
        // Populate class filter with available classes and make it visible
        this.populateClassFilter(result.data);
        
        // アクティブシート情報を記録（ポーリングで使用）
        this.state.activeSheetInfo = {
          sheetName: result.sheetName || 'フォームの回答 1',
          opinionHeader: result.header || '質問',
          lastUpdated: Date.now()
        };
        debugLog('📄 アクティブシート情報を更新:', this.state.activeSheetInfo);

        this.lastDataLoadTime = Date.now();
        
        if (isInitialLoad) {
          // 初期データロード完了フラグを設定
          this.initialDataLoaded = true;
          const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
          const sortOrder = this.elements.sortOrder ? this.elements.sortOrder.value : 'newest';
          this.lastViewKey = `${selectedClass}-${sortOrder}`;
          // Initial data load completed
        }

        // Update heading with the actual question text from server (only if valid)
        if (result.header && this.elements.headingLabel && 
            result.header !== '読み込み中...' && 
            !result.header.includes('読み込み') &&
            result.header.trim() !== '') {
          this.elements.headingLabel.textContent = result.header;
        }

        // Step 3: DOM update with proper sequencing (Phase 2.1)
        requestAnimationFrame(async () => {
          await this.renderBoard(false, isInitialLoad);
          
          // Step 4: Consistency validation after DOM update (Phase 2.1)
          await this.validatePostLoadState();
        });

        // Post-processing after successful data load
        this.adjustLayout();
        
        if (!this.state.isAdminUser || !window.hasAdminCapability) {
          this.state.showAdminFeatures = false;
          this.state.showHighlightToggle = false;
          // 管理モードボタンを確実に非表示
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.add('hidden');
            this.elements.adminToggleBtn.setAttribute('hidden', '');
            this.elements.adminToggleBtn.style.display = 'none';
          }
        } else {
          this.state.showHighlightToggle = true;
          // 管理モードボタンを表示
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.style.display = '';
          }
          // Admin settings updated
          this.cache.clear();
          // Cache cleared due to admin highlight settings
        }
        
        if (isInitialLoad) {
          this.elements.answersContainer.classList.add('render-optimized');
          // If loading is active, also add loading-safe class to prevent stacking context issues
          if (document.body.classList.contains('loading-active') || 
              this.elements.answersContainer.classList.contains('loading-active')) {
            this.elements.answersContainer.classList.add('loading-safe');
          }
        }
      } catch (error) {
        errorLog('Error loading sheet data:', error);
        const errorMessage = window.sharedUtilities.security.escapeHtml(error.message || 'Unknown error');
        this.elements.answersContainer.querySelectorAll('.skeleton').forEach(el => el.remove());
        this.elements.answersContainer.innerHTML = '<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">' + '<p class="font-bold">データの読み込みに失敗しました。</p>' + '<p class="text-sm mt-2">' + errorMessage + '</p>' + '<button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">再試行</button>' + '</div>';
        // 同期エラーの場合にもローディング状態を解除
        this.state.isLoading = false;
        this.hideLoadingOverlay();
      }
  }

  async loadAvailableSheets() {
    try {
      const sheetsData = await this.gas.getAvailableSheets();
      this.populateSheetSelector(sheetsData);
    } catch (error) {
      errorLog('Failed to load available sheets:', error);
      if (this.elements.sheetSelector) {
        this.elements.sheetSelector.innerHTML = '<option value="">エラー: シート読み込み失敗</option>';
      }
    }
  }
  populateSheetSelector(sheets) {
    const selector = this.elements.sheetSelector;
    
    if (!selector) return;

    if (!sheets || sheets.length === 0) {
      selector.innerHTML = '<option value="">利用可能なシートがありません</option>';
      selector.disabled = true;
      return;
    }
    
    // シート選択肢を構築
    if (!Array.isArray(sheets)) {
      errorLog('Invalid sheets data:', sheets);
      selector.innerHTML = '<option>シートデータが無効です</option>';
      selector.disabled = true;
      return;
    }
    
    const options = sheets.map(sheet => {
      const selected = sheet.name === this.state.sheetName ? 'selected' : ''; // Use sheet.name for comparison
      const activeLabel = sheet.name === this.state.sheetName ? ' (現在のアクティブシート)' : '';
      return `<option value="${window.sharedUtilities.security.escapeHtml(sheet.name)}" ${selected}>${window.sharedUtilities.security.escapeHtml(sheet.name)}${activeLabel}</option>`;
    }).join('');
    
    selector.innerHTML = options;
    selector.disabled = false;
    
    // 現在のアクティブシートを記録
    // this.state.currentActiveSheet is already set by loadSheetData
  }
  async switchSheet() {
    const selectedSheet = this.elements.sheetSelector.value;
    
    // 早期リターン: 無効な選択または同じシート
    if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
      debugLog('Sheet switch skipped - same sheet or invalid selection');
      return;
    }
    
    // 現在切り替え中の場合は処理を拒否
    if (this.sheetSwitchInProgress) {
      debugLog('Sheet switch already in progress - ignoring request');
      return;
    }
    
    try {
      this.sheetSwitchInProgress = true;
      
      // 前処理: 状態のクリーンアップ
      await this.prepareForSheetSwitch(selectedSheet);
      
      // メインプロセス: データ読み込み
      await this.performSheetSwitch(selectedSheet);
      
      // 後処理: 状態の確定
      await this.finalizeSheetSwitch(selectedSheet);
      
    } catch (error) {
      errorLog('❌ Sheet switch failed:', error);
      await this.handleSheetSwitchError(error, selectedSheet);
    } finally {
      this.sheetSwitchInProgress = false;
    }
  }
  
  async prepareForSheetSwitch(targetSheet) {
    // 必要な前提条件をチェック
    if (!this.state.userId) {
      throw new Error('User ID is missing - cannot switch sheet');
    }
    
    // UI状態をリセット
    this.dismissNewContentBanner();
    
    // 仮想スクロール状態をクリア
    this.clearVirtualScrollingState();
    
    // 既存のポーリングを一時停止
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    debugLog('Sheet switch preparation completed');
  }
  
  async performSheetSwitch(targetSheet) {
    const maxRetries = 3;
    let lastError = null;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        debugLog(`🔄 Loading sheet data (attempt ${attempt}/${maxRetries}):`, targetSheet);
        
        await this.loadSheetData({ 
          bypassCache: true, 
          requestedSheetName: targetSheet,
          showLoading: true
        });
        
        return; // 成功時は早期リターン
        
      } catch (error) {
        lastError = error;
        warnLog(`⚠️ Sheet load attempt ${attempt} failed:`, error.message);
        
        if (attempt < maxRetries) {
          const delay = attempt * 1000; // 指数バックオフ
          debugLog(`⏳ Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    // すべての試行が失敗した場合
    throw new Error(`Failed to load sheet after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);
  }
  
  async finalizeSheetSwitch(targetSheet) {
    // 状態の確定
    this.state.currentActiveSheet = targetSheet;
    this.state.sheetName = targetSheet;
    
    // 新着通知の基準をリセット
    this.state.lastSeenCount = this.state.currentAnswers?.length || 0;
    
    // UIの更新
    this.updateSheetSelectorLabels();
    this.updateSheetDisplayName(targetSheet);
    
    // ポーリングを再開
    this.startNewAnswerPolling();
    
    debugLog('Sheet switch finalization completed');
  }
  
  async handleSheetSwitchError(error, targetSheet) {
    errorLog('Sheet switch error details:', {
      error: error.message,
      targetSheet,
      currentSheet: this.state.currentActiveSheet,
      userId: this.state.userId
    });
    
    // 元のシートの選択に戻す
    if (this.elements.sheetSelector) {
      this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
    }
    
    // ポーリングを再開（元のシートで）
    this.startNewAnswerPolling();
    
    // ユーザーにエラーを通知
    if (window.messageManager) {
      window.messageManager.show(
        `ボードの切り替えに失敗しました: ${error.message}`,
        'error',
        5000
      );
    }
    
    // 現在のデータでUI更新を試行
    try {
      this.renderBoard(false, false);
    } catch (renderError) {
      errorLog('Failed to render board after sheet switch error:', renderError);
    }
  }
  
  updateSheetDisplayName(sheetName) {
    if (this.elements.sheetNameText && sheetName) {
      const sheetIcon = this.getIcon('users', 'w-3 h-3 inline-block mr-1');
      this.elements.sheetNameText.innerHTML = sheetIcon + window.sharedUtilities.security.escapeHtml(sheetName);
    }
  }
  
  clearVirtualScrollingState() {
    // バーチャルスクロール状態をリセット
    if (this.virtualScrollState) {
      this.virtualScrollState = {
        renderedItems: 0,
        totalItems: 0,
        isLoading: false,
        renderedRowIndexes: new Set(),
        cardRegistry: new Map()
      };
    }
    
    // 既存のオブザーバーを切断
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
      this.scrollObserver = null;
    }
    
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
      // visibilityObserver は setupObservers() で再作成されるので null にしない
    }
    
    
    
    
    
  }
  
  updateSheetSelectorLabels() {
    const selector = this.elements.sheetSelector;
    const options = Array.from(selector.options);
    
    options.forEach(option => {
      const sheetName = option.value;
      const isActive = sheetName === this.state.currentActiveSheet;
      const cleanName = sheetName.replace(/ \(現在のアクティブシート\)$/, '');
      
      if (isActive) {
        option.textContent = `${cleanName} (現在のアクティブシート)`;
      } else {
        option.textContent = cleanName;
      }
    });
  }
  
  populateClassFilter(rows) {
    const classFilter = this.elements.classFilter;
    // Ensure rows is an array before mapping
    const uniqueClasses = ['すべて', ...new Set(Array.isArray(rows) ? rows.map(r => r.class).filter(Boolean) : [])];
    classFilter.innerHTML = uniqueClasses.map(c => '<option value="' + window.sharedUtilities.security.escapeHtml(c) + '">' + window.sharedUtilities.security.escapeHtml(c) + '</option>').join('');
    classFilter.value = 'すべて';
    classFilter.classList.remove('hidden');
  }
  
  applyReactionStyles(element, data) {
    if (!element || !data || !(element instanceof HTMLElement)) return;
    
    // 既存のリアクション関連クラスをクリア
    const reactionClasses = [
      'reaction-bg-like', 'reaction-bg-understand', 'reaction-bg-curious',
      'reaction-bg-like-understand', 'reaction-bg-like-curious', 'reaction-bg-understand-curious',
      'reaction-bg-like-understand-curious', 'reaction-border-1', 'reaction-border-2', 'reaction-border-3',
      'highlighted'
    ];
    reactionClasses.forEach(cls => element.classList.remove(cls));
    
    // ハイライト状態を適用（リアクション装飾より優先）
    if (data.highlight) {
      element.classList.add('highlighted');
      // Highlight decoration applied
      // ハイライト時はリアクション装飾をスキップ
      return;
    } else {
      // No highlight decoration
    }
    
    // アクティブなリアクションを特定
    const active = this.reactionTypes.filter(rt => 
      data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
    ).map(rt => rt.key);
    
    // 背景色クラスを適用
    if (active.length === 1) {
      if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
      else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
      else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
    } else if (active.length === 2) {
      const sorted = active.sort();
      if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE') element.classList.add('reaction-bg-like-curious');
      else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-like-understand');
      else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-understand-curious');
    } else if (active.length === 3) {
      element.classList.add('reaction-bg-like-understand-curious');
    }
    
    // ボーダー幅を適用
    const totalReactions = this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
    if (totalReactions >= 10) {
      element.classList.add('reaction-border-3');
    } else if (totalReactions >= 5) {
      element.classList.add('reaction-border-2');
    } else if (totalReactions > 0) {
      element.classList.add('reaction-border-1');
    }
  }
  async renderBoard(isLayoutChange = false, isInitialLoad = false, oldRows = []) {
    try {
      // Define newRows first to avoid TDZ error
      const newRows = this.state.currentAnswers;
      
      // 空データの場合の早期処理
      if (!newRows || newRows.length === 0) {
        debugLog('renderBoard: 空データを受信、DOMをクリアして空状態を表示します');
        await this.renderEmptyState();
        return;
      }
      
      // 管理者ハイライト設定の初期化
      this.initializeAdminSettings();
      
      // レンダリング前の状態準備
      this.prepareRenderingState(newRows);
      
      // メインレンダリング処理
      this.performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad);
      
      // レンダリング後の状態更新
      this.finalizeRenderingState();
      this.validatePostLoadState();
      
    } catch (error) {
      errorLog('❌ renderBoard: レンダリングエラー:', error);
      this.handleRenderingError(error);
    }
  }
  
  async renderEmptyState() {
    await this.clearAllCardsForEmptyData();
    this.displayEmptyState();
  }
  
  initializeAdminSettings() {
    // 管理者の場合はハイライトトグルを確実に有効化
    if (this.state.isAdminUser && !this.state.showHighlightToggle) {
      this.state.showHighlightToggle = true;
      this.cache.clear();
    }
  }
  
  prepareRenderingState(newRows) {
    const container = this.elements.answersContainer;
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    
    this.updateLayoutControls(newRows);
  }
  
  updateLayoutControls(newRows) {
    const updates = [];
    if (this.elements.sliderValue && this.elements.sizeSlider &&
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value) {
      updates.push(() => this.elements.sliderValue.textContent = this.elements.sizeSlider.value);
    }
    if (this.elements.sizeSlider) {
      const className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      if (this.elements.answersContainer.className !== className) {
        updates.push(() => this.elements.answersContainer.className = className);
      }
    }
    if (this.elements.answerCount) {
      const countHtml = this.getIcon('users', 'w-4 h-4 inline-block -mt-1') + '<span>' + newRows.length + '件</span>';
      if (this.elements.answerCount.innerHTML !== countHtml) {
        updates.push(() => this.elements.answerCount.innerHTML = countHtml);
      }
    }

    this.batchDOMUpdates(updates);
  }
  
  performMainRendering(newRows, oldRows, isLayoutChange, isInitialLoad) {
    const container = this.elements.answersContainer;

    // 既存カードを先に取得してからクリア
    const existingMap = new Map();
    container.querySelectorAll('.answer-card').forEach(card => {
      existingMap.set(card.dataset.rowIndex, card);
    });

    // その後でコンテナをクリア
    container.innerHTML = '';

    existingMap.forEach((card, id) => {
      if (!newRows.some(r => String(r.rowIndex) === id)) {
        card.remove();
        existingMap.delete(id);
      }
    });

    if (newRows.length > window.RENDER_BATCH_SIZE) {
      this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad);
    } else {
      this.renderDirectly(newRows, oldRows, container, existingMap);
    }
  }
  
  renderDirectly(newRows, oldRows, container, existingMap) {
    const fragment = this.getReusableFragment();

    newRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

      if (!card) {
        card = this.createAnswerCard(row);
        if (card) {
          card.classList.add('new-card');
          fragment.appendChild(card);
        } else {
          warnLog('renderBoard: Failed to create card for row:', row.rowIndex);
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        this.updateAnswerCard(card, row, oldData);
      }
    });

    if (fragment.children.length > 0) {
      container.appendChild(fragment);
    }
  }
  
  calculateVisibleRange(totalItems) {
    const container = this.elements.answersContainer;
    if (!container) {
      warnLog('calculateVisibleRange: answersContainer not found.');
      return { startIndex: 0, endIndex: totalItems };
    }

    // DOM が準備完了するまで待つ
    if (!container.offsetParent && container.offsetHeight === 0) {
      // コンテナがまだ表示されていない場合は少し待つ
      requestAnimationFrame(() => {
        const retryHeight = container.clientHeight;
        if (retryHeight > 0) {
        }
      });
      // フォールバックとして全アイテムを表示
      return { startIndex: 0, endIndex: totalItems };
    }

    const scrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    const cardHeight = 150; // 仮のカードの高さ。実際のCSSに基づいて調整が必要。

    let startIndex = 0;
    let endIndex = totalItems;

    if (containerHeight > 0) {
      startIndex = Math.floor(scrollTop / cardHeight);
      endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / cardHeight));
    } else {
      // Container not yet rendered, use fallback range
      return { startIndex: 0, endIndex: totalItems };
    }

    return { startIndex, endIndex };
  }

  renderWithVirtualScrolling(newRows, oldRows, container, existingMap, isInitialLoad) {
    debugLog('DEBUG: renderBoard - Using virtual scrolling for', newRows.length, 'items (initial load:', isInitialLoad, ')');

    if (isInitialLoad || this.state.currentAnswers.length === 0) {
      this.clearVirtualScrollingState();
    }

    // 仮想スクロールでも既存のリアクション状態を保持
    const fragment = this.getReusableFragment();
    const visibleRange = this.calculateVisibleRange(newRows.length);
    const visibleRows = newRows.slice(visibleRange.startIndex, visibleRange.endIndex);
    debugLog('Virtual scroll rendering:', { visibleRows: visibleRows.length });

    visibleRows.forEach((row) => {
      const rowId = String(row.rowIndex);
      let card = existingMap.get(rowId);
      const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

      if (!card) {
        card = this.createAnswerCard(row);
        if (card) {
          fragment.appendChild(card);
        }
      } else if (this.shouldUpdateCard(row, oldData)) {
        // 既存カードを更新（リアクション状態を保持）
        this.updateAnswerCard(card, row, oldData);
      }
    });

    debugLog('Virtual scroll completed:', { renderedCards: fragment.children.length });
    if (fragment.children.length > 0) {
      container.appendChild(fragment);
    }
  }
  
  shouldUpdateCard(newData, oldData) {
    if (!oldData) return true;

    const newReactionCount = this.reactionTypes.reduce((sum, rt) =>
      sum + (newData.reactions?.[rt.key]?.count || 0), 0);
    const oldReactionCount = this.reactionTypes.reduce((sum, rt) =>
      sum + (oldData.reactions?.[rt.key]?.count || 0), 0);

    return newReactionCount !== oldReactionCount ||
           newData.isHighlighted !== oldData.isHighlighted ||
           newData.opinion !== oldData.opinion ||
           this.validateReasonText(newData.reason) !== this.validateReasonText(oldData.reason) ||
           newData.name !== oldData.name;
  }
  
  finalizeRenderingState() {
    // レンダリング完了後の状態更新
    this.updateAnswerCount();
    this.applyAnimations();
  }

  updateAnswerCount() {
    if (!this.elements.answerCount) return;

    const count = Array.isArray(this.state.currentAnswers)
      ? this.state.currentAnswers.length
      : 0;
    const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
    this.elements.answerCount.innerHTML =
      userIcon + '<span>' + count + '件</span>';
  }

  applyAnimations() {
    if (!this.elements.answersContainer) return;

    const newCards =
      this.elements.answersContainer.querySelectorAll('.new-card');
    newCards.forEach(card => {
      requestAnimationFrame(() => {
        card.classList.remove('new-card');
      });
    });
  }
  
  handleRenderingError(error) {
    errorLog('レンダリングエラーの詳細:', error);
    
    // フォールバック: 最小限の表示を試行
    try {
      const container = this.elements.answersContainer;
      container.innerHTML = `
        <div class="text-center py-8 col-span-full">
          <p class="text-red-400">表示エラーが発生しました</p>
          <button onclick="location.reload()" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded">
            再読み込み
          </button>
        </div>
      `;
    } catch (fallbackError) {
      errorLog('フォールバック表示も失敗:', fallbackError);
    }
  }
  
  updateAnswerCard(card, newData, oldData) {
    if (!card || !newData) return;

    try {
      if (!oldData || oldData.opinion !== newData.opinion) {
        const opinionElement = card.querySelector('.opinion-text');
        if (opinionElement) {
          opinionElement.textContent = newData.opinion || '';
        }
      }

      if (!oldData || this.validateReasonText(oldData.reason) !== this.validateReasonText(newData.reason)) {
        const reasonElement = card.querySelector('.answer-preview p');
        if (reasonElement) {
          reasonElement.textContent = newData.reason || '';
        }
      }

      if (!oldData || oldData.name !== newData.name) {
        const nameElement = card.querySelector('.font-bold');
        if (nameElement) {
          nameElement.textContent = newData.name || '';
        }
      }
      
      // リアクション状態を保持しつつ更新
      this.updateCardReactions(card, newData);
      
      // ハイライト状態を更新
      this.updateCardHighlight(card, newData);
      
    } catch (error) {
      errorLog('updateAnswerCard error:', error);
    }
  }
  
  updateCardReactions(card, data) {
    const reactionContainer = card.querySelector('.reaction-container');
    if (!reactionContainer) return;

    // DOM操作をバッチ化
    const updates = [];
    
    this.reactionTypes.forEach(reactionType => {
      const newCount = data.reactions?.[reactionType.key]?.count || 0;
      const reacted = data.reactions?.[reactionType.key]?.reacted || false;

      // バッチ更新用にデータを蓄積
      updates.push({
        rowIndex: data.rowIndex,
        reaction: reactionType.key,
        count: newCount,
        reacted,
        shouldDisplay: newCount > 0
      });
    });

    // バッチでDOM更新を実行
    this.batchUpdateReactionButtons(updates);
    this.updateCardReactionBackground(card, data);
  }

  // バッチ処理でリアクションボタンを更新
  batchUpdateReactionButtons(updates, options = {}) {
    const { onComplete, immediate = false } = options;
    const updatedElements = new Map();

    const executeUpdate = () => {
      try {
        updates.forEach(update => {
          const buttons = document.querySelectorAll(`[data-row-index="${update.rowIndex}"][data-reaction="${update.reaction}"]`);

          buttons.forEach(btn => {
            if (!updatedElements.has(btn)) {
              const countEl = btn.querySelector('.reaction-count');
              if (countEl && this.state.showCounts) {
                countEl.textContent = update.count;
              }

              const rt = this.reactionTypes.find(r => r.key === update.reaction);
              const svgEl = btn.querySelector('svg');
              if (svgEl && rt) {
                // Force icon update to ensure reacted state is visible
                const newIcon = this.getIcon(rt.icon, 'w-5 h-5', update.reacted);
                // Always update to ensure consistency
                svgEl.outerHTML = newIcon;

                // Add visual feedback for state change
                btn.style.transition = 'all 0.2s ease-out';
                if (update.reacted) {
                  btn.style.transform = 'scale(1.1)';
                  setTimeout(() => {
                    btn.style.transform = '';
                  }, 200);
                }
              }

              const colorClass = update.reaction === 'LIKE' ? 'text-red-500' :
                               update.reaction === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
              btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
              btn.classList.add(colorClass);
              btn.classList.toggle('reacted', update.reacted);
              btn.setAttribute('aria-pressed', update.reacted.toString());

              btn.style.display = update.shouldDisplay ? 'flex' : 'none';

              const reactionNames = { 'LIKE': 'いいね！', 'UNDERSTAND': 'なるほど！', 'CURIOUS': 'もっと知りたい！' };
              const reactionName = reactionNames[update.reaction] || update.reaction;
              btn.setAttribute('aria-label', `${reactionName}${update.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${update.count}件)` : ''}`);

              updatedElements.set(btn, true);
            }
          });
        });

        if (onComplete) {
          onComplete(updatedElements);
        }

      } catch (error) {
        errorLog('batchUpdateReactionButtons error:', error);
        if (onComplete) {
          onComplete(updatedElements, error);
        }
      }
    };

    if (immediate) {
      executeUpdate();
    } else {
      requestAnimationFrame(executeUpdate);
    }
  }
  
  updateCardReactionBackground(card, data) {
    // リアクションに基づいてカードの背景とボーダーを更新
    this.applyReactionStyles(card, data);
  }
  
  updateCardHighlight(card, data) {
    const isHighlighted = data.isHighlighted || data.highlight;
    
    if (isHighlighted) {
      card.classList.add('highlighted-card');
    } else {
      card.classList.remove('highlighted-card');
    }
    
    // Update highlight button if present
    const highlightBtn = card.querySelector('.highlight-btn');
    if (highlightBtn) {
      highlightBtn.classList.toggle('active', isHighlighted);
    }
  }
  
  createAnswerCard(data) {
    try {
      // Data validation and sanitization
      if (!data || typeof data !== 'object') {
        warnLog('createAnswerCard: Invalid data provided:', data);
        return null;
      }
      
      // 重要なコンテンツがない場合の処理
      if (!data.opinion && !data.reason) {
        warnLog('createAnswerCard: データにコンテンツ（opinion/reason）がありません:', {
          rowIndex: data.rowIndex,
          hasOpinion: !!data.opinion,
          hasReason: !!data.reason,
          dataKeys: Object.keys(data)
        });
        // 空のコンテンツでもカードは作成する（エラー状態として表示）
      }
      
      // Ensure required properties exist with safe defaults（理由列の堅牢化）
      const safeData = {
        rowIndex: data.rowIndex || 0,
        opinion: data.opinion || '',
        reason: this.validateReasonText(data.reason),
        name: data.name || '',
        email: data.email || '',
        reactions: data.reactions || {},
        highlight: Boolean(data.highlight)
      };
      
      // 理由列デバッグ: createAnswerCard での理由データ処理状況
      
      const cacheKey = `${safeData.rowIndex}-${safeData.opinion.slice(0,50)}-${safeData.reason.slice(0,30)}-${safeData.name}-${JSON.stringify(safeData.reactions)}-${safeData.highlight}-${this.state.showCounts}-${this.state.displayMode}-${this.state.showHighlightToggle}`;
      
      // Answer card cache check
      const cachedCard = this.cache.get(`render-${cacheKey}`);
      if (cachedCard) {
        try {
          const clonedCard = cachedCard.cloneNode(true);
          // Ensure cloned card has proper data-row-index
          clonedCard.dataset.rowIndex = safeData.rowIndex;
          
          const reactionButtons = clonedCard.querySelectorAll('.reaction-btn');
          reactionButtons.forEach(btn => {
            btn.dataset.rowIndex = safeData.rowIndex;
          });
          
          return clonedCard;
        } catch (cacheError) {
          warnLog('createAnswerCard: Cache clone error, creating new card:', cacheError);
          // Continue to create new card if cache fails
        }
      }
    
      const card = document.createElement('div');
      const highlightClass = safeData.highlight ? ' highlighted' : '';
      card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' + highlightClass;
      card.dataset.rowIndex = safeData.rowIndex;
      card.setAttribute('role', 'article');
      card.setAttribute('tabindex', '0');
      card.setAttribute('aria-label', '回答カード: ' + safeData.opinion.substring(0, 50) + (safeData.opinion.length > 50 ? '...' : ''));
    
      // Answer card created
      let highlightBtnHtml = '';
      // Highlight button condition check
      if (this.state.showHighlightToggle) {
        const cls = safeData.highlight ? 'reacted' : '';
        const highlightAriaLabel = safeData.highlight ? 'ハイライトを解除する' : 'ハイライトする';
        highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + safeData.highlight + '" data-row-index="' + safeData.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', safeData.highlight) + '</button>';
      }
      const showName = this.state.displayMode === 'named';
      let displayName = '';
      
      if (showName) {
        // 名前が利用可能な場合はそれを使用、なければemailから生成
        if (safeData.name) {
          displayName = safeData.name;
        } else if (safeData.email) {
          try {
            displayName = safeData.email.split('@')[0];
          } catch (emailError) {
            warnLog('createAnswerCard: Email parsing error:', emailError);
            displayName = 'ユーザー';
          }
        }
      }
      
      const nameHtml = showName && displayName ? '<div class="name-display flex-shrink-0 mr-2"><span class="font-bold text-sm text-cyan-300 bg-gray-800/50 px-2 py-1 rounded border border-cyan-400">' + window.sharedUtilities.security.escapeHtml(displayName) + '</span></div>' : '';
      const containerClass = nameHtml ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex flex-col sm:flex-row justify-between items-start sm:items-center gap-y-1 min-h-[2rem]' : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';
    
      // Name display configuration complete
      const reactionButtonsHtml = this.reactionTypes.map(rt => {
        try {
          const info = safeData.reactions && safeData.reactions[rt.key] ? safeData.reactions[rt.key] : { count: 0, reacted: false };
          const cls = info.reacted ? 'reacted' : '';
          const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
          const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' + (info.count || 0) + '</span>' : '';
          const reactionNames = { 'LIKE': 'いいね！', 'UNDERSTAND': 'なるほど！', 'CURIOUS': 'もっと知りたい！' };
          const reactionName = reactionNames[rt.key] || rt.key;
          const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count || 0}件)` : ''}`;
          return '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' + colorClass + ' ' + cls + '" data-row-index="' + safeData.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + ariaLabel + '" aria-pressed="' + info.reacted + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
        } catch (reactionError) {
          warnLog('createAnswerCard: Reaction button creation error:', reactionError);
          return ''; // Skip problematic reaction button
        }
      }).join('');
      const fragment = document.createDocumentFragment();
      
      // Create main content div
      const contentDiv = document.createElement('div');
      contentDiv.className = 'relative flex-grow mb-3 answer-preview';
      
      const opinionTitle = document.createElement('h3');
      opinionTitle.className = 'opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight';
      opinionTitle.textContent = safeData.opinion || '（回答内容が取得できませんでした）';
      
      const reasonText = document.createElement('p');
      reasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
      reasonText.textContent = safeData.reason || '（理由・詳細情報なし）';
      
      contentDiv.appendChild(opinionTitle);
      
      // 理由テキストが存在する場合のみ追加（堅牢化）
      
      // 理由テキストを常に追加（空の場合はプレースホルダー表示）
      try {
        // 理由テキストの有効性を検証
        if (reasonText && reasonText.textContent) {
          contentDiv.appendChild(reasonText);
        } else {
          // 理由テキスト要素の再作成が必要な場合
          const newReasonText = document.createElement('p');
          newReasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
          newReasonText.textContent = safeData.reason || '（理由・詳細情報なし）';
          contentDiv.appendChild(newReasonText);
        }
      } catch (reasonError) {
        // 理由テキスト追加でエラーが発生した場合の回復処理
        warnLog('createAnswerCard: Reason text append error, attempting recovery:', reasonError);
        try {
          const fallbackReasonText = document.createElement('p');
          fallbackReasonText.className = 'text-gray-100 whitespace-pre-wrap break-words mt-4';
          fallbackReasonText.textContent = safeData.reason || '（理由・詳細情報なし）';
          contentDiv.appendChild(fallbackReasonText);
        } catch (fallbackError) {
          errorLog('createAnswerCard: Failed to add reason text even with fallback:', fallbackError);
          // 理由テキストが追加できない場合でもカード生成は継続
        }
      }
    
      // Create footer div
      const footerDiv = document.createElement('div');
      footerDiv.className = containerClass;
      
      // 名前表示部分を追加
      if (nameHtml) {
        try {
          const nameContainer = document.createElement('div');
          nameContainer.className = 'name-container flex-shrink-0';
          nameContainer.innerHTML = nameHtml;
          footerDiv.appendChild(nameContainer);
        } catch (nameError) {
          warnLog('createAnswerCard: Name container creation error:', nameError);
        }
      }
      
      // リアクション部分を追加
      try {
        const reactionsDiv = document.createElement('div');
        reactionsDiv.className = 'flex items-center gap-1 flex-shrink-0';
        reactionsDiv.setAttribute('role', 'group');
        reactionsDiv.setAttribute('aria-label', '回答への反応');
        reactionsDiv.innerHTML = reactionButtonsHtml + highlightBtnHtml;
        
        footerDiv.appendChild(reactionsDiv);
      } catch (reactionError) {
        warnLog('createAnswerCard: Reactions div creation error:', reactionError);
      }
      
      fragment.appendChild(contentDiv);
      fragment.appendChild(footerDiv);
      card.appendChild(fragment);
      
      if (safeData.highlight) {
        try {
          const badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } catch (badgeError) {
          warnLog('createAnswerCard: Highlight badge creation error:', badgeError);
        }
      }
      
      // 統一されたリアクションスタイルを適用
      try {
        this.applyReactionStyles(card, safeData);
      } catch (styleError) {
        warnLog('createAnswerCard: Reaction styles application error:', styleError);
      }
      
      // Cache the card for reuse (limit cache size)
      try {
        if (this.cache.size > 100) {
          this.cache.cleanup();
        }
        this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
      } catch (cacheError) {
        warnLog('createAnswerCard: Cache storage error:', cacheError);
      }
      
      return card;
      
    } catch (error) {
      errorLog('createAnswerCard: Critical error creating card:', error, 'Data:', data);
      
      // Return a minimal error card instead of null
      try {
        const errorCard = document.createElement('div');
        errorCard.className = 'answer-card glass-panel rounded-xl p-4 border-2 border-red-400/50 bg-red-900/20';
        errorCard.innerHTML = `
          <div class="text-red-300 text-center">
            <div class="mb-2">⚠️ カード表示エラー</div>
            <div class="text-xs text-red-400">データ処理中に問題が発生しました</div>
          </div>
        `;
        return errorCard;
      } catch (fallbackError) {
        errorLog('createAnswerCard: Fallback card creation also failed:', fallbackError);
        return null;
      }
    }
  }
  
  createSkeletonCard() {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
    // Simplified skeleton for faster rendering
    card.innerHTML = '<div class="h-20 w-full rounded bg-gray-500/30 mb-4"></div><div class="h-6 w-full rounded bg-gray-500/20"></div>';
    return card;
  }

  /**
   * リアクション処理（既存キューイングシステム＋オプショナルバッチ処理）
   */
  async handleReaction(rowIndex, reaction) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;

    const now = Date.now();
    const lastOperation = this.lastReactionTimes?.get(reactionKey);
    if (lastOperation && (now - lastOperation) < 1000) {
      debugLog(`⚡ 重複操作スキップ: ${reactionKey}`);
      return;
    }

    if (this.pendingReactions.has(reactionKey)) {
      debugLog(`⏳ 処理中のためスキップ: ${reactionKey}`);
      return;
    }

    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    if (!item) {
      warnLog(`⚠️ アイテムが見つかりません: rowIndex=${numericRowIndex}`);
      return;
    }

    const buttons = document.querySelectorAll(`[data-row-index="${numericRowIndex}"][data-reaction="${reaction}"]`);
    this.setReactionButtonsLoading(buttons, true);

    const currentState = item.reactions?.[reaction]?.reacted || false;
    if (item.reactions && item.reactions[reaction]) {
      item.reactions[reaction].reacted = !currentState;
      item.reactions[reaction].count = currentState
        ? Math.max(0, (item.reactions[reaction].count || 1) - 1)
        : (item.reactions[reaction].count || 0) + 1;

      // Update card reactions using the efficient batch approach
      const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
      if (card) this.updateCardReactions(card, item);
    }

    this.reactionQueue.set(reactionKey, {
      rowIndex: numericRowIndex,
      reaction,
      timestamp: now,
      originalState: currentState
    });

    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(reactionKey, now);

    if (this.enableBatchProcessing && !this.batchProcessingActive) {
      this.addToBatchQueue(numericRowIndex, reaction);
    }

    this.processReactionQueue();
  }

  async processReactionQueue() {
    if (this.isProcessingReactionQueue) return;
    this.isProcessingReactionQueue = true;

    const processingStart = Date.now();
    let processedCount = 0;
    let errorCount = 0;

    try {
      
      // バッチ処理が有効で、キューに複数アイテムがある場合はバッチ処理を試行
      if (this.enableBatchProcessing && this.reactionQueue.size > 1 && !this.batchProcessingActive) {
        const canBatch = await this.tryBatchProcessing();
        if (canBatch) {
          // バッチ処理成功時は個別キューをクリア
          processedCount = this.reactionQueue.size;
          this.reactionQueue.clear();
          return;
        }
        // バッチ処理失敗時は既存の個別処理にフォールバック
      }

      // 既存の個別処理システム（完全に保持）
      const queueEntries = Array.from(this.reactionQueue.entries());
      
      for (const [reactionKey, operation] of queueEntries) {
        try {
          this.reactionQueue.delete(reactionKey);
          await this.processReaction(operation, reactionKey);
          processedCount++;
        } catch (error) {
          errorCount++;
          errorLog(`❌ 個別リアクション処理エラー (${reactionKey}):`, error);
          
          // エラー時の復旧処理
          await this.handleReactionError(error, operation.rowIndex, operation.reaction);
        }
      }
      
    } catch (error) {
      errorLog('❌ リアクションキュー処理致命的エラー:', error);
      errorCount++;
    } finally {
      this.isProcessingReactionQueue = false;
      
      const processingTime = Date.now() - processingStart;
      debugLog(`📊 リアクションキュー処理完了: ${processedCount}件成功, ${errorCount}件エラー, ${processingTime}ms`);
      
      // 残っているキューがある場合の警告
      if (this.reactionQueue.size > 0) {
        warnLog(`⚠️ キュー処理後も${this.reactionQueue.size}件が残っています`);
      }
      
      // エラー率が高い場合の対処
      if (errorCount > 0 && errorCount / (processedCount + errorCount) > 0.5) {
        warnLog('🚨 リアクション処理エラー率が高いです。システム状態を確認してください。');
      }
    }
  }

  async processReaction(operation, reactionKey) {
    const { rowIndex, reaction } = operation;

    this.pendingReactions.add(reactionKey);

    try {
        const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
        if (!item) {
            throw new Error(`Item not found for rowIndex: ${rowIndex}`);
        }

        // Use executeWithRetry for robust async reaction processing
        await this.executeWithRetry(async (attempt) => {
            debugLog(`📡 リアクション送信 (試行 ${attempt + 1}):`, { rowIndex, reaction, sheetName: this.state.sheetName });

            // Server-first approach with retry support
            const response = await this.sendReactionToServer(rowIndex, reaction);
            await this.processResponse(item, response, reaction);

            // UI update (only after successful server response)
            await this.updateReactionUI(item, false);

            return response;
        }, {
            maxRetries: 2,
            baseDelay: 500,
            context: `リアクション処理 (${reactionKey})`,
            retryCondition: (error) => {
                // Retry on network errors, timeouts, or temporary server issues
                const retryableErrors = [
                    'network', 'timeout', 'temporarily unavailable',
                    'server error', 'service unavailable'
                ];
                return retryableErrors.some(errorType =>
                    error.message.toLowerCase().includes(errorType)
                );
            }
        });

        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: true });

    } catch (error) {
        errorLog('❌ リアクション処理エラー:', error);
        await this.handleReactionError(error, rowIndex, reaction);
        this.notifyReactionComplete(reactionKey, { rowIndex, reaction, success: false, error: error.message });
    } finally {
        this.pendingReactions.delete(reactionKey);

        // Ensure loading state is cleared for all matching buttons
        const btns = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
        this.setReactionButtonsLoading(btns, false);

        // Additional safety: clear any remaining loading states for this row
        setTimeout(() => {
          const allBtns = document.querySelectorAll(`[data-row-index="${rowIndex}"].loading`);
          allBtns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
            btn.setAttribute('aria-busy', 'false');
          });
        }, 100);
    }
  }

  notifyReactionComplete(reactionKey, result) {
    const listeners = this.reactionEventListeners.get(reactionKey);
    if (listeners && listeners.length > 0) {
      listeners.forEach(listener => {
        try {
          listener(result);
        } catch (error) {
          errorLog('❌ リアクション完了リスナーエラー:', error);
        }
      });
      this.reactionEventListeners.delete(reactionKey);
    }
  }

  waitForReactionComplete(reactionKey, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.reactionEventListeners.delete(reactionKey);
        reject(new Error(`Reaction timeout: ${reactionKey}`));
      }, timeout);

      const listener = (result) => {
        clearTimeout(timeoutId);
        resolve(result);
      };

      if (!this.reactionEventListeners.has(reactionKey)) {
        this.reactionEventListeners.set(reactionKey, []);
      }
      this.reactionEventListeners.get(reactionKey).push(listener);
    });
  }

  // 動的状態変化待機システム
  async waitForReactionStateChange(rowIndex, reaction, initialState, timeoutMs = 3000, pollIntervalMs = 50) {
    const startTime = Date.now();
    
    const getReactionButtonState = () => {
      const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
      if (buttons.length === 0) return null;
      
      const btn = buttons[0];
      return {
        reacted: btn.getAttribute('aria-pressed') === 'true',
        count: parseInt(btn.querySelector('.count')?.textContent || '0'),
        disabled: btn.disabled,
        classes: btn.className,
        timestamp: Date.now()
      };
    };
    
    const hasStateChanged = (current, initial) => {
      if (!current || !initial) return false;
      return current.reacted !== initial.reacted || 
             current.count !== initial.count ||
             current.disabled !== initial.disabled;
    };
    
    return new Promise((resolve, reject) => {
      const poll = () => {
        const currentTime = Date.now();
        if (currentTime - startTime >= timeoutMs) {
          reject(new Error(`State change timeout after ${timeoutMs}ms`));
          return;
        }
        
        const currentState = getReactionButtonState();
        if (hasStateChanged(currentState, initialState)) {
          resolve({
            initialState,
            currentState,
            changeDetectedAt: currentTime - startTime,
            stateChanged: true
          });
          return;
        }
        
        setTimeout(poll, pollIntervalMs);
      };
      
      poll();
    });
  }

  // シンプルなリアクション状態監視（通知システム中心）
  async waitForReactionUpdate(rowIndex, reaction, expectedChange = null, maxWaitMs = 3000) {
    const reactionKey = `${rowIndex}-${reaction}`;
    
    try {
      // 完了通知システムのみを使用（シンプルで信頼性が高い）
      const result = await this.waitForReactionComplete(reactionKey, maxWaitMs);
      return result || { timeout: false, success: true };
    } catch (error) {
      warnLog(`⚠️ リアクション待機タイムアウト: ${reactionKey}`, error.message);
      return { 
        error: error.message, 
        timeout: true,
        success: false
      };
    }
  }

  // リアクションボタン状態取得ヘルパー
  getReactionButtonState(rowIndex, reaction) {
    const buttons = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
    if (buttons.length === 0) return null;
    
    const btn = buttons[0];
    return {
      reacted: btn.getAttribute('aria-pressed') === 'true',
      count: parseInt(btn.querySelector('.count')?.textContent || '0'),
      disabled: btn.disabled,
      classes: btn.className,
      visible: btn.style.display !== 'none',
      computedStyle: getComputedStyle(btn),
      timestamp: Date.now()
    };
  }

  // バッチ処理関連メソッド（既存機能に影響しない追加機能）
  
  addToBatchQueue(rowIndex, reaction) {
    try {
      if (!this.reactionBatchQueue.has(rowIndex)) {
        this.reactionBatchQueue.set(rowIndex, []);
      }
      
      const batchForRow = this.reactionBatchQueue.get(rowIndex);
      const existingIndex = batchForRow.findIndex(r => r.reaction === reaction);
      
      if (existingIndex >= 0) {
        // 既存リアクションのタイムスタンプを更新
        batchForRow[existingIndex].timestamp = Date.now();
      } else {
        // 新しいリアクションを追加
        batchForRow.push({
          reaction,
          timestamp: Date.now()
        });
      }
      
      // バッチサイズ制限チェック
      const totalBatchSize = Array.from(this.reactionBatchQueue.values())
        .reduce((sum, reactions) => sum + reactions.length, 0);
      
      if (totalBatchSize >= this.BATCH_SIZE_LIMIT) {
        this.processBatchQueue();
      }
    } catch (error) {
      warnLog('バッチキュー追加エラー（個別処理にフォールバック）:', error);
      // エラー時は何もしない（既存の個別処理が動作）
    }
  }

  async tryBatchProcessing() {
    try {
      if (this.batchProcessingActive || this.reactionQueue.size === 0) {
        return false;
      }

      this.batchProcessingActive = true;

      // キューからバッチ操作を準備
      const batchOperations = Array.from(this.reactionQueue.values());
      
      if (batchOperations.length === 1) {
        // 単一操作の場合はバッチ処理しない
        this.batchProcessingActive = false;
        return false;
      }

      // サーバ側のバッチAPIは使用せず、直接逐次送信
      const responseData = [];
      for (const op of batchOperations) {
        try {
          const r = await this.gas.addReaction(op.rowIndex, op.reaction, this.state.sheetName);
          const ok = r && (r.success === true || r.status === 'success');
          if (ok) {
            responseData.push({ rowIndex: op.rowIndex, reactions: r.reactions || null, reaction: op.reaction });
          }
          const reactionKey = `${op.rowIndex}-${op.reaction}`;
          this.notifyReactionComplete(reactionKey, { success: ok, batch: true });
        } catch (e) {
          const reactionKey = `${op.rowIndex}-${op.reaction}`;
          this.notifyReactionComplete(reactionKey, { success: false, error: e?.message || String(e), batch: true });
        }
      }

      if (responseData.length > 0) {
        this.processBatchReactionResponse(responseData, batchOperations);
        return true;
      }
      warnLog('バッチ処理失敗、個別処理にフォールバック');
      return false;
    } catch (error) {
      warnLog('バッチ処理エラー、個別処理にフォールバック:', error);
      return false;
    } finally {
      this.batchProcessingActive = false;
    }
  }

  processBatchReactionResponse(responseData, originalOperations) {
    try {
      if (!responseData || !Array.isArray(responseData)) {
        warnLog('無効なバッチレスポンス、個別処理で続行');
        return;
      }
      
      responseData.forEach(rowData => {
        const item = this.state.currentAnswers.find(i => i.rowIndex == rowData.rowIndex);
        if (item) {
          this.processResponse(item, rowData, rowData.reaction);
        }
      });
      
    } catch (error) {
      errorLog('バッチレスポンス処理エラー:', error);
    }
  }

  setReactionButtonsLoading(buttons, isLoading) {
    buttons.forEach(btn => {
        btn.disabled = isLoading;
        if (isLoading) {
            btn.classList.add('loading');
            btn.setAttribute('aria-busy', 'true');
        } else {
            btn.classList.remove('loading');
            btn.setAttribute('aria-busy', 'false');
        }
    });
  }

  async sendReactionToServer(rowIndex, reaction) {
    try {
      const response = await this.gas.addReaction(rowIndex, reaction, this.state.sheetName);

      if (!response) {
          throw new Error('サーバーからの応答がありません');
      }

      const success = response.success === true || response.status === 'success';
      if (!success) {
          throw new Error(response.message || 'リアクション送信に失敗しました');
      }

      return response;
    } catch (error) {
      // エラータイプを判定して適切なメッセージを返す
      if (error.userMessage) {
        throw new Error(error.userMessage);
      } else if (error.message && error.message.includes('timeout')) {
        throw new Error('サーバーへの接続がタイムアウトしました。ネットワーク接続を確認してください。');
      } else if (error.message && error.message.includes('無効')) {
        throw new Error('無効なリアクションです。ページを更新してください。');
      } else {
        throw error; // 元のエラーをそのまま投げる
      }
    }
  }

  async processResponse(item, response, reaction) {
    // Handle new user-based backend format: {success, reactions, userReaction, newValue}
    if (response.success && response.reactions && typeof response.reactions === 'object') {
        // New user-based backend format: complete server state with user context
        const serverState = response.reactions;
        item.reactions = JSON.parse(JSON.stringify(serverState));

        // Log user reaction state for debugging
        debugLog('✅ Processed user-based backend format:', {
            reaction,
            userReaction: response.userReaction,
            allReactions: response.reactions,
            item: item.reactions
        });
    } else if (response.reactions && typeof response.reactions === 'object') {
        // Legacy format: complete server state (without success flag)
        const serverState = response.reactions;
        item.reactions = JSON.parse(JSON.stringify(serverState));
        debugLog('✅ Processed legacy backend format:', { reaction, item: item.reactions });
    } else if (response.success && typeof response.newValue === 'number') {
        // Old simple backend format: update specific reaction only
        if (!item.reactions) item.reactions = {};
        if (!item.reactions[reaction]) {
            item.reactions[reaction] = { count: 0, reacted: false };
        }
        item.reactions[reaction].count = response.newValue;
        item.reactions[reaction].reacted = response.newValue > 0; // Assume user reacted if count > 0
        debugLog('✅ Processed simple backend format:', { reaction, newValue: response.newValue, item: item.reactions });
    } else {
        warnLog('⚠️ 期待されたリアクション形式ではありません:', response);
        // フォールバック処理（サーバー応答が不正な場合のみ）
        this.applyFallbackReactionUpdate(item, reaction);
    }

    // ローカルストレージに保存（サーバー状態を保存）
    this.saveReactionState(item.rowIndex, item.reactions);
}

  applyFallbackReactionUpdate(item, reaction) {
    if (!item.reactions) {
        item.reactions = {};
    }
    
    // 他のリアクションをまず解除
    this.reactionTypes.forEach(rt => {
      if (rt.key !== reaction && item.reactions[rt.key]?.reacted) {
        item.reactions[rt.key].count = Math.max(0, item.reactions[rt.key].count - 1);
        item.reactions[rt.key].reacted = false;
      }
    });
    
    if (!item.reactions[reaction]) {
        item.reactions[reaction] = { count: 0, reacted: false };
    }
    
    // Toggle reaction state
    if (item.reactions[reaction].reacted) {
        item.reactions[reaction].count = Math.max(0, item.reactions[reaction].count - 1);
        item.reactions[reaction].reacted = false;
    } else {
        item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
        item.reactions[reaction].reacted = true;
    }
  }

  // 即座UI更新（requestAnimationFrameを使わない同期更新）
  async immediateUIUpdate(rowIndex, reaction) {
    const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
    if (!item || !item.reactions || !item.reactions[reaction]) {
      warnLog('⚠️ immediateUIUpdate: アイテムまたはリアクション状態が見つかりません');
      return;
    }

    try {
      // カードのUI更新（同期実行）
      const card = document.querySelector(`[data-row-index="${rowIndex}"]`);
      if (card && card instanceof HTMLElement) {
        this.updateCardReactions(card, item);
        this.applyReactionStyles(card, item);
      }

      // モーダルが開いている場合はそちらも更新
      if (!this.elements.answerModalContainer.classList.contains('hidden')) {
        const modalRowIndex = this.elements.modalReactionContainer
          .querySelector('[data-row-index]')?.dataset.rowIndex;
        if (modalRowIndex == rowIndex) {
          this.updateModalReactionButtons(item);
        }
      }

      debugLog('⚡ 即座UI更新完了:', { rowIndex, reaction });
    } catch (error) {
      errorLog('❌ 即座UI更新エラー:', error);
    }
  }

  async updateReactionUI(item, immediate = false) {
      const lastUpdateKey = `ui_update_${item.rowIndex}`;
    const currentStateHash = this.calculateStateHash(item);
    const lastStateHash = this.lastUIStates?.get(lastUpdateKey);

    if (lastStateHash === currentStateHash && !immediate) {
      debugLog(`⚡ UI更新スキップ (変更なし): rowIndex=${item.rowIndex}`);
      return;
    }

    if (!this.lastUIStates) this.lastUIStates = new Map();
    this.lastUIStates.set(lastUpdateKey, currentStateHash);

    if (immediate) {
      try {
        const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
        if (card && card instanceof HTMLElement) {
          this.updateCardReactions(card, item);
          this.applyReactionStyles(card, item);
        } else {
          warnLog('⚠️ カード要素が見つかりません:', item.rowIndex);
        }

        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex = this.elements.modalReactionContainer
            .querySelector('[data-row-index]')?.dataset.rowIndex;
          if (modalRowIndex == item.rowIndex) {
            this.updateModalReactionButtons(item);
            this.applyReactionStyles(this.elements.answerModalCard, item);
          }
        }

      } catch (error) {
        errorLog('❌ UI即座更新エラー:', error);
      }
      return;
    }

    return new Promise(resolve => {
        requestAnimationFrame(() => {
            try {
                const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
                if (card && card instanceof HTMLElement) {
                    this.updateCardReactions(card, item);
                    this.applyReactionStyles(card, item);
                } else {
                    warnLog('⚠️ カード要素が見つかりません:', item.rowIndex);
                }

                if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                    const modalRowIndex = this.elements.modalReactionContainer
                      .querySelector('[data-row-index]')?.dataset.rowIndex;
                    if (modalRowIndex == item.rowIndex) {
                      this.updateModalReactionButtons(item);
                      this.applyReactionStyles(this.elements.answerModalCard, item);
                    }
                }

                resolve();
            } catch (error) {
                errorLog('UI更新エラー:', error);
                resolve();
            }
        });
    });
  }

  getScopedKey(base) {
    const userId = this.state?.userId || USER_ID;
    return `${base}_${userId}_${SHEET_NAME}`;
  }

  // lastSeenCount永続化機能
  loadLastSeenCount() {
    try {
      const key = this.getScopedKey('lastSeenCount');
      const stored = localStorage.getItem(key);
      const count = stored ? parseInt(stored, 10) : 0;
      
      debugLog('📥 lastSeenCount復元:', { key, count });
      return isNaN(count) ? 0 : count;
    } catch (error) {
      warnLog('⚠️ lastSeenCount読み込みエラー:', error);
      return 0;
    }
  }

  // 真の初回ボードアクセス判定
  isFirstTimeBoardAccess() {
    try {
      const hasLastSeen = localStorage.getItem(this.getScopedKey('lastSeenCount')) !== null;
      const hasDiffCards = localStorage.getItem(this.getScopedKey('differentialCards')) !== null;
      const hasInitialLoad = this.initialDataLoaded === true;
      const container = this.elements?.answersContainer;
      const hasDOMCards = container && container.querySelectorAll('.answer-card').length > 0;
      const isFirstTime = !hasLastSeen && !hasDiffCards && !hasInitialLoad && !hasDOMCards;
      
      debugLog('🔍 初回判定結果:', {
        hasLastSeen,
        hasDiffCards,
        hasInitialLoad,
        hasDOMCards,
        isFirstTime
      });
      
      return isFirstTime;
    } catch (error) {
      warnLog('⚠️ 初回判定エラー:', error);
      return false;
    }
  }

  saveLastSeenCount(count) {
    try {
      const key = this.getScopedKey('lastSeenCount');
      localStorage.setItem(key, count.toString());
      
      debugLog('💾 lastSeenCount保存:', { key, count });
    } catch (error) {
      warnLog('⚠️ lastSeenCount保存エラー:', error);
    }
  }

  updateLastSeenCount(newCount) {
    if (typeof newCount === 'number' && newCount >= 0) {
      const oldCount = this.state.lastSeenCount;
      this.state.lastSeenCount = newCount;
      this.saveLastSeenCount(newCount);
      
      debugLog('📊 lastSeenCount更新:', { 
        oldCount, 
        newCount,
        timestamp: new Date().toISOString()
      });
    }
  }

  // 差分カード管理メソッド
  loadDifferentialCards() {
    try {
      const key = this.getScopedKey('differentialCards');
      const stored = localStorage.getItem(key);
      const cards = stored ? JSON.parse(stored) : [];
      
      debugLog('📥 差分カード復元:', { key, count: cards.length });
      return Array.isArray(cards) ? cards : [];
    } catch (error) {
      warnLog('⚠️ 差分カード読み込みエラー:', error);
      return [];
    }
  }

  saveDifferentialCards(cardIds) {
    try {
      const key = this.getScopedKey('differentialCards');
      const existing = this.loadDifferentialCards();
      const merged = [...new Set([...existing, ...cardIds])];
      localStorage.setItem(key, JSON.stringify(merged));
      
      debugLog('💾 差分カード保存:', { key, count: merged.length, new: cardIds.length });
    } catch (error) {
      warnLog('⚠️ 差分カード保存エラー:', error);
    }
  }

  clearDifferentialCards() {
    try {
      const key = this.getScopedKey('differentialCards');
      localStorage.removeItem(key);
    } catch (error) {
      warnLog('⚠️ 差分カードクリアエラー:', error);
    }
  }

  // 差分カードの復元（ページ再読み込み時）
  restoreDifferentialCards() {
    const differentialCardIds = this.loadDifferentialCards();
    if (differentialCardIds.length === 0) return;

    
    const container = this.elements.answersContainer;
    if (!container) return;

    const allCards = container.querySelectorAll('.answer-card');
    let restoredCount = 0;
    
    allCards.forEach(card => {
      const rowIndex = parseInt(card.getAttribute('data-row-index'));
      if (differentialCardIds.includes(rowIndex)) {
        card.setAttribute('data-differential-card', 'true');
        card.setAttribute('data-restored', 'true');
        restoredCount++;
        debugLog('📌 差分カード復元:', rowIndex);
      }
    });
    
  }

  async handleReactionError(error, rowIndex, reaction) {
    errorLog('リアクションエラーの詳細:', {
        error: error.message,
        rowIndex,
        reaction,
        timestamp: new Date().toISOString()
    });
    
    // エラー復旧処理を追加
    try {
      // UI状態を元に戻す（楽観的更新の取り消し）
      const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
      if (item && item.reactions && item.reactions[reaction]) {
        const wasReacted = item.reactions[reaction].reacted;
        item.reactions[reaction].reacted = !wasReacted;
        if (wasReacted) {
          item.reactions[reaction].count = Math.max(0, (item.reactions[reaction].count || 1) - 1);
        } else {
          item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
        }

        // Update card reactions using the efficient batch approach
      const card = document.querySelector(`[data-row-index="${item.rowIndex}"]`);
      if (card) this.updateCardReactions(card, item);
      }
    } catch (recoveryError) {
      warnLog('⚠️ リアクションエラー復旧処理に失敗:', recoveryError);
    }
    
    // ユーザーにエラーを表示（オプション）
    if (window.messageManager) {
        window.messageManager.show(
            'リアクションの処理に失敗しました。再度お試しください。',
            'error',
            3000
        );
    }
  }

  
  showErrorFeedback(btn, message) {
    if (!btn) return;
    
    // 元のクラスを保存
    const originalClasses = btn.className;
    
    // エラー表示
    btn.classList.add('bg-red-500');
    btn.title = message;
    
    // 2秒後に元に戻す
    setTimeout(() => {
      btn.className = originalClasses;
      btn.title = '';
    }, 2000);
  }
  
  async handleHighlight(rowIndex) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const highlightKey = `${numericRowIndex}-highlight`;

    if (this.highlightDebounce.has(highlightKey)) {
      clearTimeout(this.highlightDebounce.get(highlightKey));
      return;
    }

    const now = Date.now();
    const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
    if (now - lastHighlightTime < StudyQuestApp.CONSTANTS.HIGHLIGHT_RATE_LIMIT_MS) {
      return;
    }

    if (this.pendingReactions.has(highlightKey)) {
      return;
    }

    this.pendingReactions.add(highlightKey);
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(highlightKey, now);

    const btns = document.querySelectorAll('.highlight-btn[data-row-index="' + numericRowIndex + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);

    if (!item) {
      this.pendingReactions.delete(highlightKey);
      return;
    }

    btns.forEach(btn => {
        btn.classList.add('loading');
        btn.disabled = true;
    });

    try {
        // Use executeWithRetry for robust async highlight processing
        const res = await this.executeWithRetry(async (attempt) => {
            debugLog(`🔥 ハイライト処理 (試行 ${attempt + 1}):`, { rowIndex: numericRowIndex, sheetName: this.state.sheetName });

            const response = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);

            const ok = response && (response.success === true || response.status === 'success');
            if (ok) {
                return response;
            } else {
                throw new Error(response?.message || 'ハイライトの処理に失敗しました');
            }
        }, {
            maxRetries: 2,
            baseDelay: 300,
            context: `ハイライト処理 (${highlightKey})`,
            retryCondition: (error) => {
                // Don't retry permission errors
                if (error.message && error.message.includes('管理者のみ')) {
                    return false;
                }
                // Retry on network/server errors
                const retryableErrors = ['network', 'timeout', 'server error', 'temporarily unavailable'];
                return retryableErrors.some(errorType =>
                    error.message.toLowerCase().includes(errorType)
                );
            }
        });

        // Apply highlight result with async DOM updates
        const highlighted = typeof res.highlighted === 'boolean' ? res.highlighted : !item.highlight;
        item.highlight = highlighted;

        // Use batch DOM updates for better performance
        this.batchDOMUpdates([
            () => this.applyUpdates([item])
        ]);

        // Update modal if open
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
            const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
            if (modalRowIndex == numericRowIndex) {
                requestAnimationFrame(() => this.updateModalContent(item));
            }
        }

        // Schedule async verification
        setTimeout(() => {
            this.verifyHighlightSync(numericRowIndex, res.highlight);
        }, 1000);

    } catch (error) {
        errorLog('Failed to toggle highlight:', error);

        if (error.message && error.message.includes('管理者のみ')) {
            this.showErrorFeedback(btns[0], '権限エラー: 管理者のみ利用可能です');
            warnLog('ハイライト機能は管理者のみ利用可能です');
        } else {
            this.showErrorFeedback(btns[0], 'ハイライトに失敗しました');
        }
    } finally {
        btns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
    }
  }

  async verifyHighlightSync(rowIndex, expectedHighlight) {
    try {
      const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
      if (!item) return;

      if (item.highlight !== expectedHighlight) {
        warnLog(`⚠️ ハイライト状態不整合検出: rowIndex=${rowIndex}, UI=${item.highlight}, Expected=${expectedHighlight}`);

        item.highlight = expectedHighlight;
        requestAnimationFrame(() => this.applyUpdates([item]));

        debugLog('✅ ハイライト状態を修正しました');
      } else {
        debugLog('✅ ハイライト状態同期確認: 正常');
      }
    } catch (error) {
      errorLog('ハイライト状態同期確認エラー:', error);
    }
  }

  // Data integrity management

  // 不整合の自動修復
  async fixSyncIssues(healthCheckResult) {
    if (!healthCheckResult.issues || healthCheckResult.issues.length === 0) {
      return { fixed: 0, skipped: 0 };
    }
    
    let fixed = 0;
    let skipped = 0;
    
    for (const issue of healthCheckResult.issues) {
      try {
        switch (issue.type) {
          case 'ui_data_inconsistency':
            for (const inconsistency of issue.data) {
              const item = this.state.currentAnswers.find(i => i.rowIndex === inconsistency.rowIndex);
              if (item) {
                await this.applyUpdates([item]);
                fixed++;
              }
            }
            break;
            
          case 'data_staleness':
            debugLog('🔄 古いデータを検出、強制リフレッシュ実行');
            await this.forceDataRefresh();
            fixed++;
            break;
            
          case 'cache_bloat':
            if (this.cache && typeof this.cache.clear === 'function') {
              this.cache.clear();
              fixed++;
            }
            break;
            
          default:
            skipped++;
            break;
        }
      } catch (fixError) {
        errorLog(`修復失敗 (${issue.type}):`, fixError);
        skipped++;
      }
    }
    
    debugLog(`🔧 自動修復完了: ${fixed}件修復, ${skipped}件スキップ`);
    return { fixed, skipped };
  }

  // State hash calculation utilities

  // アイテム状態のハッシュを計算（変更検出用）
  calculateStateHash(item) {
    const state = {
      reactions: item.reactions,
      highlight: item.highlight,
      rowIndex: item.rowIndex
    };
    return JSON.stringify(state);
  }

  // バッチ処理の健全性チェック

  // 通知システムの健全性チェック
  validateNotificationSystem() {
    debugLog('🔍 通知システム健全性チェック');
    
    const issues = [];
    
    // 1. 通知バナー要素の存在確認
    if (!this.elements.newContentBanner) {
      issues.push('newContentBanner要素が見つかりません');
    }
    if (!this.elements.newContentText) {
      issues.push('newContentText要素が見つかりません');
    }
    if (!this.elements.refreshContentBtn) {
      issues.push('refreshContentBtn要素が見つかりません');
    }
    
    // 2. 初期化状態の確認
    if (this.initialDataLoaded === undefined) {
      issues.push('initialDataLoaded状態が未定義です');
    }
    if (this.hadInitialDataLoadFailure === undefined) {
      issues.push('hadInitialDataLoadFailure状態が未定義です');
    }
    
    // 3. 通知状態の確認
    if (this.state.lastSeenCount === undefined) {
      issues.push('lastSeenCount状態が未定義です');
    }
    
    // 4. ポーリング状態の確認
    if (!this.pollingSettings || this.pollingSettings.enabled === undefined) {
      issues.push('ポーリング設定が不正です');
    }
    
    // 5. 結果
    if (issues.length === 0) {
      debugLog('✅ 通知システム健全性: 正常');
      return { status: 'healthy', issues: [] };
    } else {
      warnLog('⚠️ 通知システム健全性: 問題検出', issues);
      return { status: 'issues_detected', issues };
    }
  }
  
  async toggleAdminMode() {
    // Temporarily disable button to prevent duplicate clicks
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.disabled = true;
    }
    
    try {
      const enable = !this.state.showAdminFeatures;
      
      // 管理者権限チェック
      if (enable) {
        if (!this.state.isAdminUser || !window.hasAdminCapability) {
          warnLog('管理者権限がありません。');
          return;
        }
        
        // 管理モード移行時の確認モーダル
        const confirmed = await this.showAdminModeConfirmation();
        if (!confirmed) {
          return; // ユーザーがキャンセルした場合
        }
        
        // 最初の管理モード切り替え時のみサーバー側で再確認（オプション）
        if (!this.adminModeVerified) {
          try {
            const ok = await this.gas.checkAdmin();
            if (!ok) {
              warnLog('サーバー側の権限確認に失敗しました。');
              // ローカルの権限情報を信頼して継続
            }
            this.adminModeVerified = true;
          } catch (e) {
            warnLog('権限確認API呼び出しに失敗しました', e);
            // エラーが発生してもローカルの権限情報を信頼して継続
          }
        }
      }
      
      // グローバル設定を更新
      window.showAdminFeatures = enable;
      window.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
      
      debugLog('toggleAdminMode状態更新:', {
        enable,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: window.showAdminFeatures,
        showHighlightToggle: window.showHighlightToggle
      });
      if (enable) {
        // 管理モード時は強制的に名前とリアクション数を表示
        window.showCounts = true;
        window.displayMode = 'named';
        window.isStudentMode = false;
        window.showScoreSort = window.showCounts;
        debugLog('管理モード有効化: 名前とリアクション数を強制表示', {
          showCounts: window.showCounts,
          displayMode: window.displayMode
        });
      } else {
        // 閲覧モード時はサーバー設定に戻す
        window.showCounts = this.serverShowCounts;
        window.displayMode = this.serverDisplayMode;
        window.isStudentMode = true;
        window.showScoreSort = window.showCounts;
        debugLog('閲覧モード有効化: サーバー設定を復元', {
          showCounts: window.showCounts,
          displayMode: window.displayMode,
          serverShowCounts: this.serverShowCounts,
          serverDisplayMode: this.serverDisplayMode
        });
      }
      
      // 管理モード有効時は強制的にローカル状態も更新
      if (enable) {
        this.state.displayMode = 'named';
        this.state.showCounts = true;
        this.state.isStudentMode = false;
      } else {
        this.state.displayMode = this.serverDisplayMode;
        this.state.showCounts = this.serverShowCounts;
        this.state.isStudentMode = true;
      }
      
      // Update local state from global variables (but preserve displayMode if in admin mode)
      this.updateConfigFromGlobals();
      
      // Re-enforce admin mode settings after updateConfigFromGlobals
      if (enable) {
        this.state.displayMode = 'named';
        this.state.showCounts = true;
      }
      
      // 管理モード切り替え後の状態を確認
      debugLog('管理モード切り替え後の状態確認:', {
        enable,
        stateDisplayMode: this.state.displayMode,
        stateShowCounts: this.state.showCounts,
        windowDisplayMode: window.displayMode,
        windowShowCounts: window.showCounts
      });
      
      // キャッシュをクリアして新しい設定で再描画
      this.cache.clear();
      
      // 管理モード切り替え時は既存のカードを全て削除して強制再生成
      this.elements.answersContainer.innerHTML = '';
      
      // UI状態を更新
      this.updateSortOptions();
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      // 管理モード切り替え時は設定変更のため再描画が必要
      this.loadSheetData({ bypassCache: true }).then(() => {
        // 管理モード切り替え後に新着チェックの基準を更新
        this.updateLastSeenCount(this.state.currentAnswers.length);
        debugLog('🔄 管理モード切り替え完了、新着チェック基準更新:', {
          newBaselineCount: this.state.lastSeenCount,
          adminMode: this.state.showAdminFeatures
        });
      });
    } finally {
      // Re-enable button
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.disabled = false;
      }
    }
  }
  
  /**
   * 管理モード移行確認モーダル
   */
  async showAdminModeConfirmation() {
    return new Promise((resolve) => {
      // モーダル要素を作成
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
          <div class="flex items-center mb-4">
            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center">
              <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
              </svg>
            </div>
            <div class="ml-4">
              <h3 class="text-lg font-medium text-gray-900">管理モードに切り替えますか？</h3>
            </div>
          </div>
          <div class="mb-6">
            <p class="text-sm text-gray-600">
              管理モードでは、<strong>生徒の名前とリアクション数が表示</strong>されます。<br>
              画面共有時などは十分注意してください。
            </p>
          </div>
          <div class="flex justify-end space-x-3">
            <button type="button" class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
              キャンセル
            </button>
            <button type="button" class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-orange-600 border border-transparent rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
              管理モードに切り替え
            </button>
          </div>
        </div>
      `;
      
      // イベントリスナーを追加
      const cancelBtn = modal.querySelector('.cancel-btn');
      const confirmBtn = modal.querySelector('.confirm-btn');
      
      const cleanup = () => {
        document.body.removeChild(modal);
      };
      
      cancelBtn.addEventListener('click', () => {
        cleanup();
        resolve(false);
      });
      
      confirmBtn.addEventListener('click', () => {
        cleanup();
        resolve(true);
      });
      
      // Escapeキーでキャンセル
      const handleKeydown = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          document.removeEventListener('keydown', handleKeydown);
          resolve(false);
        }
      };
      document.addEventListener('keydown', handleKeydown);
      
      // モーダルを表示
      document.body.appendChild(modal);
      
      // フォーカスを確認ボタンに移動
      setTimeout(() => confirmBtn.focus(), 100);
    });
  }
  
  async endPublication() {
    if (!confirm('公開を終了しますか？生徒は回答ボードにアクセスできなくなります。')) {
      return;
    }
    
    // ボタンのローディング状態を設定
    const endPublicationBtn = this.elements.endPublicationBtn;
    let originalButtonContent = '';
    if (endPublicationBtn) {
      originalButtonContent = endPublicationBtn.innerHTML;
      endPublicationBtn.disabled = true;
      endPublicationBtn.innerHTML = `
        <svg class="w-3 h-3 animate-spin inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        公開終了中...
      `;
    }
    
    try {
      
      // サーバーに公開終了リクエストを送信
      const result = await this.runGas('clearActiveSheet', this.state.userId);
      
      
      // 成功メッセージを表示
      const successMessage = result.message || '公開を終了しました。非公開画面に移動します。';
      if (window.sharedModals) {
        window.sharedModals.showAlert('公開終了', successMessage, 'success');
      } else {
        alert(successMessage);
      }
      
      // 少し遅延してからUnpublished.htmlに移動（ユーザーがメッセージを確認できるように）
      setTimeout(() => {
        this.redirectToUnpublishedPage();
      }, 1500);
      
    } catch (error) {
      errorLog('❌ 公開終了に失敗しました:', error);
      
      // エラーメッセージを構成
      let errorMsg = '公開終了に失敗しました';
      if (error && error.message) {
        errorMsg += ': ' + error.message;
      } else if (typeof error === 'string') {
        errorMsg += ': ' + error;
      }
      
      // エラーメッセージを表示
      if (window.sharedModals) {
        window.sharedModals.showAlert('エラー', errorMsg, 'error');
      } else {
        alert(errorMsg);
      }
      
      // ボタンを元の状態に戻す
      if (endPublicationBtn && originalButtonContent) {
        endPublicationBtn.disabled = false;
        endPublicationBtn.innerHTML = originalButtonContent;
      }
    }
  }
  redirectToUnpublishedPage() {
    debugLog('🚫 Redirecting to unpublished page (legacy function)');
    
    // キャッシュクリア処理（新機能と統合）
    this.clearAllCachesForUnpublished();
    
    // 公開停止時は次回管理パネルを開いたときに全セクションをオープンにする
    try {
      localStorage.setItem('expandAllSections', 'true');
      debugLog('✅ アコーディオン全展開フラグを設定しました');
    } catch (error) {
      warnLog('⚠️ localStorage設定に失敗:', error);
    }
    
    // 新しいキャッシュバスティング機能を使用したリダイレクト
    const unpublishedUrl = new URL(window.location.href);
    unpublishedUrl.searchParams.delete('mode'); // mode=viewを削除
    unpublishedUrl.searchParams.set('_cb', Date.now()); // キャッシュバスティング
    unpublishedUrl.searchParams.set('_redirect', 'unpublished'); // リダイレクト理由
    
    debugLog('🔄 Redirecting to unpublished URL:', unpublishedUrl.toString());
    window.location.href = unpublishedUrl.toString();
  }
  
  
  /**
   * リアクション状態をlocalStorageに保存
   * @param {number} rowIndex - 行インデックス
   * @param {object} reactions - リアクション状態オブジェクト
   */
  saveReactionState(rowIndex, reactions) {
    try {
      // 既存の保存データを取得
      const existingData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      
      // 現在のリアクション状態を保存
      existingData[rowIndex] = {};
      Object.keys(reactions).forEach(reactionType => {
        const reaction = reactions[reactionType];
        if (reaction && reaction.reacted) {
          existingData[rowIndex][reactionType] = {
            reacted: true,
            timestamp: new Date().toISOString()
          };
        }
      });
      
      // 空のオブジェクトの場合は削除
      if (Object.keys(existingData[rowIndex]).length === 0) {
        delete existingData[rowIndex];
      }
      
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(existingData));
      debugLog('リアクション状態を保存:', { rowIndex, reactions: existingData[rowIndex] });
    } catch (error) {
      warnLog('リアクション状態の保存に失敗:', error);
    }
  }
  
  /**
   * localStorageからリアクション状態を読み込み
   * @returns {object} 保存されたリアクション状態
   */
  loadReactionState() {
    try {
      const savedData = JSON.parse(localStorage.getItem(this.reactionStorageKey) || '{}');
      debugLog('リアクション状態を読み込み:', savedData);
      return savedData;
    } catch (error) {
      warnLog('リアクション状態の読み込みに失敗:', error);
      return {};
    }
  }
  
  /**
   * 保存されたリアクション状態を現在のデータに適用
   * @param {array} answers - 回答データ配列
   */
  applyReactionState(answers) {
    const savedReactions = this.loadReactionState();
    let modified = false;

    answers.forEach(answer => {
      if (!savedReactions[answer.rowIndex]) {
        savedReactions[answer.rowIndex] = {};
      }
      const savedReaction = savedReactions[answer.rowIndex];

      if (answer.reactions) {
        Object.keys(answer.reactions).forEach(reactionType => {
          const info = answer.reactions[reactionType];
          if (!info) return;

          const serverReacted = !!info.reacted;
          const localReacted = !!savedReaction[reactionType];

          info.reacted = serverReacted;

          if (serverReacted) {
            if (!localReacted) {
              if (!savedReactions[answer.rowIndex]) {
                savedReactions[answer.rowIndex] = {};
              }
              savedReactions[answer.rowIndex][reactionType] = {
                reacted: true,
                timestamp: new Date().toISOString()
              };
              modified = true;
            }
          } else if (localReacted) {
            delete savedReaction[reactionType];
            modified = true;
          }

          if (Object.keys(savedReaction).length === 0) {
            delete savedReactions[answer.rowIndex];
          }

          debugLog(`✅ リアクション状態同期 [行${answer.rowIndex}][${reactionType}]:`, {
            serverReacted,
            localReacted,
            finalReacted: info.reacted,
            timestamp: new Date().toISOString()
          });
        });
      }
    });

    if (modified) {
      localStorage.setItem(this.reactionStorageKey, JSON.stringify(savedReactions));
    }

    debugLog('サーバーとローカルのリアクション状態同期完了');
  }

  updateModalReactionButtons(item) {
    if (!this.elements.modalReactionContainer) return;
    
    this.reactionTypes.forEach(rt => {
      const info = item.reactions?.[rt.key] || { count: 0, reacted: false };
      const modalBtn = this.elements.modalReactionContainer.querySelector(`[data-reaction="${rt.key}"]`);
      
      if (modalBtn) {
        // カウント表示更新
        const countEl = modalBtn.querySelector('.reaction-count');
        if (countEl && this.state.showCounts) {
          countEl.textContent = info.count;
        }
        
        // アイコン更新（強制的に更新）
        const svgEl = modalBtn.querySelector('svg');
        if (svgEl) {
          svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', info.reacted);

          // モーダル内でも視覚フィードバック
          modalBtn.style.transition = 'all 0.2s ease-out';
          if (info.reacted) {
            modalBtn.style.transform = 'scale(1.05)';
            setTimeout(() => {
              modalBtn.style.transform = '';
            }, 200);
          }
        }
        
        // スタイル更新
        const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
        modalBtn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
        modalBtn.classList.add(colorClass);
        modalBtn.classList.toggle('reacted', info.reacted);
        modalBtn.setAttribute('aria-pressed', info.reacted.toString());
        
        // aria-label更新
        const reactionNames = { 'LIKE': 'いいね！', 'UNDERSTAND': 'なるほど！', 'CURIOUS': 'もっと知りたい！' };
        const reactionName = reactionNames[rt.key] || rt.key;
        const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count}件)` : ''}`;
        modalBtn.setAttribute('aria-label', ariaLabel);
      }
    });
  }
  applyUpdates(items) {
    // パフォーマンス最適化: 変更が必要なアイテムのみ処理
    const itemsToUpdate = items.filter(item => {
      const updateKey = `apply_update_${item.rowIndex}`;
      const currentHash = this.calculateStateHash(item);
      const lastHash = this.lastApplyStates?.get(updateKey);
      
      if (lastHash === currentHash) {
        return false; // 変更なし - スキップ
      }
      
      // 状態を記録
      if (!this.lastApplyStates) this.lastApplyStates = new Map();
      this.lastApplyStates.set(updateKey, currentHash);
      return true; // 変更あり - 更新対象
    });
    
    if (itemsToUpdate.length === 0) {
      debugLog('⚡ applyUpdates: 全アイテムスキップ (変更なし)');
      return;
    }
    
    debugLog(`⚡ applyUpdates: ${itemsToUpdate.length}/${items.length}件を更新`);

    // バッチ処理用にリアクション更新データを蓄積
    const reactionUpdates = [];
    
    itemsToUpdate.forEach(item => {
      this.reactionTypes.forEach(rt => {
        if (item.reactions && item.reactions[rt.key]) {
          reactionUpdates.push({
            rowIndex: item.rowIndex,
            reaction: rt.key,
            count: item.reactions[rt.key].count,
            reacted: item.reactions[rt.key].reacted,
            shouldDisplay: item.reactions[rt.key].count > 0
          });
        }
      });
      const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
      if (card) {
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('reacted', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          const label = item.highlight ? 'ハイライトを解除する' : 'ハイライトする';
          highlightBtn.setAttribute('aria-label', label);
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);

            // ハイライトボタンにも視覚フィードバック
            highlightBtn.style.transition = 'all 0.2s ease-out';
            if (item.highlight) {
              highlightBtn.style.transform = 'scale(1.05)';
              setTimeout(() => {
                highlightBtn.style.transform = '';
              }, 200);
            }
          }
        }
        let badge = card.querySelector('.highlight-badge');
        if (item.highlight && !badge) {
          badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } else if (!item.highlight && badge) {
          badge.remove();
        }
      }
    });

    // バッチ処理でリアクション更新を実行
    if (reactionUpdates.length > 0) {
      this.batchUpdateReactionButtons(reactionUpdates);
    }
  }
  showAnswerModal(rowIndex) {
    if (DEBUG_MODE) debugLog('📱 [MODAL DEBUG] showAnswerModal called:', {
        rowIndex: rowIndex,
        rowIndexType: typeof rowIndex,
        timestamp: new Date().toISOString()
    });

    // Show answer modal called

    // Data search context
    
    // 最新データを取得（filteredDataとcurrentAnswersの両方から）
    let data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
    // Data search in currentAnswers
    
    if (!data && this.state.filteredData) {
      data = this.state.filteredData.find(r => r.rowIndex == rowIndex);
      debugLog('Data search in filteredData:', {
        found: !!data,
        searchRowIndex: rowIndex,
        availableRowIndexes: this.state.filteredData?.map(r => r.rowIndex) || []
      });
    }
    
    if (!data) {
      debugLog('ERROR: No data found for rowIndex:', {
        rowIndex: rowIndex,
        currentAnswers: this.state.currentAnswers,
        filteredData: this.state.filteredData
      });
      return;
    }
    
    debugLog('Data found for modal:', {
      rowIndex: rowIndex,
      data: data,
      opinion: data.opinion?.substring(0, 50) + '...',
      reason: data.reason?.substring(0, 50) + '...'
    });
    this.state.lastFocusedElement = document.activeElement;
    this.elements.modalAnswer.innerHTML = '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + window.sharedUtilities.security.escapeHtml(data.opinion || '') + '</p>' + '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + window.sharedUtilities.security.escapeHtml(data.reason || '') + '</p>';
    const showName = this.state.displayMode === 'named';
    let modalDisplayName = '';
    
    // Debug: Log modal display mode state
    debugLog('Modal display state:', {
      displayMode: this.state.displayMode,
      showName,
      showAdminFeatures: this.state.showAdminFeatures,
      isAdminUser: this.state.isAdminUser,
      dataName: data.name,
      dataEmail: data.email
    });
    
    if (showName) {
      // 名前が利用可能な場合はそれを使用、なければemailから生成
      if (data.name) {
        modalDisplayName = data.name;
      } else if (data.email) {
        modalDisplayName = data.email.split('@')[0];
      }
    }
    
    this.elements.modalStudentName.textContent = modalDisplayName;
    const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
    this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを追加
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'reacted' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // リアクションに基づくカード色の適用
    debugLog('モーダルにリアクション装飾適用:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions,
      element: this.elements.answerModalCard.className
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
    debugLog('モーダル装飾適用後:', {
      className: this.elements.answerModalCard.className
    });
    
    this.elements.answerModalContainer.classList.remove('hidden');
    this.elements.answerModalContainer.classList.add('modal-fade');
    this.elements.answerModalCard.classList.add('modal-scale');
    
    this.elements.answerModalCloseBtn.focus();
  }
  updateModalContent(data) {
    if (!data) return;
    
    // リアクションボタンを更新
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを更新
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'reacted' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // モーダルカードのスタイルを更新
    debugLog('updateModalContent装飾適用:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
  }
  hideAnswerModal() {
    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalContainer.classList.remove('modal-fade');
    this.elements.answerModalCard.classList.remove('modal-scale');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  showInfoModal() {
    this.state.lastFocusedElement = document.activeElement;
    this.elements.infoModalContainer.classList.remove('hidden');
    this.elements.infoModalContainer.classList.add('modal-fade');
    this.elements.infoModalCard.classList.add('modal-scale');
    
    // Ensure modal starts from the top
    this.elements.infoModalCard.scrollTop = 0;
    
    // Focus on the modal container first, then the button
    setTimeout(() => {
      this.elements.infoModalConfirmBtn.focus();
    }, 100);
  }
  hideInfoModal() {
    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalContainer.classList.remove('modal-fade');
    this.elements.infoModalCard.classList.remove('modal-scale');
    
    // Modal always shows on board updates for important information
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  getIcon(name, classes = '', solid = false) {
    // Cache icons to avoid repeated string concatenation
    const cacheKey = `icon-${name}-${classes}-${solid}`;
    const cachedIcon = this.cache.get(cacheKey);
    if (cachedIcon) {
      return cachedIcon;
    }
    
    let key = name;
    if (window.ICONS[name + '-outline'] || window.ICONS[name + '-solid']) {
      key = solid ? name + '-solid' : name + '-outline';
    }
    const icon = window.ICONS[key];
    if (!icon) {
      warnLog('Icon not found:', key);
      const fallback = '<span aria-hidden="true" class="' + classes + '">⭐</span>';
      this.cache.set(cacheKey, fallback);
      return fallback;
    }
    const result = '<span aria-hidden="true" class="' + classes + '">' + icon + '</span>';
    this.cache.set(cacheKey, result);
    return result;
  }
  renderIcons() {
    if (this.elements.infoIconLike) {
      this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
    }
    if (this.elements.infoIconUnderstand) {
      this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
    }
    if (this.elements.infoIconCurious) {
      this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
    }
    if (this.elements.infoIconHighlight) {
      this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
    }
    if (this.elements.iconClose) {
      this.elements.iconClose.innerHTML = this.getIcon('x');
    }
    if (this.elements.iconGrid) {
      this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
    }
  }
  debounce(func, delay) {
    // Use SharedUtilities with instance-specific keys
    const key = `studyquest-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.debounce.debounce(() => func.apply(this, args), key, delay);
    };
  }
  
  throttle(func, delay) {
    // Use SharedUtilities with instance-specific keys
    const key = `studyquest-throttle-${this.instanceId || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
    return (...args) => {
      window.sharedUtilities.throttle.throttle(() => func.apply(this, args), key, delay);
    };
  }
  updateSortOptions() {
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.style.display = 'block';
      } else {
        this.elements.scoreOption.style.display = 'none';
        if (this.elements.sortOrder.value === 'score') {
          this.elements.sortOrder.value = 'newest';
        }
      }
    }
  }
  updateConfigFromGlobals() {
    debugLog('updateConfigFromGlobals前の状態:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      currentDisplayMode: this.state.displayMode
    });
    
    this.state.isStudentMode = window.isStudentMode;
    this.state.showCounts = window.showCounts;
    window.showScoreSort = window.showCounts;
    this.state.showAdminFeatures = window.showAdminFeatures;
    this.state.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
    this.state.showScoreSort = window.showScoreSort;
    this.state.showPublishControls = window.showPublishControls;
    
    // Only update displayMode if not in admin mode
    if (!this.state.showAdminFeatures) {
      this.state.displayMode = window.displayMode;
    }
    
    debugLog('updateConfigFromGlobals後の状態:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      finalDisplayMode: this.state.displayMode,
      windowDisplayMode: window.displayMode
    });
  }

  // Performance optimization methods

  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measurePerformance = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      if (frameCount > 0) {
        this.perf.frameTime = delta;
        
        // If frame time is consistently over 16ms, enable low performance mode
        if (delta > getPerformanceBudget() && !this.isLowPerformanceMode) {
          warnLog('Low performance detected, enabling optimizations');
          this.isLowPerformanceMode = true;
          this.optimizeForLowPerformance();
        }
      }
      
      lastTime = now;
      frameCount++;
      
      if (frameCount < 60) { // Monitor first 60 frames
        requestAnimationFrame(measurePerformance);
      }
    };
    
    requestAnimationFrame(measurePerformance);
  }

  optimizeForLowPerformance() {
    debugLog('Enabling low performance optimizations');
    
    // Reduce animation and transition durations
    document.documentElement.style.setProperty('--transition-duration', '0.1s');
    document.documentElement.style.setProperty('--animation-duration', '0.1s');
    document.documentElement.style.setProperty('--backdrop-blur', '4px');
    
    // Create comprehensive low-performance stylesheet
    const style = document.createElement('style');
    style.id = 'low-performance-optimizations';
    style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        -webkit-backdrop-filter: blur(4px) !important;
        backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover {
        transform: scale(1.02) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        border: 3px solid #9333ea !important;
        border-image: none !important;
        box-shadow: 0 0 12px rgba(147, 51, 234, 0.5) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
    document.head.appendChild(style);
    
    // Add low-performance class to body for CSS targeting
    document.body.classList.add('low-performance');
    
    // Reduce polling frequency
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = setInterval(() => this.loadSheetData({ showLoading: false }), 30000); // 30s instead of 15s
    }
  }

  setupObservers() {
    // Intersection Observer for virtual scrolling - optimized for performance
    if ('IntersectionObserver' in window) {
      // Enhanced debounce visibility changes with batching to reduce excessive firing
      const debouncedVisibilityHandler = this.debounce((entries) => {
        // Batch entries by card to prevent rapid state changes on the same element
        const cardChanges = new Map();
        
        entries.forEach(entry => {
          const card = entry.target;
          const rowIndex = card.dataset.rowIndex;
          
          // Keep only the latest change for each card
          cardChanges.set(rowIndex, { card, entry });
        });
        
        // Process batched changes
        cardChanges.forEach(({ card, entry }) => {
          // Only log significant visibility changes for debugging
          if (DEBUG_MODE && (entry.intersectionRatio === 0 || entry.intersectionRatio === 1)) {
            debugLog('IntersectionObserver visibility change:', {
              rowIndex: card.dataset.rowIndex,
              isIntersecting: entry.isIntersecting,
              intersectionRatio: entry.intersectionRatio
            });
          }

          if (entry.isIntersecting) {
            // Card is becoming visible
            if (!card.classList.contains('visible')) {
              card.classList.add('visible');
              card.classList.remove('hidden-card');
              // Restore visibility and display if it was hidden
              if (card.style.visibility === 'hidden') {
                card.style.visibility = 'visible';
              }
              if (card.style.display === 'none') {
                card.style.display = '';
              }
            }
          } else {
            // MODIFIED: Do not hide cards for virtual scrolling - keep them in DOM
            // This prevents cards from disappearing when scrolling back up
            // Only mark as not visible for optimization purposes
            if (entry.intersectionRatio === 0 && card.classList.contains('visible')) {
              card.classList.remove('visible');
              card.classList.add('hidden-card');
              // Do NOT hide or remove from DOM - just mark as not visible
            }
          }
        });
      }, 50); // Increased debounce to 50ms for better stability
      
      this.visibilityObserver = new IntersectionObserver(debouncedVisibilityHandler, {
        rootMargin: `${window.getViewportBuffer()}px`,
        threshold: [0, 1.0] // Simplified thresholds: fully out vs fully in
      });
    }

    // ResizeObserver for responsive adjustments
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(this.debounce(() => {
        this.adjustLayout();
      }, 100));
      this.resizeObserver.observe(this.elements.answersContainer);
    }
  }

  deferredRender(callback, priority = 'normal') {
    if (this.isLowPerformanceMode) {
      // Use requestIdleCallback for low priority updates
      this.idleCallbackId = requestIdleCallback(callback, { timeout: getIdleTimeout() });
    } else {
      // Use requestAnimationFrame for normal updates
      this.animationFrameId = requestAnimationFrame(callback);
    }
  }

  batchDOMUpdates(updates) {
    if (!updates || updates.length === 0) return;

    const fragment = this.getReusableFragment();
    const CHUNK_SIZE = 8; // Optimal chunk size for 70x performance
    let processedCount = 0;

    const processBatch = () => {
      const startTime = performance.now();
      const chunkEnd = Math.min(processedCount + CHUNK_SIZE, updates.length);

      // Process chunk with fragment batching
      for (let i = processedCount; i < chunkEnd; i++) {
        const update = updates[i];
        if (typeof update === 'function') {
          // Execute update with fragment context
          update.call(this, fragment);
        } else if (update && update.element && update.operation) {
          // Handle structured DOM updates
          this.executeDOMOperation(update, fragment);
        }
      }

      processedCount = chunkEnd;

      // Yield control if more work remains and budget exceeded
      if (processedCount < updates.length) {
        if (performance.now() - startTime < getPerformanceBudget()) {
          // Continue synchronously if within budget
          setTimeout(processBatch, 0);
        } else {
          // Defer to next frame if budget exceeded
          requestAnimationFrame(processBatch);
        }
      } else {
        // All updates complete - recycle fragment
        this.recycleFragment(fragment);
      }
    };

    processBatch();
  }

  executeDOMOperation(update, fragment) {
    const { element, operation, data } = update;
    if (!element || !operation) return;

    switch (operation) {
      case 'append':
        if (data && data.content) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = data.content;
          while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
          }
          element.appendChild(fragment);
        }
        break;
      case 'update':
        if (data && data.html) {
          element.innerHTML = data.html;
        } else if (data && data.text) {
          element.textContent = data.text;
        }
        break;
      case 'setAttribute':
        if (data && data.name && data.value !== undefined) {
          element.setAttribute(data.name, data.value);
        }
        break;
      case 'addClass':
        if (data && data.className) {
          element.classList.add(data.className);
        }
        break;
      case 'removeClass':
        if (data && data.className) {
          element.classList.remove(data.className);
        }
        break;
      default:
        if (typeof operation === 'function') {
          operation.call(this, element, data, fragment);
        }
    }
  }

  getReusableFragment() {
    if (this.domFragmentPool.length > 0) {
      return this.domFragmentPool.pop();
    }

    // Create new fragment and pre-warm pool if low
    const fragment = document.createDocumentFragment();
    if (this.domFragmentPool.length < 3) {
      // Pre-allocate fragments to avoid creation overhead
      for (let i = this.domFragmentPool.length; i < 3; i++) {
        this.domFragmentPool.push(document.createDocumentFragment());
      }
    }
    return fragment;
  }

  recycleFragment(fragment) {
    if (!fragment) return;

    // Optimized fragment clearing using replaceChildren (faster than removeChild loop)
    if (fragment.replaceChildren) {
      fragment.replaceChildren(); // Modern browsers - much faster
    } else {
      // Fallback for older browsers
      while (fragment.firstChild) {
        fragment.removeChild(fragment.firstChild);
      }
    }

    // Pool management with optimal size for 70x performance
    if (this.domFragmentPool.length < 8) { // Increased optimal pool size
      this.domFragmentPool.push(fragment);
    }
  }

  throttledUpdate(key, callback, delay = 100) {
    if (this.deferredUpdates.has(key)) {
      return;
    }
    
    this.deferredUpdates.add(key);
    setTimeout(() => {
      callback();
      this.deferredUpdates.delete(key);
    }, delay);
  }

  cleanup() {
    // Consolidated cache cleanup
    this.cache.cleanup();

    // Clear DOM fragment pool
    this.domFragmentPool.length = 0;

    debugLog('Cache cleanup completed', {
      cacheSize: this.cache.size
    });
  }
  
  // Enhanced cache methods with timestamp tracking

  // Virtual Scrolling
  
  setupScrollObserver() {
    if (!this.elements.answersContainer) {
      warnLog('setupScrollObserver: answersContainer not found');
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    if (cards.length === 0) {
      debugLog('setupScrollObserver: No cards found, skipping setup');
      return;
    }
    
    // Clear existing scroll observer if it exists
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
    }
    
    // Create scroll observer for dynamic loading with debouncing
    const debouncedScrollHandler = this.debounce((entries) => {
      // Only process the first intersecting entry to prevent multiple simultaneous loads
      const intersectingEntry = entries.find(entry => entry.isIntersecting);
      if (intersectingEntry) {
        debugLog('setupScrollObserver: Trigger card intersecting:', intersectingEntry.target.dataset.rowIndex);
        this.handleVirtualScroll(intersectingEntry.target);
      }
    }, 150); // 150ms debounce for scroll triggers to prevent rapid firing
    
    this.scrollObserver = new IntersectionObserver(debouncedScrollHandler, {
      root: null,
      rootMargin: '300px', // Increased buffer for even smoother loading
      threshold: 0.1
    });
    
    // Observe the last few elements for dynamic loading trigger
    const observeCount = Math.min(3, cards.length); // Reduced to last 3 cards for better performance
    const observedCards = [];
    
    for (let i = cards.length - observeCount; i < cards.length; i++) {
      if (cards[i] && cards[i].dataset.rowIndex) {
        this.scrollObserver.observe(cards[i]);
        observedCards.push(cards[i].dataset.rowIndex);
      }
    }
    
    debugLog('setupScrollObserver: Observing cards for dynamic loading:', {
      totalCards: cards.length,
      observedCount: observedCards.length,
      observedRowIndexes: observedCards,
      totalItems: this.virtualScrollState?.totalItems || 0,
      renderedItems: this.virtualScrollState?.renderedItems || 0
    });
  }
  
  handleVirtualScroll(triggerElement) {
    if (!triggerElement || !this.virtualScrollState) {
      return;
    }
    
    if (this.virtualScrollState.isLoading) {
      debugLog('handleVirtualScroll: Already loading, skipping');
      return;
    }
    
    const currentCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const totalAvailable = this.state.currentAnswers.length;
    const currentRendered = currentCards.length;
    
    debugLog('handleVirtualScroll triggered:', {
      currentRendered,
      totalAvailable,
      triggerRowIndex: triggerElement.dataset.rowIndex
    });
    
    // Check if we need to load more items
    if (currentRendered < totalAvailable) {
      this.loadMoreItems();
    } else {
      // Optimize visible elements when we've rendered everything
      this.optimizeVisibleElements();
    }
  }
  
  loadMoreItems() {
    if (this.virtualScrollState.isLoading) {
      return;
    }
    
    this.virtualScrollState.isLoading = true;
    
    // Enhanced item tracking - use Set instead of relying on DOM count
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
      // Initialize with existing cards in DOM
      const existingCards = this.elements.answersContainer.querySelectorAll('.answer-card');
      existingCards.forEach(card => {
        if (card.dataset.rowIndex) {
          this.virtualScrollState.renderedRowIndexes.add(card.dataset.rowIndex);
        }
      });
    }
    
    // Use dynamic batch sizing for better performance adaptation
    const dynamicBatchSize = getDynamicBatchSize(this.performanceMetrics);
    const batchSize = this.isLowPerformanceMode ? Math.min(CHUNK_SIZE, dynamicBatchSize) : dynamicBatchSize;
    
    // Find items that haven't been rendered yet
    const unrenderedItems = this.state.currentAnswers.filter(item => 
      !this.virtualScrollState.renderedRowIndexes.has(String(item.rowIndex))
    );
    
    // Take next batch of unrendered items
    const remainingItems = unrenderedItems.slice(0, batchSize);
    
    if (remainingItems.length === 0) {
      this.virtualScrollState.isLoading = false;
      debugLog('loadMoreItems: No more items to load - all items rendered');
      return;
    }
    
    debugLog('loadMoreItems: Loading', remainingItems.length, 'additional items with batch size', batchSize, 
      'Total rendered:', this.virtualScrollState.renderedRowIndexes.size, 'Total available:', this.state.currentAnswers.length);
    
    // Use deferred rendering for performance
    this.deferredRender(() => {
      this.renderAdditionalItems(remainingItems);
    });
  }
  
  renderAdditionalItems(items) {
    if (!items || items.length === 0) {
      this.virtualScrollState.isLoading = false;
      debugLog('renderAdditionalItems: No items to render');
      return;
    }
    
    const fragment = this.getReusableFragment();
    const changedItems = [];
    let successfullyCreated = 0;
    
    // Ensure renderedRowIndexes exists
    if (!this.virtualScrollState.renderedRowIndexes) {
      this.virtualScrollState.renderedRowIndexes = new Set();
    }
    
    items.forEach((item) => {
      const rowIndexStr = String(item.rowIndex);
      
      // Skip if already rendered (defensive check)
      if (this.virtualScrollState.renderedRowIndexes.has(rowIndexStr)) {
        debugLog('renderAdditionalItems: Item', rowIndexStr, 'already rendered, skipping');
        return;
      }
      
      const card = this.createAnswerCard(item);
      if (card) {
        card.classList.add('new-card');
        
        // Track this item as rendered
        this.virtualScrollState.renderedRowIndexes.add(rowIndexStr);
        
        // Add to visibility observer
        if (this.visibilityObserver) {
          this.visibilityObserver.observe(card);
        }
        
        // Add to scroll observer for the last few items
        const isLastFew = items.indexOf(item) >= items.length - 3;
        if (isLastFew && this.scrollObserver) {
          this.scrollObserver.observe(card);
        }
        
        fragment.appendChild(card);
        changedItems.push(item);
        successfullyCreated++;
      } else {
        warnLog('renderAdditionalItems: Failed to create card for item:', item.rowIndex);
      }
    });
    
    // Append new items to container
    if (fragment.children.length > 0) {
      this.elements.answersContainer.appendChild(fragment);
      
      // Update virtual scroll state with actual counts
      this.virtualScrollState.renderedItems = this.elements.answersContainer.children.length;
      
      debugLog('renderAdditionalItems: Added', fragment.children.length, 'new cards. Total rendered:', 
        this.virtualScrollState.renderedRowIndexes.size, 'DOM children:', this.virtualScrollState.renderedItems);
    } else {
      debugLog('renderAdditionalItems: No cards were successfully created from', items.length, 'items');
    }
    
    // Apply updates if needed
    if (changedItems.length > 0) {
      this.deferredRender(() => this.applyUpdates(changedItems));
    }
    
    // Recycle fragment
    this.recycleFragment(fragment);
    
    // Reset loading state
    this.virtualScrollState.isLoading = false;
    
    // Validate state consistency
    this.validateVirtualScrollState();
  }
  
  validateVirtualScrollState() {
    if (!this.virtualScrollState || !this.virtualScrollState.renderedRowIndexes) {
      return;
    }
    
    const domCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const domRowIndexes = new Set();
    
    domCards.forEach(card => {
      if (card.dataset.rowIndex) {
        domRowIndexes.add(card.dataset.rowIndex);
      }
    });
    
    const trackedCount = this.virtualScrollState.renderedRowIndexes.size;
    const domCount = domRowIndexes.size;
    const totalAvailable = this.state.currentAnswers.length;
    
    // Check for inconsistencies
    const missingInDOM = [...this.virtualScrollState.renderedRowIndexes].filter(x => !domRowIndexes.has(x));
    const extraInDOM = [...domRowIndexes].filter(x => !this.virtualScrollState.renderedRowIndexes.has(x));
    
    if (missingInDOM.length > 0 || extraInDOM.length > 0 || trackedCount !== domCount) {
      warnLog('Virtual scroll state inconsistency detected:', {
        trackedCount,
        domCount,
        totalAvailable,
        missingInDOM: missingInDOM.slice(0, 5),
        extraInDOM: extraInDOM.slice(0, 5)
      });
      
      // Auto-repair: sync tracked state with DOM reality
      this.virtualScrollState.renderedRowIndexes = domRowIndexes;
      this.virtualScrollState.renderedItems = domCount;
      
      debugLog('validateVirtualScrollState: Auto-repaired state. New tracked count:', domCount);
    }
  }
  
  optimizeVisibleElements() {
    if (!this.elements.answersContainer || this.virtualScrollState.isLoading) {
      return;
    }
    
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    let hiddenCount = 0;
    let restoredCount = 0;
    const viewportHeight = window.innerHeight;
    const hideThreshold = viewportHeight * 3; // Increased threshold for better UX
    
    // Track hidden cards for better restoration
    if (!this.virtualScrollState.hiddenCards) {
      this.virtualScrollState.hiddenCards = new Set();
    }
    
    cards.forEach((card) => {
      const rect = card.getBoundingClientRect();
      const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
      const rowIndex = card.dataset.rowIndex;
      const isCurrentlyHidden = this.virtualScrollState.hiddenCards.has(rowIndex);
      
      if (!isInViewport && !isCurrentlyHidden) {
        // Calculate distance from viewport
        const distanceFromViewport = rect.top > viewportHeight 
          ? rect.top - viewportHeight  // Below viewport
          : -rect.bottom;             // Above viewport
        
        // Only hide cards that are really far away
        if (distanceFromViewport > hideThreshold) {
          this.hideCard(card, rowIndex);
          hiddenCount++;
        }
      } else if (isInViewport && isCurrentlyHidden) {
        // Restore cards that are back in viewport
        this.restoreCard(card, rowIndex);
        restoredCount++;
      }
    });
    
    if (hiddenCount > 0 || restoredCount > 0) {
      debugLog('optimizeVisibleElements: Hidden', hiddenCount, 'cards, restored', restoredCount, 'cards');
    }
  }
  
  hideCard(card, rowIndex) {
    // Use CSS transform instead of visibility for better performance
    card.style.transform = 'translateZ(0) scale(0.01)';
    card.style.opacity = '0';
    card.style.pointerEvents = 'none';
    card.classList.add('hidden-card');
    this.virtualScrollState.hiddenCards.add(rowIndex);
    
    // Temporarily unobserve from intersection observers to prevent state confusion
    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(card);
    }
    if (this.scrollObserver) {
      this.scrollObserver.unobserve(card);
    }
  }
  
  restoreCard(card, rowIndex) {
    // Restore card to full visibility
    card.style.transform = '';
    card.style.opacity = '';
    card.style.pointerEvents = '';
    card.classList.remove('hidden-card');
    card.classList.add('visible');
    this.virtualScrollState.hiddenCards.delete(rowIndex);
    
    // Re-add to intersection observers
    if (this.visibilityObserver) {
      this.visibilityObserver.observe(card);
    }
    
    // Only re-add to scroll observer if it's one of the last few cards
    const allCards = this.elements.answersContainer.querySelectorAll('.answer-card');
    const cardIndex = Array.from(allCards).indexOf(card);
    const isLastFew = cardIndex >= allCards.length - 3;
    
    if (isLastFew && this.scrollObserver) {
      this.scrollObserver.observe(card);
    }
  }
  
  // Reset virtual scrolling state for debugging and recovery
  resetVirtualScrollState() {
    debugLog('resetVirtualScrollState: Resetting virtual scroll state');
    
    // Clear state
    this.virtualScrollState = {
      renderedItems: 0,
      totalItems: this.state.currentAnswers.length,
      isLoading: false,
      renderedRowIndexes: new Set(),
      hiddenCards: new Set()
    };
    
    // Clear all observers
    if (this.scrollObserver) {
      this.scrollObserver.disconnect();
      this.scrollObserver = null;
    }
    
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
      this.visibilityObserver = null;
    }
    
    // Restore all cards to visible state
    const cards = this.elements.answersContainer.querySelectorAll('.answer-card');
    cards.forEach(card => {
      card.style.transform = '';
      card.style.opacity = '';
      card.style.pointerEvents = '';
      card.style.visibility = '';
      card.classList.remove('hidden-card');
      card.classList.add('visible');
    });
    
    // Re-setup observers
    this.setupObservers();
    
    debugLog('resetVirtualScrollState: Virtual scroll state reset complete');
  }

  /**
   * 理由テキストの堅牢化検証
   * @param {any} reason - 理由データ
   * @returns {string} 検証済み理由テキスト
   */
  validateReasonText(reason) {
    try {
      debugLog('🔍 validateReasonText デバッグ:', {
        input: reason,
        inputType: typeof reason,
        inputIsNull: reason === null,
        inputIsUndefined: reason === undefined,
        inputLength: reason?.length
      });
      
      // null, undefined, 空文字列チェック
      if (!reason && reason !== 0) {
        debugLog('🔍 validateReasonText: 空の理由データ検出 - 空文字列を返します');
        return '';
      }
      
      // 文字列変換と基本検証
      const reasonStr = String(reason).trim();
      
      debugLog('🔍 validateReasonText 処理結果:', {
        reasonStr: reasonStr,
        reasonStrLength: reasonStr.length,
        willBeEmpty: reasonStr.length === 0
      });
      
      // 長すぎる理由テキストの制限（10000文字まで）
      if (reasonStr.length > 10000) {
        warnLog('validateReasonText: Reason text too long, truncating:', reasonStr.length);
        return reasonStr.substring(0, 10000) + '...';
      }
      
      // HTMLエスケープが必要な文字をチェック
      if (reasonStr.includes('<') || reasonStr.includes('>') || reasonStr.includes('&')) {
        // HTMLが含まれている可能性がある場合は警告
        warnLog('validateReasonText: Potentially unsafe HTML content detected');
      }
      
      return reasonStr;
    } catch (error) {
      errorLog('validateReasonText: Error validating reason text:', error);
      return ''; // エラー時は空文字列を返す
    }
  }

  /**
   * ボードデータの整合性をリアルタイムで検証
   * @returns {Promise<Object>} 検証結果
   */
  async validData() {
    try {
      debugLog('🔍 Starting real-time board data integrity validation...');
      
      const validationResults = {
        timestamp: new Date().toISOString(),
        totalCards: 0,
        validCards: 0,
        invalidCards: 0,
        reasonFieldIssues: 0,
        headerIssues: 0,
        errors: []
      };

      // DOM内のカードを検証
      const cards = this.elements.answersContainer?.querySelectorAll('.answer-card') || [];
      validationResults.totalCards = cards.length;

      cards.forEach((card, index) => {
        try {
          const rowIndex = card.dataset.rowIndex;
          const opinionElement = card.querySelector('.opinion-text');
          const reasonElement = card.querySelector('.answer-preview p');
          
          // 基本要素の存在チェック
          if (!opinionElement || !rowIndex) {
            validationResults.invalidCards++;
            validationResults.errors.push(`Card ${index}: Missing essential elements`);
            return;
          }

          // 理由列の状態チェック
          const hasReasonData = this.state.currentAnswers.find(a => a.rowIndex == rowIndex)?.reason;
          const hasReasonElement = reasonElement && reasonElement.textContent.trim();
          
          if (hasReasonData && !hasReasonElement) {
            validationResults.reasonFieldIssues++;
            validationResults.errors.push(`Card ${index} (row ${rowIndex}): Reason data exists but not displayed`);
          }
          
          validationResults.validCards++;
        } catch (cardError) {
          validationResults.invalidCards++;
          validationResults.errors.push(`Card ${index}: Validation error - ${cardError.message}`);
        }
      });

      // ヘッダー情報の検証
      try {
        const headerValidation = await this.runGas('validateHeaderIntegrity', this.state.userId);
        if (!headerValidation.success) {
          validationResults.headerIssues++;
          validationResults.errors.push(`Header validation failed: ${headerValidation.error}`);
        }
      } catch (headerError) {
        validationResults.headerIssues++;
        validationResults.errors.push(`Header validation error: ${headerError.message}`);
      }

      // 検証結果のログ出力
      const issueCount = validationResults.invalidCards + validationResults.reasonFieldIssues + validationResults.headerIssues;
      if (issueCount > 0) {
        warnLog('⚠️ Board data integrity issues detected:', validationResults);
        
        // 自動修復の試行（理由列の問題のみ）
        if (validationResults.reasonFieldIssues > 0) {
          debugLog('🔧 Attempting automatic reason field recovery...');
          await this.autoRecoverReasonFields();
        }
      } else {
        debugLog('✅ Board data integrity validation passed');
      }

      return validationResults;
    } catch (error) {
      errorLog('❌ Board data integrity validation failed:', error);
      return {
        timestamp: new Date().toISOString(),
        error: error.message,
        success: false
      };
    }
  }

  /**
   * 理由列の自動修復処理
   */
  async autoRecoverReasonFields() {
    try {
      debugLog('🔧 Starting automatic reason field recovery...');
      
      // キャッシュクリアして最新データを取得
      await this.gas.clearCache();
      
      // データを再取得してカードを更新
      await this.loadBoardData();
      
      debugLog('✅ Reason field recovery completed');
    } catch (error) {
      errorLog('❌ Automatic reason field recovery failed:', error);
    }
  }
}
// ドメイン情報処理
// AdminPanel.html と Login.html で共通使用

// ドメイン情報取得
async function loadDomainInfo(onSuccess, onError) {
  try {
    const info = await new Promise((resolve, reject) => {
      if (!google?.script?.run?.getDeployUserDomainInfo) {
        warnLog('getDeployUserDomainInfo function not available, using fallback');
        resolve({
          success: true,
          domain: 'unknown',
          userEmail: 'anonymous',
          isValidDomain: true,
          fallback: true
        });
        return;
      }

      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          warnLog('getDeployUserDomainInfo failed, using fallback:', error);
          resolve({
            success: false,
            error: error.message || error,
            fallback: true
          });
        })
        .getDeployUserDomainInfo();
    });

    // Map backend response to frontend expected format
    if (info && info.success && !info.error) {
      const mappedInfo = {
        success: info.success,
        isDomainMatch: info.isValidDomain,
        deployDomain: info.adminDomain,
        currentDomain: info.userDomain || info.domain,
        userEmail: info.userEmail
      };
      displayDomainInfo(mappedInfo);
      if (onSuccess) onSuccess(mappedInfo);
    } else {
      displayDomainInfo(info);
      if (onSuccess) onSuccess(info);
    }
  } catch (error) {
    warnLog('ドメイン情報エラー:', error.message || error);
    displayDomainInfo({ error: error.message || error, fallback: true });
    if (onError) onError(error);
  }
}

/**
 * ドメイン情報を表示する共通関数
 * @param {Object} info - ドメイン情報オブジェクト
 */
function displayDomainInfo(info) {
  const headerDomainMatch = document.getElementById('header-domain-match');
  const headerDomainMismatch = document.getElementById('header-domain-mismatch');
  const headerDomainInitial = document.getElementById('header-domain-initial');
  const headerDomainMatchText = document.getElementById('header-domain-match-text');
  const headerDomainMismatchText = document.getElementById('header-domain-mismatch-text');

  // 全ての表示を一旦非表示にする
  if (headerDomainMatch) headerDomainMatch.classList.add('hidden');
  if (headerDomainMismatch) headerDomainMismatch.classList.add('hidden');
  if (headerDomainInitial) headerDomainInitial.classList.add('hidden');
  
  if (!info || info.error) {
    warnLog('ドメイン情報エラー:', info?.error);
    // エラー時は初期状態を表示
    if (headerDomainInitial) headerDomainInitial.classList.remove('hidden');
    return;
  }

  debugLog('🌐 ドメイン情報表示:', {
    isDomainMatch: info.isDomainMatch,
    deployDomain: info.deployDomain,
    currentDomain: info.currentDomain,
    success: info.success
  });

  if (info.isDomainMatch) {
    // ドメインが一致している場合
    if (headerDomainMatch && headerDomainMatchText) {
      headerDomainMatch.classList.remove('hidden');
      if (info.deployDomain) {
        headerDomainMatchText.textContent = `${info.deployDomain} ドメイン`;
      } else {
        headerDomainMatchText.textContent = 'グローバルアクセス';
      }
    }
  } else {
    // ドメイン不一致の場合
    if (headerDomainMismatch && headerDomainMismatchText) {
      headerDomainMismatch.classList.remove('hidden');
      headerDomainMismatchText.textContent = info.currentDomain;
    }
  }
}

/**
 * フォームリンクを取得して表示する関数
 */
async function loadFormLink() {
  try {
    const formInfo = await new Promise((resolve, reject) => {
      if (!google?.script?.run?.getActiveFormInfo) {
        warnLog('getActiveFormInfo function not available, skipping form link');
        resolve(null);
        return;
      }

      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          warnLog('getActiveFormInfo failed:', error);
          resolve(null);
        })
        .getActiveFormInfo();
    });

    if (formInfo && formInfo.formUrl) {
      const formLinkBtn = document.getElementById('form-link-btn');
      if (formLinkBtn) {
        formLinkBtn.href = formInfo.formUrl;
        formLinkBtn.classList.remove('hidden');

        // フォームタイトルを動的に設定
        if (formInfo.formTitle) {
          const formTitleSpan = formLinkBtn.querySelector('span');
          if (formTitleSpan) {
            formTitleSpan.textContent = `📝 ${formInfo.formTitle}`;
          }
        }
      }
    }
  } catch (error) {
    warnLog('フォーム情報の取得に失敗しました:', error);
  }
}

try {
  if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
    window.studyQuestApp.destroy();
  }
  document.addEventListener('DOMContentLoaded', () => {
  const app = new StudyQuestApp();
});

  // ドメイン情報とフォームリンクを取得
  loadDomainInfo();
  loadFormLink();

  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
  });
} catch (error) {
  errorLog('Error creating StudyQuestApp instance:', error);
  const container = document.getElementById('answers');
  if (container) {
    const msg = window.sharedUtilities.security.escapeHtml(error.message || '');
    container.innerHTML = '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + msg + '</div>';
  }
}
</script>
