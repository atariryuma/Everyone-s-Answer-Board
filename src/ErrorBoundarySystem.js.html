<script>
/**
 * åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
 * ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã‚’ã‚¨ãƒ©ãƒ¼ã‹ã‚‰ä¿è­·ã—ã€è‡ªå‹•å¾©æ—§æ©Ÿèƒ½ã‚’æä¾›
 */

// =============================================================================
// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ - ã™ã¹ã¦ã®ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
// =============================================================================

class GlobalErrorBoundary {
  constructor() {
    this.errorCount = 0;
    this.errorLog = [];
    this.maxErrorCount = 10;
    this.recoveryMode = false;
    this.lastErrorTime = 0;
    this.errorThreshold = 5000; // 5ç§’é–“ã«è¤‡æ•°ã‚¨ãƒ©ãƒ¼ã§å›å¾©ãƒ¢ãƒ¼ãƒ‰
    
    this.setupGlobalHandlers();
  }

  setupGlobalHandlers() {
    // JavaScript ã‚¨ãƒ©ãƒ¼
    window.addEventListener('error', (event) => {
      this.handleError(event.error, 'JavaScript Error', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });

    // Promise æ‹’å¦
    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(event.reason, 'Unhandled Promise Rejection', {
        promise: event.promise
      });
      event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‡¦ç†ã‚’é˜²æ­¢
    });

    // ãƒªã‚½ãƒ¼ã‚¹èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.handleResourceError(event);
      }
    }, true);

    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
    window.addEventListener('online', () => {
      console.log('ğŸŸ¢ Network connection restored');
      this.attemptRecovery();
    });

    window.addEventListener('offline', () => {
      console.log('ğŸ”´ Network connection lost');
      this.enterOfflineMode();
    });
  }

  handleError(error, type, context = {}) {
    const now = Date.now();
    this.errorCount++;
    
    // ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã«è¨˜éŒ²
    const errorRecord = {
      timestamp: now,
      type: type,
      error: error,
      message: error?.message || error?.toString() || 'Unknown error',
      stack: error?.stack || 'No stack trace',
      context: context,
      userAgent: navigator.userAgent,
      url: window.location.href,
      recoveryMode: this.recoveryMode
    };
    
    this.errorLog.push(errorRecord);
    
    // å¤ã„ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å‰Šé™¤ï¼ˆæœ€æ–°100ä»¶ã®ã¿ä¿æŒï¼‰
    if (this.errorLog.length > 100) {
      this.errorLog.shift();
    }
    
    console.error(`ğŸš¨ ${type}:`, error, context);
    
    // çŸ­æ™‚é–“ã«å¤šæ•°ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®å¯¾å‡¦
    if (now - this.lastErrorTime < this.errorThreshold) {
      if (this.errorCount >= 5 && !this.recoveryMode) {
        console.warn('âš ï¸ Multiple errors detected, entering recovery mode');
        this.enterRecoveryMode();
      }
    } else {
      // ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.errorCount = 1;
    }
    
    this.lastErrorTime = now;
    
    // ã‚¨ãƒ©ãƒ¼ã®è‡ªå‹•ä¿®å¾©ã‚’è©¦è¡Œ
    this.attemptErrorRecovery(errorRecord);
  }

  handleResourceError(event) {
    const target = event.target;
    const resourceType = target.tagName.toLowerCase();
    
    console.warn(`ğŸ”´ Resource loading failed: ${resourceType}`, target.src || target.href);
    
    // ãƒªã‚½ãƒ¼ã‚¹ã®è‡ªå‹•å¾©æ—§ã‚’è©¦è¡Œ
    this.attemptResourceRecovery(target, resourceType);
  }

  enterRecoveryMode() {
    this.recoveryMode = true;
    console.log('ğŸ”§ Entering recovery mode');
    
    // å›å¾©ãƒ¢ãƒ¼ãƒ‰UIè¡¨ç¤º
    this.showRecoveryInterface();
    
    // è‡ªå‹•å›å¾©ã‚’è©¦è¡Œ
    setTimeout(() => this.attemptFullRecovery(), 2000);
  }

  attemptErrorRecovery(errorRecord) {
    const error = errorRecord.error;
    const message = errorRecord.message;
    
    // ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã™ã‚‹è‡ªå‹•ä¿®å¾©
    if (message.includes('script error') || message.includes('network error')) {
      this.handleNetworkError();
    } else if (message.includes('permission') || message.includes('access')) {
      this.handlePermissionError();
    } else if (message.includes('quota') || message.includes('limit')) {
      this.handleQuotaError();
    } else if (message.includes('syntax') || message.includes('unexpected token')) {
      this.handleSyntaxError();
    } else {
      this.handleGenericError(errorRecord);
    }
  }

  handleNetworkError() {
    console.log('ğŸ”„ Attempting network error recovery...');
    
    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šç¢ºèª
    if (navigator.onLine) {
      // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®å ´åˆã€å°‘ã—å¾…ã£ã¦å†è©¦è¡Œ
      setTimeout(() => {
        if (window.location.reload) {
          window.location.reload();
        }
      }, 3000);
    } else {
      this.enterOfflineMode();
    }
  }

  handlePermissionError() {
    console.log('ğŸ” Handling permission error...');
    
    // æ¨©é™ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
    this.showPermissionErrorDialog();
  }

  handleQuotaError() {
    console.log('ğŸ“Š Handling quota error...');
    
    // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
    this.cleanupStorage();
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
    this.showQuotaErrorDialog();
  }

  handleSyntaxError() {
    console.log('ğŸ“ Handling syntax error...');
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ã‚¯ãƒªã‚¢
    this.clearScriptCache();
    
    // ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰ã‚’ææ¡ˆ
    setTimeout(() => {
      if (confirm('ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã‹ï¼Ÿ')) {
        window.location.reload();
      }
    }, 1000);
  }

  handleGenericError(errorRecord) {
    console.log('ğŸ”§ Handling generic error...');
    
    // ã‚¨ãƒ©ãƒ¼ã®é‡è¦åº¦ã‚’åˆ¤å®š
    const isCritical = this.isErrorCritical(errorRecord);
    
    if (isCritical) {
      // é‡è¦ãªã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§ã‚’è©¦è¡Œ
      this.attemptSystemRecovery();
    } else {
      // è»½å¾®ãªã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ­ã‚°ã®ã¿
      console.debug('Minor error handled:', errorRecord);
    }
  }

  isErrorCritical(errorRecord) {
    const criticalPatterns = [
      'cannot read property',
      'is not a function',
      'failed to fetch',
      'network request failed',
      'initialization failed'
    ];
    
    const message = errorRecord.message.toLowerCase();
    return criticalPatterns.some(pattern => message.includes(pattern));
  }

  attemptResourceRecovery(target, resourceType) {
    const originalSrc = target.src || target.href;
    
    if (!originalSrc) return;
    
    console.log(`ğŸ”„ Attempting to recover ${resourceType}:`, originalSrc);
    
    // å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œ
    setTimeout(() => {
      try {
        if (resourceType === 'script') {
          this.reloadScript(target, originalSrc);
        } else if (resourceType === 'link') {
          this.reloadStylesheet(target, originalSrc);
        } else if (resourceType === 'img') {
          this.reloadImage(target, originalSrc);
        }
      } catch (error) {
        console.error('Resource recovery failed:', error);
      }
    }, 1000);
  }

  reloadScript(originalScript, src) {
    const newScript = document.createElement('script');
    newScript.src = src + '?retry=' + Date.now();
    newScript.onload = () => console.log('âœ… Script recovered:', src);
    newScript.onerror = () => console.error('âŒ Script recovery failed:', src);
    document.head.appendChild(newScript);
  }

  reloadStylesheet(originalLink, href) {
    const newLink = document.createElement('link');
    newLink.rel = 'stylesheet';
    newLink.href = href + '?retry=' + Date.now();
    newLink.onload = () => console.log('âœ… Stylesheet recovered:', href);
    newLink.onerror = () => console.error('âŒ Stylesheet recovery failed:', href);
    document.head.appendChild(newLink);
  }

  reloadImage(originalImg, src) {
    originalImg.src = src + '?retry=' + Date.now();
  }

  enterOfflineMode() {
    console.log('ğŸ“± Entering offline mode');
    
    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰UIè¡¨ç¤º
    this.showOfflineInterface();
    
    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–
    this.enableOfflineFeatures();
  }

  attemptRecovery() {
    if (this.recoveryMode) {
      console.log('ğŸ”„ Attempting system recovery...');
      
      // ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
      const isHealthy = this.performHealthCheck();
      
      if (isHealthy) {
        this.exitRecoveryMode();
      } else {
        // è¿½åŠ ã®ä¿®å¾©ã‚’è©¦è¡Œ
        this.performDeepRecovery();
      }
    }
  }

  performHealthCheck() {
    try {
      // åŸºæœ¬çš„ãªæ©Ÿèƒ½ç¢ºèª
      const checks = [
        () => typeof window !== 'undefined',
        () => typeof document !== 'undefined',
        () => document.body !== null,
        () => window.localStorage !== null,
        () => typeof JSON !== 'undefined'
      ];
      
      return checks.every(check => {
        try {
          return check();
        } catch (error) {
          return false;
        }
      });
    } catch (error) {
      return false;
    }
  }

  performDeepRecovery() {
    console.log('ğŸ”§ Performing deep recovery...');
    
    const recoverySteps = [
      () => this.clearAllStorage(),
      () => this.resetGlobalState(),
      () => this.reinitializeCore(),
      () => this.validateRecovery()
    ];
    
    let stepIndex = 0;
    
    const executeStep = async () => {
      if (stepIndex < recoverySteps.length) {
        try {
          await recoverySteps[stepIndex]();
          stepIndex++;
          setTimeout(executeStep, 500);
        } catch (error) {
          console.error(`Recovery step ${stepIndex} failed:`, error);
          stepIndex++;
          setTimeout(executeStep, 1000);
        }
      } else {
        console.log('ğŸ¯ Deep recovery completed');
        this.attemptRecovery();
      }
    };
    
    executeStep();
  }

  exitRecoveryMode() {
    this.recoveryMode = false;
    this.errorCount = 0;
    console.log('âœ… Recovery mode exited - System restored');
    
    // å›å¾©ãƒ¢ãƒ¼ãƒ‰UIã‚’éš ã™
    this.hideRecoveryInterface();
    
    // ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§é€šçŸ¥
    this.showRecoverySuccessMessage();
  }

  // UIé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰
  showRecoveryInterface() {
    if (document.getElementById('error-boundary-recovery')) return;
    
    const recoveryDiv = document.createElement('div');
    recoveryDiv.id = 'error-boundary-recovery';
    recoveryDiv.className = 'fixed top-0 left-0 right-0 bg-red-600 text-white p-3 z-50 text-center';
    recoveryDiv.innerHTML = `
      <div class="flex items-center justify-center space-x-2">
        <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
        <span>ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ ä¿®å¾©ä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„</span>
      </div>
    `;
    document.body.appendChild(recoveryDiv);
  }

  hideRecoveryInterface() {
    const recoveryDiv = document.getElementById('error-boundary-recovery');
    if (recoveryDiv) {
      recoveryDiv.remove();
    }
  }

  showOfflineInterface() {
    if (document.getElementById('error-boundary-offline')) return;
    
    const offlineDiv = document.createElement('div');
    offlineDiv.id = 'error-boundary-offline';
    offlineDiv.className = 'fixed top-0 left-0 right-0 bg-yellow-600 text-white p-3 z-50 text-center';
    offlineDiv.innerHTML = `
      <div class="flex items-center justify-center space-x-2">
        <span>ğŸ“± ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„</span>
      </div>
    `;
    document.body.appendChild(offlineDiv);
  }

  showPermissionErrorDialog() {
    alert('æ¨©é™ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã™ã‚‹ã‹ã€ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚');
  }

  showQuotaErrorDialog() {
    if (confirm('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
      this.cleanupStorage();
    }
  }

  showRecoverySuccessMessage() {
    const successDiv = document.createElement('div');
    successDiv.className = 'fixed top-4 right-4 bg-green-600 text-white p-4 rounded-lg shadow-lg z-50';
    successDiv.innerHTML = 'âœ… ã‚·ã‚¹ãƒ†ãƒ ãŒå¾©æ—§ã—ã¾ã—ãŸ';
    document.body.appendChild(successDiv);
    
    setTimeout(() => successDiv.remove(), 3000);
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  clearAllStorage() {
    try {
      if (window.localStorage) {
        localStorage.clear();
      }
      if (window.sessionStorage) {
        sessionStorage.clear();
      }
    } catch (error) {
      console.debug('Storage clear failed:', error);
    }
  }

  cleanupStorage() {
    try {
      // å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
      if (window.localStorage) {
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
          if (key.startsWith('cache_') || key.startsWith('temp_')) {
            localStorage.removeItem(key);
          }
        });
      }
    } catch (error) {
      console.debug('Storage cleanup failed:', error);
    }
  }

  resetGlobalState() {
    try {
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
      if (window.AdminPanel) {
        window.AdminPanel.initialized = false;
      }
      if (window.studyQuestApp) {
        window.studyQuestApp = null;
      }
    } catch (error) {
      console.debug('Global state reset failed:', error);
    }
  }

  reinitializeCore() {
    try {
      // ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã®å†åˆæœŸåŒ–
      if (window.RobustAdminPanel && typeof window.RobustAdminPanel.initialize === 'function') {
        window.RobustAdminPanel.initialize();
      }
    } catch (error) {
      console.debug('Core reinitialization failed:', error);
    }
  }

  validateRecovery() {
    try {
      // å¾©æ—§ã®æ¤œè¨¼
      return this.performHealthCheck();
    } catch (error) {
      return false;
    }
  }

  clearScriptCache() {
    try {
      // Service Worker ãŒã‚ã‚‹å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
          registrations.forEach(registration => {
            registration.unregister();
          });
        });
      }
    } catch (error) {
      console.debug('Script cache clear failed:', error);
    }
  }

  enableOfflineFeatures() {
    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã®å®Ÿè£…ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    console.log('ğŸ“± Offline features enabled');
  }

  // ãƒ‡ãƒãƒƒã‚°ãƒ»è¨ºæ–­ãƒ¡ã‚½ãƒƒãƒ‰
  getErrorReport() {
    return {
      errorCount: this.errorCount,
      recoveryMode: this.recoveryMode,
      recentErrors: this.errorLog.slice(-10),
      systemHealth: this.performHealthCheck(),
      timestamp: Date.now()
    };
  }

  exportErrorLog() {
    const report = this.getErrorReport();
    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `error-report-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
}

// =============================================================================
// ç‰¹å®šæ©Ÿèƒ½å‘ã‘ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼
// =============================================================================

class APIErrorBoundary {
  constructor() {
    this.retryAttempts = new Map();
    this.circuitBreakers = new Map();
  }

  async executeAPICall(apiFunction, options = {}) {
    const config = {
      maxRetries: options.maxRetries || 3,
      retryDelay: options.retryDelay || 1000,
      timeout: options.timeout || 10000,
      circuitBreakerKey: options.circuitBreakerKey || apiFunction.name,
      ...options
    };

    // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãƒã‚§ãƒƒã‚¯
    if (this.isCircuitBreakerOpen(config.circuitBreakerKey)) {
      throw new Error(`Circuit breaker open for ${config.circuitBreakerKey}`);
    }

    const attemptKey = config.circuitBreakerKey + Date.now();
    let attempt = 0;

    while (attempt < config.maxRetries) {
      attempt++;
      
      try {
        const result = await Promise.race([
          apiFunction(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), config.timeout)
          )
        ]);

        this.recordAPISuccess(config.circuitBreakerKey);
        return result;

      } catch (error) {
        console.warn(`API call attempt ${attempt} failed:`, error);
        
        this.recordAPIFailure(config.circuitBreakerKey);
        
        if (attempt >= config.maxRetries) {
          throw error;
        }

        const delay = config.retryDelay * Math.pow(2, attempt - 1);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  isCircuitBreakerOpen(key) {
    const breaker = this.circuitBreakers.get(key);
    if (!breaker) return false;

    const now = Date.now();
    if (breaker.state === 'open' && now - breaker.lastFailure > 30000) {
      breaker.state = 'half-open';
    }

    return breaker.state === 'open';
  }

  recordAPISuccess(key) {
    const breaker = this.circuitBreakers.get(key) || { failures: 0, state: 'closed' };
    breaker.failures = 0;
    breaker.state = 'closed';
    this.circuitBreakers.set(key, breaker);
  }

  recordAPIFailure(key) {
    const breaker = this.circuitBreakers.get(key) || { failures: 0, state: 'closed' };
    breaker.failures += 1;
    breaker.lastFailure = Date.now();

    if (breaker.failures >= 3) {
      breaker.state = 'open';
      console.warn(`Circuit breaker opened for ${key}`);
    }

    this.circuitBreakers.set(key, breaker);
  }
}

// =============================================================================
// ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆæœŸåŒ–
// =============================================================================

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
window.globalErrorBoundary = new GlobalErrorBoundary();
window.apiErrorBoundary = new APIErrorBoundary();

// ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰
window.getErrorReport = () => window.globalErrorBoundary.getErrorReport();
window.exportErrorLog = () => window.globalErrorBoundary.exportErrorLog();

console.log('ğŸ›¡ï¸ ErrorBoundarySystem loaded - Comprehensive error protection enabled');
</script>