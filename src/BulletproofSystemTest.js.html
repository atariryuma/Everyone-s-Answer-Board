<script>
/**
 * 堅牢性システム包括テスト
 * エラー耐性とフォールバック機能の検証
 */

window.BulletproofSystemTest = {
  testResults: [],
  isRunning: false,
  
  // 包括的システムテスト実行
  async runCompleteTest() {
    if (this.isRunning) {
      console.warn('Test already running');
      return;
    }
    
    this.isRunning = true;
    this.testResults = [];
    
    console.log('🧪 Starting bulletproof system test...');
    
    try {
      const testSuites = [
        () => this.testRobustConfig(),
        () => this.testErrorBoundaries(),
        () => this.testAPIResilience(),
        () => this.testInitializationFailure(),
        () => this.testNetworkFailure(),
        () => this.testStorageFailure(),
        () => this.testUIResilience(),
        () => this.testRecoveryMechanisms()
      ];
      
      for (const testSuite of testSuites) {
        try {
          await testSuite();
          await this.delay(500); // テスト間の待機
        } catch (error) {
          console.error('Test suite failed:', error);
        }
      }
      
      this.displayTestResults();
      
    } finally {
      this.isRunning = false;
    }
  },
  
  // 堅牢な設定システムテスト
  async testRobustConfig() {
    console.log('🔧 Testing robust configuration system...');
    
    const tests = [
      {
        name: 'Config with null value',
        test: async () => {
          const result = await window.robustConfig.getConfig('test', 'nullValue');
          return result !== null && result !== undefined;
        }
      },
      {
        name: 'Config with fallback',
        test: async () => {
          const result = await window.robustConfig.getConfig('nonexistent', 'category');
          return result === null; // Should return null for non-existent config
        }
      },
      {
        name: 'Config save and retrieve',
        test: async () => {
          const testValue = 'test_' + Date.now();
          await window.robustConfig.saveConfig('test', 'saveTest', testValue, false);
          const retrieved = await window.robustConfig.getConfig('test', 'saveTest');
          return retrieved === testValue;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('RobustConfig', test.name, passed);
      } catch (error) {
        this.recordTestResult('RobustConfig', test.name, false, error);
      }
    }
  },
  
  // エラーバウンダリーテスト
  async testErrorBoundaries() {
    console.log('🛡️ Testing error boundaries...');
    
    const tests = [
      {
        name: 'JavaScript error handling',
        test: async () => {
          const originalErrorCount = window.globalErrorBoundary.errorCount;
          
          // 意図的にエラーを発生
          try {
            throw new Error('Test error for boundary');
          } catch (error) {
            window.globalErrorBoundary.handleError(error, 'Test Error');
          }
          
          return window.globalErrorBoundary.errorCount > originalErrorCount;
        }
      },
      {
        name: 'Promise rejection handling',
        test: async () => {
          const originalLogLength = window.globalErrorBoundary.errorLog.length;
          
          // 未処理のPromise拒否をシミュレート
          const rejectedPromise = Promise.reject(new Error('Test promise rejection'));
          
          await this.delay(100); // エラーハンドラーが動作するまで待機
          
          return window.globalErrorBoundary.errorLog.length > originalLogLength;
        }
      },
      {
        name: 'Recovery mode activation',
        test: async () => {
          const originalRecoveryMode = window.globalErrorBoundary.recoveryMode;
          
          // 短時間で複数のエラーを発生させて復旧モードをトリガー
          for (let i = 0; i < 6; i++) {
            window.globalErrorBoundary.handleError(
              new Error(`Test error ${i}`),
              'Bulk Test Error'
            );
          }
          
          const recoveryActivated = window.globalErrorBoundary.recoveryMode;
          
          // テスト後にリセット
          window.globalErrorBoundary.recoveryMode = originalRecoveryMode;
          window.globalErrorBoundary.errorCount = 0;
          
          return recoveryActivated;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('ErrorBoundary', test.name, passed);
      } catch (error) {
        this.recordTestResult('ErrorBoundary', test.name, false, error);
      }
    }
  },
  
  // API耐性テスト
  async testAPIResilience() {
    console.log('📡 Testing API resilience...');
    
    const tests = [
      {
        name: 'Retry mechanism',
        test: async () => {
          let attempts = 0;
          
          const failingFunction = () => {
            attempts++;
            if (attempts < 3) {
              throw new Error('Simulated API failure');
            }
            return { success: true, attempts };
          };
          
          try {
            const result = await window.apiErrorBoundary.executeAPICall(failingFunction, {
              maxRetries: 3,
              retryDelay: 100
            });
            
            return result.attempts === 3;
          } catch (error) {
            return false;
          }
        }
      },
      {
        name: 'Circuit breaker',
        test: async () => {
          const failingFunction = () => {
            throw new Error('Persistent API failure');
          };
          
          // 複数回失敗させてサーキットブレーカーを開く
          for (let i = 0; i < 3; i++) {
            try {
              await window.apiErrorBoundary.executeAPICall(failingFunction, {
                maxRetries: 1,
                retryDelay: 10,
                circuitBreakerKey: 'test-circuit'
              });
            } catch (error) {
              // Expected to fail
            }
          }
          
          // サーキットブレーカーが開いているか確認
          return window.apiErrorBoundary.isCircuitBreakerOpen('test-circuit');
        }
      },
      {
        name: 'Timeout handling',
        test: async () => {
          const slowFunction = () => {
            return new Promise(resolve => {
              setTimeout(() => resolve('slow response'), 2000);
            });
          };
          
          try {
            await window.apiErrorBoundary.executeAPICall(slowFunction, {
              timeout: 500,
              maxRetries: 1
            });
            return false; // Should not reach here
          } catch (error) {
            return error.message.includes('timeout');
          }
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('APIResilience', test.name, passed);
      } catch (error) {
        this.recordTestResult('APIResilience', test.name, false, error);
      }
    }
  },
  
  // 初期化失敗テスト
  async testInitializationFailure() {
    console.log('🚀 Testing initialization failure handling...');
    
    const tests = [
      {
        name: 'Fallback mode activation',
        test: async () => {
          // RobustAdminPanelの状態を一時的に変更
          const originalInitialized = window.RobustAdminPanel.initialized;
          window.RobustAdminPanel.initialized = false;
          
          // フォールバックモード初期化を実行
          await window.RobustAdminPanel.initializeFallbackMode();
          
          const fallbackActivated = window.RobustAdminPanel.state.fallbackMode;
          
          // 状態を復元
          window.RobustAdminPanel.initialized = originalInitialized;
          
          return fallbackActivated;
        }
      },
      {
        name: 'Emergency mode handling',
        test: async () => {
          // 緊急モードをテスト
          await window.RobustAdminPanel.enterEmergencyMode();
          
          const emergencyActivated = window.RobustAdminPanel.state.systemStatus === 'emergency';
          
          // UI要素が作成されているか確認
          const emergencyInterface = document.getElementById('emergency-interface');
          
          // クリーンアップ
          if (emergencyInterface) {
            emergencyInterface.remove();
          }
          
          return emergencyActivated && emergencyInterface !== null;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('Initialization', test.name, passed);
      } catch (error) {
        this.recordTestResult('Initialization', test.name, false, error);
      }
    }
  },
  
  // ネットワーク障害テスト
  async testNetworkFailure() {
    console.log('🌐 Testing network failure handling...');
    
    const tests = [
      {
        name: 'Offline mode detection',
        test: async () => {
          // オフライン状態をシミュレート
          const originalOnLine = navigator.onLine;
          Object.defineProperty(navigator, 'onLine', {
            writable: true,
            value: false
          });
          
          window.globalErrorBoundary.enterOfflineMode();
          
          const offlineInterface = document.getElementById('error-boundary-offline');
          const result = offlineInterface !== null;
          
          // クリーンアップ
          if (offlineInterface) {
            offlineInterface.remove();
          }
          
          // 状態を復元
          Object.defineProperty(navigator, 'onLine', {
            writable: true,
            value: originalOnLine
          });
          
          return result;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('NetworkFailure', test.name, passed);
      } catch (error) {
        this.recordTestResult('NetworkFailure', test.name, false, error);
      }
    }
  },
  
  // ストレージ障害テスト
  async testStorageFailure() {
    console.log('💾 Testing storage failure handling...');
    
    const tests = [
      {
        name: 'LocalStorage failure recovery',
        test: async () => {
          // localStorageを一時的に無効化
          const originalLocalStorage = window.localStorage;
          delete window.localStorage;
          
          try {
            // 設定保存を試行（失敗するはず）
            const result = await window.robustConfig.saveToLocalStorage('test', 'key', 'value');
            
            // 復元
            window.localStorage = originalLocalStorage;
            
            // 失敗を適切に処理したかチェック（falseが返るべき）
            return result === false;
          } catch (error) {
            // 復元
            window.localStorage = originalLocalStorage;
            return true; // エラーが適切に処理された
          }
        }
      },
      {
        name: 'Storage cleanup functionality',
        test: async () => {
          // テスト用データを作成
          localStorage.setItem('cache_test1', 'value1');
          localStorage.setItem('temp_test2', 'value2');
          localStorage.setItem('normal_test3', 'value3');
          
          // クリーンアップを実行
          window.globalErrorBoundary.cleanupStorage();
          
          // cache_とtemp_のプレフィックスのアイテムが削除され、
          // normal_のプレフィックスのアイテムが残っているかチェック
          const cache1Gone = localStorage.getItem('cache_test1') === null;
          const temp2Gone = localStorage.getItem('temp_test2') === null;
          const normal3Remains = localStorage.getItem('normal_test3') === 'value3';
          
          // クリーンアップ
          localStorage.removeItem('normal_test3');
          
          return cache1Gone && temp2Gone && normal3Remains;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('StorageFailure', test.name, passed);
      } catch (error) {
        this.recordTestResult('StorageFailure', test.name, false, error);
      }
    }
  },
  
  // UI耐性テスト
  async testUIResilience() {
    console.log('🎨 Testing UI resilience...');
    
    const tests = [
      {
        name: 'Safe text setting with missing element',
        test: async () => {
          // 存在しない要素に対してsafeSetTextを実行
          try {
            // safeSetText関数が存在するか確認
            if (typeof safeSetText === 'function') {
              safeSetText('non-existent-element', 'test value');
              return true; // エラーが発生しなければ成功
            } else {
              // 関数が存在しない場合はスキップ
              return true;
            }
          } catch (error) {
            return false; // エラーが発生したら失敗
          }
        }
      },
      {
        name: 'Emergency repair panel creation',
        test: async () => {
          // 最小限インターフェースの表示をテスト
          if (typeof displayMinimalInterface === 'function') {
            displayMinimalInterface();
            
            const repairPanel = document.getElementById('emergency-repair-panel');
            const result = repairPanel !== null;
            
            // クリーンアップ
            if (repairPanel) {
              repairPanel.remove();
            }
            
            return result;
          }
          return true; // 関数が存在しない場合はスキップ
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('UIResilience', test.name, passed);
      } catch (error) {
        this.recordTestResult('UIResilience', test.name, false, error);
      }
    }
  },
  
  // 回復メカニズムテスト
  async testRecoveryMechanisms() {
    console.log('🔧 Testing recovery mechanisms...');
    
    const tests = [
      {
        name: 'Health check functionality',
        test: async () => {
          const healthResult = window.globalErrorBoundary.performHealthCheck();
          return typeof healthResult === 'boolean';
        }
      },
      {
        name: 'System state reset',
        test: async () => {
          // グローバル状態を設定
          window.testGlobalState = 'test value';
          
          // リセットを実行
          window.globalErrorBoundary.resetGlobalState();
          
          // 一部の状態がリセットされたかチェック（この場合、AdminPanelの状態）
          const adminPanelReset = window.AdminPanel ? 
            window.AdminPanel.initialized === false : true;
          
          // テスト用の状態をクリーンアップ
          delete window.testGlobalState;
          
          return adminPanelReset;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('RecoveryMechanisms', test.name, passed);
      } catch (error) {
        this.recordTestResult('RecoveryMechanisms', test.name, false, error);
      }
    }
  },
  
  // ユーティリティメソッド
  recordTestResult(suite, test, passed, error = null) {
    const result = {
      suite: suite,
      test: test,
      passed: passed,
      error: error ? error.message : null,
      timestamp: new Date().toISOString()
    };
    
    this.testResults.push(result);
    
    const status = passed ? '✅' : '❌';
    console.log(`${status} ${suite}: ${test}`);
    
    if (error) {
      console.error(`   Error: ${error.message}`);
    }
  },
  
  displayTestResults() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;
    
    console.log('\n📊 Bulletproof System Test Results:');
    console.log(`Total Tests: ${totalTests}`);
    console.log(`✅ Passed: ${passedTests}`);
    console.log(`❌ Failed: ${failedTests}`);
    console.log(`🎯 Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
    
    if (failedTests > 0) {
      console.log('\n❌ Failed Tests:');
      this.testResults.filter(r => !r.passed).forEach(result => {
        console.log(`   ${result.suite}: ${result.test}`);
        if (result.error) {
          console.log(`      Error: ${result.error}`);
        }
      });
    }
    
    // 結果をページに表示
    this.displayResultsOnPage();
  },
  
  displayResultsOnPage() {
    const resultDiv = document.createElement('div');
    resultDiv.id = 'bulletproof-test-results';
    resultDiv.className = 'fixed bottom-4 right-4 bg-gray-800 text-white p-4 rounded-lg shadow-lg max-w-md z-50';
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.passed).length;
    const successRate = ((passedTests / totalTests) * 100).toFixed(1);
    
    resultDiv.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-bold">🧪 System Test Results</h3>
        <button onclick="document.getElementById('bulletproof-test-results').remove()" class="text-gray-400 hover:text-white">✕</button>
      </div>
      <div class="space-y-1 text-sm">
        <div>Total Tests: ${totalTests}</div>
        <div class="text-green-400">✅ Passed: ${passedTests}</div>
        <div class="text-red-400">❌ Failed: ${totalTests - passedTests}</div>
        <div class="font-bold">🎯 Success Rate: ${successRate}%</div>
      </div>
      <div class="mt-3 text-xs">
        <button onclick="console.log(window.BulletproofSystemTest.testResults)" class="text-cyan-400 hover:text-cyan-300">View Details in Console</button>
      </div>
    `;
    
    document.body.appendChild(resultDiv);
    
    // 10秒後に自動的に非表示
    setTimeout(() => {
      if (document.getElementById('bulletproof-test-results')) {
        resultDiv.remove();
      }
    }, 10000);
  },
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },
  
  // 外部から呼び出せるテスト実行関数
  async quickTest() {
    console.log('⚡ Running quick bulletproof test...');
    
    const quickTests = [
      () => this.testErrorBoundaries(),
      () => this.testUIResilience()
    ];
    
    this.testResults = [];
    
    for (const test of quickTests) {
      try {
        await test();
      } catch (error) {
        console.error('Quick test failed:', error);
      }
    }
    
    this.displayTestResults();
  }
};

// グローバルアクセス用関数
window.runBulletproofTest = () => window.BulletproofSystemTest.runCompleteTest();
window.runQuickTest = () => window.BulletproofSystemTest.quickTest();

console.log('🧪 BulletproofSystemTest loaded - Use runBulletproofTest() or runQuickTest() to verify system resilience');
</script>