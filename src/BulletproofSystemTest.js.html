<script>
/**
 * å …ç‰¢æ€§ã‚·ã‚¹ãƒ†ãƒ åŒ…æ‹¬ãƒ†ã‚¹ãƒˆ
 * ã‚¨ãƒ©ãƒ¼è€æ€§ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã®æ¤œè¨¼
 */

window.BulletproofSystemTest = {
  testResults: [],
  isRunning: false,
  
  // åŒ…æ‹¬çš„ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
  async runCompleteTest() {
    if (this.isRunning) {
      console.warn('Test already running');
      return;
    }
    
    this.isRunning = true;
    this.testResults = [];
    
    console.log('ğŸ§ª Starting bulletproof system test...');
    
    try {
      const testSuites = [
        () => this.testRobustConfig(),
        () => this.testErrorBoundaries(),
        () => this.testAPIResilience(),
        () => this.testInitializationFailure(),
        () => this.testNetworkFailure(),
        () => this.testStorageFailure(),
        () => this.testUIResilience(),
        () => this.testRecoveryMechanisms()
      ];
      
      for (const testSuite of testSuites) {
        try {
          await testSuite();
          await this.delay(500); // ãƒ†ã‚¹ãƒˆé–“ã®å¾…æ©Ÿ
        } catch (error) {
          console.error('Test suite failed:', error);
        }
      }
      
      this.displayTestResults();
      
    } finally {
      this.isRunning = false;
    }
  },
  
  // å …ç‰¢ãªè¨­å®šã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
  async testRobustConfig() {
    console.log('ğŸ”§ Testing robust configuration system...');
    
    const tests = [
      {
        name: 'Config with null value',
        test: async () => {
          const result = await window.robustConfig.getConfig('test', 'nullValue');
          return result !== null && result !== undefined;
        }
      },
      {
        name: 'Config with fallback',
        test: async () => {
          const result = await window.robustConfig.getConfig('nonexistent', 'category');
          return result === null; // Should return null for non-existent config
        }
      },
      {
        name: 'Config save and retrieve',
        test: async () => {
          const testValue = 'test_' + Date.now();
          await window.robustConfig.saveConfig('test', 'saveTest', testValue, false);
          const retrieved = await window.robustConfig.getConfig('test', 'saveTest');
          return retrieved === testValue;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('RobustConfig', test.name, passed);
      } catch (error) {
        this.recordTestResult('RobustConfig', test.name, false, error);
      }
    }
  },
  
  // ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒ†ã‚¹ãƒˆ
  async testErrorBoundaries() {
    console.log('ğŸ›¡ï¸ Testing error boundaries...');
    
    const tests = [
      {
        name: 'JavaScript error handling',
        test: async () => {
          const originalErrorCount = window.globalErrorBoundary.errorCount;
          
          // æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿ
          try {
            throw new Error('Test error for boundary');
          } catch (error) {
            window.globalErrorBoundary.handleError(error, 'Test Error');
          }
          
          return window.globalErrorBoundary.errorCount > originalErrorCount;
        }
      },
      {
        name: 'Promise rejection handling',
        test: async () => {
          const originalLogLength = window.globalErrorBoundary.errorLog.length;
          
          // æœªå‡¦ç†ã®Promiseæ‹’å¦ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          const rejectedPromise = Promise.reject(new Error('Test promise rejection'));
          
          await this.delay(100); // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒå‹•ä½œã™ã‚‹ã¾ã§å¾…æ©Ÿ
          
          return window.globalErrorBoundary.errorLog.length > originalLogLength;
        }
      },
      {
        name: 'Recovery mode activation',
        test: async () => {
          const originalRecoveryMode = window.globalErrorBoundary.recoveryMode;
          
          // çŸ­æ™‚é–“ã§è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¦å¾©æ—§ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒˆãƒªã‚¬ãƒ¼
          for (let i = 0; i < 6; i++) {
            window.globalErrorBoundary.handleError(
              new Error(`Test error ${i}`),
              'Bulk Test Error'
            );
          }
          
          const recoveryActivated = window.globalErrorBoundary.recoveryMode;
          
          // ãƒ†ã‚¹ãƒˆå¾Œã«ãƒªã‚»ãƒƒãƒˆ
          window.globalErrorBoundary.recoveryMode = originalRecoveryMode;
          window.globalErrorBoundary.errorCount = 0;
          
          return recoveryActivated;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('ErrorBoundary', test.name, passed);
      } catch (error) {
        this.recordTestResult('ErrorBoundary', test.name, false, error);
      }
    }
  },
  
  // APIè€æ€§ãƒ†ã‚¹ãƒˆ
  async testAPIResilience() {
    console.log('ğŸ“¡ Testing API resilience...');
    
    const tests = [
      {
        name: 'Retry mechanism',
        test: async () => {
          let attempts = 0;
          
          const failingFunction = () => {
            attempts++;
            if (attempts < 3) {
              throw new Error('Simulated API failure');
            }
            return { success: true, attempts };
          };
          
          try {
            const result = await window.apiErrorBoundary.executeAPICall(failingFunction, {
              maxRetries: 3,
              retryDelay: 100
            });
            
            return result.attempts === 3;
          } catch (error) {
            return false;
          }
        }
      },
      {
        name: 'Circuit breaker',
        test: async () => {
          const failingFunction = () => {
            throw new Error('Persistent API failure');
          };
          
          // è¤‡æ•°å›å¤±æ•—ã•ã›ã¦ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã‚’é–‹ã
          for (let i = 0; i < 3; i++) {
            try {
              await window.apiErrorBoundary.executeAPICall(failingFunction, {
                maxRetries: 1,
                retryDelay: 10,
                circuitBreakerKey: 'test-circuit'
              });
            } catch (error) {
              // Expected to fail
            }
          }
          
          // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹ã‹ç¢ºèª
          return window.apiErrorBoundary.isCircuitBreakerOpen('test-circuit');
        }
      },
      {
        name: 'Timeout handling',
        test: async () => {
          const slowFunction = () => {
            return new Promise(resolve => {
              setTimeout(() => resolve('slow response'), 2000);
            });
          };
          
          try {
            await window.apiErrorBoundary.executeAPICall(slowFunction, {
              timeout: 500,
              maxRetries: 1
            });
            return false; // Should not reach here
          } catch (error) {
            return error.message.includes('timeout');
          }
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('APIResilience', test.name, passed);
      } catch (error) {
        this.recordTestResult('APIResilience', test.name, false, error);
      }
    }
  },
  
  // åˆæœŸåŒ–å¤±æ•—ãƒ†ã‚¹ãƒˆ
  async testInitializationFailure() {
    console.log('ğŸš€ Testing initialization failure handling...');
    
    const tests = [
      {
        name: 'Fallback mode activation',
        test: async () => {
          // RobustAdminPanelã®çŠ¶æ…‹ã‚’ä¸€æ™‚çš„ã«å¤‰æ›´
          const originalInitialized = window.RobustAdminPanel.initialized;
          window.RobustAdminPanel.initialized = false;
          
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
          await window.RobustAdminPanel.initializeFallbackMode();
          
          const fallbackActivated = window.RobustAdminPanel.state.fallbackMode;
          
          // çŠ¶æ…‹ã‚’å¾©å…ƒ
          window.RobustAdminPanel.initialized = originalInitialized;
          
          return fallbackActivated;
        }
      },
      {
        name: 'Emergency mode handling',
        test: async () => {
          // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒ†ã‚¹ãƒˆ
          await window.RobustAdminPanel.enterEmergencyMode();
          
          const emergencyActivated = window.RobustAdminPanel.state.systemStatus === 'emergency';
          
          // UIè¦ç´ ãŒä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
          const emergencyInterface = document.getElementById('emergency-interface');
          
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          if (emergencyInterface) {
            emergencyInterface.remove();
          }
          
          return emergencyActivated && emergencyInterface !== null;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('Initialization', test.name, passed);
      } catch (error) {
        this.recordTestResult('Initialization', test.name, false, error);
      }
    }
  },
  
  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆ
  async testNetworkFailure() {
    console.log('ğŸŒ Testing network failure handling...');
    
    const tests = [
      {
        name: 'Offline mode detection',
        test: async () => {
          // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          const originalOnLine = navigator.onLine;
          Object.defineProperty(navigator, 'onLine', {
            writable: true,
            value: false
          });
          
          window.globalErrorBoundary.enterOfflineMode();
          
          const offlineInterface = document.getElementById('error-boundary-offline');
          const result = offlineInterface !== null;
          
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          if (offlineInterface) {
            offlineInterface.remove();
          }
          
          // çŠ¶æ…‹ã‚’å¾©å…ƒ
          Object.defineProperty(navigator, 'onLine', {
            writable: true,
            value: originalOnLine
          });
          
          return result;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('NetworkFailure', test.name, passed);
      } catch (error) {
        this.recordTestResult('NetworkFailure', test.name, false, error);
      }
    }
  },
  
  // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸éšœå®³ãƒ†ã‚¹ãƒˆ
  async testStorageFailure() {
    console.log('ğŸ’¾ Testing storage failure handling...');
    
    const tests = [
      {
        name: 'LocalStorage failure recovery',
        test: async () => {
          // localStorageã‚’ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–
          const originalLocalStorage = window.localStorage;
          delete window.localStorage;
          
          try {
            // è¨­å®šä¿å­˜ã‚’è©¦è¡Œï¼ˆå¤±æ•—ã™ã‚‹ã¯ãšï¼‰
            const result = await window.robustConfig.saveToLocalStorage('test', 'key', 'value');
            
            // å¾©å…ƒ
            window.localStorage = originalLocalStorage;
            
            // å¤±æ•—ã‚’é©åˆ‡ã«å‡¦ç†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆfalseãŒè¿”ã‚‹ã¹ãï¼‰
            return result === false;
          } catch (error) {
            // å¾©å…ƒ
            window.localStorage = originalLocalStorage;
            return true; // ã‚¨ãƒ©ãƒ¼ãŒé©åˆ‡ã«å‡¦ç†ã•ã‚ŒãŸ
          }
        }
      },
      {
        name: 'Storage cleanup functionality',
        test: async () => {
          // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
          localStorage.setItem('cache_test1', 'value1');
          localStorage.setItem('temp_test2', 'value2');
          localStorage.setItem('normal_test3', 'value3');
          
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
          window.globalErrorBoundary.cleanupStorage();
          
          // cache_ã¨temp_ã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå‰Šé™¤ã•ã‚Œã€
          // normal_ã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒæ®‹ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          const cache1Gone = localStorage.getItem('cache_test1') === null;
          const temp2Gone = localStorage.getItem('temp_test2') === null;
          const normal3Remains = localStorage.getItem('normal_test3') === 'value3';
          
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          localStorage.removeItem('normal_test3');
          
          return cache1Gone && temp2Gone && normal3Remains;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('StorageFailure', test.name, passed);
      } catch (error) {
        this.recordTestResult('StorageFailure', test.name, false, error);
      }
    }
  },
  
  // UIè€æ€§ãƒ†ã‚¹ãƒˆ
  async testUIResilience() {
    console.log('ğŸ¨ Testing UI resilience...');
    
    const tests = [
      {
        name: 'Safe text setting with missing element',
        test: async () => {
          // å­˜åœ¨ã—ãªã„è¦ç´ ã«å¯¾ã—ã¦safeSetTextã‚’å®Ÿè¡Œ
          try {
            // safeSetTexté–¢æ•°ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            if (typeof safeSetText === 'function') {
              safeSetText('non-existent-element', 'test value');
              return true; // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã‘ã‚Œã°æˆåŠŸ
            } else {
              // é–¢æ•°ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
              return true;
            }
          } catch (error) {
            return false; // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚‰å¤±æ•—
          }
        }
      },
      {
        name: 'Emergency repair panel creation',
        test: async () => {
          // æœ€å°é™ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®è¡¨ç¤ºã‚’ãƒ†ã‚¹ãƒˆ
          if (typeof displayMinimalInterface === 'function') {
            displayMinimalInterface();
            
            const repairPanel = document.getElementById('emergency-repair-panel');
            const result = repairPanel !== null;
            
            // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            if (repairPanel) {
              repairPanel.remove();
            }
            
            return result;
          }
          return true; // é–¢æ•°ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('UIResilience', test.name, passed);
      } catch (error) {
        this.recordTestResult('UIResilience', test.name, false, error);
      }
    }
  },
  
  // å›å¾©ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãƒ†ã‚¹ãƒˆ
  async testRecoveryMechanisms() {
    console.log('ğŸ”§ Testing recovery mechanisms...');
    
    const tests = [
      {
        name: 'Health check functionality',
        test: async () => {
          const healthResult = window.globalErrorBoundary.performHealthCheck();
          return typeof healthResult === 'boolean';
        }
      },
      {
        name: 'System state reset',
        test: async () => {
          // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’è¨­å®š
          window.testGlobalState = 'test value';
          
          // ãƒªã‚»ãƒƒãƒˆã‚’å®Ÿè¡Œ
          window.globalErrorBoundary.resetGlobalState();
          
          // ä¸€éƒ¨ã®çŠ¶æ…‹ãŒãƒªã‚»ãƒƒãƒˆã•ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã“ã®å ´åˆã€AdminPanelã®çŠ¶æ…‹ï¼‰
          const adminPanelReset = window.AdminPanel ? 
            window.AdminPanel.initialized === false : true;
          
          // ãƒ†ã‚¹ãƒˆç”¨ã®çŠ¶æ…‹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          delete window.testGlobalState;
          
          return adminPanelReset;
        }
      }
    ];
    
    for (const test of tests) {
      try {
        const passed = await test.test();
        this.recordTestResult('RecoveryMechanisms', test.name, passed);
      } catch (error) {
        this.recordTestResult('RecoveryMechanisms', test.name, false, error);
      }
    }
  },
  
  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  recordTestResult(suite, test, passed, error = null) {
    const result = {
      suite: suite,
      test: test,
      passed: passed,
      error: error ? error.message : null,
      timestamp: new Date().toISOString()
    };
    
    this.testResults.push(result);
    
    const status = passed ? 'âœ…' : 'âŒ';
    console.log(`${status} ${suite}: ${test}`);
    
    if (error) {
      console.error(`   Error: ${error.message}`);
    }
  },
  
  displayTestResults() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;
    
    console.log('\nğŸ“Š Bulletproof System Test Results:');
    console.log(`Total Tests: ${totalTests}`);
    console.log(`âœ… Passed: ${passedTests}`);
    console.log(`âŒ Failed: ${failedTests}`);
    console.log(`ğŸ¯ Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
    
    if (failedTests > 0) {
      console.log('\nâŒ Failed Tests:');
      this.testResults.filter(r => !r.passed).forEach(result => {
        console.log(`   ${result.suite}: ${result.test}`);
        if (result.error) {
          console.log(`      Error: ${result.error}`);
        }
      });
    }
    
    // çµæœã‚’ãƒšãƒ¼ã‚¸ã«è¡¨ç¤º
    this.displayResultsOnPage();
  },
  
  displayResultsOnPage() {
    const resultDiv = document.createElement('div');
    resultDiv.id = 'bulletproof-test-results';
    resultDiv.className = 'fixed bottom-4 right-4 bg-gray-800 text-white p-4 rounded-lg shadow-lg max-w-md z-50';
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.passed).length;
    const successRate = ((passedTests / totalTests) * 100).toFixed(1);
    
    resultDiv.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-bold">ğŸ§ª System Test Results</h3>
        <button onclick="document.getElementById('bulletproof-test-results').remove()" class="text-gray-400 hover:text-white">âœ•</button>
      </div>
      <div class="space-y-1 text-sm">
        <div>Total Tests: ${totalTests}</div>
        <div class="text-green-400">âœ… Passed: ${passedTests}</div>
        <div class="text-red-400">âŒ Failed: ${totalTests - passedTests}</div>
        <div class="font-bold">ğŸ¯ Success Rate: ${successRate}%</div>
      </div>
      <div class="mt-3 text-xs">
        <button onclick="console.log(window.BulletproofSystemTest.testResults)" class="text-cyan-400 hover:text-cyan-300">View Details in Console</button>
      </div>
    `;
    
    document.body.appendChild(resultDiv);
    
    // 10ç§’å¾Œã«è‡ªå‹•çš„ã«éè¡¨ç¤º
    setTimeout(() => {
      if (document.getElementById('bulletproof-test-results')) {
        resultDiv.remove();
      }
    }, 10000);
  },
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },
  
  // å¤–éƒ¨ã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–¢æ•°
  async quickTest() {
    console.log('âš¡ Running quick bulletproof test...');
    
    const quickTests = [
      () => this.testErrorBoundaries(),
      () => this.testUIResilience()
    ];
    
    this.testResults = [];
    
    for (const test of quickTests) {
      try {
        await test();
      } catch (error) {
        console.error('Quick test failed:', error);
      }
    }
    
    this.displayTestResults();
  }
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ç”¨é–¢æ•°
window.runBulletproofTest = () => window.BulletproofSystemTest.runCompleteTest();
window.runQuickTest = () => window.BulletproofSystemTest.quickTest();

console.log('ğŸ§ª BulletproofSystemTest loaded - Use runBulletproofTest() or runQuickTest() to verify system resilience');
</script>