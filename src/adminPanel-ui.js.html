<script>
let lastSelectedSheetName = null; // To prevent redundant sheet selection change events

// =============================================================================
// UI UPDATE BATCHING SYSTEM - Prevent Duplicate DOM Operations
// =============================================================================

// UI Update Mutex to prevent race conditions
let isUIUpdateInProgress = false;
let pendingUIUpdate = null;

// ğŸ¯ UIæ›´æ–°ãƒãƒƒãƒãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
const uiUpdateBatching = {
  pendingUpdates: new Map(),
  batchTimer: null,
  lastBatchTime: 0,
  batchInterval: 100, // 100ms batching window
  
  // ãƒãƒƒãƒãƒ³ã‚°çŠ¶æ…‹ã®ç®¡ç†
  completedOperations: new Set(),
  
  // DOMæ“ä½œã®çµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥
  domCache: new Map(),
  
  // æœ€å¾Œã®æ›´æ–°å†…å®¹
  lastUpdateData: null
};

/**
 * UIæ›´æ–°ã‚’ãƒãƒƒãƒå‡¦ç†ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 * @param {string} updateType - æ›´æ–°ã‚¿ã‚¤ãƒ—
 */
function scheduleUIUpdate(status, updateType = 'full') {
  const updateId = `${updateType}_${Date.now()}`;
  
  // åŒã˜ã‚¿ã‚¤ãƒ—ã®æ›´æ–°ãŒæ—¢ã«ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®å ´åˆã¯ç½®ãæ›ãˆ
  for (const [id, data] of uiUpdateBatching.pendingUpdates) {
    if (data.type === updateType) {
      uiUpdateBatching.pendingUpdates.delete(id);
      console.log(`ğŸ”„ UIæ›´æ–°ã‚’çµ±åˆ: ${updateType}`);
    }
  }
  
  uiUpdateBatching.pendingUpdates.set(updateId, {
    status,
    type: updateType,
    timestamp: Date.now()
  });
  
  // ãƒãƒƒãƒã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
  if (uiUpdateBatching.batchTimer) {
    clearTimeout(uiUpdateBatching.batchTimer);
  }
  
  uiUpdateBatching.batchTimer = setTimeout(() => {
    executeBatchedUIUpdates();
  }, uiUpdateBatching.batchInterval);
  
  console.log(`ğŸ“‹ UIæ›´æ–°ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«: ${updateType} (ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°: ${uiUpdateBatching.pendingUpdates.size})`);
}

/**
 * ãƒãƒƒãƒåŒ–ã•ã‚ŒãŸUIæ›´æ–°ã‚’å®Ÿè¡Œ
 */
function executeBatchedUIUpdates() {
  if (uiUpdateBatching.pendingUpdates.size === 0) return;
  
  console.log(`ğŸš€ ãƒãƒƒãƒUIæ›´æ–°é–‹å§‹ (${uiUpdateBatching.pendingUpdates.size}ä»¶ã®æ›´æ–°ã‚’çµ±åˆ)`);
  
  // æœ€æ–°ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  let latestStatus = null;
  let latestTimestamp = 0;
  
  for (const [id, data] of uiUpdateBatching.pendingUpdates) {
    if (data.timestamp > latestTimestamp) {
      latestStatus = data.status;
      latestTimestamp = data.timestamp;
    }
  }
  
  if (!latestStatus) {
    console.warn('âš ï¸ ãƒãƒƒãƒæ›´æ–°: æœ‰åŠ¹ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    uiUpdateBatching.pendingUpdates.clear();
    return;
  }
  
  // é‡è¤‡ãƒã‚§ãƒƒã‚¯: å‰å›ã¨åŒã˜ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—
  const statusHash = generateStatusHash(latestStatus);
  if (uiUpdateBatching.lastUpdateData === statusHash) {
    console.log('ğŸ¯ ãƒãƒƒãƒæ›´æ–°: å‰å›ã¨åŒã˜ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—');
    uiUpdateBatching.pendingUpdates.clear();
    return;
  }
  
  // å®Ÿéš›ã®UIæ›´æ–°ã‚’å®Ÿè¡Œ
  performOptimizedUIUpdate(latestStatus);
  
  // çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
  uiUpdateBatching.pendingUpdates.clear();
  uiUpdateBatching.lastUpdateData = statusHash;
  uiUpdateBatching.lastBatchTime = Date.now();
  
  console.log('âœ… ãƒãƒƒãƒUIæ›´æ–°å®Œäº†');
}

/**
 * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚·ãƒ¥ç”Ÿæˆï¼ˆé‡è¤‡æ¤œå‡ºç”¨ï¼‰
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 * @returns {string} ãƒãƒƒã‚·ãƒ¥å€¤
 */
function generateStatusHash(status) {
  const keyData = {
    setupStep: status.setupStep,
    setupStatus: status.userInfo?.configJson ? JSON.parse(status.userInfo.configJson).setupStatus : null,
    activeSheet: status.activeSheetName,
    appPublished: status.config?.appPublished,
    hasSheetDetails: !!status.sheetDetails
  };
  return JSON.stringify(keyData);
}

/**
 * æœ€é©åŒ–ã•ã‚ŒãŸUIæ›´æ–°å®Ÿè¡Œ
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 */
function performOptimizedUIUpdate(status) {
  console.log('ğŸ”§ æœ€é©åŒ–UIæ›´æ–°é–‹å§‹');
  
  // DOMæ“ä½œã‚’æœ€å°é™ã«æŠ‘åˆ¶ã™ã‚‹æœ€é©åŒ–ã•ã‚ŒãŸæ›´æ–°
  const updateOperations = new Map();
  
  // 1. ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆ1å›ã®ã¿ï¼‰
  const preparedStatus = prepareStatusData(status);
  
  // 2. DOMæ›´æ–°æ“ä½œã‚’ãƒãƒƒãƒåŒ–
  updateOperations.set('static', () => updateStaticUIOptimized(preparedStatus));
  updateOperations.set('dynamic', () => updateDynamicContentOptimized(preparedStatus));
  updateOperations.set('footer', () => updateFooterAndGuidanceOptimized(preparedStatus));
  updateOperations.set('indicators', () => updateStepIndicatorsOptimized(preparedStatus));
  
  // 3. DOMæ“ä½œã‚’åŠ¹ç‡çš„ã«å®Ÿè¡Œ
  requestAnimationFrame(() => {
    for (const [operationType, operation] of updateOperations) {
      try {
        // é‡è¤‡å®Ÿè¡Œãƒã‚§ãƒƒã‚¯
        const operationKey = `${operationType}_${uiUpdateBatching.lastBatchTime}`;
        if (!uiUpdateBatching.completedOperations.has(operationKey)) {
          operation();
          uiUpdateBatching.completedOperations.add(operationKey);
        }
      } catch (error) {
        console.error(`âŒ UIæ›´æ–°ã‚¨ãƒ©ãƒ¼ (${operationType}):`, error);
      }
    }
    
    // å®Œäº†æ“ä½œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ï¼‰
    setTimeout(() => {
      uiUpdateBatching.completedOperations.clear();
    }, 5000);
  });
}

/**
 * æœ€é©åŒ–ã•ã‚ŒãŸãƒ•ãƒƒã‚¿ãƒ¼ãƒ»ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹æ›´æ–°ï¼ˆé‡è¤‡å®Ÿè¡Œé˜²æ­¢ï¼‰
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 */
function updateFooterAndGuidanceOptimized(status) {
  const cacheKey = `footer_${status.setupStep}_${status.activeSheetName || 'none'}`;
  
  // DOMæ“ä½œçµæœã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
  if (uiUpdateBatching.domCache.has(cacheKey)) {
    console.log('ğŸ¯ ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°: DOMã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ');
    return;
  }
  
  console.log('ğŸ¦¶ æœ€é©åŒ–ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°é–‹å§‹');
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('âŒ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }
  
  // å®Ÿéš›ã®ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå…ƒã®é–¢æ•°ã‹ã‚‰ï¼‰
  updateFooterAndGuidance(status);
  
  // DOMæ“ä½œçµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  uiUpdateBatching.domCache.set(cacheKey, true);
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®TTLã‚’è¨­å®šï¼ˆ10ç§’ï¼‰
  setTimeout(() => {
    uiUpdateBatching.domCache.delete(cacheKey);
  }, 10000);
  
  console.log('âœ… æœ€é©åŒ–ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°å®Œäº†');
}

/**
 * æœ€é©åŒ–ã•ã‚ŒãŸé™çš„UIæ›´æ–°
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 */
function updateStaticUIOptimized(status) {
  console.log('ğŸ¨ æœ€é©åŒ–é™çš„UIæ›´æ–°é–‹å§‹');
  
  // æ—¢å­˜ã®é™çš„UIæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨
  clearInitialDisplayElements();
  updateStaticUI(status);
  
  const setupStatus = getSetupStatusFromUserInfo(status.userInfo);
  if (setupStatus === 'pending') {
    updateButtonStatesForSetup(status);
  }
  
  console.log('âœ… æœ€é©åŒ–é™çš„UIæ›´æ–°å®Œäº†');
}

/**
 * æœ€é©åŒ–ã•ã‚ŒãŸå‹•çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 */
function updateDynamicContentOptimized(status) {
  console.log('ğŸ”§ æœ€é©åŒ–å‹•çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°é–‹å§‹');
  
  if (status.activeSheetName) {
    updateDynamicContent(status);
  } else {
    updateUIForNoActiveSheet(status);
  }
  
  console.log('âœ… æœ€é©åŒ–å‹•çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°å®Œäº†');
}

/**
 * æœ€é©åŒ–ã•ã‚ŒãŸã‚¹ãƒ†ãƒƒãƒ—ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‡ãƒ¼ã‚¿
 */
function updateStepIndicatorsOptimized(status) {
  console.log('ğŸ“Š æœ€é©åŒ–ã‚¹ãƒ†ãƒƒãƒ—ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°é–‹å§‹');
  
  const currentStep = status?.setupStep || 1;
  updateStepIndicators(currentStep, status);
  
  console.log('âœ… æœ€é©åŒ–ã‚¹ãƒ†ãƒƒãƒ—ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°å®Œäº†');
}

// =============================================================================
// ADMIN PANEL UI UPDATES & DISPLAY CONTROL
// =============================================================================

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Unified publication state detection with enhanced flow completion recognition
function getPublicationState(status) {
  if (!status) {
    return { isPublished: false, reason: 'No status data' };
  }
  
  // Check multiple possible publication indicators in priority order
  let isPublished = false;
  let reason = '';
  
  // 1. Direct isPublished property
  if (status.isPublished === true) {
    isPublished = true;
    reason = 'status.isPublished=true';
  }
  // 2. Direct appPublished property  
  else if (status.appPublished === true) {
    isPublished = true;
    reason = 'status.appPublished=true';
  }
  // 3. Check configJson for appPublished
  else if (status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.appPublished === true) {
        isPublished = true;
        reason = 'configJson.appPublished=true';
        
        // Enhanced validation: Verify setup completion indicators
        const hasCompletedSetup = (
          config.setupStatus === 'completed' &&
          config.formCreated === true &&
          config.publishedSheetName &&
          config.publishedSpreadsheetId
        );
        
        if (hasCompletedSetup) {
          reason += ' (å®Œå…¨ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿)';
        } else {
          console.log('âš ï¸ Publication state: appPublished=true but setup incomplete', {
            setupStatus: config.setupStatus,
            formCreated: config.formCreated,
            hasPublishedSheet: !!config.publishedSheetName,
            hasPublishedSpreadsheet: !!config.publishedSpreadsheetId
          });
          reason += ' (ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸å®Œå…¨)';
        }
      } 
      // 4. Enhanced completion check: Allow recognition of completed but not yet published setups
      else if (config.setupStatus === 'completed' && 
               config.formCreated === true && 
               config.publishedSheetName && 
               config.publishedSpreadsheetId) {
        // This covers cases where setup is complete but appPublished might not be properly set
        console.log('ğŸ”§ Publication state: Setup complete but appPublished=false - potential state inconsistency');
        reason = 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã ãŒå…¬é–‹çŠ¶æ…‹ä¸æ•´åˆ';
        // Don't auto-publish, but log for debugging
      }
    } catch (e) {
      console.warn('Failed to parse configJson:', e);
    }
  }
  
  // Maintained strict logic to prevent false positives
  // Note: Removed loose fallback logic that assumed activeSheetName = published
  
  return { 
    isPublished, 
    reason,
    // Add confidence level for better debugging
    confidence: isPublished ? (reason.includes('å®Œå…¨ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿') ? 'high' : 'medium') : 'low'
  };
}



// =============================================================================
// MAIN UI UPDATE FUNCTIONS
// =============================================================================

// Update UI with new status data - æœ€é©åŒ–ãƒãƒƒãƒãƒ³ã‚°ç‰ˆ
window.updateUIWithNewStatus = function(status) {
  if (!validateStatus(status)) {
    logWarn('Invalid status received, skipping UI update');
    return;
  }

  // ğŸ¯ æ–°ã—ã„UIæ›´æ–°ãƒãƒƒãƒãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨
  console.log('ğŸ“‹ UIæ›´æ–°ã‚’ãƒãƒƒãƒãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
  scheduleUIUpdate(status, 'full');
  
  // currentStatusã‚’æ›´æ–°ï¼ˆä»–ã®é–¢æ•°ã§å‚ç…§ã•ã‚Œã‚‹ï¼‰
  currentStatus = status;
};
console.log('âœ… updateUIWithNewStatus actual function loaded');

// ãƒ¬ã‚¬ã‚·ãƒ¼é–¢æ•°ï¼ˆäº’æ›æ€§ã®ãŸã‚ä¿æŒï¼‰
function updateUIWithNewStatusLegacy(status) {
  if (!validateStatus(status)) {
    logWarn('Invalid status received, skipping UI update');
    return;
  }

  // UI Update Mutex: Prevent concurrent UI updates
  if (isUIUpdateInProgress) {
    logDebug('UI update in progress, queuing this update');
    pendingUIUpdate = status;
    return;
  }

  isUIUpdateInProgress = true;
  
  try {
    // Phase 1: ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆåŒæœŸå‡¦ç†ï¼‰
    status = prepareStatusData(status);
    currentStatus = status;
    
    // Phase 2: ä¸¦åˆ—UIæ›´æ–°ï¼ˆéåŒæœŸå‡¦ç†ã®æœ€é©åŒ–ï¼‰
    executeParallelUIUpdates(status);
    
  } catch (error) {
    logError('UIæ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
  } finally {
    // æœ€å¾Œã«Mutexã‚’è§£é™¤
    setTimeout(() => finishUIUpdate(), 0);
  }
}

// ãƒ‡ãƒ¼ã‚¿æº–å‚™ã®æœ€é©åŒ–ï¼ˆåŒæœŸå‡¦ç†éƒ¨åˆ†ï¼‰
function prepareStatusData(status) {
  // 1. configJsonæ­£è¦åŒ–å‡¦ç†ï¼ˆåŒ…æ‹¬çš„ã‚·ã‚¹ãƒ†ãƒ æœ€é©åŒ–ï¼‰
  status.config = normalizeConfigJson(status.config, status.userInfo);
  
  // 2. æ­£è¦åŒ–ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¿½åŠ ï¼ˆè¨ˆç®—é›†ç´„å‡¦ç†ï¼‰
  const publicationState = getPublicationState(status);
  const viewUrl = `${getProductionWebAppUrl()}?mode=view&userId=${encodeURIComponent(userId)}`;
  
  status._normalized = {
    isPublished: publicationState.isPublished,
    publishReason: publicationState.reason,
    viewUrl: viewUrl,
    hasValidViewUrl: !!viewUrl
  };
  
  return status;
}

// ä¸¦åˆ—UIæ›´æ–°ã®å®Ÿè¡Œï¼ˆéåŒæœŸå‡¦ç†ã®æœ€é©åŒ–ï¼‰
function executeParallelUIUpdates(status) {
  const setupStatus = getSetupStatusFromUserInfo(status.userInfo);
  const currentStep = status.setupStep || 1;
  
  // ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªæ›´æ–°ã‚¿ã‚¹ã‚¯ã‚’å®šç¾©
  const updateTasks = [
    // Task 1: é™çš„è¦ç´ ã®æ›´æ–°
    () => {
      clearInitialDisplayElements();
      updateStaticUI(status);
      if (setupStatus === 'pending') {
        updateButtonStatesForSetup(status);
      }
    },
    
    // Task 2: å‹•çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ›´æ–°
    () => {
      if (status.activeSheetName) {
        updateDynamicContent(status);
      } else {
        updateUIForNoActiveSheet(status);
      }
    },
    
    // Task 3: ãƒ•ãƒƒã‚¿ãƒ¼ã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã®æ›´æ–°
    () => updateFooterAndGuidance(status),
    
    // Task 4: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®æ›´æ–°ï¼ˆçµ±åˆæœ€é©åŒ–ç‰ˆï¼‰
    () => updateStepIndicators(status?.setupStep || currentStep, status)
  ];
  
  // ä¸¦åˆ—å®Ÿè¡Œï¼ˆrequestAnimationFrameã§æœ€é©åŒ–ï¼‰
  requestAnimationFrame(() => {
    // é‡ã„å‡¦ç†ã‚’è¤‡æ•°ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«åˆ†æ•£
    executeTasksInBatches(updateTasks);
  });
}

// ã‚¿ã‚¹ã‚¯ã®ãƒãƒƒãƒå®Ÿè¡Œï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ åˆ†æ•£æœ€é©åŒ–ï¼‰
function executeTasksInBatches(tasks, batchSize = 2) {
  if (tasks.length === 0) return;
  
  // ç¾åœ¨ã®ãƒãƒƒãƒã‚’å®Ÿè¡Œ
  const currentBatch = tasks.splice(0, batchSize);
  currentBatch.forEach(task => {
    try {
      task();
    } catch (error) {
      logError('UIæ›´æ–°ã‚¿ã‚¹ã‚¯ã‚¨ãƒ©ãƒ¼:', error);
    }
  });
  
  // æ®‹ã‚Šã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹å ´åˆã¯æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œ
  if (tasks.length > 0) {
    requestAnimationFrame(() => executeTasksInBatches(tasks, batchSize));
  }
}

// UIæ›´æ–°å®Œäº†å‡¦ç†
function finishUIUpdate() {
  isUIUpdateInProgress = false;
  
  // å¾…æ©Ÿä¸­ã®æ›´æ–°ãŒã‚ã‚Œã°å®Ÿè¡Œ
  if (pendingUIUpdate) {
    const nextUpdate = pendingUIUpdate;
    pendingUIUpdate = null;
    updateUIWithNewStatus(nextUpdate);
  }
}

// =============================================================================
// HELPER FUNCTIONS FOR UI UPDATES
// =============================================================================

// Update unpublish button state
function updateUnpublishButton(status) {
  const unpublishBtn = document.getElementById('unpublish-board-btn');
  if (!unpublishBtn) return;

  // Use same strict logic as footer: both normalized and explicit checks
  const isPublished = status._normalized?.isPublished || false;
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('âŒ Failed to parse configJson for unpublish button check:', configError);
      explicitAppPublished = false;
    }
  }
  
  const finalIsPublished = isPublished && explicitAppPublished;

  if (finalIsPublished) {
    unpublishBtn.classList.remove('hidden');
  } else {
    unpublishBtn.classList.add('hidden');
  }
}

// Update spreadsheet access button state
function updateSpreadsheetButton() {
  const btn = document.getElementById('open-spreadsheet-btn-step2');
  if (!btn) return;
  
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetUrl) {
    btn.disabled = false;
    btn.onclick = function() {
      window.open(currentStatus.userInfo.spreadsheetUrl, '_blank');
    };
    logDebug('âœ… Spreadsheet button enabled with URL:', currentStatus.userInfo.spreadsheetUrl);
  } else {
    btn.disabled = true;
    btn.onclick = null;
    logDebug('âš ï¸ Spreadsheet button disabled - no URL available');
  }
}

// Update static UI elements
function updateStaticUI(status) {
  // Update database info panel
  updateDatabaseInfo(status);
  
  // Update existing user section
  updateExistingUserSection(status);
  
  // Populate sheet selection - fix property name mismatch
  logDebug('ğŸ” Debug: Checking sheet data properties', {
    allSheets: status.allSheets,
    sheetNames: status.sheetNames,
    activeSheetName: status.activeSheetName
  });
  
  const sheetsData = status.sheetNames || status.allSheets || [];
  populateSheetSelect(sheetsData, status.activeSheetName);
  
  // Update custom form info
  updateCustomFormInfo(status);
  
  // Check for auto-publish dialog
  checkAutoPublishDialog(status);
}

// =============================================================================
// DATABASE INFO PANEL UPDATES
// =============================================================================

function updateDatabaseInfo(status) {
  if (!status || !status.userInfo) {
    console.warn('System info update failed: No user info available');
    return;
  }

  // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆURLã‚’è¨­å®š
  if (status.userInfo.spreadsheetUrl) {
    currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
  }

  const cfg = status.config || {};

  // åŸºæœ¬æƒ…å ±ã®æ›´æ–°
  safeSetText('info-admin-email', status.userInfo.adminEmail);
  safeSetText('info-user-id', status.userInfo.userId);
  safeSetText('info-published-sheet', cfg.publishedSheetName || status.publishedSheetName || 'ãªã—');
  safeSetText('info-answer-count', status.answerCount || '0');
  safeSetText('info-reaction-count', status.totalReactions || '0');

  // å…¬é–‹çŠ¶æ…‹ã®è¡¨ç¤ºã‚’æ›´æ–°
  const isPublished = cfg.isPublished !== undefined
    ? cfg.isPublished
    : status.appPublished || status.isPublished || (status.activeSheetName && (cfg.publishedSheetName || status.publishedSheetName));
  updatePublicationStatusUI(isPublished);

  // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã®æ›´æ–°
  const displayModeFlag = cfg.showNames !== undefined ? cfg.showNames : status.showNames;
  const displayMode = displayModeFlag ? 'åå‰è¡¨ç¤º' : 'åŒ¿åè¡¨ç¤º';
  safeSetText('info-display-mode', displayMode);

  // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºã®æ›´æ–°
  const showCountsFlag = cfg.showCounts !== undefined
    ? cfg.showCounts
    : (status.showCounts !== undefined ? status.showCounts : false);
  const showCounts = showCountsFlag ? 'è¡¨ç¤º' : 'éè¡¨ç¤º';
  safeSetText('info-show-counts', showCounts);

  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹åŒæœŸ
  syncCheckboxStates(status);
}

// Update publication status UI
function updatePublicationStatusUI(isPublished) {
  const statusElement = safeGetElement('info-publish-status');
  const indicatorElement = safeGetElement('info-publish-indicator');
  const textElement = safeGetElement('info-publish-text');
  
  if (statusElement) {
    if (isPublished) {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      if (textElement) textElement.textContent = 'å…¬é–‹ä¸­';
    } else {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      if (textElement) textElement.textContent = 'éå…¬é–‹';
    }
  }
}

// ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’åŒæœŸã™ã‚‹é–¢æ•°
function syncCheckboxStates(status) {
  // Priority: Database config (configJson) > status properties > defaults
  let showNames = false;
  let showCounts = false;
  
  // 1. Prefer status.config if available
  if (status.config) {
    if (status.config.showNames !== undefined) showNames = status.config.showNames;
    if (status.config.showCounts !== undefined) showCounts = status.config.showCounts;
  } else if (status.userInfo?.configJson) {
    // 2. Fallback to raw configJson
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.showNames !== undefined) showNames = config.showNames;
      if (config.showCounts !== undefined) showCounts = config.showCounts;
    } catch (e) {
      logWarn('Failed to parse configJson, using status properties');
      if (status.showNames !== undefined) showNames = status.showNames;
      if (status.showCounts !== undefined) showCounts = status.showCounts;
    }
  } else {
    // 3. Use status properties as last resort
    if (status.showNames !== undefined) showNames = status.showNames;
    if (status.showCounts !== undefined) showCounts = status.showCounts;
  }

  // Update checkbox elements
  const showNamesCheckbox = safeGetElement('show-names');
  const showCountsCheckbox = safeGetElement('show-counts');
  
  if (showNamesCheckbox) {
    showNamesCheckbox.checked = showNames;
  }
  
  if (showCountsCheckbox) {
    showCountsCheckbox.checked = showCounts;
  }
}

// =============================================================================
// SHEET SELECTION AND CONFIGURATION
// =============================================================================

// Populate sheet selection dropdown
function populateSheetSelect(sheetNames, activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) {
    logWarn('Sheet select element not found');
    return;
  }

  logDebug('ğŸ“‹ Populating sheet select with data:', {
    sheetNames: sheetNames,
    activeSheetName: activeSheetName,
    dataType: typeof sheetNames,
    isArray: Array.isArray(sheetNames)
  });

  // Clear existing options
  select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠ --</option>';
  
  if (sheetNames && sheetNames.length > 0) {
    logDebug('âœ… Adding sheets to dropdown:', sheetNames.length);
    
    sheetNames.forEach((sheet, index) => {
      const option = document.createElement('option');
      
      // Handle both object and string formats
      let sheetName;
      if (typeof sheet === 'object' && sheet.name) {
        sheetName = sheet.name;
        option.value = sheet.name;
        logDebug(`ğŸ“„ Sheet ${index + 1}: ${sheet.name} (ID: ${sheet.id})`);
      } else if (typeof sheet === 'string') {
        sheetName = sheet;
        option.value = sheet;
        logDebug(`ğŸ“„ Sheet ${index + 1}: ${sheet}`);
      } else {
        console.warn('âš ï¸ Unknown sheet format:', sheet);
        return;
      }
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã®è¡¨ç¤ºã‚’æ”¹å–„
      if (sheetName === activeSheetName) {
        option.textContent = `${sheetName} (ã‚¢ã‚¯ãƒ†ã‚£ãƒ–)`;
        option.style.fontWeight = 'bold';
        option.style.color = '#10b981'; // ç·‘è‰²ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚’è¡¨ç¤º
        option.className = 'active-sheet-option';
        logDebug(`âœ… Active sheet marked: ${sheetName}`);
      } else {
        option.textContent = sheetName;
      }
      
      select.appendChild(option);
    });
    select.disabled = false;
    logDebug('âœ… Sheet dropdown populated successfully');
  } else {
    console.warn('âš ï¸ No sheets available:', sheetNames);
    select.innerHTML = '<option value="">åˆ©ç”¨å¯èƒ½ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</option>';
    select.disabled = true;
  }
  
  // Set active sheet if available
  if (activeSheetName) {
    select.value = activeSheetName;
    selectedSheet = activeSheetName;
    lastSelectedSheetName = activeSheetName; // Update last selected sheet
    logDebug('âœ… Active sheet set:', activeSheetName);
  }
  
  // Add change event listener for data preview
  select.removeEventListener('change', handleSheetSelectionChange);
  select.addEventListener('change', handleSheetSelectionChange);
  
  // Update UI for selected sheet and enable spreadsheet button
  updateUIForSelectedSheet();
  updateSpreadsheetButton();
}

// Populate header options for configuration
function populateHeaderOptions(headers) {
  // Throttle function calls to prevent spam
  if (window.populateHeaderOptionsRunning) {
    return;
  }
  window.populateHeaderOptionsRunning = true;
  
  const selects = [
    'opinionHeader',      // Main required field
    'reason-column',     // Optional details field (reason column)
    'name-column', 
    'class-column'
  ];
  
  selects.forEach(selectId => {
    const select = document.getElementById(selectId);
    
    if (select) {
      // Store current value
      const currentValue = select.value;
      
      // Clear and repopulate with appropriate placeholder
      if (headers && headers.length > 0) {
        select.innerHTML = '<option value="">-- åˆ—ã‚’é¸æŠ --</option>';
        select.disabled = false;
      } else {
        select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ --</option>';
        select.disabled = true;
      }
      
      const excludedHeaders = [
        'ãªã‚‹ã»ã©ï¼',
        'ã„ã„ã­ï¼',
        'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼',
        'ãƒã‚¤ãƒ©ã‚¤ãƒˆ',
        'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', // ãƒ•ã‚©ãƒ¼ãƒ ã§è‡ªå‹•åé›†ã•ã‚Œã‚‹ãŸã‚ã€ãƒãƒƒãƒ”ãƒ³ã‚°å¯¾è±¡ã‹ã‚‰é™¤å¤–
        'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—' // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æœ›ã«ã‚ˆã‚Šé™¤å¤–
      ];

      const filteredHeaders = headers.filter(header => !excludedHeaders.includes(header));

      filteredHeaders.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        select.appendChild(option);
      });
      
      // Restore previous value if still valid
      if (currentValue && headers.includes(currentValue)) {
        select.value = currentValue;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateHeaderOptionsRunning = false;
  }, 100);
}

// Ensure global access
window.populateHeaderOptions = populateHeaderOptions;
console.log('âœ… populateHeaderOptions actual function loaded');

// Populate configuration with guessed values
function populateConfig(cfg) {
  if (!cfg) return;
  
  // Throttle function calls to prevent spam
  if (window.populateConfigRunning) {
    return;
  }
  window.populateConfigRunning = true;
  
  const mappings = {
    // Main opinion dropdown (primary target)
    'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
    
    // Detail configuration dropdowns (secondary targets with property name fixes)
    'reason-column': cfg.reasonColumn || cfg.reasonHeader,
    'name-column': cfg.nameColumn || cfg.nameHeader,
    'class-column': cfg.classColumn || cfg.classHeader,
    'show-names': cfg.showNames,
    'show-counts': cfg.showCounts
  };
  
  Object.keys(mappings).forEach(elementId => {
    const element = document.getElementById(elementId);
    const value = mappings[elementId];
    
    if (element && value !== undefined) {
      if (element.type === 'checkbox') {
        element.checked = Boolean(value);
      } else {
        element.value = value;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateConfigRunning = false;
  }, 100);
  
  updateConfigButtons();
}

// Ensure global access
window.populateConfig = populateConfig;
console.log('âœ… populateConfig actual function loaded');

// Clear configuration fields
function clearConfigFields() {
  const fieldIds = [
    'opinionHeader',      // Main required field
    'reason-column',
    'name-column',
    'class-column'
  ];
  
  fieldIds.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.value = '';
    }
  });
  
  updateConfigButtons();
}

// Build configuration object from form
function buildConfigObject() {
  // Get values from primary elements (with fallback to secondary elements)
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  const nameValue = document.getElementById('name-column')?.value || '';
  const classValue = document.getElementById('class-column')?.value || '';
  const showNames = document.getElementById('show-names')?.checked || false;
  const showCounts = document.getElementById('show-counts')?.checked || false;
  
  return {
    sheetName: selectedSheet,
    // Use property names that match backend expectations (opinionHeader format)
    opinionHeader: opinionValue,
    nameHeader: nameValue,
    classHeader: classValue,
    reasonHeader: document.getElementById('reason-column')?.value || '',
    // Also provide legacy format for backward compatibility
    opinionColumn: opinionValue,
    nameColumn: nameValue,
    classColumn: classValue,
    showNames: showNames,
    showCounts: showCounts
  };
}

// Validate configuration
function validateConfig() {
  // Check primary element first, then fallback to secondary element
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  
  return opinionValue && opinionValue.trim() !== '';
}

// Update configuration buttons state
function updateConfigButtons() {
  const isValid = validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
  
  if (saveBtn) {
    saveBtn.disabled = !isValid;
    if (isValid) {
      saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
      saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
  }
}

// Ensure global access
window.updateConfigButtons = updateConfigButtons;
console.log('âœ… updateConfigButtons actual function loaded');

// =============================================================================
// STEP INDICATORS AND GUIDANCE
// =============================================================================

// çµ±ä¸€ã•ã‚ŒãŸã‚¹ãƒ†ãƒƒãƒ—å®Œäº†ãƒã‚§ãƒƒã‚¯ - å…¬é–‹çŠ¶æ…‹å„ªå…ˆåˆ¤å®šå¯¾å¿œç‰ˆ
function getStepCompletionFromConfig(status) {
  if (!status?.userInfo?.configJson) {
    return { step1: false, step2: false, step3: false, isPublished: false };
  }

  try {
    const config = typeof status.userInfo.configJson === 'string' 
      ? JSON.parse(status.userInfo.configJson) 
      : status.userInfo.configJson;

    // å…¬é–‹çŠ¶æ…‹ã®å„ªå…ˆãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã«é–¢ä¿‚ãªãå…¬é–‹æ¸ˆã¿ãªã‚‰å…¨ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†ï¼‰
    const publicationState = getPublicationState(status);
    if (publicationState.isPublished) {
      return {
        step1: true,
        step2: true,
        step3: true,
        isPublished: true
      };
    }

    // é€šå¸¸ã®ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†åˆ¤å®š
    // Step 1: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDã®å­˜åœ¨ç¢ºèª
    const step1Complete = !!(status.userInfo.spreadsheetId);
    
    // Step 2: ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†çŠ¶æ…‹ã®ç¢ºèª
    const step2Complete = config.setupStatus === 'completed' && 
                          config.formCreated === true && 
                          config.formUrl && config.formUrl.trim();
    
    // Step 3: å…¬é–‹çŠ¶æ…‹ã®ç¢ºèª
    const step3Complete = config.appPublished === true;
    
    return {
      step1: step1Complete,
      step2: step2Complete,
      step3: step3Complete,
      isPublished: step3Complete
    };
  } catch (error) {
    console.warn('âŒ configJsonã®è§£æã«å¤±æ•—:', error);
    return { step1: false, step2: false, step3: false, isPublished: false };
  }
}

// Update step indicators - æœ€é©åŒ–ç‰ˆï¼ˆãƒãƒƒãƒDOMæ›´æ–°ï¼‰
function updateStepIndicators(currentStep, status = null) {
  const steps = [
    document.getElementById('step-1-indicator'),
    document.getElementById('step-2-indicator'),
    document.getElementById('step-3-indicator')
  ];

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ã‹ã‚‰å®Ÿéš›ã®å®Œäº†çŠ¶æ³ã‚’å–å¾—
  const completion = getStepCompletionFromConfig(status);
  logDebug('ğŸ“Š Step completion from database:', completion);

  // DOMæ›´æ–°ã‚’ãƒãƒƒãƒåŒ–ã™ã‚‹ãŸã‚ã®è¨­å®šé…åˆ—ã‚’ä½œæˆ
  const updates = [];
  
  steps.forEach((step, index) => {
    if (!step) return;
    
    const stepNumber = index + 1;
    const circle = step.querySelector('div');
    const text = step.querySelector('span');

    // æ—¢å­˜ã®ãƒãƒƒã‚¸ã‚’å‰Šé™¤ï¼ˆæœ€é©åŒ–ï¼‰
    const existingBadge = step.querySelector('.publication-badge');
    if (existingBadge) {
      existingBadge.remove();
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ã«åŸºã¥ãå®Œäº†åˆ¤å®š
    const isStepComplete = completion[`step${stepNumber}`];
    
    // æ›´æ–°æƒ…å ±ã‚’é…åˆ—ã«è¿½åŠ ï¼ˆå®Ÿéš›ã®DOMæ›´æ–°ã¯å¾Œã§ä¸€æ‹¬å®Ÿè¡Œï¼‰
    updates.push({
      circle,
      text,
      stepNumber,
      isStepComplete,
      isCurrentStep: stepNumber === currentStep
    });
  });
  
  // ãƒãƒƒãƒDOMæ›´æ–°å®Ÿè¡Œï¼ˆãƒªãƒ•ãƒ­ãƒ¼ã‚’æœ€å°åŒ–ï¼‰
  requestAnimationFrame(() => {
    executeBatchStepUpdates(updates);
    // é€²è¡ŒçŠ¶æ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ›´æ–°ï¼ˆåŒã˜ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§å®Ÿè¡Œï¼‰
    updateProgressMessage(currentStep, status, completion);
  });
}

// ãƒãƒƒãƒDOMæ›´æ–°ã®å®Ÿè¡Œï¼ˆæœ€é©åŒ–ã•ã‚ŒãŸDOMæ“ä½œï¼‰
function executeBatchStepUpdates(updates) {
  const styleConfigs = {
    completed: {
      circleClass: 'w-6 h-6 bg-green-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all',
      circleContent: 'âœ“',
      textClasses: { remove: ['text-gray-500', 'text-cyan-400'], add: ['text-green-400', 'font-medium'] }
    },
    current: {
      circleClass: 'w-6 h-6 bg-cyan-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all ring-2 ring-cyan-400 ring-offset-2 ring-offset-gray-900 animate-pulse',
      textClasses: { remove: ['text-gray-500', 'text-green-400'], add: ['text-cyan-400', 'font-bold'] }
    },
    pending: {
      circleClass: 'w-6 h-6 bg-gray-700 text-gray-500 rounded-full flex items-center justify-center font-bold text-xs transition-all border border-gray-600',
      textClasses: { remove: ['text-white', 'text-green-400', 'text-cyan-400', 'font-bold', 'font-medium'], add: ['text-gray-500'] }
    }
  };

  updates.forEach(({ circle, text, stepNumber, isStepComplete, isCurrentStep }) => {
    let config;
    
    if (isStepComplete) {
      config = styleConfigs.completed;
    } else if (isCurrentStep) {
      config = styleConfigs.current;
    } else {
      config = styleConfigs.pending;
    }

    // Circleè¦ç´ ã®æ›´æ–°
    if (circle) {
      circle.className = config.circleClass;
      circle.innerHTML = config.circleContent || stepNumber;
    }

    // Textè¦ç´ ã®æ›´æ–°ï¼ˆã‚¯ãƒ©ã‚¹æ“ä½œã®æœ€é©åŒ–ï¼‰
    if (text && config.textClasses) {
      text.classList.remove(...config.textClasses.remove);
      text.classList.add(...config.textClasses.add);
    }
  });
}

function updateProgressMessage(currentStep, status = null, completion = null) {
  const messageElement = document.getElementById('progress-message');
  if (!messageElement) return;
  
  // completionãŒæ¸¡ã•ã‚Œã¦ã„ãªã„å ´åˆã¯å–å¾—
  if (!completion) {
    completion = getStepCompletionFromConfig(status);
  }
  
  // æ”¹å–„ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
  const messageData = getEnhancedProgressMessage(currentStep, completion, status);
  
  messageElement.textContent = messageData.message;
  messageElement.className = `text-sm ${messageData.colorClass} font-medium transition-colors duration-300`;
}

// å¼·åŒ–ã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç”Ÿæˆ
function getEnhancedProgressMessage(currentStep, completion, status) {
  const messageConfigs = {
    1: {
      completed: {
        message: 'âœ… ãƒ‡ãƒ¼ã‚¿æº–å‚™å®Œäº†ï¼šãƒ•ã‚©ãƒ¼ãƒ ãƒ»ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãŒåˆ©ç”¨å¯èƒ½ã§ã™',
        colorClass: 'text-green-400'
      },
      inProgress: {
        message: 'ğŸ“‹ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆè‡ªå‹•ï¼‰ã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’é¸æŠ',
        colorClass: 'text-cyan-400'
      }
    },
    2: {
      completed: {
        message: 'âœ… ã‚·ãƒ¼ãƒˆè¨­å®šå®Œäº†ï¼šå›ç­”ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºæº–å‚™ãŒã§ãã¾ã—ãŸ',
        colorClass: 'text-green-400'  
      },
      inProgress: {
        message: 'âš™ï¸ ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ã€è¡¨ç¤ºã™ã‚‹åˆ—ï¼ˆè³ªå•ãƒ»å›ç­”ãªã©ï¼‰ã‚’è¨­å®šã—ã¦ãã ã•ã„',
        colorClass: 'text-yellow-400'
      }
    },
    3: {
      published: {
        message: 'ğŸ‰ ãƒœãƒ¼ãƒ‰å…¬é–‹ä¸­ï¼šå‚åŠ è€…ãŒå›ç­”ã‚’æŠ•ç¨¿ãƒ»é–²è¦§ã§ãã¾ã™',
        colorClass: 'text-green-400'
      },
      readyToPublish: {
        message: 'ğŸš€ å…¬é–‹æº–å‚™å®Œäº†ï¼šã€Œãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã€ã§å‚åŠ è€…ã«å…±æœ‰ã—ã¾ã—ã‚‡ã†',
        colorClass: 'text-purple-400'
      },
      needsConfiguration: {
        message: 'ğŸ”§ åˆ—è¨­å®šã‚’å®Œäº†ã—ã¦ã‹ã‚‰å…¬é–‹ã—ã¦ãã ã•ã„',
        colorClass: 'text-orange-400'
      }
    }
  };
  
  // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®çŠ¶æ…‹åˆ¤å®šã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é¸æŠ
  switch (currentStep) {
    case 1:
      return completion.step1 ? 
        messageConfigs[1].completed : 
        messageConfigs[1].inProgress;
        
    case 2:
      return completion.step2 ? 
        messageConfigs[2].completed : 
        messageConfigs[2].inProgress;
        
    case 3:
      if (completion.isPublished) {
        return messageConfigs[3].published;
      } else if (completion.step2) {
        return messageConfigs[3].readyToPublish;
      } else {
        return messageConfigs[3].needsConfiguration;
      }
      
    default:
      return {
        message: 'ğŸ‰ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ï¼šStudyQuestã‚’ãŠæ¥½ã—ã¿ãã ã•ã„ï¼',
        colorClass: 'text-green-400'
      };
  }
}

// Update footer and guidance text
function updateFooterAndGuidance(status) {
  console.group('ğŸ¦¶ updateFooterAndGuidance');
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('âŒ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }

  // Use normalized publication state from status object with additional validation
  const isPublished = status._normalized?.isPublished || false;
  const viewUrl = `${google.script.run.withSuccessHandler(function(url){ return url; }).getProductionWebAppUrl()}?mode=view&userId=${encodeURIComponent(status.userInfo.userId)}`;
  
  // Additional strict check: ensure appPublished is explicitly true
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('âŒ Failed to parse configJson for publication check:', configError);
      explicitAppPublished = false;
    }
  }
  
  // Final publication decision: both normalized and explicit checks must agree
  const finalIsPublished = isPublished && explicitAppPublished;
  
  console.log('ğŸ” Enhanced publication check:', {
    'normalized isPublished': isPublished,
    'explicit appPublished': explicitAppPublished,
    'final decision': finalIsPublished,
    'publish reason': status._normalized?.publishReason,
    'normalized viewUrl': viewUrl,
    'has valid viewUrl': status._normalized?.hasValidViewUrl,
    'will show footer': finalIsPublished
  });

  // Show footer if published (with strict validation)
  if (finalIsPublished) {
    footer.classList.remove('hidden');
    
    // Update board URL using our generated viewUrl (if available)
    const boardUrlInput = document.getElementById('board-url');
    const viewBoardLink = document.getElementById('view-board-link');
    
    if (boardUrlInput) {
      boardUrlInput.value = viewUrl || 'URLç”Ÿæˆä¸­...';
      console.log('ğŸ“ Board URL input updated:', viewUrl || 'URL generation pending');
    }
    if (viewBoardLink && viewUrl) {
      viewBoardLink.href = viewUrl;
      console.log('ğŸ”— View board link updated:', viewUrl);
    } else if (viewBoardLink) {
      viewBoardLink.removeAttribute('href');
      console.log('ğŸ”— View board link cleared - no URL available');
    }
    
    // Update topic text
    updateTopicText(status);
    
    guidanceText.textContent = 'å›ç­”ãƒœãƒ¼ãƒ‰ã¯ç¾åœ¨å…¬é–‹ä¸­ã§ã™ã€‚';
    console.log('âœ… Footer shown - board is published');
  } else {
    footer.classList.add('hidden');
    console.log('âŒ Footer hidden - board not published');
    
    // Update guidance based on setup step
    updateGuidanceForStep(status.setupStep || 1, guidanceText);
  }
  
  console.groupEnd();
  
  // è‡ªå‹•åœæ­¢é€šçŸ¥ã®è¡¨ç¤ºãƒã‚§ãƒƒã‚¯
  checkAndShowAutoStopNotification(status);
  
  adjustLayout();
}

// Update UI for selected sheet
function updateUIForSelectedSheet() {
  var hasSelection = selectedSheet && selectedSheet.trim() !== '';
  
  // Update step indicators based on server-provided setupStep
  const currentStep = currentStatus.setupStep || 1;
  updateStepIndicators(currentStep);
  
  // Enable/disable configuration section
  var configSection = document.getElementById('config-section');
  if (configSection) {
    if (hasSelection) {
      configSection.classList.remove('opacity-50', 'pointer-events-none');
      
      // é˜²å¾¡çš„ãƒ­ã‚¸ãƒƒã‚¯: config-areaãŒç¢ºå®Ÿã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
      var configArea = document.getElementById('config-area');
      if (configArea) {
        configArea.classList.remove('hidden');
        console.log('ğŸ›¡ï¸ updateUIForSelectedSheet: Config area shown defensively');
      }
    } else {
      configSection.classList.add('opacity-50', 'pointer-events-none');
    }
  }
  
  // Update guidance text
  var guidanceText = document.getElementById('guidance-text');
  if (guidanceText) {
    if (hasSelection) {
      guidanceText.textContent = 'ã‚¹ãƒ†ãƒƒãƒ—3: åˆ—ã‚’è¨­å®šã—ã¦ãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã—ã¾ã—ã‚‡ã†';
    } else {
      guidanceText.textContent = 'ã‚¹ãƒ†ãƒƒãƒ—2: è¡¨ç¤ºã—ãŸã„ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚';
    }
  }

  // Toggle placeholder visibility
  var configPlaceholder = document.getElementById('config-placeholder');
  if (configPlaceholder) {
    if (hasSelection) {
      configPlaceholder.classList.add('hidden');
    } else {
      configPlaceholder.classList.remove('hidden');
    }
  }
}

// Update topic text in footer
function updateTopicText(status) {
  const topicTextElement = document.getElementById('current-topic-text');
  const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
  
  if (!topicTextElement) return;

  let topic = 'ï¼ˆå•é¡Œæ–‡æœªè¨­å®šï¼‰';
  // ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªconfigå–å¾—
  let cfg = status.config || {};
  
  // userInfo.configJsonã‹ã‚‰ã‚‚æƒ…å ±ã‚’å–å¾—
  if (status.userInfo?.configJson) {
    try {
      const fullConfig = JSON.parse(status.userInfo.configJson);
      cfg = { ...cfg, ...fullConfig };
    } catch (e) {
      console.warn('Failed to parse userInfo.configJson:', e);
    }
  }

  if (status.customFormInfo && status.customFormInfo.mainQuestion) {
    topic = status.customFormInfo.mainQuestion;
  } else if (cfg.opinionHeader) {
    topic = cfg.opinionHeader;
  } else {
    const sheetName = cfg.publishedSheetName || status.publishedSheetName;
    if (sheetName) {
      if (status.userInfo?.configJson) {
        try {
          const fullCfg = JSON.parse(status.userInfo.configJson);
          const sheetCfg = fullCfg['sheet_' + sheetName] || {};
          topic = sheetCfg.opinionHeader || sheetName || 'ï¼ˆå•é¡Œæ–‡æœªè¨­å®šï¼‰';
        } catch (e) {
          topic = sheetName || 'ï¼ˆå•é¡Œæ–‡æœªè¨­å®šï¼‰';
        }
      } else {
        topic = sheetName;
      }
    }
  }

  topicTextElement.textContent = topic;
  
  // äºˆå®šçµ‚äº†æ—¥æ™‚ã®æ›´æ–°
  if (scheduledEndTimeElement) {
    updateScheduledEndTime(cfg, scheduledEndTimeElement);
  }
}

// äºˆå®šçµ‚äº†æ—¥æ™‚ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateScheduledEndTime(config, element) {
  // è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ scheduledEndAt ã‚’å–å¾—ã‚’è©¦è¡Œ
  const scheduledEndAt = config.scheduledEndAt || 
                         config.scheduledEndTime ||  // å¤ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¨ã®äº’æ›æ€§
                         (window.lastStatusCache?.config?.scheduledEndAt) ||
                         (window.lastStatusCache?.config?.scheduledEndTime);
  
  // scheduledEndAtãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€publishedAt + autoStopMinutesã‹ã‚‰è¨ˆç®—
  let finalScheduledEndTime = scheduledEndAt;
  
  if (!finalScheduledEndTime && config.publishedAt && config.autoStopMinutes) {
    const publishedTime = new Date(config.publishedAt);
    const autoStopMs = config.autoStopMinutes * 60 * 1000;
    finalScheduledEndTime = new Date(publishedTime.getTime() + autoStopMs).toISOString();
    console.log('ğŸ• çµ‚äº†äºˆå®šæ™‚åˆ»ã‚’è¨ˆç®—ã—ã¾ã—ãŸ:', finalScheduledEndTime);
  }
  
  if (finalScheduledEndTime) {
    try {
      const endDate = new Date(finalScheduledEndTime);
      const formattedTime = endDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      // ç¾åœ¨æ™‚åˆ»ã¨ã®æ¯”è¼ƒ
      const now = new Date();
      const isOverdue = endDate < now;
      const timeRemaining = endDate.getTime() - now.getTime();
      const oneHourMs = 60 * 60 * 1000; // 1æ™‚é–“ã®ãƒŸãƒªç§’
      
      if (isOverdue) {
        element.textContent = `${formattedTime} (æœŸé™åˆ‡ã‚Œ)`;
        element.className = 'text-xs font-medium text-red-400';
      } else if (timeRemaining <= oneHourMs) {
        // 1æ™‚é–“ä»¥å†…ã®å ´åˆã¯è­¦å‘Šè¡¨ç¤º
        const minutesRemaining = Math.floor(timeRemaining / (60 * 1000));
        element.textContent = `${formattedTime} (æ®‹ã‚Š${minutesRemaining}åˆ†)`;
        element.className = 'text-xs font-medium text-red-400 animate-pulse';
        console.log('âš ï¸ æœŸé™ã¾ã§1æ™‚é–“ä»¥å†…ã§ã™:', minutesRemaining + 'åˆ†');
      } else {
        element.textContent = formattedTime;
        element.className = 'text-xs font-medium text-orange-400';
      }
    } catch (e) {
      element.textContent = 'è¨­å®šã‚¨ãƒ©ãƒ¼';
      element.className = 'text-xs font-medium text-gray-400';
    }
  } else {
    element.textContent = 'æœªè¨­å®š';
    element.className = 'text-xs font-medium text-gray-400';
  }
}

// Update guidance text for specific step
function updateGuidanceForStep(step, guidanceElement) {
  const messages = {
    1: 'ã‚¹ãƒ†ãƒƒãƒ—1: ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã¾ãŸã¯æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚',
    2: 'ã‚¹ãƒ†ãƒƒãƒ—2: è¡¨ç¤ºã—ãŸã„ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚',
    3: 'ã‚¹ãƒ†ãƒƒãƒ—3: åˆ—ã‚’è¨­å®šã—ã¦ãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã—ã¾ã—ã‚‡ã†'
  };
  
  // å…¬é–‹çµ‚äº†å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—1ã§ã¯ã€æ˜ç¢ºã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å†é–‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
  if (step === 1) {
    guidanceElement.textContent = 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¦ãã ã•ã„';
  } else {
    guidanceElement.textContent = messages[step] || 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¦ãã ã•ã„';
  }
}

// è‡ªå‹•åœæ­¢é€šçŸ¥ã®è¡¨ç¤ºãƒã‚§ãƒƒã‚¯
function checkAndShowAutoStopNotification(status) {
  const notificationElement = document.getElementById('auto-stop-notification');
  const autoStoppedTimeElement = document.getElementById('auto-stopped-time');
  
  if (!notificationElement || !autoStoppedTimeElement) return;
  
  const config = status.config || {};
  
  // è‡ªå‹•åœæ­¢ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿é€šçŸ¥ã‚’è¡¨ç¤º
  if (config.autoStoppedAt && config.autoStopReason === 'scheduled_timeout') {
    console.log('ğŸ”” è‡ªå‹•åœæ­¢é€šçŸ¥ã‚’è¡¨ç¤ºã—ã¾ã™:', config.autoStoppedAt);
    
    // åœæ­¢æ™‚åˆ»ã‚’è¡¨ç¤º
    try {
      const stoppedDate = new Date(config.autoStoppedAt);
      const formattedTime = stoppedDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      autoStoppedTimeElement.textContent = formattedTime;
    } catch (e) {
      autoStoppedTimeElement.textContent = 'æ™‚åˆ»ä¸æ˜';
    }
    
    // é€šçŸ¥ã‚’è¡¨ç¤º
    notificationElement.classList.remove('hidden');
    
    // å†å…¬é–‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
    const republishBtn = document.getElementById('republish-after-auto-stop-btn');
    if (republishBtn) {
      // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
      republishBtn.replaceWith(republishBtn.cloneNode(true));
      
      // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
      const newRepublishBtn = document.getElementById('republish-after-auto-stop-btn');
      newRepublishBtn.addEventListener('click', function() {
        // Step 3ã«ç§»å‹•ã—ã¦å†å…¬é–‹ã‚’ä¿ƒã™
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // é€šçŸ¥ã‚’éè¡¨ç¤º
        notificationElement.classList.add('hidden');
        
        showMessage('è¡¨ç¤ºè¨­å®šã‚’ç¢ºèªã—ã¦å†å…¬é–‹ã—ã¦ãã ã•ã„', 'info');
      });
    }
  } else {
    // è‡ªå‹•åœæ­¢ã•ã‚Œã¦ã„ãªã„å ´åˆã¯é€šçŸ¥ã‚’éè¡¨ç¤º
    notificationElement.classList.add('hidden');
  }
}

// =============================================================================
// SECTION TOGGLE FUNCTIONALITY
// =============================================================================

// Toggle section expansion/collapse
function toggleSection(sectionId) {
  // Validate input parameter
  if (!sectionId || typeof sectionId !== 'string') {
    logWarn('toggleSection: Invalid sectionId parameter:', sectionId);
    return;
  }

  try {
    const section = document.getElementById(sectionId);
    if (!section) {
      logWarn('toggleSection: Section not found:', sectionId);
      return;
    }
    
    // Find the toggle button for this section
    const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
    const arrow = toggleBtn ? toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up') : null;
    
    // Toggle the section visibility
    if (section.classList.contains('hidden')) {
      // Show section
      section.classList.remove('hidden');
      if (toggleBtn) {
        toggleBtn.setAttribute('aria-expanded', 'true');
      }
      if (arrow) {
        arrow.classList.remove('fa-chevron-up');
        arrow.classList.add('fa-chevron-down');
      }
    } else {
      // Hide section
      section.classList.add('hidden');
      if (toggleBtn) {
        toggleBtn.setAttribute('aria-expanded', 'false');
      }
      if (arrow) {
        arrow.classList.remove('fa-chevron-down');
        arrow.classList.add('fa-chevron-up');
      }
    }
  } catch (error) {
    logError('toggleSection: Exception occurred:', error);
  }
}

// Replace stub with actual function and ensure global access
window.toggleSection = toggleSection;
console.log('âœ… toggleSection actual function loaded');

// Automatically collapse completed sections
function collapseCompletedSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`ğŸ“ Auto-collapsing completed step ${stepNumber}`);
  
  // Collapse the section
  section.classList.add('hidden');
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'false');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Automatically expand active section
function expandActiveSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`ğŸ“‚ Auto-expanding active step ${stepNumber}`);
  
  // Expand the section
  section.classList.remove('hidden');
  
  // Special handling for Step 3: ensure config-area is visible
  if (stepNumber === 3) {
    const configArea = document.getElementById('config-area');
    if (configArea && currentStatus && currentStatus.activeSheetName) {
      configArea.classList.remove('hidden');
      console.log(`ğŸ“‹ expandActiveSection: Config area shown for Step 3`);
    }
  }
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'true');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Manage section states based on current step (simplified - no visual effects)
function manageSectionStates(currentStep) {
  console.log(`ğŸ”„ Managing section states for step ${currentStep}`);
  
  // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ¶å¾¡
  for (let i = 1; i <= 3; i++) {
    const sectionId = `step${i}-content`;
    const section = document.getElementById(sectionId);
    
    if (i === currentStep) {
      // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—: å±•é–‹ã—ã¦æœ‰åŠ¹åŒ–
      expandActiveSection(i);
      
      // Step 3ã®ç‰¹åˆ¥å‡¦ç†: config-areaã®è¡¨ç¤º
      if (i === 3) {
        const configArea = document.getElementById('config-area');
        if (configArea && currentStatus && currentStatus.activeSheetName) {
          configArea.classList.remove('hidden');
          console.log(`ğŸ“‹ Step 3: Config area shown for sheet: ${currentStatus.activeSheetName}`);
        }
      }
      
      console.log(`ğŸ”„ Step ${i}: Active (current step)`);
    } else if (i < currentStep) {
      // å®Œäº†æ¸ˆã¿ã‚¹ãƒ†ãƒƒãƒ—: ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã ãŒã€å±•é–‹ã¯ä»»æ„
      if (section) {
        section.classList.add('opacity-90'); // å®Œäº†ã—ãŸçŠ¶æ…‹ã‚’è¦–è¦šçš„ã«ç¤ºã™
      }
      console.log(`âœ… Step ${i}: Completed (accessible)`);
    } else {
      // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—: Step 1ã®å ´åˆã¯pendingçŠ¶æ…‹ã§ã‚‚å…¨ã¦é–²è¦§å¯èƒ½
      if (currentStep === 1) {
        // Step 1ã§ã¯å…¨ã‚¹ãƒ†ãƒƒãƒ—ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆãƒ‡ãƒ¼ã‚¿ç¢ºèªã®ãŸã‚ï¼‰
        if (section) {
          section.classList.add('opacity-75'); // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦è»½ãè¡¨ç¤º
        }
        console.log(`â­ï¸ Step ${i}: Available for preview`);
      } else {
        // Step 2ä»¥é™ã§ã¯é †æ¬¡é–‹æ”¾
        if (section) {
          section.classList.add('opacity-50'); // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦è¡¨ç¤º
        }
        console.log(`â­ï¸ Step ${i}: Future step (available)`);
      }
    }
  }
}

// =============================================================================
// MODAL MANAGEMENT
// =============================================================================

// Show form configuration modal
function showFormConfigModal() {
  try {
    if (window.sharedModals) {
      window.sharedModals.showFormConfig();
      loadSavedClassChoices();
      manageFocusForModal('form-config-modal', true);
    } else {
      // Fallback for legacy support
      const modal = document.getElementById('form-config-modal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        loadSavedClassChoices();
        manageFocusForModal('form-config-modal', true);
      } else {
        logWarn('showFormConfigModal: Modal element not found');
      }
    }
  } catch (error) {
    logError('showFormConfigModal: Exception occurred:', error);
  }
}

// Replace stub with actual function and ensure global access
window.showFormConfigModal = showFormConfigModal;
console.log('âœ… showFormConfigModal actual function loaded');

// Hide form configuration modal
function hideFormConfigModal() {
  try {
    if (window.sharedModals) {
      window.sharedModals.hideModal('form-config-modal');
      manageFocusForModal('form-config-modal', false);
    } else {
      // Fallback for legacy support
      const modal = document.getElementById('form-config-modal');
      if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        manageFocusForModal('form-config-modal', false);
      } else {
        logWarn('hideFormConfigModal: Modal element not found');
      }
    }
  } catch (error) {
    logError('hideFormConfigModal: Exception occurred:', error);
  }
}

// Replace stub with actual function and ensure global access
window.hideFormConfigModal = hideFormConfigModal;
console.log('âœ… hideFormConfigModal actual function loaded');

// Show privacy modal
function showPrivacyModal(onContinue) {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('privacy-modal', true);
    
    // Set up continue handler
    const continueBtn = document.getElementById('privacy-modal-continue');
    if (continueBtn && onContinue) {
      continueBtn.onclick = onContinue;
    }
  }
}

// Hide privacy modal
function hidePrivacyModal() {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('privacy-modal', false);
  }
}

// Ensure global access
window.hidePrivacyModal = hidePrivacyModal;
console.log('âœ… hidePrivacyModal actual function loaded');

// Show digital citizenship modal
function showDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('digital-citizenship-modal', true);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('digital-citizenship-modal', false);
  }
}

// Show confirmation modal
function showConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  console.log('ğŸ” showConfirmationModal: è¦ç´ æ¤œç´¢çµæœ:', {
    modal: !!modal,
    titleElement: !!titleElement,
    messageElement: !!messageElement,
    confirmBtn: !!confirmBtn,
    cancelBtn: !!cancelBtn
  });
  
  if (modal && titleElement && messageElement && confirmBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // ç¢ºèªãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    confirmBtn.onclick = function() {
      console.log('âœ… ç¢ºèªãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
      hideConfirmationModal();
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('âŒ ç¢ºèªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
        }
      }
    };
    
    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        console.log('âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
        hideConfirmationModal();
      };
    }
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('confirmation-modal', true);
    console.log('âœ… ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ');
  } else {
    console.error('âŒ ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–ã®ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    if (window.confirm(`${title}

${message}`)) {
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('âŒ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¢ºèªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
        }
      }
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('confirmation-modal', false);
  }
}

// =============================================================================
// DYNAMIC CONTENT UPDATES
// =============================================================================

// Update dynamic content when board is active
function updateDynamicContent(status) {
  // Enable buttons that require active state
  const buttons = [
    'open-spreadsheet-btn'
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = false;
      button.classList.remove('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update UI when no sheet is active
function updateUIForNoActiveSheet(status) {
  // Disable buttons that require active state
  const buttons = [
    // No form buttons to disable since we only support spreadsheets
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = true;
      button.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update existing user section
function updateExistingUserSection(status) {
  // Update any user-specific UI elements
  if (status.userInfo) {
    // Update user-specific elements here if needed
  }
}

// Update custom form info
function updateCustomFormInfo(status) {
  if (status.customFormInfo) {
    // Update form-related UI elements
    const formTitle = document.getElementById('form-title-display');
    const formQuestion = document.getElementById('form-question-display');
    
    if (formTitle) {
      formTitle.textContent = status.customFormInfo.title || 'ãƒ•ã‚©ãƒ¼ãƒ æœªä½œæˆ';
    }
    
    if (formQuestion) {
      formQuestion.textContent = status.customFormInfo.mainQuestion || '';
    }
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ URLè¡¨ç¤ºã®æ›´æ–°ï¼ˆconfigJsonã‹ã‚‰ç¢ºå®Ÿã«å–å¾—ï¼‰
  updateFormUrlDisplay(status);
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¡¨ç¤ºã‚’ç¢ºå®Ÿã«æ›´æ–°
function updateFormUrlDisplay(status = null) {
  const formUrlInput = document.getElementById('form-url-input');
  const formUrlSection = document.getElementById('form-url-section');
  const openFormLink = document.getElementById('open-form-url-link');
  
  if (!formUrlInput) return;
  
  // ç¾åœ¨ã®statusã®æœ€é©åŒ–ã•ã‚ŒãŸå–å¾—
  const currentStatusToUse = status || currentStatus;
  if (!currentStatusToUse || !currentStatusToUse.userInfo) {
    logWarn('âš ï¸ updateFormUrlDisplay: statusæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    return;
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã®æœ€é©åŒ–ï¼ˆå„ªå…ˆåº¦é †ï¼‰
  const formUrl = getFormUrlFromStatus(currentStatusToUse);
  
  // UIæ›´æ–°ã®æœ€é©åŒ–
  if (formUrl) {
    updateFormUrlElements(formUrlInput, openFormLink, formUrl);
    handleFormUrlSectionVisibility(formUrlSection);
    logDebug('ğŸ”— FormURL UIæ›´æ–°å®Œäº†:', formUrl);
  } else {
    clearFormUrlElements(formUrlInput, formUrlSection);
    logDebug('ğŸ“­ FormURLæœªè¨­å®šã®ãŸã‚UIéè¡¨ç¤º');
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLå–å¾—ã®æœ€é©åŒ–ã•ã‚ŒãŸãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getFormUrlFromStatus(status) {
  const userInfo = status.userInfo;
  
  // 1. configJsonã‹ã‚‰ç›´æ¥å–å¾—ï¼ˆæœ€ã‚‚ç¢ºå®Ÿï¼‰
  if (userInfo.configJson) {
    try {
      const configJson = typeof userInfo.configJson === 'string' 
        ? JSON.parse(userInfo.configJson) 
        : userInfo.configJson;
      
      if (configJson?.formUrl) {
        logDebug('âœ… FormURL: configJsonã‹ã‚‰å–å¾—');
        return configJson.formUrl;
      }
    } catch (error) {
      logWarn('âš ï¸ configJSONè§£æã‚¨ãƒ©ãƒ¼:', error.message);
    }
  }
  
  // 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‹ã‚‰ç›´æ¥å–å¾—
  if (userInfo.formUrl) {
    logDebug('ğŸ“‹ FormURL: userInfoã‹ã‚‰å–å¾—');
    return userInfo.formUrl;
  }
  
  // 3. ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã‹ã‚‰å–å¾—ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
  if (status.customFormInfo?.formUrl) {
    logDebug('ğŸ“„ FormURL: customFormInfoã‹ã‚‰å–å¾—');
    return status.customFormInfo.formUrl;
  }
  
  return null;
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¦ç´ æ›´æ–°ã®æœ€é©åŒ–
function updateFormUrlElements(input, link, url) {
  input.value = url;
  if (link) {
    link.href = url;
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¦ç´ ã‚¯ãƒªã‚¢ã®æœ€é©åŒ–
function clearFormUrlElements(input, section) {
  input.value = '';
  if (section) {
    section.classList.add('hidden');
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºåˆ¶å¾¡ã®æœ€é©åŒ–
function handleFormUrlSectionVisibility(section) {
  if (!section) return;
  
  const formJustCreated = sessionStorage.getItem('form_just_created');
  if (formJustCreated === 'true') {
    section.classList.remove('hidden');
    logDebug('ğŸ†• æ–°è¦ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º');
    
    // ãƒ•ãƒ©ã‚°ã‚¯ãƒªã‚¢ã®æœ€é©åŒ–ï¼ˆã‚¿ã‚¤ãƒãƒ¼å‡¦ç†ï¼‰
    setTimeout(() => {
      sessionStorage.removeItem('form_just_created');
      logDebug('ğŸ§¹ ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆãƒ•ãƒ©ã‚°ã‚¯ãƒªã‚¢');
    }, 10000);
  } else {
    section.classList.add('hidden');
  }
}

// Check for auto-publish dialog
function checkAutoPublishDialog(status) {
  // Implementation for auto-publish dialog if needed
  if (status.needsAutoPublish) {
    // Show auto-publish confirmation
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Initialize UI components
function initializeUI() {
  console.log('âœ… AdminPanel: UI components ready');
  // UIåˆæœŸåŒ–ã®ã¿å®Ÿè¡Œã€loadStatusã¯ adminPanel-api.js ã§å‡¦ç†ã•ã‚Œã‚‹
}

// =============================================================================
// SHEET SELECTION FUNCTIONALITY  
// =============================================================================

// Handle sheet selection change
function handleSheetSelectionChange(event) {
  const newSelectedSheet = event.target.value;

  // Prevent redundant calls if the selected sheet hasn't actually changed
  if (newSelectedSheet === lastSelectedSheetName) {
    console.log('ğŸ“Š Sheet selection changed, but value is the same. Skipping redundant processing.');
    return;
  }
  
  console.log('ğŸ“Š Sheet selection changed:', {
    previousSheet: selectedSheet,
    newSelectedSheet: newSelectedSheet
  });