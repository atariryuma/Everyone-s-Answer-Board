<script>
let lastSelectedSheetName = null; // To prevent redundant sheet selection change events

// UI Update Mutex to prevent race conditions
let isUIUpdateInProgress = false;
let pendingUIUpdate = null;

// =============================================================================
// ADMIN PANEL UI UPDATES & DISPLAY CONTROL
// =============================================================================

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Unified publication state detection
function getPublicationState(status) {
  if (!status) {
    return { isPublished: false, reason: 'No status data' };
  }
  
  // Check multiple possible publication indicators in priority order
  let isPublished = false;
  let reason = '';
  
  // 1. Direct isPublished property
  if (status.isPublished === true) {
    isPublished = true;
    reason = 'status.isPublished=true';
  }
  // 2. Direct appPublished property  
  else if (status.appPublished === true) {
    isPublished = true;
    reason = 'status.appPublished=true';
  }
  // 3. Check configJson for appPublished
  else if (status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.appPublished === true) {
        isPublished = true;
        reason = 'configJson.appPublished=true';
      }
    } catch (e) {
      console.warn('Failed to parse configJson:', e);
    }
  }
  
  // 4. Fallback: if there's an active sheet, likely published
  if (!isPublished && status.activeSheetName) {
    isPublished = true;
    reason = 'activeSheetName exists (fallback)';
  }
  
  return { isPublished, reason };
}

// Generate viewUrl with comprehensive fallback logic
function generateViewUrl(status, userId) {
  // 1. Use existing viewUrl if available
  let viewUrl = status.appUrls?.viewUrl;
  if (viewUrl) {
    return viewUrl;
  }
  
  // 2. Generate from appUrls.webApp with userId
  if (status.appUrls?.webApp && userId) {
    return status.appUrls.webApp + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 3. Generate from status.webAppUrl with userId
  if (status.webAppUrl && userId) {
    return status.webAppUrl + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 4. Simple fallback without userId
  if (status.appUrls?.webApp) {
    return status.appUrls.webApp + '?mode=view';
  }
  
  logWarn('Could not generate viewUrl');
  return null;
}

// =============================================================================
// MAIN UI UPDATE FUNCTIONS
// =============================================================================

// Update UI with new status data
function updateUIWithNewStatus(status) {
  if (!validateStatus(status)) {
    logWarn('Invalid status received, skipping UI update');
    return;
  }

  // UI Update Mutex: Prevent concurrent UI updates
  if (isUIUpdateInProgress) {
    logDebug('UI update in progress, queuing this update');
    pendingUIUpdate = status;
    return;
  }

  isUIUpdateInProgress = true;
  
  try {
    // Standardize status object with publication state and viewUrl
    const publicationState = getPublicationState(status);
    const viewUrl = generateViewUrl(status, userId);
    
    // Add normalized properties to status object
    status._normalized = {
      isPublished: publicationState.isPublished,
      publishReason: publicationState.reason,
      viewUrl: viewUrl,
      hasValidViewUrl: !!viewUrl
    };
    
    currentStatus = status;
  
  // セットアップ状況を確認
  const setupStatus = getSetupStatusFromUserInfo(status.userInfo);
  
  // 固定表示要素をクリア（setupStatus関係なく実行）
  clearInitialDisplayElements();
  
  // Update static UI elements first（常に実行）
  updateStaticUI(status);
  
  // セットアップ未完了時の追加処理
  if (setupStatus === 'pending') {
    updateButtonStatesForSetup(status);
  }
  
  // Update dynamic content based on state
  if (status.activeSheetName) {
    updateDynamicContent(status);
  } else {
    updateUIForNoActiveSheet(status);
  }
  
  // Update footer and guidance
  updateFooterAndGuidance(status);
  
  // Update step indicators and manage sections
  const currentStep = status.setupStep || 1;
  updateStepIndicators(currentStep);
  manageSectionStates(currentStep);
  
  // Update unpublish button state
  updateUnpublishButton(status);

  // Update system status display and resource buttons (スプレッドシート・フォームボタンの有効化処理を含む)
  updateSystemStatusDisplay(status);

    // If an active sheet is set on initial load, load its configuration
    if (status.activeSheetName && status.userInfo && status.userInfo.spreadsheetId) {
      selectedSheet = status.activeSheetName;
      loadConfigForSelected(status.activeSheetName, status.userInfo.spreadsheetId)
        .then(result => {
          console.log('✅ 初期化時のシート設定読み込み完了:', result);
        })
        .catch(error => {
          console.warn('⚠️ 初期化時のシート設定読み込み失敗:', error);
        });
    }
    
  } finally {
    // Release the UI update mutex
    isUIUpdateInProgress = false;
    
    // Process any pending UI update
    if (pendingUIUpdate) {
      const nextUpdate = pendingUIUpdate;
      pendingUIUpdate = null;
      logDebug('Processing queued UI update');
      setTimeout(() => updateUIWithNewStatus(nextUpdate), 0);
    }
  }
}

// Update unpublish button state
function updateUnpublishButton(status) {
  const unpublishBtn = document.getElementById('unpublish-board-btn');
  if (!unpublishBtn) return;

  if (status._normalized?.isPublished) {
    unpublishBtn.classList.remove('hidden');
  } else {
    unpublishBtn.classList.add('hidden');
  }
}

// Update spreadsheet access button state
function updateSpreadsheetButton() {
  const btn = document.getElementById('open-spreadsheet-btn-step2');
  if (!btn) return;
  
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetUrl) {
    btn.disabled = false;
    btn.onclick = function() {
      window.open(currentStatus.userInfo.spreadsheetUrl, '_blank');
    };
    logDebug('✅ Spreadsheet button enabled with URL:', currentStatus.userInfo.spreadsheetUrl);
  } else {
    btn.disabled = true;
    btn.onclick = null;
    logDebug('⚠️ Spreadsheet button disabled - no URL available');
  }
}

// Update static UI elements
function updateStaticUI(status) {
  // Update database info panel
  updateDatabaseInfo(status);
  
  // Update existing user section
  updateExistingUserSection(status);
  
  // Populate sheet selection - fix property name mismatch
  logDebug('🔍 Debug: Checking sheet data properties', {
    allSheets: status.allSheets,
    sheetNames: status.sheetNames,
    activeSheetName: status.activeSheetName
  });
  
  const sheetsData = status.sheetNames || status.allSheets || [];
  populateSheetSelect(sheetsData, status.activeSheetName);
  
  // Update custom form info
  updateCustomFormInfo(status);
  
  // Check for auto-publish dialog
  checkAutoPublishDialog(status);
}

// =============================================================================
// DATABASE INFO PANEL UPDATES
// =============================================================================

function updateDatabaseInfo(status) {
  if (!status || !status.userInfo) {
    console.warn('System info update failed: No user info available');
    return;
  }

  // スプレッドシートURLを設定
  if (status.userInfo.spreadsheetUrl) {
    currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
  }

  const cfg = status.config || {};

  // 基本情報の更新
  safeSetText('info-admin-email', status.userInfo.adminEmail);
  safeSetText('info-user-id', status.userInfo.userId);
  safeSetText('info-published-sheet', cfg.publishedSheetName || status.publishedSheetName || 'なし');
  safeSetText('info-answer-count', status.answerCount || '0');
  safeSetText('info-reaction-count', status.totalReactions || '0');

  // 公開状態の表示を更新
  const isPublished = cfg.isPublished !== undefined
    ? cfg.isPublished
    : status.appPublished || status.isPublished || (status.activeSheetName && (cfg.publishedSheetName || status.publishedSheetName));
  updatePublicationStatusUI(isPublished);

  // 表示モードの更新
  const displayModeFlag = cfg.showNames !== undefined ? cfg.showNames : status.showNames;
  const displayMode = displayModeFlag ? '名前表示' : '匿名表示';
  safeSetText('info-display-mode', displayMode);

  // カウント表示の更新
  const showCountsFlag = cfg.showCounts !== undefined
    ? cfg.showCounts
    : (status.showCounts !== undefined ? status.showCounts : false);
  const showCounts = showCountsFlag ? '表示' : '非表示';
  safeSetText('info-show-counts', showCounts);

  // チェックボックスの状態同期
  syncCheckboxStates(status);
}

// Update publication status UI
function updatePublicationStatusUI(isPublished) {
  const statusElement = safeGetElement('info-publish-status');
  const indicatorElement = safeGetElement('info-publish-indicator');
  const textElement = safeGetElement('info-publish-text');
  
  if (statusElement) {
    if (isPublished) {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      if (textElement) textElement.textContent = '公開中';
    } else {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      if (textElement) textElement.textContent = '非公開';
    }
  }
}

// チェックボックスの状態を同期する関数
function syncCheckboxStates(status) {
  // Priority: Database config (configJson) > status properties > defaults
  let showNames = false;
  let showCounts = false;
  
  // 1. Prefer status.config if available
  if (status.config) {
    if (status.config.showNames !== undefined) showNames = status.config.showNames;
    if (status.config.showCounts !== undefined) showCounts = status.config.showCounts;
  } else if (status.userInfo?.configJson) {
    // 2. Fallback to raw configJson
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.showNames !== undefined) showNames = config.showNames;
      if (config.showCounts !== undefined) showCounts = config.showCounts;
    } catch (e) {
      logWarn('Failed to parse configJson, using status properties');
      if (status.showNames !== undefined) showNames = status.showNames;
      if (status.showCounts !== undefined) showCounts = status.showCounts;
    }
  } else {
    // 3. Use status properties as last resort
    if (status.showNames !== undefined) showNames = status.showNames;
    if (status.showCounts !== undefined) showCounts = status.showCounts;
  }

  // Update checkbox elements
  const showNamesCheckbox = safeGetElement('show-names');
  const showCountsCheckbox = safeGetElement('show-counts');
  
  if (showNamesCheckbox) {
    showNamesCheckbox.checked = showNames;
  }
  
  if (showCountsCheckbox) {
    showCountsCheckbox.checked = showCounts;
  }
}

// =============================================================================
// SHEET SELECTION AND CONFIGURATION
// =============================================================================

// Populate sheet selection dropdown
function populateSheetSelect(sheetNames, activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) {
    logWarn('Sheet select element not found');
    return;
  }

  logDebug('📋 Populating sheet select with data:', {
    sheetNames: sheetNames,
    activeSheetName: activeSheetName,
    dataType: typeof sheetNames,
    isArray: Array.isArray(sheetNames)
  });

  // Clear existing options
  select.innerHTML = '<option value="">-- シートを選択 --</option>';
  
  if (sheetNames && sheetNames.length > 0) {
    logDebug('✅ Adding sheets to dropdown:', sheetNames.length);
    
    sheetNames.forEach((sheet, index) => {
      const option = document.createElement('option');
      
      // Handle both object and string formats
      let sheetName;
      if (typeof sheet === 'object' && sheet.name) {
        sheetName = sheet.name;
        option.value = sheet.name;
        logDebug(`📄 Sheet ${index + 1}: ${sheet.name} (ID: ${sheet.id})`);
      } else if (typeof sheet === 'string') {
        sheetName = sheet;
        option.value = sheet;
        logDebug(`📄 Sheet ${index + 1}: ${sheet}`);
      } else {
        console.warn('⚠️ Unknown sheet format:', sheet);
        return;
      }
      
      // アクティブシートの表示を改善
      if (sheetName === activeSheetName) {
        option.textContent = `${sheetName} (アクティブ)`;
        option.style.fontWeight = 'bold';
        option.style.color = '#10b981'; // 緑色でアクティブを表示
        option.className = 'active-sheet-option';
        logDebug(`✅ Active sheet marked: ${sheetName}`);
      } else {
        option.textContent = sheetName;
      }
      
      select.appendChild(option);
    });
    select.disabled = false;
    logDebug('✅ Sheet dropdown populated successfully');
  } else {
    console.warn('⚠️ No sheets available:', sheetNames);
    select.innerHTML = '<option value="">利用可能なシートがありません</option>';
    select.disabled = true;
  }
  
  // Set active sheet if available
  if (activeSheetName) {
    select.value = activeSheetName;
    selectedSheet = activeSheetName;
    lastSelectedSheetName = activeSheetName; // Update last selected sheet
    logDebug('✅ Active sheet set:', activeSheetName);
  }
  
  // Add change event listener for data preview
  select.removeEventListener('change', handleSheetSelectionChange);
  select.addEventListener('change', handleSheetSelectionChange);
  
  // Update UI for selected sheet and enable spreadsheet button
  updateUIForSelectedSheet();
  updateSpreadsheetButton();
}

// Populate header options for configuration
function populateHeaderOptions(headers) {
  // Throttle function calls to prevent spam
  if (window.populateHeaderOptionsRunning) {
    return;
  }
  window.populateHeaderOptionsRunning = true;
  
  const selects = [
    'opinionHeader',      // Main required field
    'reason-column',     // Optional details field (reason column)
    'name-column', 
    'class-column'
  ];
  
  selects.forEach(selectId => {
    const select = document.getElementById(selectId);
    
    if (select) {
      // Store current value
      const currentValue = select.value;
      
      // Clear and repopulate
      select.innerHTML = '<option value="">-- 列を選択 --</option>';
      
      const excludedHeaders = [
        'なるほど！',
        'いいね！',
        'もっと知りたい！',
        'ハイライト',
        'メールアドレス', // フォームで自動収集されるため、マッピング対象から除外
        'タイムスタンプ' // ユーザーの要望により除外
      ];

      const filteredHeaders = headers.filter(header => !excludedHeaders.includes(header));

      filteredHeaders.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        select.appendChild(option);
      });
      
      // Restore previous value if still valid
      if (currentValue && headers.includes(currentValue)) {
        select.value = currentValue;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateHeaderOptionsRunning = false;
  }, 100);
}

// Populate configuration with guessed values
function populateConfig(cfg) {
  if (!cfg) return;
  
  // Throttle function calls to prevent spam
  if (window.populateConfigRunning) {
    return;
  }
  window.populateConfigRunning = true;
  
  const mappings = {
    // Main opinion dropdown (primary target)
    'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
    
    // Detail configuration dropdowns (secondary targets with property name fixes)
    'reason-column': cfg.reasonColumn || cfg.reasonHeader,
    'name-column': cfg.nameColumn || cfg.nameHeader,
    'class-column': cfg.classColumn || cfg.classHeader,
    'show-names': cfg.showNames,
    'show-counts': cfg.showCounts
  };
  
  Object.keys(mappings).forEach(elementId => {
    const element = document.getElementById(elementId);
    const value = mappings[elementId];
    
    if (element && value !== undefined) {
      if (element.type === 'checkbox') {
        element.checked = Boolean(value);
      } else {
        element.value = value;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateConfigRunning = false;
  }, 100);
  
  updateConfigButtons();
}

// Clear configuration fields
function clearConfigFields() {
  const fieldIds = [
    'opinionHeader',      // Main required field
    'reason-column',
    'name-column',
    'class-column'
  ];
  
  fieldIds.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.value = '';
    }
  });
  
  updateConfigButtons();
}

// Build configuration object from form
function buildConfigObject() {
  // Get values from primary elements (with fallback to secondary elements)
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  const nameValue = document.getElementById('name-column')?.value || '';
  const classValue = document.getElementById('class-column')?.value || '';
  const showNames = document.getElementById('show-names')?.checked || false;
  const showCounts = document.getElementById('show-counts')?.checked || false;
  
  return {
    sheetName: selectedSheet,
    // Use property names that match backend expectations (opinionHeader format)
    opinionHeader: opinionValue,
    nameHeader: nameValue,
    classHeader: classValue,
    reasonHeader: document.getElementById('reason-column')?.value || '',
    // Also provide legacy format for backward compatibility
    opinionColumn: opinionValue,
    nameColumn: nameValue,
    classColumn: classValue,
    showNames: showNames,
    showCounts: showCounts
  };
}

// Validate configuration
function validateConfig() {
  // Check primary element first, then fallback to secondary element
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  
  return opinionValue && opinionValue.trim() !== '';
}

// Update configuration buttons state
function updateConfigButtons() {
  const isValid = validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
  
  if (saveBtn) {
    saveBtn.disabled = !isValid;
    if (isValid) {
      saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
      saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
  }
}

// =============================================================================
// STEP INDICATORS AND GUIDANCE
// =============================================================================

// Update step indicators
function updateStepIndicators(currentStep) {
  const steps = [
    document.getElementById('step-1-indicator'),
    document.getElementById('step-2-indicator'),
    document.getElementById('step-3-indicator')
  ];

  steps.forEach((step, index) => {
    if (!step) return;
    
    const stepNumber = index + 1;
    const circle = step.querySelector('div');
    const text = step.querySelector('span');

    if (stepNumber < currentStep) {
      // 完了したステップ
      if (circle) {
        circle.className = 'w-6 h-6 bg-green-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all';
      }
      if (text) {
        text.classList.remove('text-gray-500');
        text.classList.add('text-gray-300');
      }
    } else if (stepNumber === currentStep) {
      // 現在のステップ
      if (circle) {
        circle.className = 'w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all ring-2 ring-blue-400 ring-offset-2 ring-offset-gray-800';
      }
      if (text) {
        text.classList.remove('text-gray-500');
        text.classList.add('text-white', 'font-semibold');
      }
    } else {
      // 未完了のステップ
      if (circle) {
        circle.className = 'w-6 h-6 bg-gray-600 text-gray-400 rounded-full flex items-center justify-center font-bold text-xs transition-all';
      }
      if (text) {
        text.classList.remove('text-white', 'font-semibold');
        text.classList.add('text-gray-500');
      }
    }
  });
}

// Update footer and guidance text
function updateFooterAndGuidance(status) {
  console.group('🦶 updateFooterAndGuidance');
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('❌ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }

  // Use normalized publication state from status object
  const isPublished = status._normalized?.isPublished || false;
  const viewUrl = status._normalized?.viewUrl;
  
  console.log('🔍 Simplified publication check:', {
    'normalized isPublished': isPublished,
    'publish reason': status._normalized?.publishReason,
    'normalized viewUrl': viewUrl,
    'has valid viewUrl': status._normalized?.hasValidViewUrl,
    'will show footer': isPublished
  });

  // Show footer if published (regardless of viewUrl availability for now)
  if (isPublished) {
    footer.classList.remove('hidden');
    
    // Update board URL using our generated viewUrl (if available)
    const boardUrlInput = document.getElementById('board-url');
    const viewBoardLink = document.getElementById('view-board-link');
    
    if (boardUrlInput) {
      boardUrlInput.value = viewUrl || 'URL生成中...';
      console.log('📝 Board URL input updated:', viewUrl || 'URL generation pending');
    }
    if (viewBoardLink && viewUrl) {
      viewBoardLink.href = viewUrl;
      console.log('🔗 View board link updated:', viewUrl);
    } else if (viewBoardLink) {
      viewBoardLink.removeAttribute('href');
      console.log('🔗 View board link cleared - no URL available');
    }
    
    // Update topic text
    updateTopicText(status);
    
    guidanceText.textContent = '回答ボードは現在公開中です。';
    console.log('✅ Footer shown - board is published');
  } else {
    footer.classList.add('hidden');
    console.log('❌ Footer hidden - board not published');
    
    // Update guidance based on setup step
    updateGuidanceForStep(status.setupStep || 1, guidanceText);
  }
  
  console.groupEnd();
  adjustLayout();
}

// Update topic text in footer
function updateTopicText(status) {
  const topicTextElement = document.getElementById('current-topic-text');
  if (!topicTextElement) return;

  let topic = '（問題文未設定）';
  const cfg = status.config || {};

  if (status.customFormInfo && status.customFormInfo.mainQuestion) {
    topic = status.customFormInfo.mainQuestion;
  } else if (cfg.opinionHeader) {
    topic = cfg.opinionHeader;
  } else {
    const sheetName = cfg.publishedSheetName || status.publishedSheetName;
    if (sheetName) {
      if (status.userInfo?.configJson) {
        try {
          const fullCfg = JSON.parse(status.userInfo.configJson);
          const sheetCfg = fullCfg['sheet_' + sheetName] || {};
          topic = sheetCfg.opinionHeader || sheetName || '（問題文未設定）';
        } catch (e) {
          topic = sheetName || '（問題文未設定）';
        }
      } else {
        topic = sheetName;
      }
    }
  }

  topicTextElement.textContent = topic;
}

// Update guidance text for specific step
function updateGuidanceForStep(step, guidanceElement) {
  const messages = {
    1: 'ステップ1: ボードを作成または既存のリソースを追加してください。',
    2: 'ステップ2: 表示したいシートを選択してください。',
    3: 'ステップ3: 列を設定してボードを公開しましょう。'
  };
  
  // 公開終了後のステップ1では、明確にセットアップ再開のメッセージを表示
  if (step === 1) {
    guidanceElement.textContent = 'セットアップを開始してください';
  } else {
    guidanceElement.textContent = messages[step] || 'セットアップを開始してください';
  }
}

// =============================================================================
// SECTION TOGGLE FUNCTIONALITY
// =============================================================================

// Toggle section expansion/collapse
function toggleSection(sectionId) {
  const section = document.getElementById(sectionId);
  if (!section) {
    console.warn('Section not found:', sectionId);
    return;
  }
  
  // Find the toggle button for this section
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  const arrow = toggleBtn ? toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up') : null;
  
  // Toggle the section visibility
  if (section.classList.contains('hidden')) {
    // Show section
    section.classList.remove('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'true');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  } else {
    // Hide section
    section.classList.add('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'false');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
}

// Automatically collapse completed sections
function collapseCompletedSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📁 Auto-collapsing completed step ${stepNumber}`);
  
  // Collapse the section
  section.classList.add('hidden');
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'false');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Automatically expand active section
function expandActiveSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📂 Auto-expanding active step ${stepNumber}`);
  
  // Expand the section
  section.classList.remove('hidden');
  
  // Special handling for Step 3: ensure config-area is visible
  if (stepNumber === 3) {
    const configArea = document.getElementById('config-area');
    if (configArea && currentStatus && currentStatus.activeSheetName) {
      configArea.classList.remove('hidden');
      console.log(`📋 expandActiveSection: Config area shown for Step 3`);
    }
  }
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'true');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Manage section states based on current step (simplified - no visual effects)
function manageSectionStates(currentStep) {
  console.log(`🔄 Managing section states for step ${currentStep}`);
  
  // Check if we're in reconfiguring state (after unpublish)
  const isReconfiguring = currentStatus && currentStatus.userInfo && 
    JSON.parse(currentStatus.userInfo.configJson || '{}').setupStatus === 'reconfiguring';
  
  if (isReconfiguring) {
    console.log('🔧 Reconfiguring mode: Opening all steps for easy reconfiguration');
    // In reconfiguring mode, open all steps 1-3 for easy reconfiguration
    for (let i = 1; i <= 3; i++) {
      expandActiveSection(i);
      
      // Show config area for step 3 if we have a sheet
      if (i === 3 && currentStatus && currentStatus.activeSheetName) {
        const configArea = document.getElementById('config-area');
        if (configArea) {
          configArea.classList.remove('hidden');
        }
      }
    }
    return;
  }
  
  // Simplified section management - just expand the current step
  for (let i = 1; i <= 3; i++) {
    if (i === currentStep) {
      // Current active section - expand it
      expandActiveSection(i);
      
      // Special handling for Step 3: ensure config-area is visible
      if (i === 3) {
        const configArea = document.getElementById('config-area');
        if (configArea && currentStatus && currentStatus.activeSheetName) {
          configArea.classList.remove('hidden');
          console.log(`📋 Step 3: Config area shown for sheet: ${currentStatus.activeSheetName}`);
        }
      }
      
      console.log(`🔄 Step ${i}: Active`);
    }
    // Note: No collapsing or darkening of other steps - keep them all accessible
  }
}

// =============================================================================
// MODAL MANAGEMENT
// =============================================================================

// Show form configuration modal
function showFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.showFormConfig();
    loadSavedClassChoices();
    manageFocusForModal('form-config-modal', true);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      loadSavedClassChoices();
      manageFocusForModal('form-config-modal', true);
    }
  }
}

// Hide form configuration modal
function hideFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.hideModal('form-config-modal');
    manageFocusForModal('form-config-modal', false);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      manageFocusForModal('form-config-modal', false);
    }
  }
}

// Show privacy modal
function showPrivacyModal(onContinue) {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('privacy-modal', true);
    
    // Set up continue handler
    const continueBtn = document.getElementById('privacy-modal-continue');
    if (continueBtn && onContinue) {
      continueBtn.onclick = onContinue;
    }
  }
}

// Hide privacy modal
function hidePrivacyModal() {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('privacy-modal', false);
  }
}

// Show digital citizenship modal
function showDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('digital-citizenship-modal', true);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('digital-citizenship-modal', false);
  }
}

// Show confirmation modal
function showConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  console.log('🔍 showConfirmationModal: 要素検索結果:', {
    modal: !!modal,
    titleElement: !!titleElement,
    messageElement: !!messageElement,
    confirmBtn: !!confirmBtn,
    cancelBtn: !!cancelBtn
  });
  
  if (modal && titleElement && messageElement && confirmBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // 確認ボタンのクリックイベント
    confirmBtn.onclick = function() {
      console.log('✅ 確認ボタンがクリックされました');
      hideConfirmationModal();
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ 確認コールバック実行エラー:', error);
        }
      }
    };
    
    // キャンセルボタンのクリックイベント
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        console.log('❌ キャンセルボタンがクリックされました');
        hideConfirmationModal();
      };
    }
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('confirmation-modal', true);
    console.log('✅ 確認モーダルを表示しました');
  } else {
    console.error('❌ モーダル要素が見つかりません。フォールバックを使用します。');
    // フォールバック: ブラウザ標準の確認ダイアログ
    if (window.confirm(`${title}\n\n${message}`)) {
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ フォールバック確認コールバック実行エラー:', error);
        }
      }
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('confirmation-modal', false);
  }
}

// =============================================================================
// DYNAMIC CONTENT UPDATES
// =============================================================================

// Update dynamic content when board is active
function updateDynamicContent(status) {
  // Enable buttons that require active state
  const buttons = [
    'open-spreadsheet-btn'
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = false;
      button.classList.remove('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update UI when no sheet is active
function updateUIForNoActiveSheet(status) {
  // Disable buttons that require active state
  const buttons = [
    // No form buttons to disable since we only support spreadsheets
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = true;
      button.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update existing user section
function updateExistingUserSection(status) {
  // Update any user-specific UI elements
  if (status.userInfo) {
    // Update user-specific elements here if needed
  }
}

// Update custom form info
function updateCustomFormInfo(status) {
  if (status.customFormInfo) {
    // Update form-related UI elements
    const formTitle = document.getElementById('form-title-display');
    const formQuestion = document.getElementById('form-question-display');
    
    if (formTitle) {
      formTitle.textContent = status.customFormInfo.title || 'フォーム未作成';
    }
    
    if (formQuestion) {
      formQuestion.textContent = status.customFormInfo.mainQuestion || '';
    }
  }
  
  // フォームURL表示の更新（configJsonから確実に取得）
  updateFormUrlDisplay(status);
}

// フォームURL表示を確実に更新
function updateFormUrlDisplay(status = null) {
  const formUrlInput = document.getElementById('form-url-input');
  const formUrlSection = document.getElementById('form-url-section');
  const openFormLink = document.getElementById('open-form-url-link');
  
  if (!formUrlInput) return;
  
  // 現在のstatusがない場合はglobal currentStatusを使用
  const currentStatusToUse = status || currentStatus;
  let formUrl = null;
  
  // 1. configJsonから直接取得（最も確実）
  if (currentStatusToUse && currentStatusToUse.userInfo && currentStatusToUse.userInfo.configJson) {
    try {
      const configJson = typeof currentStatusToUse.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatusToUse.userInfo.configJson) 
        : currentStatusToUse.userInfo.configJson;
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        logDebug('✅ FormURL表示: configJsonから直接取得成功');
      }
    } catch (error) {
      logWarn('⚠️ configJsonの解析でエラー:', error);
    }
  }
  
  // 2. ユーザー情報のformUrlから取得（フォールバック）
  if (!formUrl && currentStatusToUse && currentStatusToUse.userInfo && currentStatusToUse.userInfo.formUrl) {
    formUrl = currentStatusToUse.userInfo.formUrl;
    logDebug('📋 FormURL表示: userInfo.formUrlから取得');
  }
  
  // 3. カスタムフォーム情報から取得（後方互換性）
  if (!formUrl && currentStatusToUse && currentStatusToUse.customFormInfo && currentStatusToUse.customFormInfo.formUrl) {
    formUrl = currentStatusToUse.customFormInfo.formUrl;
    logDebug('📄 FormURL表示: customFormInfo.formUrlから取得');
  }
  
  // UI要素の更新
  if (formUrl) {
    formUrlInput.value = formUrl;
    if (formUrlSection) {
      formUrlSection.classList.remove('hidden');
    }
    if (openFormLink) {
      openFormLink.href = formUrl;
    }
    logDebug('🔗 FormURL UI更新完了:', formUrl);
  } else {
    formUrlInput.value = '';
    if (formUrlSection) {
      formUrlSection.classList.add('hidden');
    }
    logDebug('📭 FormURL未設定のためUI非表示');
  }
}

// Check for auto-publish dialog
function checkAutoPublishDialog(status) {
  // Implementation for auto-publish dialog if needed
  if (status.needsAutoPublish) {
    // Show auto-publish confirmation
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Initialize UI components
function initializeUI() {
  console.log('✅ AdminPanel: UI components ready');
  // UI初期化のみ実行、loadStatusは adminPanel-api.js で処理される
}

// =============================================================================
// SHEET SELECTION FUNCTIONALITY  
// =============================================================================

// Handle sheet selection change
function handleSheetSelectionChange(event) {
  const newSelectedSheet = event.target.value;

  // Prevent redundant calls if the selected sheet hasn't actually changed
  if (newSelectedSheet === lastSelectedSheetName) {
    console.log('📊 Sheet selection changed, but value is the same. Skipping redundant processing.');
    return;
  }
  
  console.log('📊 Sheet selection changed:', {
    previousSheet: selectedSheet,
    newSelectedSheet: newSelectedSheet
  });
  
  // Update global selected sheet variable and last selected sheet
  selectedSheet = newSelectedSheet;
  lastSelectedSheetName = newSelectedSheet;
  
  if (newSelectedSheet) {
    console.log('📋 Loading config for sheet:', newSelectedSheet);

    // Call getSheetDetails once and use its result for config
    if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
      console.error('スプレッドシート情報が見つかりません');
      return;
    }

    // Call loadConfigForSelected which now handles getSheetDetails and populates UI
    loadConfigForSelected(newSelectedSheet, currentStatus.userInfo.spreadsheetId)
      .then(result => {
        console.log('✅ シート設定読み込み完了:', result);
        // UI更新完了後の処理
        updateUIForSelectedSheet();
      })
      .catch(error => {
        console.error('❌ シート設定読み込み失敗:', error);
        showMessage('シートの設定読み込みに失敗しました', 'error');
        // エラー時もUI状態を更新
        updateUIForSelectedSheet();
      });
  }
}

// Load configuration for selected sheet - OPTIMIZED
function loadConfigForSelected(sheetName, spreadsheetId, retryCount = 0, maxRetries = 3) {
  console.log('📋 Loading config for:', { selectedSheet: sheetName, spreadsheetId: spreadsheetId, retry: retryCount });

  if (!spreadsheetId || !sheetName) {
    console.error('スプレッドシート情報が不足しています。');
    return Promise.reject(new Error('スプレッドシート情報が不足しています'));
  }

  return new Promise((resolve, reject) => {

  // Check if fresh save protection is active - skip cache if so
  const timeSinceFreshSave = Date.now() - (window.freshSaveTimestamp || 0);
  const isFreshSaveActive = timeSinceFreshSave < 30000; // 30 seconds
  
    // Check if we already have sheet details from integrated API
    if (!isFreshSaveActive && currentStatus && currentStatus.sheetDetails && 
        currentStatus.activeSheetName === sheetName && currentStatus.sheetDetails.allHeaders && currentStatus.sheetDetails.allHeaders.length > 0) {
      console.log('⚡ Using cached sheet details from integrated API');
      try {
        populateHeaderOptions(currentStatus.sheetDetails.allHeaders);
        console.log('✅ Header options populated from cache');
        populateConfig(currentStatus.sheetDetails.guessedConfig);
        console.log('✅ AI configuration applied from cache');
        resolve({ source: 'cache', headers: currentStatus.sheetDetails.allHeaders, config: currentStatus.sheetDetails.guessedConfig });
        return; // Early return - no API call needed
      } catch (error) {
        console.error('Error in cached config population:', error);
        // Fall through to API call if cache fails
      }
    }

  // Force fresh API call if fresh save protection is active or cache unavailable
  if (isFreshSaveActive) {
    console.log('🔄 Fresh save protection active - forcing API call for latest data');
  } else {
    console.log('📞 Making API call for sheet details:', sheetName);
  }
  
    runGasWithUserId('getSheetDetails', 'シート情報を取得中...', spreadsheetId, sheetName)
      .then(function(details) {
        console.log('✅ Sheet details loaded via API:', details);
        
        // If headers are empty, and we have retries left, try again after a delay
        if (details && (!details.allHeaders || details.allHeaders.length === 0) && retryCount < maxRetries) {
          console.warn(`⚠️ No headers found for ${sheetName}. Retrying in 2 seconds... (Attempt ${retryCount + 1}/${maxRetries})`);
          showMessage(`シート情報を再取得中... (${retryCount + 1}/${maxRetries})`, 'info');
          setTimeout(() => {
            loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
              .then(resolve)
              .catch(reject);
          }, 2000); // Retry after 2 seconds
          return;
        }

        try {
          populateHeaderOptions(details.allHeaders);
          console.log('✅ Header options populated from API');
          populateConfig(details.guessedConfig);
          console.log('✅ AI configuration applied from API');
          if (retryCount > 0) {
            showMessage('✅ シート情報が正常に読み込まれました！', 'success');
          }
          resolve({ source: 'api', headers: details.allHeaders, config: details.guessedConfig });
        } catch (error) {
          console.error('Error in API config population sequence:', error);
          showMessage('設定の適用中にエラーが発生しました', 'error');
          reject(error);
        }
      })
      .catch(function(error) {
        console.error('Failed to load sheet config via API:', error);
        
        // より詳細なエラーメッセージの表示
        let errorMessage = 'シート設定の読み込みに失敗しました';
        
        if (error && error.message) {
          if (error.message.includes('が見つかりません')) {
            errorMessage = `指定されたシート "${sheetName}" が見つかりません。`;
          } else if (error.message.includes('ヘッダーが見つかりません')) {
            errorMessage = `シート "${sheetName}" の1行目にヘッダーが見つかりません。`;
          } else if (error.message.includes('アクセス権限')) {
            errorMessage = 'スプレッドシートへのアクセス権限がありません。管理者にお問い合わせください。';
          } else if (error.message.includes('SheetsService')) {
            errorMessage = 'Google Sheets APIサービスでエラーが発生しました。しばらく時間をおいて再試行してください。';
          } else {
            errorMessage = `エラーの詳細: ${error.message}`;
          }
        }
        
        showMessage(errorMessage, 'error');
        
        // エラー時のリトライオプションを提供
        if (retryCount < maxRetries) {
          setTimeout(() => {
            const retryButton = document.createElement('button');
            retryButton.textContent = '再試行';
            retryButton.className = 'ml-2 px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
            retryButton.onclick = () => {
              retryButton.remove();
              loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            };
            
            const messageElement = document.querySelector('.message');
            if (messageElement) {
              messageElement.appendChild(retryButton);
            }
          }, 1000);
        } else {
          reject(error);
        }
      });
  }); // Promise終了
}


// =============================================================================
// SETUP STATUS HANDLING FUNCTIONS
// =============================================================================

/**
 * userInfoからsetupStatusを安全に取得
 * @param {Object} userInfo - ユーザー情報オブジェクト
 * @returns {string} setupStatus ('pending', 'completed', 'error')
 */
function getSetupStatusFromUserInfo(userInfo) {
  try {
    if (!userInfo || !userInfo.configJson) {
      return 'pending'; // ユーザー情報がない場合はセットアップ未完了とみなす
    }

    const config = typeof userInfo.configJson === 'string'
      ? JSON.parse(userInfo.configJson)
      : userInfo.configJson;

    // setupStatusが明示的に設定されている場合はそれを使用
    if (config.setupStatus) {
      console.log('🔧 configJson setupStatus:', config.setupStatus);
      return config.setupStatus;
    }
    
    // setupStatusがない場合、他のフィールドから推測
    if (config.appPublished === true && config.formCreated === true) {
      return 'completed';
    }
    
    return 'pending';
    
  } catch (error) {
    console.warn('getSetupStatusFromUserInfo JSON解析エラー:', error.message);
    return 'pending'; // エラー時はセットアップ未完了とみなす
  }
}


/**
 * 初期表示要素をクリアして適切なドメイン表示に切り替え
 */
function clearInitialDisplayElements() {
  // 初期表示を非表示にして、適切なドメイン表示に切り替え
  const initialContainer = document.getElementById('header-domain-initial');
  if (initialContainer) {
    initialContainer.style.display = 'none';
    console.log('✅ 初期ドメイン表示を非表示');
  }
  
  // 適切なドメイン情報を表示
  showAppropriateHeaderStatus();
  
  // 既存のセットアップガイドのみ削除
  const existingGuides = [
    document.getElementById('setup-pending-guide'),
    document.querySelector('.setup-guide')
  ];
  
  existingGuides.forEach(guide => {
    if (guide) {
      guide.remove();
      console.log('✅ 既存セットアップガイドを削除');
    }
  });
}

/**
 * ヘッダーに適切なステータス表示を設定
 */
function showAppropriateHeaderStatus() {
  // ドメイン一致表示（仮）を表示
  const domainMatch = document.getElementById('header-domain-match');
  const domainMismatch = document.getElementById('header-domain-mismatch');
  
  if (domainMatch && domainMismatch) {
    // 現在はドメイン一致として表示（実際のドメインチェックは別途実装）
    domainMatch.style.display = 'block';
    domainMismatch.style.display = 'none';
    
    // ドメイン名を適切に設定
    const domainText = document.getElementById('header-domain-match-text');
    if (domainText) {
      domainText.textContent = 'naha-okinawa.ed.jp';
    }
    
    console.log('✅ ドメイン一致表示を有効化');
  }
}

/**
 * セットアップ状況に応じてボタン状態を更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateButtonStatesForSetup(status) {
  // より穏やかなUI制御（完全無効化ではなく、適切なガイダンス）
  
  // 最低限無効化すべき公開関連ボタンのみ
  const criticalPublishButtons = [
    'save-publish-btn',
    'unpublish-board-btn'
  ];
  
  criticalPublishButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      // データが不足している場合のみ無効化
      const hasSpreadsheet = status.userInfo && status.userInfo.spreadsheetId;
      const hasActiveSheet = status.activeSheetName;
      
      if (!hasSpreadsheet || !hasActiveSheet) {
        button.disabled = true;
        button.classList.add('opacity-75');
        button.title = '先にデータソースとシートを設定してください';
      } else {
        button.disabled = false;
        button.classList.remove('opacity-75');
        button.title = '';
      }
    }
  });
  
  console.log('✅ ボタン状態を適切に更新しました');
}


/**
 * 基本的な静的UI要素のみ更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateBasicStaticUI(status) {
  // ユーザー情報など最低限の情報のみ更新
  if (status.userInfo) {
    // 既存のupdateDatabaseInfo関数を使用して重複を避ける
    updateDatabaseInfo(status);
  }
}

// Update system status display
function updateSystemStatusDisplay(status) {
  if (!status) return;
  
  // Update publish status
  const publishIndicator = document.getElementById('info-publish-indicator');
  const publishText = document.getElementById('info-publish-text');
  
  if (status.isPublished) {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-green-400';
    publishText.textContent = '公開中';
  } else {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-gray-400';
    publishText.textContent = '非公開';
  }
  
  // Update other status fields
  document.getElementById('info-published-sheet').textContent = status.sheetName || '-';
  document.getElementById('info-display-mode').textContent = status.displayMode || '-';
  document.getElementById('info-show-counts').textContent = status.showCounts ? '表示' : '非表示';
  document.getElementById('info-answer-count').textContent = status.answerCount || '0';
  document.getElementById('info-reaction-count').textContent = status.reactionCount || '0';
  
  // Enable resource buttons if URLs are available
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
  const formBtn = document.getElementById('open-form-btn');
  const resourceBtn = document.getElementById('open-resource-btn');
  
  if (status.spreadsheetUrl) {
    if (spreadsheetBtn) {
      spreadsheetBtn.disabled = false;
      spreadsheetBtn.onclick = () => window.open(status.spreadsheetUrl, '_blank');
    }
  }

  // フォームURLの取得（複数ソースから）
  let formUrl = null;
  
  // 1. configJsonから取得
  if (status.userInfo && status.userInfo.configJson) {
    try {
      const configJson = typeof status.userInfo.configJson === 'string' 
        ? JSON.parse(status.userInfo.configJson) 
        : status.userInfo.configJson;
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        console.log('✅ FormURL found in configJson:', formUrl);
      }
    } catch (error) {
      console.warn('⚠️ configJson parse error:', error);
    }
  }
  
  // 2. userInfo.formUrlから取得（フォールバック）
  if (!formUrl && status.userInfo && status.userInfo.formUrl) {
    formUrl = status.userInfo.formUrl;
    console.log('📋 FormURL found in userInfo:', formUrl);
  }
  
  // 3. customFormInfoから取得（後方互換性）
  if (!formUrl && status.customFormInfo && status.customFormInfo.formUrl) {
    formUrl = status.customFormInfo.formUrl;
    console.log('📄 FormURL found in customFormInfo:', formUrl);
  }
  
  // statusオブジェクトにformUrlを設定
  status.formUrl = formUrl;

  if (status.formUrl) { // statusオブジェクトにformUrlが存在する場合
    if (formBtn) {
      formBtn.disabled = false;
      // onclick は既に adminPanel-events.js で openForm 関数が設定されているため、
      // ここでは disabled 状態とスタイルのみを制御
      formBtn.title = 'フォームを開く';
      formBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      console.log('✅ Form button enabled with URL:', status.formUrl);
    }
  } else { // formUrlが存在しない場合、ボタンを無効化し、メッセージを表示
    if (formBtn) {
      formBtn.disabled = true;
      // onclick イベントは既存のものを保持（openForm関数）
      formBtn.title = 'フォームURLが未設定です。フォームを作成してください。';
      formBtn.classList.add('opacity-50', 'cursor-not-allowed');
      console.log('⚠️ Form button disabled - no URL available');
    }
  }
  
  // Handle generic resource button in Step 1 (spreadsheet only)
  if (resourceBtn && status.spreadsheetUrl) {
    resourceBtn.disabled = false;
    resourceBtn.onclick = () => {
      window.open(status.spreadsheetUrl, '_blank');
    };
    
    // Update button title for spreadsheet only
    resourceBtn.title = 'スプレッドシートを開く';
  }
}

// Navigate to specific step
function navigateToStep(step) {
  currentStep = step;
  
  // Update step indicators
  document.querySelectorAll('.step-indicator').forEach((indicator, index) => {
    const stepNumber = index + 1;
    indicator.classList.toggle('completed', stepNumber < step);
    indicator.classList.toggle('active', stepNumber === step);
  });
  
  // Show/hide step content
  document.querySelectorAll('.step-content').forEach((content, index) => {
    const stepNumber = index + 1;
    content.classList.toggle('hidden', stepNumber !== step);
  });
  
  // Update progress bar
  const progressBar = document.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.width = `${(step / 3) * 100}%`;
  }
  
  validateCurrentStep();
}


// セットアップ状況をグローバルステータスから取得

// セットアップ未完了時の段階的制御を強制
function enforceStepProgression() {
  const step1Completed = checkStep1Completion();
  const step2Completed = checkStep2Completion();
  
  // Step 2の制御
  const step2Section = document.getElementById('sheet-selection-section');
  if (!step1Completed) {
    disableSection(step2Section, '⚠️ 先にデータ準備を完了してください');
  } else {
    enableSection(step2Section);
  }
  
  // Step 3の制御
  const step3Section = document.getElementById('config-section');
  if (!step1Completed || !step2Completed) {
    disableSection(step3Section, '⚠️ 前のステップを完了してください');
  } else {
    enableSection(step3Section);
  }
}

// Step 1完了チェック
function checkStep1Completion() {
  return !!(selectedSheetId || selectedFormId || 
            (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetId));
}

// Step 2完了チェック
function checkStep2Completion() {
  return !!(currentStatus && currentStatus.activeSheetName);
}

// セクションを無効化
function disableSection(section, message) {
  if (!section) return;
  
  section.style.opacity = '0.5';
  section.style.pointerEvents = 'none';
  
  // 警告メッセージを追加
  const existingWarning = section.querySelector('.step-warning');
  if (!existingWarning) {
    const warning = document.createElement('div');
    warning.className = 'step-warning bg-yellow-100 border border-yellow-300 rounded-lg p-3 mb-4 text-sm text-yellow-800';
    warning.innerHTML = `<span class="font-semibold">${message}</span>`;
    section.insertBefore(warning, section.firstChild);
  }
}

// セクションを有効化
function enableSection(section) {
  if (!section) return;
  
  section.style.opacity = '1';
  section.style.pointerEvents = 'auto';
  
  // 警告メッセージを削除
  const warning = section.querySelector('.step-warning');
  if (warning) {
    warning.remove();
  }
}



// Validate configuration
function validateConfiguration() {
  if (!currentConfig || !currentConfig.columnMappings) return false;
  
  const mappings = currentConfig.columnMappings;
  const hasContent = Object.values(mappings).includes('content');
  const hasAuthor = Object.values(mappings).includes('author');
  
  return hasContent && hasAuthor;
}


// =============================================================================
// HISTORY MANAGEMENT FUNCTIONS
// =============================================================================

// 履歴アイテムの最大保存数
const MAX_HISTORY_ITEMS = 10;

/**
 * 回答ボードの履歴を保存
 * @param {Object} historyItem - 保存する履歴アイテム
 */
function saveToHistory(historyItem) {
  try {
    if (!historyItem || !historyItem.questionText) {
      logWarn('Invalid history item, skipping save');
      return;
    }

    const history = getHistoryFromStorage();
    
    // 新しいアイテムを先頭に追加
    const newItem = {
      id: generateHistoryId(),
      timestamp: new Date().toISOString(),
      publishedAt: historyItem.publishedAt || new Date().toISOString(),
      publishedEndAt: historyItem.publishedEndAt || null,
      questionText: historyItem.questionText,
      sheetName: historyItem.sheetName || '',
      answerCount: historyItem.answerCount || 0,
      reactionCount: historyItem.reactionCount || 0,
      config: historyItem.config || {},
      formUrl: historyItem.formUrl || '',
      spreadsheetUrl: historyItem.spreadsheetUrl || '',
      setupType: historyItem.setupType || 'unknown' // クイックスタート、カスタムセットアップ、外部リソースを識別
    };
    
    history.unshift(newItem);
    
    // 最大数を超えた場合は古いものを削除
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }
    
    localStorage.setItem('answerBoardHistory', JSON.stringify(history));
    logDebug('History saved:', newItem);
    
    // UI を更新
    loadSimpleHistoryTable();
    
  } catch (error) {
    logWarn('Failed to save history:', error);
  }
}

/**
 * 履歴を localStorage から取得
 * @returns {Array} 履歴配列
 */
function getHistoryFromStorage() {
  try {
    const historyJson = localStorage.getItem('answerBoardHistory');
    return historyJson ? JSON.parse(historyJson) : [];
  } catch (error) {
    logWarn('Failed to parse history from storage:', error);
    return [];
  }
}

/**
 * 履歴用のユニークIDを生成
 * @returns {string} ユニークID
 */
function generateHistoryId() {
  return 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// 旧来のカード形式の履歴表示は削除 - 簡単なテーブル形式のみ使用

/**
 * 簡単な履歴テーブルを表示（新実装）
 */
function loadSimpleHistoryTable() {
  const tableBody = document.getElementById('history-table-body');
  
  if (!tableBody) return;
  
  const history = getHistoryFromStorage();
  
  // テーブルをクリア
  tableBody.innerHTML = '';
  
  if (history.length === 0) {
    // 履歴が空の場合
    const emptyRow = document.createElement('tr');
    emptyRow.innerHTML = `
      <td colspan="4" class="px-3 py-4 text-center text-gray-500 text-sm">
        履歴がありません
      </td>
    `;
    tableBody.appendChild(emptyRow);
    return;
  }
  
  // 履歴アイテムをテーブル行として表示
  history.forEach((item, index) => {
    const row = createHistoryTableRow(item, index);
    tableBody.appendChild(row);
  });
}

/**
 * 履歴テーブル行を作成
 * @param {Object} item - 履歴アイテム
 * @param {number} index - インデックス
 * @returns {HTMLElement} テーブル行要素
 */
function createHistoryTableRow(item, index) {
  const row = document.createElement('tr');
  row.className = 'hover:bg-gray-700/30 cursor-pointer transition-colors';
  row.onclick = () => selectHistoryItem(item.id);
  
  const formatDateTime = (dateString) => {
    if (!dateString) return '未設定';
    const date = new Date(dateString);
    return date.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  row.innerHTML = `
    <td class="px-3 py-2 text-xs text-gray-300">${formatDateTime(item.publishedAt)}</td>
    <td class="px-3 py-2 text-xs text-gray-300">${formatDateTime(item.publishedEndAt)}</td>
    <td class="px-3 py-2 text-xs text-gray-300 truncate" title="${escapeHtml(item.questionText)}">${escapeHtml(item.questionText)}</td>
    <td class="px-3 py-2 text-xs text-gray-300">${item.answerCount || 0}</td>
  `;
  
  return row;
}

/**
 * 履歴選択時の自動フロー処理
 * @param {string} historyId - 履歴ID
 */
function selectHistoryItem(historyId) {
  try {
    const history = getHistoryFromStorage();
    const item = history.find(h => h.id === historyId);
    
    if (!item) {
      showMessage('履歴アイテムが見つかりませんでした', 'error');
      return;
    }
    
    // 自動でシートを選択
    if (item.sheetName) {
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        sheetSelect.value = item.sheetName;
        selectedSheet = item.sheetName;
        
        // シート選択イベントを発生させてプレビューを読み込み
        const changeEvent = new Event('change', { bubbles: true });
        sheetSelect.dispatchEvent(changeEvent);
      }
    }
    
    // 設定を復元
    if (item.config) {
      setTimeout(() => {
        restoreConfigFromHistory(item.config);
        
        // Step 3の表示設定セクションに移動
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 現在のステップを3に更新
        updateStepIndicators(3);
        manageSectionStates(3);
        
        showMessage(`「${item.questionText}」の設定を復元しました`, 'success');
      }, 500); // シート選択処理の完了を待つ
    }
    
  } catch (error) {
    logError('Failed to select history item:', error);
    showMessage('履歴の選択に失敗しました', 'error');
  }
}

/**
 * 履歴から設定を復元
 * @param {Object} config - 設定オブジェクト
 */
function restoreConfigFromHistory(config) {
  try {
    // フォーム設定の復元
    if (config.opinionHeader) {
      const opinionSelect = document.getElementById('opinionHeader');
      if (opinionSelect) opinionSelect.value = config.opinionHeader;
    }
    
    if (config.nameHeader) {
      const nameSelect = document.getElementById('name-column');
      if (nameSelect) nameSelect.value = config.nameHeader;
    }
    
    if (config.classHeader) {
      const classSelect = document.getElementById('class-column');
      if (classSelect) classSelect.value = config.classHeader;
    }
    
    if (config.reasonHeader) {
      const reasonSelect = document.getElementById('reason-column');
      if (reasonSelect) reasonSelect.value = config.reasonHeader;
    }
    
    // チェックボックスの復元
    const showNamesCheckbox = document.getElementById('show-names');
    if (showNamesCheckbox) showNamesCheckbox.checked = config.showNames || false;
    
    const showCountsCheckbox = document.getElementById('show-counts');
    if (showCountsCheckbox) showCountsCheckbox.checked = config.showCounts || false;
    
    // 設定ボタンの状態を更新
    updateConfigButtons();
    
  } catch (error) {
    logError('Failed to restore config from history:', error);
  }
}

// createHistoryItemElement関数は削除 - テーブル形式のcreateHistoryTableRowを使用

/**
 * HTMLエスケープ関数
 * @param {string} text - エスケープするテキスト
 * @returns {string} エスケープされたテキスト
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// 旧来の複雑な履歴管理関数群は削除 - selectHistoryItem()による自動フローのみ使用

// 簡単な履歴テーブル初期化
document.addEventListener('DOMContentLoaded', function() {
  // 簡単な履歴テーブルを読み込み
  loadSimpleHistoryTable();
});

// 初期化は adminPanel-core.js の統合初期化システムで管理されます
</script>
