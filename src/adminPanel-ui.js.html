<script>
let lastSelectedSheetName = null; // To prevent redundant sheet selection change events

// UI Update Mutex to prevent race conditions
let isUIUpdateInProgress = false;
let pendingUIUpdate = null;

// =============================================================================
// EARLY FUNCTION DEFINITIONS (Critical functions that must be available immediately)
// =============================================================================

// Define critical functions early and register them globally
if (typeof window !== 'undefined') {
  // Placeholder functions that will be properly defined later
  // All critical functions are now defined in adminPanel-framework.js.html which loads first
  // Keeping only functions not moved to framework
  window.hideFormConfigModal = window.hideFormConfigModal || function() { console.warn('hideFormConfigModal not yet loaded'); };
  window.showPrivacyModal = window.showPrivacyModal || function() { console.warn('showPrivacyModal not yet loaded'); };
}


// =============================================================================
// ADMIN PANEL UI UPDATES & DISPLAY CONTROL
// =============================================================================

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Unified publication state detection with enhanced flow completion recognition
function getPublicationState(status) {
  if (!status) {
    return { isPublished: false, reason: 'No status data' };
  }
  
  // Check multiple possible publication indicators in priority order
  let isPublished = false;
  let reason = '';
  
  // 1. Direct isPublished property
  if (status.isPublished === true) {
    isPublished = true;
    reason = 'status.isPublished=true';
  }
  // 2. Direct appPublished property  
  else if (status.appPublished === true) {
    isPublished = true;
    reason = 'status.appPublished=true';
  }
  // 3. Check configJson for appPublished
  else if (status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.appPublished === true) {
        isPublished = true;
        reason = 'configJson.appPublished=true';
        
        // Enhanced validation: Verify setup completion indicators
        const hasCompletedSetup = (
          config.setupStatus === 'completed' &&
          config.formCreated === true &&
          config.publishedSheetName &&
          config.publishedSpreadsheetId
        );
        
        if (hasCompletedSetup) {
          reason += ' (ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿)';
        } else {
          console.log('âš ï¸ Publication state: appPublished=true but setup incomplete', {
            setupStatus: config.setupStatus,
            formCreated: config.formCreated,
            hasPublishedSheet: !!config.publishedSheetName,
            hasPublishedSpreadsheet: !!config.publishedSpreadsheetId
          });
          reason += ' (ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸å®Œå…¨)';
        }
      } 
      // 4. Enhanced completion check: Allow recognition of completed but not yet published setups
      else if (config.setupStatus === 'completed' && 
               config.formCreated === true && 
               config.publishedSheetName && 
               config.publishedSpreadsheetId) {
        // This covers cases where setup is complete but appPublished might not be properly set
        console.log('ğŸ”§ Publication state: Setup complete but appPublished=false - potential state inconsistency');
        reason = 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã ãŒå…¬é–‹çŠ¶æ…‹ä¸æ•´åˆ';
        // Don't auto-publish, but log for debugging
      }
    } catch (e) {
      console.warn('Failed to parse configJson:', e);
    }
  }
  
  // Maintained strict logic to prevent false positives
  // Note: Removed loose fallback logic that assumed activeSheetName = published
  
  return { 
    isPublished, 
    reason,
    // Add confidence level for better debugging
    confidence: isPublished ? (reason.includes('ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿') ? 'high' : 'medium') : 'low'
  };
}

// Generate viewUrl with comprehensive fallback logic
function generateViewUrl(status, userId) {
  // 1. Use existing viewUrl if available
  let viewUrl = status.appUrls?.viewUrl;
  if (viewUrl) {
    return viewUrl;
  }
  
  // 2. Generate from appUrls.webApp with userId
  if (status.appUrls?.webApp && userId) {
    return status.appUrls.webApp + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 3. Generate from status.webAppUrl with userId
  if (status.webAppUrl && userId) {
    return status.webAppUrl + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 4. Simple fallback without userId
  if (status.appUrls?.webApp) {
    return status.appUrls.webApp + '?mode=view';
  }
  
  logWarn('Could not generate viewUrl');
  return null;
}

// =============================================================================
// MAIN UI UPDATE FUNCTIONS
// =============================================================================

// Update UI with new status data
// Full implementation of updateUIWithNewStatus for later use
function _fullUpdateUIWithNewStatus(status) {
  if (!validateStatus(status)) {
    logWarn('Invalid status received, skipping UI update');
    return;
  }

  // UI Update Mutex: Prevent concurrent UI updates
  if (isUIUpdateInProgress) {
    logDebug('UI update in progress, queuing this update');
    pendingUIUpdate = status;
    return;
  }

  isUIUpdateInProgress = true;
  
  try {
    // Phase 1: ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆåŒæœŸå‡¦ç†ï¼‰
    status = prepareStatusData(status);
    currentStatus = status;
    
    // Phase 2: ä¸¦åˆ—UIæ›´æ–°ï¼ˆéåŒæœŸå‡¦ç†ã®æœ€é©åŒ–ï¼‰
    executeParallelUIUpdates(status);
    
  } catch (error) {
    logError('UIæ›´æ–°ã§ã‚¨ãƒ©ãƒ¼:', error);
  } finally {
    // æœ€å¾Œã«Mutexã‚’è§£é™¤
    setTimeout(() => finishUIUpdate(), 0);
  }
}

// Make the full implementation available for the framework version
if (typeof window !== 'undefined') {
  window._fullUpdateUIWithNewStatus = _fullUpdateUIWithNewStatus;
}

// ãƒ‡ãƒ¼ã‚¿æº–å‚™ã®æœ€é©åŒ–ï¼ˆåŒæœŸå‡¦ç†éƒ¨åˆ†ï¼‰
function prepareStatusData(status) {
  // 1. configJsonæ­£è¦åŒ–å‡¦ç†ï¼ˆåŒ…æ‹¬çš„ã‚·ã‚¹ãƒ†ãƒ æœ€é©åŒ–ï¼‰
  status.config = normalizeConfigJson(status.config, status.userInfo);
  
  // 2. æ­£è¦åŒ–ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¿½åŠ ï¼ˆè¨ˆç®—é›†ç´„å‡¦ç†ï¼‰
  const publicationState = getPublicationState(status);
  const viewUrl = generateViewUrl(status, userId);
  
  status._normalized = {
    isPublished: publicationState.isPublished,
    publishReason: publicationState.reason,
    viewUrl: viewUrl,
    hasValidViewUrl: !!viewUrl
  };
  
  return status;
}

// ä¸¦åˆ—UIæ›´æ–°ã®å®Ÿè¡Œï¼ˆéåŒæœŸå‡¦ç†ã®æœ€é©åŒ–ï¼‰
function executeParallelUIUpdates(status) {
  const setupStatus = getSetupStatusFromUserInfo(status.userInfo);
  const currentStep = status.setupStep || 1;
  
  // ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªæ›´æ–°ã‚¿ã‚¹ã‚¯ã‚’å®šç¾©
  const updateTasks = [
    // Task 1: é™çš„è¦ç´ ã®æ›´æ–°
    () => {
      clearInitialDisplayElements();
      updateStaticUI(status);
      updateUnpublishButton(status);
      if (setupStatus === 'pending') {
        updateButtonStatesForSetup(status);
      }
    },
    
    // Task 2: å‹•çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ›´æ–°
    () => {
      if (status.activeSheetName) {
        updateDynamicContent(status);
      } else {
        updateUIForNoActiveSheet(status);
      }
    },
    
    // Task 3: ãƒ•ãƒƒã‚¿ãƒ¼ã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã®æ›´æ–°
    () => updateFooterAndGuidance(status),
    
    // Task 4: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®æ›´æ–°ï¼ˆçµ±åˆæœ€é©åŒ–ç‰ˆï¼‰
    () => updateStepIndicators(status?.setupStep || currentStep, status)
  ];
  
  // ä¸¦åˆ—å®Ÿè¡Œï¼ˆrequestAnimationFrameã§æœ€é©åŒ–ï¼‰
  requestAnimationFrame(() => {
    // é‡ã„å‡¦ç†ã‚’è¤‡æ•°ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«åˆ†æ•£
    executeTasksInBatches(updateTasks);
  });
}

// ã‚¿ã‚¹ã‚¯ã®ãƒãƒƒãƒå®Ÿè¡Œï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ åˆ†æ•£æœ€é©åŒ–ï¼‰
function executeTasksInBatches(tasks, batchSize = 2) {
  if (tasks.length === 0) return;
  
  // ç¾åœ¨ã®ãƒãƒƒãƒã‚’å®Ÿè¡Œ
  const currentBatch = tasks.splice(0, batchSize);
  currentBatch.forEach(task => {
    try {
      task();
    } catch (error) {
      logError('UIæ›´æ–°ã‚¿ã‚¹ã‚¯ã‚¨ãƒ©ãƒ¼:', error);
    }
  });
  
  // æ®‹ã‚Šã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹å ´åˆã¯æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œ
  if (tasks.length > 0) {
    requestAnimationFrame(() => executeTasksInBatches(tasks, batchSize));
  }
}

// UIæ›´æ–°å®Œäº†å‡¦ç†
function finishUIUpdate() {
  isUIUpdateInProgress = false;
  
  // å¾…æ©Ÿä¸­ã®æ›´æ–°ãŒã‚ã‚Œã°å®Ÿè¡Œ
  if (pendingUIUpdate) {
    const nextUpdate = pendingUIUpdate;
    pendingUIUpdate = null;
    updateUIWithNewStatus(nextUpdate);
  }
}

// =============================================================================
// HELPER FUNCTIONS FOR UI UPDATES
// =============================================================================

// Update unpublish button state
function updateUnpublishButton(status) {
  const unpublishBtn = document.getElementById('unpublish-board-btn');
  if (!unpublishBtn) return;

  // Use same strict logic as footer: both normalized and explicit checks
  const isPublished = status._normalized?.isPublished || false;
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('âŒ Failed to parse configJson for unpublish button check:', configError);
      explicitAppPublished = false;
    }
  }
  
  const finalIsPublished = isPublished && explicitAppPublished;

  if (finalIsPublished) {
    unpublishBtn.classList.remove('hidden');
  } else {
    unpublishBtn.classList.add('hidden');
  }
}

// Update spreadsheet access button state
function updateSpreadsheetButton() {
  const btn = document.getElementById('open-spreadsheet-btn-step2');
  if (!btn) return;
  
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetUrl) {
    btn.disabled = false;
    btn.onclick = function() {
      window.open(currentStatus.userInfo.spreadsheetUrl, '_blank');
    };
    logDebug('âœ… Spreadsheet button enabled with URL:', currentStatus.userInfo.spreadsheetUrl);
  } else {
    btn.disabled = true;
    btn.onclick = null;
    logDebug('âš ï¸ Spreadsheet button disabled - no URL available');
  }
}

// Update static UI elements
function updateStaticUI(status) {
  // Update database info panel
  updateDatabaseInfo(status);
  
  // Update existing user section
  updateExistingUserSection(status);
  
  // Populate sheet selection - fix property name mismatch
  logDebug('ğŸ” Debug: Checking sheet data properties', {
    allSheets: status.allSheets,
    sheetNames: status.sheetNames,
    activeSheetName: status.activeSheetName
  });
  
  const sheetsData = status.sheetNames || status.allSheets || [];
  populateSheetSelect(sheetsData, status.activeSheetName);
  
  // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã®ç¢ºå®Ÿãªåæ˜ ï¼ˆå¼·åŒ–ï¼‰
  if (status.activeSheetName) {
    setTimeout(() => {
      const select = document.getElementById('sheet-select');
      if (select && select.value !== status.activeSheetName) {
        console.log('ğŸ”„ Force updating active sheet selection:', status.activeSheetName);
        updateActiveSheetUI(status.activeSheetName);
      }
    }, 100);
  }
  
  // Update custom form info
  updateCustomFormInfo(status);
  
  // Check for auto-publish dialog
  checkAutoPublishDialog(status);
}

// =============================================================================
// DATABASE INFO PANEL UPDATES
// =============================================================================

function updateDatabaseInfo(status) {
  if (!status || !status.userInfo) {
    console.warn('System info update failed: No user info available');
    return;
  }

  // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆURLã‚’è¨­å®š
  if (status.userInfo.spreadsheetUrl) {
    currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
  }

  const cfg = status.config || {};

  // åŸºæœ¬æƒ…å ±ã®æ›´æ–°
  safeSetText('info-admin-email', status.userInfo.adminEmail);
  safeSetText('info-user-id', status.userInfo.userId);
  safeSetText('info-published-sheet', cfg.publishedSheetName || status.publishedSheetName || 'ãªã—');
  

  // å…¬é–‹çŠ¶æ…‹ã®è¡¨ç¤ºã‚’æ›´æ–°
  const isPublished = cfg.isPublished !== undefined
    ? cfg.isPublished
    : status.appPublished || status.isPublished || (status.activeSheetName && (cfg.publishedSheetName || status.publishedSheetName));
  updatePublicationStatusUI(isPublished);

  // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã®æ›´æ–°
  const displayModeFlag = cfg.showNames !== undefined ? cfg.showNames : status.showNames;
  const displayMode = displayModeFlag ? 'åå‰è¡¨ç¤º' : 'åŒ¿åè¡¨ç¤º';
  safeSetText('info-display-mode', displayMode);

  // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºã®æ›´æ–°
  const showCountsFlag = cfg.showCounts !== undefined
    ? cfg.showCounts
    : (status.showCounts !== undefined ? status.showCounts : false);
  const showCounts = showCountsFlag ? 'è¡¨ç¤º' : 'éè¡¨ç¤º';
  safeSetText('info-show-counts', showCounts);

  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹åŒæœŸ
  syncCheckboxStates(status);
}

// Update publication status UI
function updatePublicationStatusUI(isPublished) {
  const statusElement = safeGetElement('info-publish-status');
  const indicatorElement = safeGetElement('info-publish-indicator');
  const textElement = safeGetElement('info-publish-text');
  
  if (statusElement) {
    if (isPublished) {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      if (textElement) textElement.textContent = 'å…¬é–‹ä¸­';
    } else {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      if (textElement) textElement.textContent = 'éå…¬é–‹';
    }
  }
}

// ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’åŒæœŸã™ã‚‹é–¢æ•°
function syncCheckboxStates(status) {
  // Priority: Database config (configJson) > status properties > defaults
  let showNames = false;
  let showCounts = false;
  
  // 1. Prefer status.config if available
  if (status.config) {
    if (status.config.showNames !== undefined) showNames = status.config.showNames;
    if (status.config.showCounts !== undefined) showCounts = status.config.showCounts;
  } else if (status.userInfo?.configJson) {
    // 2. Fallback to raw configJson
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.showNames !== undefined) showNames = config.showNames;
      if (config.showCounts !== undefined) showCounts = config.showCounts;
    } catch (e) {
      logWarn('Failed to parse configJson, using status properties');
      if (status.showNames !== undefined) showNames = status.showNames;
      if (status.showCounts !== undefined) showCounts = status.showCounts;
    }
  } else {
    // 3. Use status properties as last resort
    if (status.showNames !== undefined) showNames = status.showNames;
    if (status.showCounts !== undefined) showCounts = status.showCounts;
  }

  // Update checkbox elements
  const showNamesCheckbox = safeGetElement('show-names');
  const showCountsCheckbox = safeGetElement('show-counts');
  
  if (showNamesCheckbox) {
    showNamesCheckbox.checked = showNames;
  }
  
  if (showCountsCheckbox) {
    showCountsCheckbox.checked = showCounts;
  }
}

// =============================================================================
// SHEET SELECTION AND CONFIGURATION
// =============================================================================

// Populate sheet selection dropdown
function populateSheetSelect(sheetNames, activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) {
    logWarn('Sheet select element not found');
    return;
  }

  logDebug('ğŸ“‹ Populating sheet select with data:', {
    sheetNames: sheetNames,
    activeSheetName: activeSheetName,
    dataType: typeof sheetNames,
    isArray: Array.isArray(sheetNames)
  });

  // Clear existing options
  select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠ --</option>';
  
  if (sheetNames && sheetNames.length > 0) {
    logDebug('âœ… Adding sheets to dropdown:', sheetNames.length);
    
    sheetNames.forEach((sheet, index) => {
      const option = document.createElement('option');
      
      // Handle both object and string formats
      let sheetName;
      if (typeof sheet === 'object' && sheet.name) {
        sheetName = sheet.name;
        option.value = sheet.name;
        logDebug(`ğŸ“„ Sheet ${index + 1}: ${sheet.name} (ID: ${sheet.id})`);
      } else if (typeof sheet === 'string') {
        sheetName = sheet;
        option.value = sheet;
        logDebug(`ğŸ“„ Sheet ${index + 1}: ${sheet}`);
      } else {
        console.warn('âš ï¸ Unknown sheet format:', sheet);
        return;
      }
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã®è¡¨ç¤ºã‚’æ”¹å–„
      if (sheetName === activeSheetName) {
        option.textContent = `${sheetName} (ã‚¢ã‚¯ãƒ†ã‚£ãƒ–)`;
        option.style.fontWeight = 'bold';
        option.style.color = '#10b981'; // ç·‘è‰²ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚’è¡¨ç¤º
        option.className = 'active-sheet-option';
        logDebug(`âœ… Active sheet marked: ${sheetName}`);
      } else {
        option.textContent = sheetName;
      }
      
      select.appendChild(option);
    });
    select.disabled = false;
    logDebug('âœ… Sheet dropdown populated successfully');
  } else {
    console.warn('âš ï¸ No sheets available:', sheetNames);
    select.innerHTML = '<option value="">åˆ©ç”¨å¯èƒ½ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</option>';
    select.disabled = true;
  }
  
  // Set active sheet if available (å¼·åŒ–ã•ã‚ŒãŸé¸æŠãƒ­ã‚¸ãƒƒã‚¯)
  if (activeSheetName) {
    // ã‚·ãƒ¼ãƒˆåã®æ­£è¦åŒ–ã‚’è€ƒæ…®ã—ãŸé¸æŠå‡¦ç†
    const normalizedActiveSheet = activeSheetName.trim();
    
    // æ­£ç¢ºãªä¸€è‡´ã‚’ç¢ºèª
    const availableOptions = Array.from(select.options);
    const matchingOption = availableOptions.find(option => option.value === normalizedActiveSheet);
    
    if (matchingOption) {
      select.value = normalizedActiveSheet;
      selectedSheet = normalizedActiveSheet;
      lastSelectedSheetName = normalizedActiveSheet;
      logDebug('âœ… Active sheet set successfully:', normalizedActiveSheet);
    } else {
      // éƒ¨åˆ†ä¸€è‡´ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
      console.warn('âš ï¸ Active sheet not found in options, attempting fallback:', {
        activeSheetName: normalizedActiveSheet,
        availableOptions: availableOptions.map(opt => opt.value)
      });
      
      // æœ€åˆã®æœ‰åŠ¹ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸æŠ
      if (availableOptions.length > 1) { // Skip the default "-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠ --"
        const firstSheet = availableOptions[1].value;
        select.value = firstSheet;
        selectedSheet = firstSheet;
        lastSelectedSheetName = firstSheet;
        logDebug('ğŸ”„ Fallback to first available sheet:', firstSheet);
      }
    }
    
    // é¸æŠçŠ¶æ…‹ã‚’ç¢ºèª
    if (select.value) {
      logDebug('âœ… Final sheet selection confirmed:', select.value);
    } else {
      console.error('âŒ Sheet selection failed - no sheet selected');
    }
  }
  
  // Add change event listener for data preview
  select.removeEventListener('change', handleSheetSelectionChange);
  select.addEventListener('change', handleSheetSelectionChange);
  
  // Update UI for selected sheet and enable spreadsheet button
  updateUIForSelectedSheet();
  updateSpreadsheetButton();
}

// Populate header options for configuration
function populateHeaderOptions(headers) {
  // Throttle function calls to prevent spam
  if (window.populateHeaderOptionsRunning) {
    return;
  }
  window.populateHeaderOptionsRunning = true;
  
  const selects = [
    'opinionHeader',      // Main required field
    'reason-column',     // Optional details field (reason column)
    'name-column', 
    'class-column'
  ];
  
  selects.forEach(selectId => {
    const select = document.getElementById(selectId);
    
    if (select) {
      // Store current value
      const currentValue = select.value;
      
      // Clear and repopulate with appropriate placeholder
      if (headers && headers.length > 0) {
        select.innerHTML = '<option value="">-- åˆ—ã‚’é¸æŠ --</option>';
        select.disabled = false;
      } else {
        select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ --</option>';
        select.disabled = true;
      }
      
      const excludedHeaders = [
        'ãªã‚‹ã»ã©ï¼',
        'ã„ã„ã­ï¼',
        'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ï¼',
        'ãƒã‚¤ãƒ©ã‚¤ãƒˆ',
        'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', // ãƒ•ã‚©ãƒ¼ãƒ ã§è‡ªå‹•åé›†ã•ã‚Œã‚‹ãŸã‚ã€ãƒãƒƒãƒ”ãƒ³ã‚°å¯¾è±¡ã‹ã‚‰é™¤å¤–
        'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—' // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æœ›ã«ã‚ˆã‚Šé™¤å¤–
      ];

      const filteredHeaders = headers.filter(header => !excludedHeaders.includes(header));

      filteredHeaders.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        select.appendChild(option);
      });
      
      // Restore previous value if still valid
      if (currentValue && headers.includes(currentValue)) {
        select.value = currentValue;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateHeaderOptionsRunning = false;
  }, 100);
}

// Populate configuration with guessed values
function populateConfig(cfg) {
  if (!cfg) return;
  
  // Throttle function calls to prevent spam
  if (window.populateConfigRunning) {
    return;
  }
  window.populateConfigRunning = true;
  
  const mappings = {
    // Main opinion dropdown (primary target)
    'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
    
    // Detail configuration dropdowns (secondary targets with property name fixes)
    'reason-column': cfg.reasonColumn || cfg.reasonHeader,
    'name-column': cfg.nameColumn || cfg.nameHeader,
    'class-column': cfg.classColumn || cfg.classHeader,
    'show-names': cfg.showNames,
    'show-counts': cfg.showCounts
  };
  
  Object.keys(mappings).forEach(elementId => {
    const element = document.getElementById(elementId);
    const value = mappings[elementId];
    
    if (element && value !== undefined) {
      if (element.type === 'checkbox') {
        element.checked = Boolean(value);
      } else {
        element.value = value;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateConfigRunning = false;
  }, 100);
  
  updateConfigButtons();
}

// Clear configuration fields
function clearConfigFields() {
  const fieldIds = [
    'opinionHeader',      // Main required field
    'reason-column',
    'name-column',
    'class-column'
  ];
  
  fieldIds.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.value = '';
    }
  });
  
  updateConfigButtons();
}

// Build configuration object from form
function buildConfigObject() {
  // Get values from primary elements (with fallback to secondary elements)
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  const nameValue = document.getElementById('name-column')?.value || '';
  const classValue = document.getElementById('class-column')?.value || '';
  const showNames = document.getElementById('show-names')?.checked || false;
  const showCounts = document.getElementById('show-counts')?.checked || false;
  
  return {
    sheetName: selectedSheet,
    // Use property names that match backend expectations (opinionHeader format)
    opinionHeader: opinionValue,
    nameHeader: nameValue,
    classHeader: classValue,
    reasonHeader: document.getElementById('reason-column')?.value || '',
    // Also provide legacy format for backward compatibility
    opinionColumn: opinionValue,
    nameColumn: nameValue,
    classColumn: classValue,
    showNames: showNames,
    showCounts: showCounts
  };
}

// Validate configuration
function validateConfig() {
  // Check primary element first, then fallback to secondary element
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  
  return opinionValue && opinionValue.trim() !== '';
}

// Update configuration buttons state
function updateConfigButtons() {
  const isValid = validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
  
  if (saveBtn) {
    saveBtn.disabled = !isValid;
    if (isValid) {
      saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
      saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
  }
}

// =============================================================================
// STEP INDICATORS AND GUIDANCE
// =============================================================================

// çµ±ä¸€ã•ã‚ŒãŸã‚¹ãƒ†ãƒƒãƒ—å®Œäº†ãƒã‚§ãƒƒã‚¯ - å…¬é–‹çŠ¶æ…‹å„ªå…ˆåˆ¤å®šå¯¾å¿œç‰ˆ
function getStepCompletionFromConfig(status) {
  if (!status?.userInfo?.configJson) {
    return { step1: false, step2: false, step3: false, isPublished: false };
  }

  try {
    const config = typeof status.userInfo.configJson === 'string' 
      ? JSON.parse(status.userInfo.configJson) 
      : status.userInfo.configJson;

    // å…¬é–‹çŠ¶æ…‹ã®å„ªå…ˆãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã«é–¢ä¿‚ãªãå…¬é–‹æ¸ˆã¿ãªã‚‰å…¨ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†ï¼‰
    const publicationState = getPublicationState(status);
    if (publicationState.isPublished) {
      return {
        step1: true,
        step2: true,
        step3: true,
        isPublished: true
      };
    }

    // é€šå¸¸ã®ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†åˆ¤å®š
    // Step 1: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDã®å­˜åœ¨ç¢ºèª
    const step1Complete = !!(status.userInfo.spreadsheetId);
    
    // Step 2: ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†çŠ¶æ…‹ã®ç¢ºèª
    const step2Complete = config.setupStatus === 'completed' && 
                          config.formCreated === true && 
                          config.formUrl && config.formUrl.trim();
    
    // Step 3: å…¬é–‹çŠ¶æ…‹ã®ç¢ºèª
    const step3Complete = config.appPublished === true;
    
    return {
      step1: step1Complete,
      step2: step2Complete,
      step3: step3Complete,
      isPublished: step3Complete
    };
  } catch (error) {
    console.warn('âŒ configJsonã®è§£æã«å¤±æ•—:', error);
    return { step1: false, step2: false, step3: false, isPublished: false };
  }
}

// Update step indicators - æœ€é©åŒ–ç‰ˆï¼ˆãƒãƒƒãƒDOMæ›´æ–°ï¼‰
function updateStepIndicators(currentStep, status = null) {
  const steps = [
    document.getElementById('step-1-indicator'),
    document.getElementById('step-2-indicator'),
    document.getElementById('step-3-indicator')
  ];

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ã‹ã‚‰å®Ÿéš›ã®å®Œäº†çŠ¶æ³ã‚’å–å¾—
  const completion = getStepCompletionFromConfig(status);
  logDebug('ğŸ“Š Step completion from database:', completion);

  // DOMæ›´æ–°ã‚’ãƒãƒƒãƒåŒ–ã™ã‚‹ãŸã‚ã®è¨­å®šé…åˆ—ã‚’ä½œæˆ
  const updates = [];
  
  steps.forEach((step, index) => {
    if (!step) return;
    
    const stepNumber = index + 1;
    const circle = step.querySelector('div');
    const text = step.querySelector('span');

    // æ—¢å­˜ã®ãƒãƒƒã‚¸ã‚’å‰Šé™¤ï¼ˆæœ€é©åŒ–ï¼‰
    const existingBadge = step.querySelector('.publication-badge');
    if (existingBadge) {
      existingBadge.remove();
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ã«åŸºã¥ãå®Œäº†åˆ¤å®š
    const isStepComplete = completion[`step${stepNumber}`];
    
    // æ›´æ–°æƒ…å ±ã‚’é…åˆ—ã«è¿½åŠ ï¼ˆå®Ÿéš›ã®DOMæ›´æ–°ã¯å¾Œã§ä¸€æ‹¬å®Ÿè¡Œï¼‰
    updates.push({
      circle,
      text,
      stepNumber,
      isStepComplete,
      isCurrentStep: stepNumber === currentStep
    });
  });
  
  // ãƒãƒƒãƒDOMæ›´æ–°å®Ÿè¡Œï¼ˆãƒªãƒ•ãƒ­ãƒ¼ã‚’æœ€å°åŒ–ï¼‰
  requestAnimationFrame(() => {
    executeBatchStepUpdates(updates);
    // é€²è¡ŒçŠ¶æ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ›´æ–°ï¼ˆåŒã˜ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§å®Ÿè¡Œï¼‰
    updateProgressMessage(currentStep, status, completion);
  });
}

// ãƒãƒƒãƒDOMæ›´æ–°ã®å®Ÿè¡Œï¼ˆæœ€é©åŒ–ã•ã‚ŒãŸDOMæ“ä½œï¼‰
function executeBatchStepUpdates(updates) {
  const styleConfigs = {
    completed: {
      circleClass: 'w-6 h-6 bg-green-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all',
      circleContent: 'âœ“',
      textClasses: { remove: ['text-gray-500', 'text-cyan-400'], add: ['text-green-400', 'font-medium'] }
    },
    current: {
      circleClass: 'w-6 h-6 bg-cyan-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all ring-2 ring-cyan-400 ring-offset-2 ring-offset-gray-900 animate-pulse',
      textClasses: { remove: ['text-gray-500', 'text-green-400'], add: ['text-cyan-400', 'font-bold'] }
    },
    pending: {
      circleClass: 'w-6 h-6 bg-gray-700 text-gray-500 rounded-full flex items-center justify-center font-bold text-xs transition-all border border-gray-600',
      textClasses: { remove: ['text-white', 'text-green-400', 'text-cyan-400', 'font-bold', 'font-medium'], add: ['text-gray-500'] }
    }
  };

  updates.forEach(({ circle, text, stepNumber, isStepComplete, isCurrentStep }) => {
    let config;
    
    if (isStepComplete) {
      config = styleConfigs.completed;
    } else if (isCurrentStep) {
      config = styleConfigs.current;
    } else {
      config = styleConfigs.pending;
    }

    // Circleè¦ç´ ã®æ›´æ–°
    if (circle) {
      circle.className = config.circleClass;
      circle.innerHTML = config.circleContent || stepNumber;
    }

    // Textè¦ç´ ã®æ›´æ–°ï¼ˆã‚¯ãƒ©ã‚¹æ“ä½œã®æœ€é©åŒ–ï¼‰
    if (text && config.textClasses) {
      text.classList.remove(...config.textClasses.remove);
      text.classList.add(...config.textClasses.add);
    }
  });
}

function updateProgressMessage(currentStep, status = null, completion = null) {
  const messageElement = document.getElementById('progress-message');
  if (!messageElement) return;
  
  // completionãŒæ¸¡ã•ã‚Œã¦ã„ãªã„å ´åˆã¯å–å¾—
  if (!completion) {
    completion = getStepCompletionFromConfig(status);
  }
  
  // æ”¹å–„ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
  const messageData = getEnhancedProgressMessage(currentStep, completion, status);
  
  messageElement.textContent = messageData.message;
  messageElement.className = `text-sm ${messageData.colorClass} font-medium transition-colors duration-300`;
}

// å¼·åŒ–ã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç”Ÿæˆ
function getEnhancedProgressMessage(currentStep, completion, status) {
  const messageConfigs = {
    1: {
      completed: {
        message: 'âœ… ãƒ‡ãƒ¼ã‚¿æº–å‚™å®Œäº†ï¼šãƒ•ã‚©ãƒ¼ãƒ ãƒ»ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãŒåˆ©ç”¨å¯èƒ½ã§ã™',
        colorClass: 'text-green-400'
      },
      inProgress: {
        message: 'ğŸ“‹ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆè‡ªå‹•ï¼‰ã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’é¸æŠ',
        colorClass: 'text-cyan-400'
      }
    },
    2: {
      completed: {
        message: 'âœ… ã‚·ãƒ¼ãƒˆè¨­å®šå®Œäº†ï¼šå›ç­”ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºæº–å‚™ãŒã§ãã¾ã—ãŸ',
        colorClass: 'text-green-400'  
      },
      inProgress: {
        message: 'âš™ï¸ ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ã€è¡¨ç¤ºã™ã‚‹åˆ—ï¼ˆè³ªå•ãƒ»å›ç­”ãªã©ï¼‰ã‚’è¨­å®šã—ã¦ãã ã•ã„',
        colorClass: 'text-yellow-400'
      }
    },
    3: {
      published: {
        message: 'ğŸ‰ ãƒœãƒ¼ãƒ‰å…¬é–‹ä¸­ï¼šå‚åŠ è€…ãŒå›ç­”ã‚’æŠ•ç¨¿ãƒ»é–²è¦§ã§ãã¾ã™',
        colorClass: 'text-green-400'
      },
      readyToPublish: {
        message: 'ğŸš€ å…¬é–‹æº–å‚™å®Œäº†ï¼šã€Œãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã€ã§å‚åŠ è€…ã«å…±æœ‰ã—ã¾ã—ã‚‡ã†',
        colorClass: 'text-purple-400'
      },
      needsConfiguration: {
        message: 'ğŸ”§ åˆ—è¨­å®šã‚’å®Œäº†ã—ã¦ã‹ã‚‰å…¬é–‹ã—ã¦ãã ã•ã„',
        colorClass: 'text-orange-400'
      }
    }
  };
  
  // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®çŠ¶æ…‹åˆ¤å®šã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é¸æŠ
  switch (currentStep) {
    case 1:
      return completion.step1 ? 
        messageConfigs[1].completed : 
        messageConfigs[1].inProgress;
        
    case 2:
      return completion.step2 ? 
        messageConfigs[2].completed : 
        messageConfigs[2].inProgress;
        
    case 3:
      if (completion.isPublished) {
        return messageConfigs[3].published;
      } else if (completion.step2) {
        return messageConfigs[3].readyToPublish;
      } else {
        return messageConfigs[3].needsConfiguration;
      }
      
    default:
      return {
        message: 'ğŸ‰ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ï¼šStudyQuestã‚’ãŠæ¥½ã—ã¿ãã ã•ã„ï¼',
        colorClass: 'text-green-400'
      };
  }
}

// ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ç”¨ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç®¡ç†
let footerUpdateTimeout = null;

// Update footer and guidance text (with debounce)
function updateFooterAndGuidance(status) {
  // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼šçŸ­æ™‚é–“ã®é€£ç¶šå‘¼ã³å‡ºã—ã‚’åˆ¶å¾¡
  clearTimeout(footerUpdateTimeout);
  footerUpdateTimeout = setTimeout(() => {
    updateFooterAndGuidanceImmediate(status);
  }, 150); // 150msé…å»¶
}

// å®Ÿéš›ã®ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°å‡¦ç†
function updateFooterAndGuidanceImmediate(status) {
  console.group('ğŸ¦¶ updateFooterAndGuidance');
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('âŒ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }

  // Use normalized publication state from status object with additional validation
  const isPublished = status._normalized?.isPublished || false;
  const viewUrl = status._normalized?.viewUrl;
  
  // Additional strict check: ensure appPublished is explicitly true
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('âŒ Failed to parse configJson for publication check:', configError);
      explicitAppPublished = false;
    }
  }
  
  // Final publication decision: both normalized and explicit checks must agree
  const finalIsPublished = isPublished && explicitAppPublished;
  
  // æœ¬ç•ªç’°å¢ƒã§ã¯è©³ç´°ãƒ­ã‚°ã‚’å‰Šæ¸›
  if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('ğŸ” Enhanced publication check:', {
      'normalized isPublished': isPublished,
      'explicit appPublished': explicitAppPublished,
      'final decision': finalIsPublished,
      'publish reason': status._normalized?.publishReason,
      'normalized viewUrl': viewUrl,
      'has valid viewUrl': status._normalized?.hasValidViewUrl,
      'will show footer': finalIsPublished
    });
  } else {
    console.log(`ğŸ” Publication check: ${finalIsPublished ? 'å…¬é–‹ä¸­' : 'éå…¬é–‹'}`);
  }

  // Show footer if published (with strict validation)
  if (finalIsPublished) {
    footer.classList.remove('hidden');
    
    // Update board URL using our generated viewUrl (if available)
    const boardUrlInput = document.getElementById('board-url');
    const viewBoardLink = document.getElementById('view-board-link');
    
    if (boardUrlInput) {
      boardUrlInput.value = viewUrl || 'URLç”Ÿæˆä¸­...';
      console.log('ğŸ“ Board URL input updated:', viewUrl || 'URL generation pending');
    }
    if (viewBoardLink && viewUrl) {
      viewBoardLink.href = viewUrl;
      console.log('ğŸ”— View board link updated:', viewUrl);
    } else if (viewBoardLink) {
      viewBoardLink.removeAttribute('href');
      console.log('ğŸ”— View board link cleared - no URL available');
    }
    
    // Update topic text
    updateTopicText(status);
    
    guidanceText.textContent = 'å›ç­”ãƒœãƒ¼ãƒ‰ã¯ç¾åœ¨å…¬é–‹ä¸­ã§ã™ã€‚';
  } else {
    footer.classList.add('hidden');
    console.log('âŒ Footer hidden - board not published');
    
    // Update guidance based on setup step
    updateGuidanceForStep(status.setupStep || 1, guidanceText);
  }
  
  console.groupEnd();
  
  // è‡ªå‹•åœæ­¢é€šçŸ¥ã®è¡¨ç¤ºãƒã‚§ãƒƒã‚¯
  checkAndShowAutoStopNotification(status);
  
  adjustLayout();
}

// Update UI for selected sheet
function updateUIForSelectedSheet() {
  var hasSelection = selectedSheet && selectedSheet.trim() !== '';
  
  // Update step indicators based on server-provided setupStep
  const currentStep = currentStatus.setupStep || 1;
  updateStepIndicators(currentStep);
  
  // Enable/disable configuration section
  var configSection = document.getElementById('config-section');
  if (configSection) {
    if (hasSelection) {
      configSection.classList.remove('opacity-50', 'pointer-events-none');
      
      // é˜²å¾¡çš„ãƒ­ã‚¸ãƒƒã‚¯: config-areaãŒç¢ºå®Ÿã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
      var configArea = document.getElementById('config-area');
      if (configArea) {
        configArea.classList.remove('hidden');
        console.log('ğŸ›¡ï¸ updateUIForSelectedSheet: Config area shown defensively');
      }
    } else {
      configSection.classList.add('opacity-50', 'pointer-events-none');
    }
  }
  
  // Update guidance text
  var guidanceText = document.getElementById('guidance-text');
  if (guidanceText) {
    if (hasSelection) {
      guidanceText.textContent = 'ã‚¹ãƒ†ãƒƒãƒ—3: åˆ—ã‚’è¨­å®šã—ã¦ãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã—ã¾ã—ã‚‡ã†';
    } else {
      guidanceText.textContent = 'ã‚¹ãƒ†ãƒƒãƒ—2: è¡¨ç¤ºã—ãŸã„ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚';
    }
  }

  // Toggle placeholder visibility
  var configPlaceholder = document.getElementById('config-placeholder');
  if (configPlaceholder) {
    if (hasSelection) {
      configPlaceholder.classList.add('hidden');
    } else {
      configPlaceholder.classList.remove('hidden');
    }
  }
}

// Update topic text in footer
function updateTopicText(status) {
  const topicTextElement = document.getElementById('current-topic-text');
  const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
  
  if (!topicTextElement) return;

  let topic = 'ï¼ˆå•é¡Œæ–‡æœªè¨­å®šï¼‰';
  // ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªconfigå–å¾—
  let cfg = status.config || {};
  
  // userInfo.configJsonã‹ã‚‰ã‚‚æƒ…å ±ã‚’å–å¾—
  if (status.userInfo?.configJson) {
    try {
      const fullConfig = JSON.parse(status.userInfo.configJson);
      cfg = { ...cfg, ...fullConfig };
    } catch (e) {
      console.warn('Failed to parse userInfo.configJson:', e);
    }
  }

  if (status.customFormInfo && status.customFormInfo.mainQuestion) {
    topic = status.customFormInfo.mainQuestion;
  } else if (cfg.opinionHeader) {
    topic = cfg.opinionHeader;
  } else {
    const sheetName = cfg.publishedSheetName || status.publishedSheetName;
    if (sheetName) {
      if (status.userInfo?.configJson) {
        try {
          const fullCfg = JSON.parse(status.userInfo.configJson);
          const sheetCfg = fullCfg['sheet_' + (sheetName || '')] || {};
          
          // guessedConfigå†…ã®opinionHeaderã‚’å„ªå…ˆ
          if (sheetCfg.guessedConfig && sheetCfg.guessedConfig.opinionHeader) {
            topic = sheetCfg.guessedConfig.opinionHeader;
          } else if (sheetCfg.opinionHeader) {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›´æ¥ã®opinionHeader
            topic = sheetCfg.opinionHeader;
          } else {
            // ã‚·ãƒ¼ãƒˆåã§ã¯ãªãã€é©åˆ‡ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            topic = 'ï¼ˆè³ªå•æ–‡ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼‰';
          }
        } catch (e) {
          // ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆç›´å¾Œã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ”¹å–„
          if (sheetName && fullCfg['sheet_' + (sheetName || '')]?.flowType === 'quickstart') {
            // ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆç”¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè³ªå•æ–‡ã‚’è¡¨ç¤º
            topic = 'ã‚ãªãŸã®è€ƒãˆã‚„æ°—ã¥ã„ãŸã“ã¨ã‚’æ•™ãˆã¦ãã ã•ã„';
          } else {
            topic = 'ï¼ˆè³ªå•æ–‡ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼‰';
          }
        }
      } else {
        // ã‚·ãƒ¼ãƒˆåã‚’ãã®ã¾ã¾è¡¨ç¤ºã›ãšã€é©åˆ‡ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        topic = 'ï¼ˆè³ªå•æ–‡ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼‰';
      }
    }
  }

  topicTextElement.textContent = topic;
  
  // äºˆå®šçµ‚äº†æ—¥æ™‚ã®æ›´æ–°
  if (scheduledEndTimeElement) {
    updateScheduledEndTime(cfg, scheduledEndTimeElement);
  }
}

// äºˆå®šçµ‚äº†æ—¥æ™‚ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateScheduledEndTime(config, element) {
  // è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ scheduledEndAt ã‚’å–å¾—ã‚’è©¦è¡Œ
  const scheduledEndAt = config.scheduledEndAt || 
                         config.scheduledEndTime ||  // å¤ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¨ã®äº’æ›æ€§
                         (window.lastStatusCache?.config?.scheduledEndAt) ||
                         (window.lastStatusCache?.config?.scheduledEndTime);
  
  // scheduledEndAtãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€publishedAt + autoStopMinutesã‹ã‚‰è¨ˆç®—
  let finalScheduledEndTime = scheduledEndAt;
  
  if (!finalScheduledEndTime && config.publishedAt && config.autoStopMinutes) {
    const publishedTime = new Date(config.publishedAt);
    const autoStopMs = config.autoStopMinutes * 60 * 1000;
    finalScheduledEndTime = new Date(publishedTime.getTime() + autoStopMs).toISOString();
    console.log('ğŸ• çµ‚äº†äºˆå®šæ™‚åˆ»ã‚’è¨ˆç®—ã—ã¾ã—ãŸ:', finalScheduledEndTime);
  }
  
  if (finalScheduledEndTime) {
    try {
      const endDate = new Date(finalScheduledEndTime);
      const formattedTime = endDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      // ç¾åœ¨æ™‚åˆ»ã¨ã®æ¯”è¼ƒ
      const now = new Date();
      const isOverdue = endDate < now;
      const timeRemaining = endDate.getTime() - now.getTime();
      const oneHourMs = 60 * 60 * 1000; // 1æ™‚é–“ã®ãƒŸãƒªç§’
      
      if (isOverdue) {
        element.textContent = `${formattedTime} (æœŸé™åˆ‡ã‚Œ)`;
        element.className = 'text-xs font-medium text-red-400';
      } else if (timeRemaining <= oneHourMs) {
        // 1æ™‚é–“ä»¥å†…ã®å ´åˆã¯è­¦å‘Šè¡¨ç¤º
        const minutesRemaining = Math.floor(timeRemaining / (60 * 1000));
        element.textContent = `${formattedTime} (æ®‹ã‚Š${minutesRemaining}åˆ†)`;
        element.className = 'text-xs font-medium text-red-400 animate-pulse';
        console.log('âš ï¸ æœŸé™ã¾ã§1æ™‚é–“ä»¥å†…ã§ã™:', minutesRemaining + 'åˆ†');
      } else {
        element.textContent = formattedTime;
        element.className = 'text-xs font-medium text-orange-400';
      }
    } catch (e) {
      element.textContent = 'è¨­å®šã‚¨ãƒ©ãƒ¼';
      element.className = 'text-xs font-medium text-gray-400';
    }
  } else {
    element.textContent = 'æœªè¨­å®š';
    element.className = 'text-xs font-medium text-gray-400';
  }
}

// Update guidance text for specific step
function updateGuidanceForStep(step, guidanceElement) {
  const messages = {
    1: 'ã‚¹ãƒ†ãƒƒãƒ—1: ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã¾ãŸã¯æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚',
    2: 'ã‚¹ãƒ†ãƒƒãƒ—2: è¡¨ç¤ºã—ãŸã„ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚',
    3: 'ã‚¹ãƒ†ãƒƒãƒ—3: åˆ—ã‚’è¨­å®šã—ã¦ãƒœãƒ¼ãƒ‰ã‚’å…¬é–‹ã—ã¾ã—ã‚‡ã†'
  };
  
  // å…¬é–‹çµ‚äº†å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—1ã§ã¯ã€æ˜ç¢ºã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å†é–‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
  if (step === 1) {
    guidanceElement.textContent = 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¦ãã ã•ã„';
  } else {
    guidanceElement.textContent = messages[step] || 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¦ãã ã•ã„';
  }
}

// è‡ªå‹•åœæ­¢é€šçŸ¥ã®è¡¨ç¤ºãƒã‚§ãƒƒã‚¯
function checkAndShowAutoStopNotification(status) {
  const notificationElement = document.getElementById('auto-stop-notification');
  const autoStoppedTimeElement = document.getElementById('auto-stopped-time');
  
  if (!notificationElement || !autoStoppedTimeElement) return;
  
  const config = status.config || {};
  
  // è‡ªå‹•åœæ­¢ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿é€šçŸ¥ã‚’è¡¨ç¤º
  if (config.autoStoppedAt && config.autoStopReason === 'scheduled_timeout') {
    console.log('ğŸ”” è‡ªå‹•åœæ­¢é€šçŸ¥ã‚’è¡¨ç¤ºã—ã¾ã™:', config.autoStoppedAt);
    
    // åœæ­¢æ™‚åˆ»ã‚’è¡¨ç¤º
    try {
      const stoppedDate = new Date(config.autoStoppedAt);
      const formattedTime = stoppedDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      autoStoppedTimeElement.textContent = formattedTime;
    } catch (e) {
      autoStoppedTimeElement.textContent = 'æ™‚åˆ»ä¸æ˜';
    }
    
    // é€šçŸ¥ã‚’è¡¨ç¤º
    notificationElement.classList.remove('hidden');
    
    // å†å…¬é–‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
    const republishBtn = document.getElementById('republish-after-auto-stop-btn');
    if (republishBtn) {
      // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
      republishBtn.replaceWith(republishBtn.cloneNode(true));
      
      // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
      const newRepublishBtn = document.getElementById('republish-after-auto-stop-btn');
      newRepublishBtn.addEventListener('click', function() {
        // Step 3ã«ç§»å‹•ã—ã¦å†å…¬é–‹ã‚’ä¿ƒã™
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // é€šçŸ¥ã‚’éè¡¨ç¤º
        notificationElement.classList.add('hidden');
        
        showMessage('è¡¨ç¤ºè¨­å®šã‚’ç¢ºèªã—ã¦å†å…¬é–‹ã—ã¦ãã ã•ã„', 'info');
      });
    }
  } else {
    // è‡ªå‹•åœæ­¢ã•ã‚Œã¦ã„ãªã„å ´åˆã¯é€šçŸ¥ã‚’éè¡¨ç¤º
    notificationElement.classList.add('hidden');
  }
}

// =============================================================================
// SECTION TOGGLE FUNCTIONALITY
// =============================================================================

// Toggle section expansion/collapse
// toggleSection function is now defined in adminPanel-framework.js.html

// Automatically collapse completed sections
function collapseCompletedSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`ğŸ“ Auto-collapsing completed step ${stepNumber}`);
  
  // Collapse the section
  section.classList.add('hidden');
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'false');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Automatically expand active section
function expandActiveSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`ğŸ“‚ Auto-expanding active step ${stepNumber}`);
  
  // Expand the section
  section.classList.remove('hidden');
  
  // Special handling for Step 3: ensure config-area is visible
  if (stepNumber === 3) {
    const configArea = document.getElementById('config-area');
    if (configArea && currentStatus && currentStatus.activeSheetName) {
      configArea.classList.remove('hidden');
      console.log(`ğŸ“‹ expandActiveSection: Config area shown for Step 3`);
    }
  }
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'true');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Manage section states based on current step (simplified - no visual effects)
function manageSectionStates(currentStep) {
  console.log(`ğŸ”„ Managing section states for step ${currentStep}`);
  
  // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ¶å¾¡
  for (let i = 1; i <= 3; i++) {
    const sectionId = `step${i}-content`;
    const section = document.getElementById(sectionId);
    
    if (i === currentStep) {
      // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—: å±•é–‹ã—ã¦æœ‰åŠ¹åŒ–
      expandActiveSection(i);
      
      // Step 3ã®ç‰¹åˆ¥å‡¦ç†: config-areaã®è¡¨ç¤º
      if (i === 3) {
        const configArea = document.getElementById('config-area');
        if (configArea && currentStatus && currentStatus.activeSheetName) {
          configArea.classList.remove('hidden');
          console.log(`ğŸ“‹ Step 3: Config area shown for sheet: ${currentStatus.activeSheetName}`);
        }
      }
      
      console.log(`ğŸ”„ Step ${i}: Active (current step)`);
    } else if (i < currentStep) {
      // å®Œäº†æ¸ˆã¿ã‚¹ãƒ†ãƒƒãƒ—: ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã ãŒã€å±•é–‹ã¯ä»»æ„
      if (section) {
        section.classList.add('opacity-90'); // å®Œäº†ã—ãŸçŠ¶æ…‹ã‚’è¦–è¦šçš„ã«ç¤ºã™
      }
      console.log(`âœ… Step ${i}: Completed (accessible)`);
    } else {
      // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—: Step 1ã®å ´åˆã¯pendingçŠ¶æ…‹ã§ã‚‚å…¨ã¦é–²è¦§å¯èƒ½
      if (currentStep === 1) {
        // Step 1ã§ã¯å…¨ã‚¹ãƒ†ãƒƒãƒ—ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆãƒ‡ãƒ¼ã‚¿ç¢ºèªã®ãŸã‚ï¼‰
        if (section) {
          section.classList.add('opacity-75'); // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦è»½ãè¡¨ç¤º
        }
        console.log(`â­ï¸ Step ${i}: Available for preview`);
      } else {
        // Step 2ä»¥é™ã§ã¯é †æ¬¡é–‹æ”¾
        if (section) {
          section.classList.add('opacity-50'); // æœªæ¥ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦è¡¨ç¤º
        }
        console.log(`â­ï¸ Step ${i}: Future step (available)`);
      }
    }
  }
}

// =============================================================================
// MODAL MANAGEMENT
// =============================================================================

// Show form configuration modal
// showFormConfigModal function is now defined in adminPanel-framework.js.html

// Hide form configuration modal
function hideFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.hideModal('form-config-modal');
    manageFocusForModal('form-config-modal', false);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      manageFocusForModal('form-config-modal', false);
    }
  }
}

// Override placeholder with actual function
if (typeof window !== 'undefined') {
  window.hideFormConfigModal = hideFormConfigModal;
}

// Show privacy modal
function showPrivacyModal(onContinue) {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('privacy-modal', true);
    
    // Set up continue handler
    const continueBtn = document.getElementById('privacy-modal-continue');
    if (continueBtn && onContinue) {
      continueBtn.onclick = onContinue;
    }
  }
}

// Override placeholder with actual function
if (typeof window !== 'undefined') {
  window.showPrivacyModal = showPrivacyModal;
}

// Hide privacy modal
// hidePrivacyModal function is now defined in adminPanel-framework.js.html

// Show digital citizenship modal
function showDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('digital-citizenship-modal', true);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('digital-citizenship-modal', false);
  }
}

// Show confirmation modal
function showConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  console.log('ğŸ” showConfirmationModal: è¦ç´ æ¤œç´¢å®Œäº†');
  
  if (modal && titleElement && messageElement && confirmBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // ç¢ºèªãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    confirmBtn.onclick = function() {
      console.log('âœ… ç¢ºèªãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
      hideConfirmationModal();
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('âŒ ç¢ºèªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
        }
      }
    };
    
    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        console.log('âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
        hideConfirmationModal();
      };
    }
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('confirmation-modal', true);
    console.log('âœ… ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ');
  } else {
    console.error('âŒ ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–ã®ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    if (window.confirm(`${title}\n\n${message}`)) {
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('âŒ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¢ºèªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
        }
      }
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('confirmation-modal', false);
  }
}

// =============================================================================
// DYNAMIC CONTENT UPDATES
// =============================================================================

// Update dynamic content when board is active
function updateDynamicContent(status) {
  // Enable buttons that require active state
  const buttons = [
    'open-spreadsheet-btn'
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = false;
      button.classList.remove('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update UI when no sheet is active
function updateUIForNoActiveSheet(status) {
  // Disable buttons that require active state
  const buttons = [
    // No form buttons to disable since we only support spreadsheets
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = true;
      button.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update existing user section
function updateExistingUserSection(status) {
  // Update any user-specific UI elements
  if (status.userInfo) {
    // Update user-specific elements here if needed
  }
}

// Update custom form info
function updateCustomFormInfo(status) {
  if (status.customFormInfo) {
    // Update form-related UI elements
    const formTitle = document.getElementById('form-title-display');
    const formQuestion = document.getElementById('form-question-display');
    
    if (formTitle) {
      formTitle.textContent = status.customFormInfo.title || 'ãƒ•ã‚©ãƒ¼ãƒ æœªä½œæˆ';
    }
    
    if (formQuestion) {
      formQuestion.textContent = status.customFormInfo.mainQuestion || '';
    }
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ URLè¡¨ç¤ºã®æ›´æ–°ï¼ˆconfigJsonã‹ã‚‰ç¢ºå®Ÿã«å–å¾—ï¼‰
  updateFormUrlDisplay(status);
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¡¨ç¤ºã‚’ç¢ºå®Ÿã«æ›´æ–°
function updateFormUrlDisplay(status = null) {
  const formUrlInput = document.getElementById('form-url-input');
  const formUrlSection = document.getElementById('form-url-section');
  const openFormLink = document.getElementById('open-form-url-link');

  if (!formUrlInput) return;

  // ç¾åœ¨ã®statusã®æœ€é©åŒ–ã•ã‚ŒãŸå–å¾—
  const currentStatusToUse = status || currentStatus;
  if (!currentStatusToUse || !currentStatusToUse.userInfo) {
    logWarn('âš ï¸ updateFormUrlDisplay: statusæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    return;
  }

  // æ–°ã—ã„çµ±ä¸€ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‹ã‚‰ãƒ•ã‚©ãƒ¼ãƒ URLã‚’å–å¾—
  const resourceUrls = getActiveResourceUrls(currentStatusToUse);
  const formUrl = resourceUrls.form;

  // UIæ›´æ–°ã®æœ€é©åŒ–
  if (formUrl) {
    updateFormUrlElements(formUrlInput, openFormLink, formUrl);
    handleFormUrlSectionVisibility(formUrlSection);
    logDebug('ğŸ”— FormURL UIæ›´æ–°å®Œäº†:', formUrl);
  } else {
    clearFormUrlElements(formUrlInput, formUrlSection);
    logDebug('ğŸ“­ FormURLæœªè¨­å®šã®ãŸã‚UIéè¡¨ç¤º');
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¦ç´ æ›´æ–°ã®æœ€é©åŒ–
function updateFormUrlElements(input, link, url) {
  input.value = url;
  if (link) {
    link.href = url;
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLè¦ç´ ã‚¯ãƒªã‚¢ã®æœ€é©åŒ–
function clearFormUrlElements(input, section) {
  input.value = '';
  if (section) {
    section.classList.add('hidden');
  }
}

// ãƒ•ã‚©ãƒ¼ãƒ URLã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºåˆ¶å¾¡ã®æœ€é©åŒ–
function handleFormUrlSectionVisibility(section) {
  if (!section) return;
  
  const formJustCreated = sessionStorage.getItem('form_just_created');
  if (formJustCreated === 'true') {
    section.classList.remove('hidden');
    logDebug('ğŸ†• æ–°è¦ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º');
    
    // ãƒ•ãƒ©ã‚°ã‚¯ãƒªã‚¢ã®æœ€é©åŒ–ï¼ˆã‚¿ã‚¤ãƒãƒ¼å‡¦ç†ï¼‰
    setTimeout(() => {
      sessionStorage.removeItem('form_just_created');
      logDebug('ğŸ§¹ ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆãƒ•ãƒ©ã‚°ã‚¯ãƒªã‚¢');
    }, 10000);
  } else {
    section.classList.add('hidden');
  }
}

// Check for auto-publish dialog
function checkAutoPublishDialog(status) {
  // Implementation for auto-publish dialog if needed
  if (status.needsAutoPublish) {
    // Show auto-publish confirmation
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// UI initialization is now handled in adminPanel-framework.js.html

// =============================================================================
// SHEET SELECTION FUNCTIONALITY  
// =============================================================================

// ã‚·ãƒ¼ãƒˆé¸æŠå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
let sheetSelectionInProgress = false;

// Handle sheet selection change (æœ€é©åŒ–ç‰ˆ)
function handleSheetSelectionChange(event) {
  const newSelectedSheet = event.target.value;

  // é‡è¤‡å®Ÿè¡Œé˜²æ­¢
  if (sheetSelectionInProgress) {
    console.log('ğŸ“Š Sheet selection already in progress, skipping...');
    return;
  }

  // Prevent redundant calls if the selected sheet hasn't actually changed
  if (newSelectedSheet === lastSelectedSheetName) {
    console.log('ğŸ“Š Sheet selection unchanged, skipping redundant processing.');
    return;
  }
  
  sheetSelectionInProgress = true;
  console.log('ğŸ“Š Sheet selection changed: ' + newSelectedSheet);
  
  try {
    // Update global selected sheet variable and last selected sheet
    selectedSheet = newSelectedSheet;
    lastSelectedSheetName = newSelectedSheet;
    
    if (newSelectedSheet) {
      console.log('ğŸ“‹ Loading config for sheet:', newSelectedSheet);

      // åŸºæœ¬æ¤œè¨¼
      if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
        console.error('ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
      }

      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã®åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦åˆ—é¸æŠã‚’æ›´æ–°
      loadConfigForSelected(newSelectedSheet, currentStatus.userInfo.spreadsheetId)
        .then(result => {
          console.log('âœ… ã‚·ãƒ¼ãƒˆè¨­å®šèª­ã¿è¾¼ã¿å®Œäº†:', result);
          updateUIForSelectedSheet();
        })
        .catch(error => {
          console.error('âŒ ã‚·ãƒ¼ãƒˆè¨­å®šèª­ã¿è¾¼ã¿å¤±æ•—:', error);
          showMessage('ã‚·ãƒ¼ãƒˆã®è¨­å®šèª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
          updateUIForSelectedSheet();
        })
        .finally(() => {
          // å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
          sheetSelectionInProgress = false;
        });
        
      // å³åº§ã«ã‚·ãƒ¼ãƒˆã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
      activateSelectedSheet(newSelectedSheet);
    } else {
      // ã‚·ãƒ¼ãƒˆé¸æŠãŒè§£é™¤ã•ã‚ŒãŸå ´åˆ
      clearColumnSelections();
      updateUIForSelectedSheet();
    }
  } catch (error) {
    console.error('âŒ Sheet selection error:', error);
  } finally {
    // å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ç¢ºå®Ÿã«ï¼‰
    sheetSelectionInProgress = false;
  }
}

// ã‚·ãƒ¼ãƒˆã‚’å³åº§ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã™ã‚‹é–¢æ•°
function activateSelectedSheet(sheetName) {
  if (!sheetName || !currentStatus || !currentStatus.userInfo) {
    console.warn('âš ï¸ ã‚·ãƒ¼ãƒˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã«å¿…è¦ãªæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    return;
  }

  console.log(`ğŸ¯ ã‚·ãƒ¼ãƒˆã‚’å³åº§ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–: ${sheetName}`);
  
  // ã‚µãƒ¼ãƒãƒ¼å´ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã‚’è¨­å®š
  runGasWithUserId('setActiveSheet', 'ã‚·ãƒ¼ãƒˆã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ä¸­...', sheetName)
    .then(response => {
      console.log('âœ… ã‚·ãƒ¼ãƒˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–å®Œäº†:', response);
      
      // currentStatusã‚’æ›´æ–°
      if (currentStatus.userInfo.configJson) {
        try {
          const config = JSON.parse(currentStatus.userInfo.configJson);
          config.publishedSheetName = sheetName;
          currentStatus.userInfo.configJson = JSON.stringify(config);
          currentStatus.activeSheetName = sheetName;
          
          // ã‚·ãƒ¼ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
          updateSheetSelectActiveIndicator(sheetName);
          
          console.log('âœ… ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹æ›´æ–°å®Œäº†');
        } catch (e) {
          console.warn('âš ï¸ configJsonæ›´æ–°ã«å¤±æ•—:', e);
        }
      }
    })
    .catch(error => {
      console.error('âŒ ã‚·ãƒ¼ãƒˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–å¤±æ•—:', error);
      showMessage('ã‚·ãƒ¼ãƒˆã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'warning');
    });
}

// ã‚·ãƒ¼ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤ºã‚’æ›´æ–°
function updateSheetSelectActiveIndicator(activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) return;
  
  // å…¨ã¦ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‹ã‚‰ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤ºã‚’å‰Šé™¤
  Array.from(select.options).forEach(option => {
    if (option.value && option.textContent.includes(' (ã‚¢ã‚¯ãƒ†ã‚£ãƒ–)')) {
      option.textContent = option.value;
      option.style.fontWeight = 'normal';
      option.style.color = '';
      option.className = '';
    }
  });
  
  // æ–°ã—ã„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆã«è¡¨ç¤ºã‚’è¿½åŠ 
  const activeOption = Array.from(select.options).find(option => option.value === activeSheetName);
  if (activeOption) {
    activeOption.textContent = `${activeSheetName} (ã‚¢ã‚¯ãƒ†ã‚£ãƒ–)`;
    activeOption.style.fontWeight = 'bold';
    activeOption.style.color = '#10b981';
    activeOption.className = 'active-sheet-option';
  }
}

// é‡è¤‡UIæ›´æ–°é˜²æ­¢ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
let lastUIUpdateSheet = null;
let uiUpdateCount = 0;

// æ–°ã—ã„é–¢æ•°: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆUIæ›´æ–°
function updateActiveSheetUI(sheetName) {
  // é‡è¤‡é˜²æ­¢: åŒã˜ã‚·ãƒ¼ãƒˆã«å¯¾ã™ã‚‹é€£ç¶šæ›´æ–°ã‚’åˆ¶é™
  if (lastUIUpdateSheet === sheetName && uiUpdateCount >= 2) {
    return; // é‡è¤‡æ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—
  }
  
  if (lastUIUpdateSheet !== sheetName) {
    uiUpdateCount = 0; // æ–°ã—ã„ã‚·ãƒ¼ãƒˆã®å ´åˆã¯ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
  }
  
  console.log('ğŸ”„ updateActiveSheetUI called with:', sheetName);
  
  const select = document.getElementById('sheet-select');
  if (!select) {
    console.warn('âš ï¸ Sheet select element not found');
    return;
  }
  
  // ã‚·ãƒ¼ãƒˆé¸æŠã‚’æ›´æ–°
  if (sheetName && select.value !== sheetName) {
    const normalizedSheetName = sheetName.trim();
    const availableOptions = Array.from(select.options);
    const matchingOption = availableOptions.find(option => option.value === normalizedSheetName);
    
    if (matchingOption) {
      select.value = normalizedSheetName;
      selectedSheet = normalizedSheetName;
      lastSelectedSheetName = normalizedSheetName;
      lastUIUpdateSheet = normalizedSheetName;
      uiUpdateCount++;
      console.log('âœ… Active sheet UI updated:', normalizedSheetName);
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤ºã‚‚æ›´æ–°
      updateSheetSelectActiveIndicator(normalizedSheetName);
      
      // UIçŠ¶æ…‹ã‚‚æ›´æ–°
      updateUIForSelectedSheet();
    } else {
      console.warn('âš ï¸ Sheet not found in select options:', normalizedSheetName);
    }
  }
}

// æ–°ã—ã„é–¢æ•°: ã‚·ãƒ¼ãƒˆé¸æŠã®å†åŒæœŸ
function refreshSheetSelection() {
  console.log('ğŸ”„ refreshSheetSelection called');
  
  // ç¾åœ¨ã®çŠ¶æ…‹ã‹ã‚‰ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’å–å¾—
  if (window.currentStatus && window.currentStatus.activeSheetName) {
    updateActiveSheetUI(window.currentStatus.activeSheetName);
  } else if (selectedSheet) {
    updateActiveSheetUI(selectedSheet);
  }
}

// åˆ—é¸æŠã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
function clearColumnSelections() {
  console.log('ğŸ§¹ åˆ—é¸æŠã‚’ã‚¯ãƒªã‚¢');
  
  const columnSelects = [
    'opinion-column',
    'name-column', 
    'reason-column',
    'class-column',
    'timestamp-column'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ --</option>';
      select.disabled = true;
    }
  });
}

// Load configuration for selected sheet - OPTIMIZED
function loadConfigForSelected(sheetName, spreadsheetId, retryCount = 0, maxRetries = 3) {
  console.log('ğŸ“‹ Loading config for: ' + sheetName);

  if (!spreadsheetId || !sheetName) {
    console.error('ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚');
    return Promise.reject(new Error('ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™'));
  }

  return new Promise((resolve, reject) => {

  // Check if fresh save protection is active - skip cache if so
  const timeSinceFreshSave = Date.now() - (window.freshSaveTimestamp || 0);
  const isFreshSaveActive = timeSinceFreshSave < 30000; // 30 seconds
  
    // Check if we already have sheet details from integrated API
    if (!isFreshSaveActive && currentStatus && currentStatus.sheetDetails && 
        currentStatus.activeSheetName === sheetName && currentStatus.sheetDetails.allHeaders && currentStatus.sheetDetails.allHeaders.length > 0) {
      console.log('âš¡ Using cached sheet details from integrated API');
      try {
        populateHeaderOptions(currentStatus.sheetDetails.allHeaders);
        console.log('âœ… Header options populated from cache');
        populateConfig(currentStatus.sheetDetails.guessedConfig);
        console.log('âœ… AI configuration applied from cache');
        resolve({ source: 'cache', headers: currentStatus.sheetDetails.allHeaders, config: currentStatus.sheetDetails.guessedConfig });
        return; // Early return - no API call needed
      } catch (error) {
        console.error('Error in cached config population:', error);
        // Fall through to API call if cache fails
      }
    }

  // Force fresh API call if fresh save protection is active or cache unavailable
  if (isFreshSaveActive) {
    console.log('ğŸ”„ Fresh save protection active - forcing API call for latest data');
  } else {
    console.log('ğŸ“ Making API call for sheet details:', sheetName);
  }
  
    runGasWithUserId('getSheetDetails', 'ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’å–å¾—ä¸­...', spreadsheetId, sheetName)
      .then(function(details) {
        console.log('âœ… Sheet details loaded via API:', details);
        
        // If headers are empty, and we have retries left, try again after a delay
        if (details && (!details.allHeaders || details.allHeaders.length === 0) && retryCount < maxRetries) {
          console.warn(`âš ï¸ No headers found for ${sheetName}. Retrying in 2 seconds... (Attempt ${retryCount + 1}/${maxRetries})`);
          showMessage(`ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’å†å–å¾—ä¸­... (${retryCount + 1}/${maxRetries})`, 'info');
          setTimeout(() => {
            loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
              .then(resolve)
              .catch(reject);
          }, 2000); // Retry after 2 seconds
          return;
        }

        try {
          populateHeaderOptions(details.allHeaders);
          console.log('âœ… Header options populated from API');
          populateConfig(details.guessedConfig);
          console.log('âœ… AI configuration applied from API');
          if (retryCount > 0) {
            showMessage('âœ… ã‚·ãƒ¼ãƒˆæƒ…å ±ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸï¼', 'success');
          }
          resolve({ source: 'api', headers: details.allHeaders, config: details.guessedConfig });
        } catch (error) {
          console.error('Error in API config population sequence:', error);
          showMessage('è¨­å®šã®é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
          reject(error);
        }
      })
      .catch(function(error) {
        console.error('Failed to load sheet config via API:', error);
        
        // ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º
        let errorMessage = 'ã‚·ãƒ¼ãƒˆè¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
        
        if (error && error.message) {
          if (error.message.includes('ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
            errorMessage = `æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ¼ãƒˆ "${sheetName}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`;
          } else if (error.message.includes('ãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
            errorMessage = `ã‚·ãƒ¼ãƒˆ "${sheetName}" ã®1è¡Œç›®ã«ãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`;
          } else if (error.message.includes('ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™')) {
            errorMessage = 'ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚';
          } else if (error.message.includes('SheetsService')) {
            errorMessage = 'Google Sheets APIã‚µãƒ¼ãƒ“ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚';
          } else {
            errorMessage = `ã‚¨ãƒ©ãƒ¼ã®è©³ç´°: ${error.message}`;
          }
        }
        
        showMessage(errorMessage, 'error');
        
        // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªãƒˆãƒ©ã‚¤ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æä¾›
        if (retryCount < maxRetries) {
          setTimeout(() => {
            const retryButton = document.createElement('button');
            retryButton.textContent = 'å†è©¦è¡Œ';
            retryButton.className = 'ml-2 px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
            retryButton.onclick = () => {
              retryButton.remove();
              loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            };
            
            const messageElement = document.querySelector('.message');
            if (messageElement) {
              messageElement.appendChild(retryButton);
            }
          }, 1000);
        } else {
          reject(error);
        }
      });
  }); // Promiseçµ‚äº†
}


// =============================================================================
// SETUP STATUS HANDLING FUNCTIONS
// =============================================================================

/**
 * userInfoã‹ã‚‰setupStatusã‚’å®‰å…¨ã«å–å¾—
 * @param {Object} userInfo - ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns {string} setupStatus ('pending', 'completed', 'error')
 */
function getSetupStatusFromUserInfo(userInfo) {
  try {
    if (!userInfo || !userInfo.configJson) {
      return 'pending'; // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒãªã„å ´åˆã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æœªå®Œäº†ã¨ã¿ãªã™
    }

    const config = typeof userInfo.configJson === 'string'
      ? JSON.parse(userInfo.configJson)
      : userInfo.configJson;

    // setupStatusãŒæ˜ç¤ºçš„ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
    if (config.setupStatus) {
      console.log('ğŸ”§ configJson setupStatus:', config.setupStatus);
      return config.setupStatus;
    }
    
    // setupStatusãŒãªã„å ´åˆã€ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰æ¨æ¸¬ï¼ˆå¾ªç’°å‚ç…§å›é¿ï¼‰
    // Note: ã“ã®æ¨æ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã¯å¾ªç’°å‚ç…§ã‚’é¿ã‘ã‚‹ãŸã‚ã€formUrlãƒ™ãƒ¼ã‚¹ã«å¤‰æ›´
    if (config.formCreated === true && config.formUrl && config.formUrl.trim()) {
      return 'completed';
    }
    
    return 'pending';
    
  } catch (error) {
    console.warn('getSetupStatusFromUserInfo JSONè§£æã‚¨ãƒ©ãƒ¼:', error.message);
    return 'pending'; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æœªå®Œäº†ã¨ã¿ãªã™
  }
}


/**
 * åˆæœŸè¡¨ç¤ºè¦ç´ ã‚’ã‚¯ãƒªã‚¢ã—ã¦é©åˆ‡ãªãƒ‰ãƒ¡ã‚¤ãƒ³è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ
 */
function clearInitialDisplayElements() {
  // åˆæœŸè¡¨ç¤ºã‚’éè¡¨ç¤ºã«ã—ã¦ã€é©åˆ‡ãªãƒ‰ãƒ¡ã‚¤ãƒ³è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ
  const initialContainer = document.getElementById('header-domain-initial');
  if (initialContainer) {
    initialContainer.style.display = 'none';
    console.log('âœ… åˆæœŸãƒ‰ãƒ¡ã‚¤ãƒ³è¡¨ç¤ºã‚’éè¡¨ç¤º');
  }
  
  // é©åˆ‡ãªãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’è¡¨ç¤º
  showAppropriateHeaderStatus();
  
  // æ—¢å­˜ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã®ã¿å‰Šé™¤
  const existingGuides = [
    document.getElementById('setup-pending-guide'),
    document.querySelector('.setup-guide')
  ];
  
  existingGuides.forEach(guide => {
    if (guide) {
      guide.remove();
      console.log('âœ… æ—¢å­˜ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã‚’å‰Šé™¤');
    }
  });
}

/**
 * ãƒ˜ãƒƒãƒ€ãƒ¼ã«é©åˆ‡ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚’è¨­å®š
 */
function showAppropriateHeaderStatus() {
  // ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸€è‡´è¡¨ç¤ºï¼ˆä»®ï¼‰ã‚’è¡¨ç¤º
  const domainMatch = document.getElementById('header-domain-match');
  const domainMismatch = document.getElementById('header-domain-mismatch');
  
  if (domainMatch && domainMismatch) {
    // ç¾åœ¨ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸€è‡´ã¨ã—ã¦è¡¨ç¤ºï¼ˆå®Ÿéš›ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯ã¯åˆ¥é€”å®Ÿè£…ï¼‰
    domainMatch.style.display = 'block';
    domainMismatch.style.display = 'none';
    
    // ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’é©åˆ‡ã«è¨­å®š
    const domainText = document.getElementById('header-domain-match-text');
    if (domainText) {
      domainText.textContent = 'naha-okinawa.ed.jp';
    }
    
    console.log('âœ… ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸€è‡´è¡¨ç¤ºã‚’æœ‰åŠ¹åŒ–');
  }
}

/**
 * ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—çŠ¶æ³ã«å¿œã˜ã¦ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ›´æ–°
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function updateButtonStatesForSetup(status) {
  // ã‚ˆã‚Šç©ã‚„ã‹ãªUIåˆ¶å¾¡ï¼ˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç„¡åŠ¹åŒ–ã§ã¯ãªãã€é©åˆ‡ãªã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ï¼‰

  // æœ€ä½é™ç„¡åŠ¹åŒ–ã™ã¹ãå…¬é–‹é–¢é€£ãƒœã‚¿ãƒ³ã®ã¿
  const criticalPublishButtons = [
    'save-publish-btn',
    'unpublish-board-btn'
  ];
  
  criticalPublishButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      // ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã®ã¿ç„¡åŠ¹åŒ–
      const hasSpreadsheet = status.userInfo && status.userInfo.spreadsheetId;
      const hasActiveSheet = status.activeSheetName;
      
      if (!hasSpreadsheet || !hasActiveSheet) {
        button.disabled = true;
        button.classList.add('opacity-75');
        button.title = 'å…ˆã«ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã¨ã‚·ãƒ¼ãƒˆã‚’è¨­å®šã—ã¦ãã ã•ã„';
      } else {
        button.disabled = false;
        button.classList.remove('opacity-75');
        button.title = '';
      }
    }
  });
  
  console.log('âœ… ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’é©åˆ‡ã«æ›´æ–°ã—ã¾ã—ãŸ');
}


/**
 * åŸºæœ¬çš„ãªé™çš„UIè¦ç´ ã®ã¿æ›´æ–°
 * @param {Object} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function updateBasicStaticUI(status) {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãªã©æœ€ä½é™ã®æƒ…å ±ã®ã¿æ›´æ–°
  if (status.userInfo) {
    // æ—¢å­˜ã®updateDatabaseInfoé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦é‡è¤‡ã‚’é¿ã‘ã‚‹
    updateDatabaseInfo(status);
  }
}

// Update system status display
/**
 * ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹URLã‚’å–å¾—ã—ã€çµ±ä¸€ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã™ã€‚
 * @param {object} status - æœ€æ–°ã®ã‚·ã‚¹ãƒ†ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns {object} - å„ãƒªã‚½ãƒ¼ã‚¹ã®URLã‚’æ ¼ç´ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function getActiveResourceUrls(status) {
  const urls = {
    spreadsheet: null,
    folder: null,
    form: null,
    editForm: null
  };

  if (!status || !status.userInfo) {
    console.log('getActiveResourceUrls: status or userInfo missing', status); // Gemini Debug
    return urls; // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒãªã‘ã‚Œã°ç©ºã®URLã‚’è¿”ã™
  }

  // 1. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆURLã®å–å¾— (userInfoç›´ä¸‹ã‹ã‚‰)
  urls.spreadsheet = status.userInfo.spreadsheetUrl || null;

  // 2. configJsonã®è§£æ (ä¸€åº¦ã ã‘å®Ÿè¡Œ)
  let config = {};
  if (status.userInfo.configJson) {
    try {
      config = typeof status.userInfo.configJson === 'string' 
        ? JSON.parse(status.userInfo.configJson) 
        : status.userInfo.configJson;
      console.log('getActiveResourceUrls: configJson parsed:', config); // Gemini Debug
    } catch (e) {
      console.warn("configJsonã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ", e);
    }
  }

  // 3. ãƒ•ã‚©ãƒ«ãƒ€URLã®å–å¾— (configJsonã‹ã‚‰ã€ã¾ãŸã¯folderId ã‹ã‚‰æ§‹ç¯‰)
  urls.folder = config.folderUrl || null;
  
  // ãƒ•ã‚©ãƒ«ãƒ€URLãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€folderIdã‹ã‚‰æ§‹ç¯‰ã‚’è©¦è¡Œ
  if (!urls.folder && config.folderId) {
    const safeFolderId = String(config.folderId || '');
    urls.folder = 'https://drive.google.com/drive/folders/' + safeFolderId;
    console.log('ğŸ“ Folder URL constructed from folderId:', urls.folder);
  }

  // 4. ãƒ•ã‚©ãƒ¼ãƒ URLã®å–å¾— (configJsonã‹ã‚‰ã€å…¬é–‹ã‚·ãƒ¼ãƒˆã‚’å„ªå…ˆ)
  const publishedSheetName = config.publishedSheetName;
  if (publishedSheetName) {
    const sheetConfig = config['sheet_' + String(publishedSheetName || '')];
    if (sheetConfig) {
      urls.form = sheetConfig.formUrl || urls.form;
      urls.editForm = sheetConfig.editFormUrl || urls.editForm;
    }
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒ URL
  if (!urls.form && config.formUrl) {
    urls.form = config.formUrl;
  }
  if (!urls.editForm && config.editFormUrl) {
    urls.editForm = config.editFormUrl;
  }

  return urls;
}

function updateSystemStatusDisplay(status) {
  console.log('--- Entering updateSystemStatusDisplay ---'); // Gemini Debug
  if (!status) return;

  // ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹URLã‚’ä¸€æ‹¬å–å¾—
  console.log('Calling getActiveResourceUrls...'); // Gemini Debug
  const resourceUrls = getActiveResourceUrls(status);
  console.log('resourceUrls received:', resourceUrls); // Gemini Debug

  // Update publish status
  const publishIndicator = document.getElementById('info-publish-indicator');
  const publishText = document.getElementById('info-publish-text');

  if (status.isPublished) {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-green-400';
    publishText.textContent = 'å…¬é–‹ä¸­';
  } else {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-gray-400';
    publishText.textContent = 'éå…¬é–‹';
  }

  // Update other status fields
  document.getElementById('info-published-sheet').textContent = status.sheetName || '-';
  document.getElementById('info-display-mode').textContent = status.displayMode || '-';
  document.getElementById('info-show-counts').textContent = status.showCounts ? 'è¡¨ç¤º' : 'éè¡¨ç¤º';

  // Enable resource buttons if URLs are available
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
  if (spreadsheetBtn) {
    spreadsheetBtn.disabled = !resourceUrls.spreadsheet;
    if (resourceUrls.spreadsheet) {
      spreadsheetBtn.onclick = () => window.open(resourceUrls.spreadsheet, '_blank');
      spreadsheetBtn.title = 'ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã';
    } else {
      spreadsheetBtn.title = 'ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆURLãŒæœªè¨­å®šã§ã™';
    }
  }

  // ãƒ•ã‚©ãƒ¼ãƒ ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹åŒ–
  const formBtn = document.getElementById('open-form-btn');
  if (formBtn) {
    formBtn.disabled = false;
    formBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    if (resourceUrls.form) {
      formBtn.onclick = () => window.open(resourceUrls.form, '_blank');
      formBtn.title = 'ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ã';
    } else {
      formBtn.onclick = () => showMessage('ãƒ•ã‚©ãƒ¼ãƒ URLãŒæœªè¨­å®šã§ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚', 'warning');
      formBtn.title = 'ãƒ•ã‚©ãƒ¼ãƒ URLãŒæœªè¨­å®šã§ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚';
    }
  }

  // Handle generic resource button in Step 1 (any resource)
  const resourceBtn = document.getElementById('add-resource-btn');
  if (resourceBtn) {
    const anyResourceUrl = resourceUrls.spreadsheet || resourceUrls.folder || resourceUrls.form || resourceUrls.editForm;
    resourceBtn.disabled = false;
    if (anyResourceUrl) {
      resourceBtn.onclick = () => window.open(anyResourceUrl, '_blank');
      resourceBtn.title = 'ãƒªã‚½ãƒ¼ã‚¹ã‚’é–‹ã';
    } else {
      resourceBtn.onclick = () => showMessage('ãƒªã‚½ãƒ¼ã‚¹URLãŒæœªè¨­å®šã§ã™', 'warning');
      resourceBtn.title = 'ãƒªã‚½ãƒ¼ã‚¹URLãŒæœªè¨­å®šã§ã™';
    }
  }

  // Handle new resource buttons
  console.log('resourceUrls:', resourceUrls); // Gemini Debug
  updateNewResourceButtons(resourceUrls);
}

// Navigate to specific step
// navigateToStep function is now defined in adminPanel-framework.js.html


// ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—çŠ¶æ³ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‹ã‚‰å–å¾—




// Validate configuration
function validateConfiguration() {
  if (!currentConfig || !currentConfig.columnMappings) return false;
  
  const mappings = currentConfig.columnMappings;
  const hasContent = Object.values(mappings).includes('content');
  const hasAuthor = Object.values(mappings).includes('author');
  
  return hasContent && hasAuthor;
}


// =============================================================================
// HISTORY MANAGEMENT FUNCTIONS
// =============================================================================

// å±¥æ­´ç®¡ç†ã®å®šæ•°
const HISTORY_STORAGE_KEY = 'answerBoardHistory';
const MAX_HISTORY_ITEMS = 50;

/**
 * å›ç­”ãƒœãƒ¼ãƒ‰ã®å±¥æ­´ã‚’ä¿å­˜
 * @param {Object} historyItem - ä¿å­˜ã™ã‚‹å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ 
 */
function saveToHistory(historyItem) {
  try {
    if (!historyItem || !historyItem.questionText) {
      logWarn('Invalid history item, skipping save');
      return;
    }

    const history = getHistoryFromStorage();
    
    // AIåˆ—åˆ¤å®šçµæœã‚’å«ã‚€æ‹¡å¼µã•ã‚ŒãŸå±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½œæˆ
    const newItem = {
      id: generateHistoryId(),
      timestamp: new Date().toISOString(),
      publishedAt: historyItem.publishedAt || new Date().toISOString(),
      publishedEndAt: historyItem.publishedEndAt || null,
      // æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: çµ‚äº†é–¢é€£
      endTime: historyItem.endTime || null, // å®Ÿéš›ã®çµ‚äº†æ—¥æ™‚ï¼ˆçµ‚äº†æ™‚ã«è¨˜éŒ²ï¼‰
      scheduledEndTime: historyItem.scheduledEndTime || null, // äºˆå®šçµ‚äº†æ—¥æ™‚
      questionText: historyItem.questionText,
      sheetName: historyItem.sheetName || '',
      answerCount: historyItem.answerCount || 0,
      reactionCount: historyItem.reactionCount || 0,
      config: historyItem.config || {},
      formUrl: historyItem.formUrl || '',
      spreadsheetUrl: historyItem.spreadsheetUrl || '',
      setupType: historyItem.setupType || 'unknown', // ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã€å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥
      isActive: historyItem.isActive || false, // ç¾åœ¨å…¬é–‹ä¸­ã‹ã©ã†ã‹
      displayMode: historyItem.displayMode || 'é€šå¸¸è¡¨ç¤º',
      countDisplay: historyItem.countDisplay || 'è¡¨ç¤º',
      status: historyItem.status || 'published',
      
      // AIåˆ—åˆ¤å®šçµæœã®ä¿å­˜ï¼ˆå¾©å…ƒæ™‚ã«å¿…è¦ï¼‰
      sheetDetails: {
        allHeaders: currentStatus?.sheetDetails?.allHeaders || [],
        guessedConfig: currentStatus?.sheetDetails?.guessedConfig || {},
        existingConfig: currentStatus?.sheetDetails?.existingConfig || {}
      },
      
      // å¾©å…ƒã«å¿…è¦ãªè¿½åŠ æƒ…å ±
      activeSheetName: currentStatus?.activeSheetName || historyItem.sheetName,
      spreadsheetId: currentStatus?.userInfo?.spreadsheetId || '',
      
      // ä¿å­˜æ™‚ç‚¹ã§ã®è¨­å®šå®Œäº†çŠ¶æ…‹
      configurationComplete: !!(currentStatus?.sheetDetails?.guessedConfig?.opinionHeader)
    };
    
    history.unshift(newItem);
    
    // æœ€å¤§æ•°ã‚’è¶…ãˆãŸå ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }
    
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    logDebug('Enhanced history saved:', newItem);
    
    // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã«åŒæœŸï¼ˆéåŒæœŸã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
    syncHistoryToServer(newItem).then(result => {
      if (result.status === 'error') {
        logWarn('Server sync failed after retries:', result.message);
        // ã‚µãƒ¼ãƒãƒ¼åŒæœŸå¤±æ•—ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if (typeof showMessage === 'function' && result.retryCount > 2) {
          showMessage('âš ï¸ ã‚µãƒ¼ãƒãƒ¼ã¸ã®åŒæœŸã«å¤±æ•—ã—ã¾ã—ãŸãŒã€ãƒ­ãƒ¼ã‚«ãƒ«ã«ã¯ä¿å­˜ã•ã‚Œã¾ã—ãŸ', 'warning');
        }
      } else {
        logDebug('Server sync completed successfully');
      }
    }).catch(error => {
      logError('Unexpected error in server sync:', error);
    });
    
    // UI ã‚’æ›´æ–°
    loadSimpleHistoryTable();
    
  } catch (error) {
    logWarn('Failed to save history:', error);
  }
}

/**
 * å±¥æ­´ã‚’ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã«åŒæœŸ
 * @param {Object} historyItem - åŒæœŸã™ã‚‹å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ 
 */
async function syncHistoryToServer(historyItem, retryCount = 0) {
  const MAX_RETRIES = 1; // 2â†’1ã«å‰Šæ¸›ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
  
  try {
    if (!historyItem || !historyItem.id) {
      logWarn('Invalid history item for server sync:', historyItem);
      return { status: 'error', message: 'Invalid history item' };
    }
    
    logDebug('Syncing history to server (attempt ' + (retryCount + 1) + '):', historyItem.questionText);
    
    // è»½é‡ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã§ã‚µãƒ¼ãƒãƒ¼åŒæœŸã‚’å®Ÿè¡Œ  
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Server sync timeout')), 15000); // 30sâ†’15sã«çŸ­ç¸®
    });
    
    const syncPromise = runGasWithUserId('saveHistoryToSheetAPI', false, historyItem);
    const response = await Promise.race([syncPromise, timeoutPromise]);
    
    if (response && response.status === 'success') {
      logDebug('History synced to server successfully');
      return { status: 'success', message: 'Server sync completed' };
    } else {
      const errorMsg = response?.message || 'Unknown server error';
      logWarn('Server history sync failed:', errorMsg);
      
      // ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯
      if (retryCount < MAX_RETRIES) {
        logDebug('Retrying server sync in 2 seconds...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        return await syncHistoryToServer(historyItem, retryCount + 1);
      }
      
      return { status: 'error', message: errorMsg, retryCount: retryCount + 1 };
    }
  } catch (error) {
    const errorMsg = error.message || 'Server sync failed';
    logWarn('Failed to sync history to server:', errorMsg);
    
    // ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯
    if (retryCount < MAX_RETRIES && !errorMsg.includes('timeout')) {
      logDebug('Retrying server sync due to error in 2 seconds...');
      await new Promise(resolve => setTimeout(resolve, 2000));
      return await syncHistoryToServer(historyItem, retryCount + 1);
    }
    
    return { status: 'error', message: errorMsg, retryCount: retryCount + 1 };
  }
}

/**
 * å±¥æ­´ã‚’ localStorage ã‹ã‚‰å–å¾—
 * @returns {Array} å±¥æ­´é…åˆ—
 */
function getHistoryFromStorage() {
  try {
    const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
    return historyJson ? JSON.parse(historyJson) : [];
  } catch (error) {
    logWarn('Failed to parse history from storage:', error);
    return [];
  }
}

/**
 * ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å±¥æ­´ã‚’çµ±åˆ
 * @returns {Promise<Array>} çµ±åˆã•ã‚ŒãŸå±¥æ­´é…åˆ—
 */
async function getMergedHistory() {
  try {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—ï¼ˆæ¤œè¨¼ä»˜ãï¼‰
    let localHistory = [];
    try {
      localHistory = getHistoryFromStorage();
      if (!Array.isArray(localHistory)) {
        logWarn('Local history is not an array, resetting to empty');
        localHistory = [];
      }
    } catch (localError) {
      logWarn('Failed to load local history:', localError);
      localHistory = [];
    }
    
    // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‹ã‚‰å–å¾—ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
    let serverHistory = [];
    try {
      logDebug('Loading server history...');
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Server history timeout')), 8000); // 15sâ†’8sã«çŸ­ç¸®
      });
      
      const historyPromise = runGasWithUserId('getHistoryFromServerAPI', false);
      const response = await Promise.race([historyPromise, timeoutPromise]);
      
      if (response && response.status === 'success') {
        if (Array.isArray(response.historyArray)) {
          serverHistory = response.historyArray.filter(item => item?.id); // è»½é‡æ¤œè¨¼
          if (serverHistory.length > 0) logDebug('Server history loaded:', serverHistory.length, 'items');
        } else {
          logWarn('Server response historyArray is not an array');
        }
      } else {
        logWarn('Server history response failed:', response?.message || 'Unknown error');
      }
    } catch (serverError) {
      if (serverError.message.includes('timeout')) {
        logWarn('Server history request timed out, using local only');
      } else {
        logWarn('Failed to load server history:', serverError.message);
      }
    }
    
    // è»½é‡çµ±åˆå‡¦ç†ï¼šIDé‡è¤‡ã‚’é™¤å»
    const mergedMap = new Map();
    let totalItems = 0;
    
    // ãƒ­ãƒ¼ã‚«ãƒ«å±¥æ­´ã‚’è¿½åŠ ï¼ˆè»½é‡æ¤œè¨¼ï¼‰
    for (const item of localHistory) {
      if (item?.id) {
        mergedMap.set(item.id, { ...item, source: 'local' });
        totalItems++;
      }
    }
    
    // ã‚µãƒ¼ãƒãƒ¼å±¥æ­´ã‚’è¿½åŠ ï¼ˆã‚µãƒ¼ãƒãƒ¼å´å„ªå…ˆï¼‰
    for (const item of serverHistory) {
      if (item?.id) {
        mergedMap.set(item.id, { ...item, source: 'server' });
        totalItems++;
      }
    }
    
    // è»½é‡ã‚½ãƒ¼ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç°¡ç•¥åŒ–ï¼‰
    const mergedArray = Array.from(mergedMap.values()).sort((a, b) => {
      const aTime = new Date(a.timestamp || a.publishedAt || a.createdAt || 0).getTime();
      const bTime = new Date(b.timestamp || b.publishedAt || b.createdAt || 0).getTime();
      return bTime - aTime; // é™é †
    });
    
    if (mergedArray.length > 0) {
      logDebug(`History merged: ${mergedArray.length} items (${localHistory.length} local, ${serverHistory.length} server)`);
    }
    
    return mergedArray;
  } catch (error) {
    logError('Critical error in getMergedHistory:', error);
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿ï¼ˆã•ã‚‰ã«å®‰å…¨ã«ï¼‰
    try {
      const fallbackHistory = getHistoryFromStorage();
      logDebug('Using fallback local history:', fallbackHistory.length, 'items');
      return Array.isArray(fallbackHistory) ? fallbackHistory : [];
    } catch (fallbackError) {
      logError('Even fallback failed:', fallbackError);
      return [];
    }
  }
}

/**
 * å±¥æ­´ç”¨ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ç”Ÿæˆ
 * @returns {string} ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
 */
function generateHistoryId() {
  return 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

/**
 * Draft session storage management functions
 */

// Draft session storage key
const DRAFT_SESSION_KEY = 'answerboard_draft_state';

/**
 * Save draft state to session storage
 * @param {Object} draftData - Draft form data
 */
function saveDraftToSession(draftData) {
  try {
    if (!draftData || !draftData.questionText) {
      logWarn('Invalid draft data, skipping session save');
      return;
    }

    // Create unique form identifier
    const formId = `${currentStatus?.userInfo?.spreadsheetId || 'unknown'}_${draftData.sheetName || selectedSheet || 'unknown'}`;
    
    const draftState = {
      formId,
      createdAt: new Date().toISOString(),
      questionText: draftData.questionText,
      sheetName: draftData.sheetName || selectedSheet,
      config: draftData.config || {},
      displayMode: draftData.displayMode || 'é€šå¸¸è¡¨ç¤º', // é€šå¸¸è¡¨ç¤º or åŒ¿åè¡¨ç¤º
      countDisplay: draftData.countDisplay || 'è¡¨ç¤º', // è¡¨ç¤º or éè¡¨ç¤º
      
      // AI column prediction results for recovery
      sheetDetails: {
        allHeaders: currentStatus?.sheetDetails?.allHeaders || [],
        guessedConfig: currentStatus?.sheetDetails?.guessedConfig || {},
        existingConfig: currentStatus?.sheetDetails?.existingConfig || {}
      },
      
      // Form configuration state
      spreadsheetId: currentStatus?.userInfo?.spreadsheetId || '',
      configurationComplete: !!(currentStatus?.sheetDetails?.guessedConfig?.opinionHeader),
      
      // Timestamp for draft management
      lastUpdated: new Date().toISOString()
    };
    
    sessionStorage.setItem(DRAFT_SESSION_KEY, JSON.stringify(draftState));
    logDebug('Draft saved to session storage:', draftState.questionText);
    
  } catch (error) {
    logWarn('Failed to save draft to session:', error);
  }
}

/**
 * Get draft state from session storage
 * @returns {Object|null} Draft state or null if not found
 */
function getDraftFromSession() {
  try {
    const draftJson = sessionStorage.getItem(DRAFT_SESSION_KEY);
    if (!draftJson) return null;
    
    const draftState = JSON.parse(draftJson);
    logDebug('Draft loaded from session storage:', draftState.questionText);
    return draftState;
    
  } catch (error) {
    logWarn('Failed to load draft from session:', error);
    return null;
  }
}

/**
 * Clear draft from session storage
 */
function clearDraftFromSession() {
  try {
    sessionStorage.removeItem(DRAFT_SESSION_KEY);
    logDebug('Draft cleared from session storage');
  } catch (error) {
    logWarn('Failed to clear draft from session:', error);
  }
}

/**
 * Check if draft exists in session storage
 * @returns {boolean} True if draft exists
 */
function hasDraftInSession() {
  try {
    return !!sessionStorage.getItem(DRAFT_SESSION_KEY);
  } catch (error) {
    logWarn('Failed to check draft in session:', error);
    return false;
  }
}

/**
 * Recover draft state from session storage on page load
 * @returns {Promise<boolean>} True if draft was recovered successfully
 */
async function recoverDraftFromSession() {
  try {
    const draftState = getDraftFromSession();
    if (!draftState) {
      logDebug('No draft found in session storage');
      return false;
    }
    
    logDebug('Attempting to recover draft from session:', draftState.questionText);
    
    // Show recovery notification
    showMessage('ä¸‹æ›¸ãã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...', 'info');
    
    // Restore basic form state
    if (draftState.sheetName) {
      selectedSheet = draftState.sheetName;
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        sheetSelect.value = draftState.sheetName;
      }
    }
    
    // Restore spreadsheet ID if available
    if (draftState.spreadsheetId && currentStatus?.userInfo) {
      currentStatus.userInfo.spreadsheetId = draftState.spreadsheetId;
    }
    
    // Restore sheet details and AI prediction results
    if (draftState.sheetDetails && currentStatus) {
      if (!currentStatus.sheetDetails) {
        currentStatus.sheetDetails = {};
      }
      
      currentStatus.sheetDetails.allHeaders = draftState.sheetDetails.allHeaders || [];
      currentStatus.sheetDetails.guessedConfig = draftState.sheetDetails.guessedConfig || {};
      currentStatus.sheetDetails.existingConfig = draftState.sheetDetails.existingConfig || {};
    }
    
    // Restore question text
    const questionInput = document.getElementById('question-input');
    if (questionInput && draftState.questionText) {
      questionInput.value = draftState.questionText;
    }
    
    // Restore display mode settings
    const anonymousCheckbox = document.getElementById('anonymous-mode');
    if (anonymousCheckbox) {
      anonymousCheckbox.checked = draftState.displayMode === 'åŒ¿åè¡¨ç¤º';
    }
    
    // Update UI to reflect recovered state
    if (draftState.configurationComplete) {
      // Show that AI column prediction is completed
      const currentStep = document.querySelector('[data-step="4"]');
      if (currentStep) {
        updateStepProgress(4, currentStatus);
      }
    }
    
    // Update any config panels if they exist
    if (draftState.config && Object.keys(draftState.config).length > 0) {
      updateConfigPanelUI(draftState.config);
    }
    
    // Show success message
    const ageMinutes = Math.floor((new Date() - new Date(draftState.createdAt)) / (1000 * 60));
    const ageText = ageMinutes < 1 ? 'ç›´å‰' : `${ageMinutes}åˆ†å‰`;
    showMessage(`ä¸‹æ›¸ãã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ${ageText}ã«ä½œæˆï¼‰`, 'success');
    
    logDebug('Draft recovered successfully from session storage');
    return true;
    
  } catch (error) {
    logError('Failed to recover draft from session:', error);
    showMessage('ä¸‹æ›¸ãã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
    return false;
  }
}

/**
 * Update config panel UI with recovered settings
 * @param {Object} config - Configuration object
 */
function updateConfigPanelUI(config) {
  try {
    // Update opinion header if available
    if (config.opinionHeader) {
      const opinionSelect = document.getElementById('opinion-header-select');
      if (opinionSelect) {
        opinionSelect.value = config.opinionHeader;
      }
    }
    
    // Update name header if available
    if (config.nameHeader) {
      const nameSelect = document.getElementById('name-header-select');
      if (nameSelect) {
        nameSelect.value = config.nameHeader;
      }
    }
    
    // Update reaction settings if available
    if (config.allowReactions !== undefined) {
      const reactionCheckbox = document.getElementById('allow-reactions');
      if (reactionCheckbox) {
        reactionCheckbox.checked = !!config.allowReactions;
      }
    }
    
    logDebug('Config panel UI updated with recovered settings');
    
  } catch (error) {
    logWarn('Failed to update config panel UI:', error);
  }
}

// æ—§æ¥ã®ã‚«ãƒ¼ãƒ‰å½¢å¼ã®å±¥æ­´è¡¨ç¤ºã¯å‰Šé™¤ - ç°¡å˜ãªãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã®ã¿ä½¿ç”¨

/**
 * ç°¡å˜ãªå±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¡¨ç¤ºï¼ˆæ–°å®Ÿè£…ï¼‰
 */

async function loadSimpleHistoryTable() {
  const tableBody = document.getElementById('history-table-body');
  
  if (!tableBody) {
    logWarn('History table body not found');
    return;
  }
  
  try {
    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºï¼ˆæ”¹å–„ã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ï¼‰
    tableBody.innerHTML = `
      <tr>
        <td colspan="4" class="px-3 py-6 text-center text-gray-500 text-sm">
          <div class="flex flex-col items-center justify-center">
            <div class="spinner mb-3"></div>
            <div>å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
            <div class="text-xs text-gray-600 mt-1">ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚µãƒ¼ãƒãƒ¼ã®å±¥æ­´ã‚’çµ±åˆã—ã¦ã„ã¾ã™</div>
          </div>
        </td>
      </tr>
    `;
    
    // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å±¥æ­´ã‚’å–å¾—ãƒ»çµ±åˆ
    const mergedHistory = await getMergedHistory();
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã‚¯ãƒªã‚¢
    tableBody.innerHTML = '';
    
    if (!Array.isArray(mergedHistory) || mergedHistory.length === 0) {
      // å±¥æ­´ãŒç©ºã®å ´åˆï¼ˆæ”¹å–„ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `
        <td colspan="4" class="px-3 py-8 text-center text-gray-500 text-sm">
          <div class="flex flex-col items-center">
            <div class="text-4xl mb-2">ğŸ“</div>
            <div class="font-medium mb-1">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>
            <div class="text-xs text-gray-600">ãƒ•ã‚©ãƒ¼ãƒ ã‚’å…¬é–‹ã™ã‚‹ã¨å±¥æ­´ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
          </div>
        </td>
      `;
      tableBody.appendChild(emptyRow);
      return;
    }
    
    // å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã¨ã—ã¦è¡¨ç¤ºï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
    let successCount = 0;
    let errorCount = 0;
    
    mergedHistory.forEach((item, index) => {
      try {
        if (!item || !item.id) {
          logWarn('Invalid history item at index', index, item);
          errorCount++;
          return;
        }
        
        const row = createHistoryTableRow(item, index);
        if (row) {
          tableBody.appendChild(row);
          successCount++;
        } else {
          errorCount++;
        }
      } catch (rowError) {
        logWarn('Failed to create row for history item at index', index, rowError);
        errorCount++;
      }
    });
    
    // çµ±è¨ˆæƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
    logDebug(`History table loaded: ${successCount} success, ${errorCount} errors`);
    
    if (errorCount > 0) {
      showMessage(`âš ï¸ ä¸€éƒ¨ã®å±¥æ­´é …ç›®ï¼ˆ${errorCount}ä»¶ï¼‰ã®è¡¨ç¤ºã«å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸ`, 'warning');
    }
    
    logDebug('History table loaded with', mergedHistory.length, 'items');
  } catch (error) {
    logError('Failed to load history table:', error);
    
    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ã¿ä½¿ç”¨
    const localHistory = getHistoryFromStorage();
    tableBody.innerHTML = '';
    
    if (localHistory.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `
        <td colspan="4" class="px-3 py-4 text-center text-gray-500 text-sm">
          å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ
        </td>
      `;
      tableBody.appendChild(emptyRow);
    } else {
      localHistory.forEach((item, index) => {
        const row = createHistoryTableRow(item, index);
        tableBody.appendChild(row);
      });
    }
  }
}

/**
 * å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã‚’ä½œæˆ
 * @param {Object} item - å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ 
 * @param {number} index - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {HTMLElement} ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œè¦ç´ 
 */
function createHistoryTableRow(item, index) {
  const row = document.createElement('tr');
  
  // å…¬é–‹ä¸­ã®é …ç›®ã¯ç·‘è‰²ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  const isActive = !!item.isActive;
  row.className = isActive 
    ? 'hover:bg-green-700/20 cursor-pointer transition-colors bg-green-900/10' 
    : 'hover:bg-gray-700/30 cursor-pointer transition-colors';
  
  row.onclick = () => selectHistoryItem(item.id);
  
  const formatDateTime = (dateString) => {
    if (!dateString) return '<span class="text-gray-500 text-xs">æœªè¨­å®š</span>';
    
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) {
        return '<span class="text-red-400 text-xs">ç„¡åŠ¹ãªæ—¥ä»˜</span>';
      }
      
      const now = new Date();
      const diffMs = now - date;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      
      let relativeTime = '';
      if (diffDays > 7) {
        // 1é€±é–“ä»¥ä¸Šå‰ã¯é€šå¸¸ã®æ—¥ä»˜è¡¨ç¤º
        relativeTime = date.toLocaleString('ja-JP', {
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit'
        });
      } else if (diffDays > 0) {
        relativeTime = `${diffDays}æ—¥å‰`;
      } else if (diffHours > 0) {
        relativeTime = `${diffHours}æ™‚é–“å‰`;
      } else if (diffMinutes > 0) {
        relativeTime = `${diffMinutes}åˆ†å‰`;
      } else {
        relativeTime = 'ãŸã£ãŸä»Š';
      }
      
      const fullDate = date.toLocaleString('ja-JP', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        weekday: 'short'
      });
      
      return `<span class="text-xs" title="${fullDate}">${relativeTime}</span>`;
    } catch (error) {
      return '<span class="text-red-400 text-xs">æ—¥ä»˜ã‚¨ãƒ©ãƒ¼</span>';
    }
  };
  
  // å›ç­”å½¢å¼ã®è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ”¹å–„ç‰ˆï¼‰
  const getAnswerFormatDisplay = (item) => {
    // 1. QuickStartã®å ´åˆã¯ç¢ºå®Ÿã«ãƒ†ã‚­ã‚¹ãƒˆã¨åˆ¤å®š
    if (item.setupType === 'quickstart') {
      return `<span class="text-green-400">ãƒ†ã‚­ã‚¹ãƒˆ</span>`;
    }
    
    // 2. setupType ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ
    if (item.setupType) {
      switch (item.setupType) {
        case 'external':
          return `<span class="text-orange-400">å¤–éƒ¨</span>`;
        case 'custom':
          // ã‚«ã‚¹ã‚¿ãƒ ã®å ´åˆã¯è©³ç´°è¨­å®šã‚’ç¢ºèªï¼ˆä¸‹è¨˜ã®åˆ¤å®šã«é€²ã‚€ï¼‰
          break;
      }
    }
    
    const config = item.config;
    if (!config) {
      // configãŒãªã„å ´åˆã‚‚ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æ‰±ã†ï¼ˆ"ä¸æ˜"ã‚’è¡¨ç¤ºã—ãªã„ï¼‰
      return `<span class="text-green-400">ãƒ†ã‚­ã‚¹ãƒˆ</span>`;
    }
    
    // 3. ãƒ•ã‚©ãƒ¼ãƒ è¨­å®šã‹ã‚‰åˆ¤å®š
    // è¤‡æ•°é¸æŠï¼ˆcheckboxï¼‰ã®åˆ¤å®š
    if (config.multipleChoice || 
        config.allowMultipleAnswers || 
        (config.formElements && config.formElements.some(elem => elem.type === 'checkbox'))) {
      return `<span class="text-purple-400">è¤‡æ•°</span>`;
    }
    
    // å˜ä¸€é¸æŠï¼ˆradio/selectï¼‰ã®åˆ¤å®š
    if (config.singleChoice || 
        config.choices || 
        config.options ||
        (config.formElements && config.formElements.some(elem => elem.type === 'radio' || elem.type === 'select'))) {
      return `<span class="text-blue-400">é¸æŠ</span>`;
    }
    
    // 4. è³ªå•æ–‡ã®å†…å®¹ã‹ã‚‰æ¨æ¸¬ï¼ˆAIãŒæ¨æ¸¬ã—ãŸå†…å®¹ï¼‰
    const questionText = item.questionText || '';
    if (questionText.includes('é¸æŠ') || questionText.includes('ã©ã‚Œ')) {
      if (questionText.includes('è¤‡æ•°') || questionText.includes('ã„ãã¤')) {
        return `<span class="text-purple-400">è¤‡æ•°</span>`;
      } else {
        return `<span class="text-blue-400">é¸æŠ</span>`;
      }
    }
    
    // 5. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šãƒ†ã‚­ã‚¹ãƒˆï¼ˆè‡ªç”±è¨˜è¿°ï¼‰
    return `<span class="text-green-400">ãƒ†ã‚­ã‚¹ãƒˆ</span>`;
  };
  
  // Visual indicators for display options
  const getDisplayModeIcon = (displayMode) => {
    return displayMode === 'åŒ¿åè¡¨ç¤º' ? 'ğŸ­' : 'ğŸ‘¥';
  };
  
  const getCountDisplayIcon = (countDisplay) => {
    return countDisplay === 'éè¡¨ç¤º' ? 'ğŸš«' : 'ğŸ“Š';
  };
  
  const getStatusIcon = (status, isActive) => {
    if (isActive && status === 'published') return 'ğŸŒ';
    if (status === 'ended') return 'â¹ï¸';
    if (status === 'draft') return 'ğŸ“';
    return 'ğŸŒ'; // default for published
  };
  
  // Helper functions for tooltip text descriptions
  const getStatusText = (status, isActive) => {
    if (isActive && status === 'published') return 'å…¬é–‹ä¸­';
    if (status === 'ended') return 'çµ‚äº†';
    if (status === 'draft') return 'ä¸‹æ›¸ã';
    return 'å…¬é–‹æ¸ˆã¿';
  };

  const getDisplayModeText = (displayMode) => {
    return displayMode === 'åŒ¿åè¡¨ç¤º' ? 'åŒ¿åè¡¨ç¤º' : 'é€šå¸¸è¡¨ç¤º';
  };

  const getCountDisplayText = (countDisplay) => {
    return countDisplay === 'éè¡¨ç¤º' ? 'ã‚«ã‚¦ãƒ³ãƒˆéè¡¨ç¤º' : 'ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º';
  };
  
  // Format display mode and count display as compact visual indicators
  const displayMode = item.displayMode || item.config?.displayMode || 'é€šå¸¸è¡¨ç¤º';
  const countDisplay = item.countDisplay || item.config?.countDisplay || 'è¡¨ç¤º';
  const status = item.status || item.config?.status || 'published';
  const displayModeIcon = getDisplayModeIcon(displayMode);
  const countDisplayIcon = getCountDisplayIcon(countDisplay);
  const statusIcon = getStatusIcon(status, isActive);
  
  // Combine visual indicators
  const visualIndicators = `${statusIcon} ${displayModeIcon} ${countDisplayIcon}`;

  // Enhanced question text display with truncation
  const questionText = item.questionText || 'ï¼ˆè³ªå•æ–‡æœªè¨­å®šï¼‰';
  const displayQuestionText = questionText.length > 40 
    ? questionText.substring(0, 40) + '...' 
    : questionText;
  
  // Sheet name display (if available)
  const sheetName = item.sheetName || '';
  const sheetDisplay = sheetName ? `<div class="text-xs text-gray-500 mt-1">ğŸ“Š ${escapeHtml(sheetName)}</div>` : '';
  
  // Create detailed tooltip text with better formatting
  const tooltipText = `è³ªå•: ${escapeHtml(questionText)}
çŠ¶æ…‹: ${getStatusText(status, isActive)}
è¡¨ç¤º: ${getDisplayModeText(displayMode)}
ã‚«ã‚¦ãƒ³ãƒˆ: ${getCountDisplayText(countDisplay)}
ã‚·ãƒ¼ãƒˆ: ${sheetName || 'æœªè¨­å®š'}
ä½œæˆ: ${item.createdAt ? new Date(item.createdAt).toLocaleString('ja-JP') : 'ä¸æ˜'}
å…¬é–‹: ${item.publishedAt ? new Date(item.publishedAt).toLocaleString('ja-JP') : 'æœªå…¬é–‹'}`;

  row.innerHTML = `
    <td class="px-3 py-2 text-xs text-gray-300">${formatDateTime(item.createdAt || item.timestamp)}</td>
    <td class="px-3 py-2 text-xs text-gray-300">${formatDateTime(item.publishedAt)}</td>
    <td class="px-3 py-2 text-xs text-gray-300" title="${escapeHtml(tooltipText)}" style="max-width: 250px;">
      <div class="flex items-start gap-2">
        <div class="flex-1 min-w-0">
          <div class="truncate leading-tight">${escapeHtml(displayQuestionText)}</div>
          ${sheetDisplay}
        </div>
        <div class="text-xs opacity-75 flex-shrink-0 flex gap-1">
          <span title="çŠ¶æ…‹: ${getStatusText(status, isActive)}">${statusIcon}</span>
          <span title="è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰: ${getDisplayModeText(displayMode)}">${displayModeIcon}</span>
          <span title="ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º: ${getCountDisplayText(countDisplay)}">${countDisplayIcon}</span>
        </div>
      </div>
    </td>
    <td class="px-3 py-2 text-xs text-center">${getAnswerFormatDisplay(item)}</td>
  `;
  
  return row;
}

/**
 * å±¥æ­´é¸æŠæ™‚ã®è‡ªå‹•ãƒ•ãƒ­ãƒ¼å‡¦ç†
 * @param {string} historyId - å±¥æ­´ID
 */
async function selectHistoryItem(historyId) {
  try {
    // çµ±åˆå±¥æ­´ã‹ã‚‰æ¤œç´¢ï¼ˆãƒ­ãƒ¼ã‚«ãƒ« + ã‚µãƒ¼ãƒãƒ¼ï¼‰
    const mergedHistory = await getMergedHistory();
    const item = mergedHistory.find(h => h.id === historyId);
    
    if (!item) {
      showMessage('å±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'error');
      return;
    }
    
    // å¾©å…ƒãƒ—ãƒ­ã‚»ã‚¹é–‹å§‹ã®é€šçŸ¥ã¨é€²æ—è¡¨ç¤º
    const progressSteps = [
      'ğŸ” å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’è§£æä¸­...',
      'ğŸ“Š AIåˆ—åˆ¤å®šçµæœã‚’èª­ã¿è¾¼ã¿ä¸­...',
      'âš™ï¸ è¨­å®šã‚’é©ç”¨ä¸­...',
      'âœ… èª­ã¿è¾¼ã¿å®Œäº†'
    ];
    
    let currentStep = 0;
    const showProgress = (message) => {
      showMessage(message, 'info', 2000);
    };
    
    showProgress(progressSteps[currentStep++]);
    
    // 1. ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’è¨­å®š
    if (item.sheetName && item.spreadsheetId) {
      selectedSheet = item.sheetName;
      
      // currentStatus ã«ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’è¨­å®š
      if (!currentStatus) {
        currentStatus = {};
      }
      if (!currentStatus.userInfo) {
        currentStatus.userInfo = {};
      }
      currentStatus.userInfo.spreadsheetId = item.spreadsheetId;
      currentStatus.activeSheetName = item.activeSheetName || item.sheetName;
      
      // sheet select UI ã‚’æ›´æ–°
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        sheetSelect.value = item.sheetName;
      }
    }
    
    // 2. AIåˆ—åˆ¤å®šçµæœã‚’å¾©å…ƒï¼ˆPromiseåŒ–ã§ç¢ºå®Ÿæ€§å‘ä¸Šï¼‰
    await new Promise(resolve => {
      setTimeout(() => {
        showProgress(progressSteps[currentStep++]); // AIåˆ—åˆ¤å®šçµæœã‚’å¾©å…ƒä¸­...
        
        if (item.sheetDetails) {
          if (!window.currentStatus) window.currentStatus = {};
          window.currentStatus.sheetDetails = {
            allHeaders: item.sheetDetails.allHeaders || [],
            guessedConfig: item.sheetDetails.guessedConfig || {},
            existingConfig: item.sheetDetails.existingConfig || {}
          };
          
          logDebug('Restored AI column prediction results:', window.currentStatus.sheetDetails);
          
          // 3. ãƒ˜ãƒƒãƒ€ãƒ¼é¸æŠè‚¢ã‚’è¨­å®š
          if (item.sheetDetails.allHeaders && item.sheetDetails.allHeaders.length > 0) {
            if (typeof populateHeaderOptions === 'function') {
              populateHeaderOptions(item.sheetDetails.allHeaders);
              console.log('âœ… Header options restored from history');
            } else {
              logWarn('populateHeaderOptions function not available');
            }
          }
          
          // 4. AIåˆ¤å®šè¨­å®šã‚’é©ç”¨
          if (item.sheetDetails.guessedConfig) {
            setTimeout(() => {
              if (typeof populateConfig === 'function') {
                populateConfig(item.sheetDetails.guessedConfig);
                console.log('âœ… AI configuration restored from history');
              } else {
                logWarn('populateConfig function not available');
              }
              resolve();
            }, 100);
          } else {
            resolve();
          }
        } else {
          resolve();
        }
      }, 500);
    });
    
    // 5. ãƒ•ã‚©ãƒ¼ãƒ è¨­å®šã‚’å¾©å…ƒï¼ˆæ”¹å–„ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¶å¾¡ï¼‰
    showProgress(progressSteps[currentStep++]); // è¨­å®šã‚’é©ç”¨ä¸­...
    
    if (item.config) {
      await new Promise(resolve => {
        setTimeout(() => {
          restoreConfigFromHistory(item.config);
          resolve();
        }, 200);
      });
    }
    
    // 6. UIçŠ¶æ…‹ã‚’Step 3ï¼ˆè¨­å®šå®Œäº†ï¼‰ã«æ›´æ–°
    const step3Section = document.getElementById('step3-content');
    if (step3Section) {
      step3Section.classList.remove('hidden');
      step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    // ã‚¹ãƒ†ãƒƒãƒ—ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’æ›´æ–°
    if (typeof updateStepIndicators === 'function') {
      updateStepIndicators(3);
    }
    if (typeof manageSectionStates === 'function') {
      manageSectionStates(3);
    }
    
    // è¨­å®šãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
    if (typeof updateConfigButtons === 'function') {
      updateConfigButtons();
    }
    
    // è¨­å®šå®Œäº†çŠ¶æ…‹ã‚’åæ˜ 
    if (item.configurationComplete && typeof updateUIForSelectedSheet === 'function') {
      updateUIForSelectedSheet();
    }
    
    // æœ€çµ‚å®Œäº†é€šçŸ¥ï¼ˆç¢ºå®Ÿãªå®Œäº†ã‚’ä¿è¨¼ï¼‰
    await new Promise(resolve => {
      setTimeout(() => {
        showProgress(progressSteps[currentStep++]); // å¾©å…ƒå®Œäº†
        setTimeout(() => {
          const truncatedQuestion = item.questionText && item.questionText.length > 50 
            ? item.questionText.substring(0, 50) + '...'
            : item.questionText || 'å±¥æ­´é …ç›®';
          showMessage(`ã€Œ${truncatedQuestion}ã€ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ`, 'success');
          resolve();
        }, 500);
      }, 300);
    });
    
  } catch (error) {
    logError('Failed to select history item:', error);
    
    // è©³ç´°ãªã‚¨ãƒ©ãƒ¼åˆ†æã¨éƒ¨åˆ†å¾©å…ƒã®è©¦è¡Œ
    let errorMessage = 'å±¥æ­´ã®é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ';
    let partiallyRestored = false;
    
    try {
      // éƒ¨åˆ†å¾©å…ƒã‚’è©¦è¡Œ
      const mergedHistory = await getMergedHistory();
      const item = mergedHistory.find(h => h.id === historyId);
      
      if (item) {
        // æœ€ä½é™ã®è¨­å®šå¾©å…ƒã‚’è©¦è¡Œ
        if (item.sheetName) {
          selectedSheet = item.sheetName;
          const sheetSelect = document.getElementById('sheet-select');
          if (sheetSelect) {
            sheetSelect.value = item.sheetName;
          }
          partiallyRestored = true;
        }
        
        if (item.config && item.config.opinionHeader) {
          const opinionSelect = document.getElementById('opinionHeader');
          if (opinionSelect) {
            opinionSelect.innerHTML = `<option value="${item.config.opinionHeader}">${item.config.opinionHeader}</option>`;
            opinionSelect.value = item.config.opinionHeader;
            partiallyRestored = true;
          }
        }
        
        if (partiallyRestored) {
          errorMessage = `ã€Œ${item.questionText}ã€ã®åŸºæœ¬è¨­å®šã®ã¿èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚AIåˆ—åˆ¤å®šã¯æ‰‹å‹•ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚`;
          showMessage(errorMessage, 'warning');
          
          // Step 2ã«ç§»å‹•ï¼ˆæ‰‹å‹•è¨­å®šã‚’ä¿ƒã™ï¼‰
          updateStepIndicators(2);
          manageSectionStates(2);
          return;
        }
      }
    } catch (partialError) {
      logWarn('Partial restoration also failed:', partialError);
    }
    
    // å®Œå…¨ãªå¤±æ•—æ™‚ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    if (error.message.includes('not found')) {
      errorMessage = 'æŒ‡å®šã•ã‚ŒãŸå±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚µãƒ¼ãƒãƒ¼ã¨ã®åŒæœŸã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚';
    } else if (error.message.includes('network') || error.message.includes('timeout')) {
      errorMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
    } else if (error.message.includes('permission')) {
      errorMessage = 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚';
    }
    
    showMessage(errorMessage, 'error');
  }
}

/**
 * å±¥æ­´ã‹ã‚‰è¨­å®šã‚’å¾©å…ƒ
 * @param {Object} config - è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function restoreConfigFromHistory(config) {
  try {
    logDebug('Restoring config from history:', config);
    
    // ãƒ•ã‚©ãƒ¼ãƒ è¨­å®šã®å¾©å…ƒï¼ˆãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
    const configMappings = [
      { configKey: 'opinionHeader', elementId: 'opinionHeader', label: 'Opinion Header' },
      { configKey: 'nameHeader', elementId: 'name-column', label: 'Name Column' },
      { configKey: 'classHeader', elementId: 'class-column', label: 'Class Column' },
      { configKey: 'reasonHeader', elementId: 'reason-column', label: 'Reason Column' }
    ];
    
    configMappings.forEach(({ configKey, elementId, label }) => {
      if (config[configKey]) {
        const element = document.getElementById(elementId);
        if (element) {
          element.value = config[configKey];
          logDebug(`âœ… ${label} restored:`, config[configKey]);
          
          // å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã¦é–¢é€£UIã‚’æ›´æ–°
          const event = new Event('change', { bubbles: true });
          element.dispatchEvent(event);
        } else {
          logWarn(`âš ï¸ Element not found for ${label} (${elementId})`);
        }
      }
    });
    
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å¾©å…ƒï¼ˆã‚¤ãƒ™ãƒ³ãƒˆä»˜ãï¼‰
    const checkboxMappings = [
      { configKey: 'showNames', elementId: 'show-names', label: 'Show Names' },
      { configKey: 'showCounts', elementId: 'show-counts', label: 'Show Counts' }
    ];
    
    checkboxMappings.forEach(({ configKey, elementId, label }) => {
      const checkbox = document.getElementById(elementId);
      if (checkbox) {
        const value = config[configKey] || false;
        checkbox.checked = value;
        logDebug(`âœ… ${label} restored:`, value);
        
        // å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
        const event = new Event('change', { bubbles: true });
        checkbox.dispatchEvent(event);
      } else {
        logWarn(`âš ï¸ Checkbox not found for ${label} (${elementId})`);
      }
    });
    
    // è¿½åŠ ã®è¨­å®šé …ç›®ã®å¾©å…ƒ
    if (config.displayMode) {
      const displayModeElements = document.querySelectorAll('input[name="displayMode"]');
      displayModeElements.forEach(radio => {
        if (radio.value === config.displayMode) {
          radio.checked = true;
          const event = new Event('change', { bubbles: true });
          radio.dispatchEvent(event);
        }
      });
      logDebug('âœ… Display mode restored:', config.displayMode);
    }
    
    if (config.countDisplay) {
      const countDisplayElements = document.querySelectorAll('input[name="countDisplay"]');
      countDisplayElements.forEach(radio => {
        if (radio.value === config.countDisplay) {
          radio.checked = true;
          const event = new Event('change', { bubbles: true });
          radio.dispatchEvent(event);
        }
      });
      logDebug('âœ… Count display restored:', config.countDisplay);
    }
    
    // è¨­å®šãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
    if (typeof updateConfigButtons === 'function') {
      updateConfigButtons();
      logDebug('âœ… Config buttons updated');
    }
    
    // UIçŠ¶æ…‹ã®å¼·åˆ¶æ›´æ–°
    setTimeout(() => {
      if (typeof validateConfiguration === 'function') {
        validateConfiguration();
      }
      logDebug('âœ… Configuration validation completed');
    }, 100);
    
  } catch (error) {
    logError('Failed to restore config from history:', error);
    showMessage('âš ï¸ è¨­å®šã®å¾©å…ƒã«ä¸€éƒ¨å¤±æ•—ã—ã¾ã—ãŸãŒã€å¯èƒ½ãªé …ç›®ã¯å¾©å…ƒã•ã‚Œã¾ã—ãŸ', 'warning');
  }
}

// createHistoryItemElementé–¢æ•°ã¯å‰Šé™¤ - ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã®createHistoryTableRowã‚’ä½¿ç”¨

/**
 * HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°
 * @param {string} text - ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
 * @returns {string} ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// æ—§æ¥ã®è¤‡é›‘ãªå±¥æ­´ç®¡ç†é–¢æ•°ç¾¤ã¯å‰Šé™¤ - selectHistoryItem()ã«ã‚ˆã‚‹è‡ªå‹•ãƒ•ãƒ­ãƒ¼ã®ã¿ä½¿ç”¨

// =============================================================================
// CONFIG JSON æ­£è¦åŒ–ãƒ»ä¿®å¾©ã‚·ã‚¹ãƒ†ãƒ 
// =============================================================================

/**
 * configJsonã®æ•´åˆæ€§ã‚’ç¢ºä¿ã—ã€çŸ›ç›¾ã—ãŸçŠ¶æ…‹ã‚’ä¿®å¾©ã™ã‚‹
 * @param {Object} config - ä¿®å¾©å¯¾è±¡ã®config
 * @param {Object} userInfo - ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
 * @return {Object} æ­£è¦åŒ–ã•ã‚ŒãŸconfig
 */
function normalizeConfigJson(config, userInfo) {
  if (!config || typeof config !== 'object') {
    console.warn('âš ï¸ normalizeConfigJson: ç„¡åŠ¹ãªconfigã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ');
    return config;
  }
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜ãƒ‡ãƒ¼ã‚¿ã®é‡è¤‡å‡¦ç†ã‚’é˜²æ­¢ï¼‰
  if (window.processCache && window.generateSimpleHash && window.isCacheValid) {
    const configHash = window.generateSimpleHash(config);
    const cacheEntry = window.processCache.configNormalization;
    
    if (window.isCacheValid(cacheEntry) && cacheEntry.dataHash === configHash) {
      console.log('ğŸš€ configJsonæ­£è¦åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰çµæœã‚’å–å¾—');
      return cacheEntry.data;
    }
  }
  
  // æœ¬ç•ªç’°å¢ƒã§ã¯è©³ç´°ãƒ­ã‚°ã‚’å‰Šæ¸›
  if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('ğŸ”§ configJsonæ­£è¦åŒ–é–‹å§‹:', {
      setupStatus: config.setupStatus,
      setupStep: config.setupStep,
      appPublished: config.appPublished,
      publishedSheetName: config.publishedSheetName
    });
  }
  
  // Step 1: publishedSheetNameä¿®å¾©
  config = fixPublishedSheetName(config);
  
  // Step 2: setupStepå†è¨ˆç®—ï¼ˆçµ±ä¸€é–¢æ•°ä½¿ç”¨ï¼‰
  // Note: setupStepã¯è¨ˆç®—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦å¸¸ã«å‹•çš„ã«ç®—å‡ºã•ã‚Œã€configJsonã«ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“
  
  // Step 3: ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ—è¨­å®šåŒæœŸ
  config = syncGlobalColumnSettings(config);
  
  // Step 4: å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è£œå®Œ
  config = ensureRequiredFields(config);
  
  // Step 5: å†—é•·ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‰Šé™¤
  config = removeRedundantFields(config);
  
  // æœ¬ç•ªç’°å¢ƒã§ã¯è©³ç´°ãƒ­ã‚°ã‚’å‰Šæ¸›
  if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('âœ… configJsonæ­£è¦åŒ–å®Œäº†:', {
      setupStatus: config.setupStatus,
      appPublished: config.appPublished,
      publishedSheetName: config.publishedSheetName
    });
  }
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
  if (window.processCache && window.generateSimpleHash) {
    const configHash = window.generateSimpleHash(config);
    const cacheEntry = window.processCache.configNormalization;
    cacheEntry.data = config;
    cacheEntry.dataHash = configHash;
    cacheEntry.timestamp = Date.now();
  }
  
  return config;
}

/**
 * å†—é•·ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‰Šé™¤ï¼ˆãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§å‘ä¸Šï¼‰
 * @param {Object} config - å¯¾è±¡config
 * @return {Object} ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚ŒãŸconfig
 */
function removeRedundantFields(config) {
  const cleanConfig = { ...config };
  
  // setupStepã¯è¨ˆç®—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ãŸã‚ã€ä¿å­˜æ¸ˆã¿ã®å€¤ã‚’å‰Šé™¤
  delete cleanConfig.setupStep;
  
  console.log('ğŸ§¹ å†—é•·ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‰Šé™¤: setupStep');
  
  return cleanConfig;
}

/**
 * ConfigJsonã®æ•´åˆæ€§æ¤œè¨¼æ©Ÿèƒ½ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å°‚ç”¨ï¼‰
 * @param {Object} config - æ¤œè¨¼å¯¾è±¡ã®config
 * @param {Object} userInfo - ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
 */
function validateConfigJsonIntegrity(config, userInfo) {
  if (!config || !userInfo) {
    console.warn('âš ï¸ æ•´åˆæ€§æ¤œè¨¼: ç„¡åŠ¹ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿');
    return;
  }
  
  const setupStatus = config.setupStatus || 'pending';
  const formCreated = !!config.formCreated;
  const appPublished = !!config.appPublished;
  const hasFormUrl = !!(config.formUrl && config.formUrl.trim());
  const hasPublishedSheet = !!(config.publishedSheetName && config.publishedSheetName.trim());
  const hasSpreadsheet = !!(userInfo.spreadsheetId && userInfo.spreadsheetId.trim());
  
  console.group('ğŸ” ConfigJsonæ•´åˆæ€§æ¤œè¨¼');
  
  // åŸºæœ¬çŠ¶æ…‹ã®è¡¨ç¤º
  console.log('ğŸ“Š ç¾åœ¨ã®çŠ¶æ…‹:', {
    setupStatus,
    formCreated,
    appPublished,
    hasFormUrl,
    hasPublishedSheet,
    hasSpreadsheet
  });
  
  // é‡è¦ãªä¸æ•´åˆã‚’æ¤œå‡º
  const issues = [];
  
  if (setupStatus === 'completed' && !formCreated) {
    issues.push('âŒ setupStatus=completedãªã®ã«formCreated=false');
  }
  
  if (formCreated && !hasFormUrl) {
    issues.push('âŒ formCreated=trueãªã®ã«formUrlãŒæœªè¨­å®š');
  }
  
  if (appPublished && !hasPublishedSheet) {
    issues.push('âŒ appPublished=trueãªã®ã«publishedSheetNameãŒæœªè¨­å®š');
  }
  
  if (!hasSpreadsheet && (setupStatus === 'completed' || formCreated || appPublished)) {
    issues.push('âŒ ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹æœªè¨­å®šãªã®ã«é«˜åº¦ãªè¨­å®šãŒæœ‰åŠ¹');
  }
  
  // setupStepãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã®è­¦å‘Š
  if (config.setupStep !== undefined) {
    issues.push('âš ï¸ setupStepãŒconfigJsonã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ï¼ˆå†—é•·ï¼‰');
  }
  
  // çµæœè¡¨ç¤º
  if (issues.length === 0) {
    console.log('âœ… æ•´åˆæ€§æ¤œè¨¼å®Œäº†: å•é¡Œãªã—');
  } else {
    console.warn('âš ï¸ æ•´åˆæ€§å•é¡Œæ¤œå‡º:', issues);
  }
  
  console.groupEnd();
}

/**
 * publishedSheetNameä¿®å¾©é–¢æ•°
 * @param {Object} config - ä¿®å¾©å¯¾è±¡ã®config
 * @return {Object} ä¿®å¾©ã•ã‚ŒãŸconfig
 */
function fixPublishedSheetName(config) {
  // publishedSheetNameãŒ'ãƒ•ã‚©ãƒ¼ãƒ ã®å›ç­” 1'ã®ã‚ˆã†ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåã®å ´åˆã‚‚ä¿®å¾©å¯¾è±¡
  const isDefaultSheetName = config.publishedSheetName === 'ãƒ•ã‚©ãƒ¼ãƒ ã®å›ç­” 1' || 
                            config.publishedSheetName?.startsWith('ãƒ•ã‚©ãƒ¼ãƒ ã®å›ç­”');
                            
  if ((!config.publishedSheetName || 
       config.publishedSheetName.trim() === '' || 
       isDefaultSheetName) && 
      config.publishedSpreadsheetId) {
    
    // AIåˆ—åˆ¤å®šçµæœã‹ã‚‰è³ªå•æ–‡ã‚’å–å¾—ã‚’è©¦è¡Œ
    if (currentStatus?.sheetDetails?.guessedConfig?.opinionHeader) {
      const questionText = currentStatus.sheetDetails.guessedConfig.opinionHeader;
      config.publishedSheetName = questionText;
      
      if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
        console.log('ğŸ”§ publishedSheetNameä¿®å¾© (AIåˆ—åˆ¤å®šçµæœä½¿ç”¨):', {
          å…ƒã®åå‰: config.publishedSheetName,
          æ–°ã—ã„åå‰: questionText
        });
      }
      return config;
    }
    
    // AIåˆ—åˆ¤å®šçµæœãŒç„¡ã„å ´åˆã¯å¾“æ¥ã®sheet_ã‚­ãƒ¼æ¤œç´¢
    const sheetKeys = Object.keys(config).filter(key => key.startsWith('sheet_'));
    
    if (sheetKeys.length > 0) {
      // æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚·ãƒ¼ãƒˆåã‚’ä½¿ç”¨
      const detectedSheetName = sheetKeys[0].replace('sheet_', '');
      config.publishedSheetName = detectedSheetName;
      
      if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
        console.log('ğŸ”§ publishedSheetNameä¿®å¾© (ã‚·ãƒ¼ãƒˆã‚­ãƒ¼ä½¿ç”¨):', {
          æ¤œå‡ºã•ã‚ŒãŸã‚·ãƒ¼ãƒˆå: detectedSheetName,
          åˆ©ç”¨å¯èƒ½ãªã‚·ãƒ¼ãƒˆè¨­å®š: sheetKeys
        });
      }
    }
  }
  
  return config;
}





/**
 * ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ—è¨­å®šã‚’æœ€æ–°ã®ã‚·ãƒ¼ãƒˆè¨­å®šã¨åŒæœŸ
 * @param {Object} config - åŒæœŸå¯¾è±¡ã®config
 * @return {Object} åŒæœŸã•ã‚ŒãŸconfig
 */
function syncGlobalColumnSettings(config) {
  if (!config.publishedSheetName) {
    return config; // ã‚·ãƒ¼ãƒˆåãŒä¸æ˜ãªå ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
  }
  
  const sheetConfigKey = 'sheet_' + String(config.publishedSheetName || '');
  const sheetConfig = config[sheetConfigKey];
  
  if (sheetConfig && typeof sheetConfig === 'object') {
    // ã‚·ãƒ¼ãƒˆå›ºæœ‰è¨­å®šã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«åŒæœŸ
    config.opinionHeader = sheetConfig.opinionHeader || config.opinionHeader || '';
    config.nameHeader = sheetConfig.nameHeader || config.nameHeader || '';
    config.reasonHeader = sheetConfig.reasonHeader || config.reasonHeader || '';
    config.classHeader = sheetConfig.classHeader || config.classHeader || '';
    config.timestampHeader = sheetConfig.timestampHeader || config.timestampHeader || '';
    
    // ãƒ•ã‚©ãƒ¼ãƒ URLåŒæœŸ - ã‚·ãƒ¼ãƒˆå›ºæœ‰ã®formUrlã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«åŒæœŸ
    if (sheetConfig.formUrl) {
      config.formUrl = sheetConfig.formUrl;
      console.log('ğŸ”— ãƒ•ã‚©ãƒ¼ãƒ URLåŒæœŸ:', {
        ã‚·ãƒ¼ãƒˆå: config.publishedSheetName,
        ãƒ•ã‚©ãƒ¼ãƒ URL: config.formUrl
      });
    }
    
    console.log('ğŸ”§ ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ—è¨­å®šåŒæœŸå®Œäº†:', {
      ã‚·ãƒ¼ãƒˆå: config.publishedSheetName,
      ãƒ¡ã‚¤ãƒ³è³ªå•: config.opinionHeader,
      åå‰åˆ—: config.nameHeader
    });
  }
  
  return config;
}

/**
 * å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è£œå®Œ
 * @param {Object} config - è£œå®Œå¯¾è±¡ã®config
 * @return {Object} è£œå®Œã•ã‚ŒãŸconfig
 */
function ensureRequiredFields(config) {
  const defaults = {
    showNames: false,
    showCounts: false,
    highlightMode: false,
    autoStopEnabled: true,
    autoStopMinutes: 360
  };
  
  Object.keys(defaults).forEach(key => {
    if (config[key] === undefined) {
      config[key] = defaults[key];
    }
  });
  
  return config;
}


/**
 * å…¬é–‹æ¸ˆã¿çŠ¶æ…‹ç”¨configJsonä¿®å¾©é–¢æ•°
 * @param {Object} config - ä¿®å¾©å¯¾è±¡ã®config
 * @return {Object} ä¿®å¾©ã•ã‚ŒãŸconfig
 */
function fixConfigForPublishedState(config) {
  const fixedConfig = { ...config };
  
  // å…¬é–‹æ¸ˆã¿çŠ¶æ…‹ã®å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¿®å¾©
  if (fixedConfig.setupStatus !== 'completed') {
    console.log('ğŸ”§ setupStatus fixed from pending to completed');
    fixedConfig.setupStatus = 'completed';
  }
  
  if (!fixedConfig.formCreated) {
    console.log('ğŸ”§ formCreated status fixed from false to true');
    fixedConfig.formCreated = true;
  }
  
  if (!fixedConfig.appPublished) {
    console.log('ğŸ”§ appPublished status fixed from false to true');
    fixedConfig.appPublished = true;
  }
  
  // Form URL temporary setting (if actual form URL is unknown)
  if (!fixedConfig.formUrl || fixedConfig.formUrl.trim() === '') {
    console.log('ğŸ”§ formUrl temporary setting for published state maintenance');
    fixedConfig.formUrl = 'https://docs.google.com/temp-form-url'; // Temporary license URL
  }
  
  return fixedConfig;
}


// ç°¡å˜ãªå±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', async function() {
  // Load history table
  loadSimpleHistoryTable();
  
  // Check for and recover draft from session storage
  if (hasDraftInSession()) {
    await recoverDraftFromSession();
  }
});

// æ—¥æ™‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°
function formatDateTime(date) {
  try {
    const options = {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Asia/Tokyo'
    };
    return new Intl.DateTimeFormat('ja-JP', options).format(date).replace(/\//g, '-');
  } catch (error) {
    console.warn('âš ï¸ Date formatting failed:', error);
    return date.toISOString().split('T')[0] + ' ' + date.toISOString().split('T')[1].substring(0, 5);
  }
}

// æ–°ã—ã„ãƒªã‚½ãƒ¼ã‚¹ãƒœã‚¿ãƒ³ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateNewResourceButtons(resourceUrls) {
  const folderBtn = document.getElementById('open-folder-btn');

  // è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ãƒ•ã‚©ãƒ«ãƒ€URLã‚’å–å¾—ã‚’è©¦è¡Œ
  let folderUrl = resourceUrls.folder;
  
  // ãƒ•ã‚©ãƒ«ãƒ€URLãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ä»–ã®ã‚½ãƒ¼ã‚¹ã‚’ç¢ºèª
  if (!folderUrl) {
    // configJsonã‹ã‚‰ç›´æ¥å–å¾—ã‚’è©¦è¡Œ
    const config = window.configJson || window.AdminPanel?.status?.config;
    if (config) {
      folderUrl = config.folderUrl || (config.folderId && ('https://drive.google.com/drive/folders/' + String(config.folderId || '')));
    }
    
    // ãƒ•ã‚©ãƒ«ãƒ€IDã‹ã‚‰ç›´æ¥URLã‚’æ§‹ç¯‰
    if (!folderUrl && config?.folderId) {
      folderUrl = 'https://drive.google.com/drive/folders/' + String(config.folderId || '');
      console.log('ğŸ“ Folder URL constructed from folderId:', folderUrl);
    }
  }
  
  // ãƒ•ã‚©ãƒ«ãƒ€ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹åŒ–
  if (folderBtn) {
    folderBtn.disabled = false;
    folderBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    if (folderUrl) {
      folderBtn.onclick = () => {
        console.log('ğŸ“ Opening folder URL:', folderUrl);
        const link = document.createElement('a');
        link.href = folderUrl;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        document.body.appendChild(link);
        link.click();
        link.remove();
      };
      folderBtn.title = 'ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã';
      console.log('âœ… Folder button enabled with URL:', folderUrl);
    } else {
      folderBtn.onclick = () => showMessage('ãƒ•ã‚©ãƒ«ãƒ€URLãŒæœªè¨­å®šã§ã™', 'warning');
      folderBtn.title = 'ãƒ•ã‚©ãƒ«ãƒ€URLãŒæœªè¨­å®šã§ã™';
      console.log('âš ï¸ Folder button enabled - no URL available');
    }
  }
}

// åˆæœŸåŒ–ã¯ adminPanel-core.js ã®çµ±åˆåˆæœŸåŒ–ã‚·ã‚¹ãƒ†ãƒ ã§ç®¡ç†ã•ã‚Œã¾ã™
</script>
