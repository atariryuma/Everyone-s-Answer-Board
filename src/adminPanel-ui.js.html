<script>
// 🔍 スクリプト読み込み確認
console.log('📄 adminPanel-ui.js.html: スクリプト読み込み開始');
console.log('📄 DOMContentLoaded状態:', document.readyState);
console.log('📄 現在時刻:', new Date().toISOString());

let lastSelectedSheetName = null; // To prevent redundant sheet selection change events

// UI Update Mutex to prevent race conditions
let isUIUpdateInProgress = false;
let pendingUIUpdate = null;

// スクリプト読み込み完了の確認
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    console.log('✅ adminPanel-ui.js.html: DOMContentLoaded完了');
    console.log('✅ updateUIWithNewStatus関数定義状況:', typeof updateUIWithNewStatus);
  });
} else {
  console.log('✅ adminPanel-ui.js.html: DOM既に読み込み済み');
  console.log('✅ updateUIWithNewStatus関数定義状況:', typeof updateUIWithNewStatus);
}

// ページ読み込み完了の確認
window.addEventListener('load', function() {
  console.log('✅ adminPanel-ui.js.html: ページ読み込み完了');
  console.log('✅ 全スクリプト読み込み後のupdateUIWithNewStatus:', typeof updateUIWithNewStatus);
});


// =============================================================================
// ADMIN PANEL UI UPDATES & DISPLAY CONTROL
// =============================================================================

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Unified publication state detection with enhanced flow completion recognition
function getPublicationState(status) {
  if (!status) {
    return { isPublished: false, reason: 'No status data' };
  }
  
  // Check multiple possible publication indicators in priority order
  let isPublished = false;
  let reason = '';
  
  // 1. Direct isPublished property
  if (status.isPublished === true) {
    isPublished = true;
    reason = 'status.isPublished=true';
  }
  // 2. Direct appPublished property  
  else if (status.appPublished === true) {
    isPublished = true;
    reason = 'status.appPublished=true';
  }
  // 3. Check configJson for appPublished
  else if (status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.appPublished === true) {
        isPublished = true;
        reason = 'configJson.appPublished=true';
        
        // Enhanced validation: Verify setup completion indicators
        const hasCompletedSetup = (
          config.setupStatus === 'completed' &&
          config.formCreated === true &&
          config.publishedSheetName &&
          config.publishedSpreadsheetId
        );
        
        if (hasCompletedSetup) {
          reason += ' (完全セットアップ済み)';
        } else {
          console.log('⚠️ Publication state: appPublished=true but setup incomplete', {
            setupStatus: config.setupStatus,
            formCreated: config.formCreated,
            hasPublishedSheet: !!config.publishedSheetName,
            hasPublishedSpreadsheet: !!config.publishedSpreadsheetId
          });
          reason += ' (セットアップ不完全)';
        }
      } 
      // 4. Enhanced completion check: Allow recognition of completed but not yet published setups
      else if (config.setupStatus === 'completed' && 
               config.formCreated === true && 
               config.publishedSheetName && 
               config.publishedSpreadsheetId) {
        // This covers cases where setup is complete but appPublished might not be properly set
        console.log('🔧 Publication state: Setup complete but appPublished=false - potential state inconsistency');
        reason = 'セットアップ完了だが公開状態不整合';
        // Don't auto-publish, but log for debugging
      }
    } catch (e) {
      console.warn('Failed to parse configJson:', e);
    }
  }
  
  // Maintained strict logic to prevent false positives
  // Note: Removed loose fallback logic that assumed activeSheetName = published
  
  return { 
    isPublished, 
    reason,
    // Add confidence level for better debugging
    confidence: isPublished ? (reason.includes('完全セットアップ済み') ? 'high' : 'medium') : 'low'
  };
}

// Generate viewUrl with comprehensive fallback logic
function generateViewUrl(status, userId) {
  // 1. Use existing viewUrl if available
  let viewUrl = status.appUrls?.viewUrl;
  if (viewUrl) {
    return viewUrl;
  }
  
  // 2. Generate from appUrls.webApp with userId
  if (status.appUrls?.webApp && userId) {
    return status.appUrls.webApp + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 3. Generate from status.webAppUrl with userId
  if (status.webAppUrl && userId) {
    return status.webAppUrl + '?userId=' + encodeURIComponent(userId) + '&mode=view';
  }
  
  // 4. Simple fallback without userId
  if (status.appUrls?.webApp) {
    return status.appUrls.webApp + '?mode=view';
  }
  
  logWarn('Could not generate viewUrl');
  return null;
}

// =============================================================================
// MAIN UI UPDATE FUNCTIONS
// =============================================================================

// Update UI with new status data - SIMPLIFIED VERSION
function updateUIWithNewStatus(status) {
  if (!validateStatus(status)) {
    console.warn('❌ Status validation failed, using emergency update');
    emergencyUpdateDatabaseInfo(status);
    return;
  }
  
  try {
    // Direct UI update (simplified for performance)
    updateDatabaseInfo(status);
    
    // Update basic UI elements
    if (status.userInfo && status.userInfo.spreadsheetUrl) {
      currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
    }
    
    // Update currentStatus with normalization
    currentStatus = status;
    
    // Basic normalization processing
    if (!currentStatus._normalized) {
      currentStatus._normalized = {
        isPublished: currentStatus.isPublished || currentStatus.appPublished || 
                    (currentStatus.config && currentStatus.config.isPublished) || false
      };
    }
    
  } catch (error) {
    console.error('❌ updateUIWithNewStatus error:', error);
    emergencyUpdateDatabaseInfo(status);
  }
}

// データ準備の最適化（同期処理部分）
function prepareStatusData(status) {
  // 1. configJson正規化処理（包括的システム最適化）
  // 統一スキーマを使用してconfigを正規化（重複機能削除）
  status.config = getConfigJSON(status.userInfo);
  
  // 2. 正規化されたプロパティの追加（計算集約処理）
  const publicationState = getPublicationState(status);
  const viewUrl = generateViewUrl(status, userId);
  
  status._normalized = {
    isPublished: publicationState.isPublished,
    publishReason: publicationState.reason,
    viewUrl: viewUrl,
    hasValidViewUrl: !!viewUrl
  };
  
  return status;
}

// 並列UI更新の実行（非同期処理の最適化）
function executeParallelUIUpdates(status) {
  console.log('🔄 executeParallelUIUpdates: 開始', {
    hasStatus: !!status,
    hasUserInfo: !!(status && status.userInfo),
    setupStep: status.setupStep
  });
  
  const setupStatus = getSetupStatusFromUserInfo(status.userInfo);
  const currentStep = status.setupStep || 1;
  
  // 並列実行可能な更新タスクを定義
  const updateTasks = [
    // Task 1: 静的要素の更新
    () => {
      console.log('🔄 Task 1: 静的要素の更新開始');
      try {
        clearInitialDisplayElements();
        updateStaticUI(status);
        if (setupStatus === 'pending') {
          updateButtonStatesForSetup(status);
        }
        console.log('✅ Task 1: 静的要素の更新完了');
      } catch (error) {
        console.error('❌ Task 1: 静的要素の更新エラー:', error);
      }
    },
    
    // Task 2: 動的コンテンツの更新
    () => {
      if (status.activeSheetName) {
        updateDynamicContent(status);
      } else {
        updateUIForNoActiveSheet(status);
      }
    },
    
    // Task 3: フッターとガイダンスの更新
    () => updateFooterAndGuidance(status),
    
    // Task 4: ステータスバーの更新（統合最適化版）
    () => updateStepIndicators(status?.setupStep || currentStep, status)
  ];
  
  // 並列実行（requestAnimationFrameで最適化）
  requestAnimationFrame(() => {
    // 重い処理を複数のフレームに分散
    executeTasksInBatches(updateTasks);
  });
}

// タスクのバッチ実行（フレーム分散最適化）
function executeTasksInBatches(tasks, batchSize = 2) {
  if (tasks.length === 0) return;
  
  // 現在のバッチを実行
  const currentBatch = tasks.splice(0, batchSize);
  currentBatch.forEach(task => {
    try {
      task();
    } catch (error) {
      logError('UI更新タスクエラー:', error);
    }
  });
  
  // 残りのタスクがある場合は次のフレームで実行
  if (tasks.length > 0) {
    requestAnimationFrame(() => executeTasksInBatches(tasks, batchSize));
  }
}

// UI更新完了処理
function finishUIUpdate() {
  isUIUpdateInProgress = false;
  
  // 待機中の更新があれば実行
  if (pendingUIUpdate) {
    const nextUpdate = pendingUIUpdate;
    pendingUIUpdate = null;
    updateUIWithNewStatus(nextUpdate);
  }
}

// =============================================================================
// HELPER FUNCTIONS FOR UI UPDATES
// =============================================================================

// Update unpublish button state
function updateUnpublishButton(status) {
  const unpublishBtn = document.getElementById('unpublish-board-btn');
  if (!unpublishBtn) return;

  // Use same strict logic as footer: both normalized and explicit checks
  const isPublished = status._normalized?.isPublished || false;
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('❌ Failed to parse configJson for unpublish button check:', configError);
      explicitAppPublished = false;
    }
  }
  
  const finalIsPublished = isPublished && explicitAppPublished;

  if (finalIsPublished) {
    unpublishBtn.classList.remove('hidden');
  } else {
    unpublishBtn.classList.add('hidden');
  }
}

// Update spreadsheet access button state
function updateSpreadsheetButton() {
  const btn = document.getElementById('open-spreadsheet-btn-step2');
  if (!btn) return;
  
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetUrl) {
    btn.disabled = false;
    btn.onclick = function() {
      window.open(currentStatus.userInfo.spreadsheetUrl, '_blank');
    };
    logDebug('✅ Spreadsheet button enabled with URL:', currentStatus.userInfo.spreadsheetUrl);
  } else {
    btn.disabled = true;
    btn.onclick = null;
    logDebug('⚠️ Spreadsheet button disabled - no URL available');
  }
}

// Update static UI elements
function updateStaticUI(status) {
  console.log('🔄 updateStaticUI: 開始', {
    hasStatus: !!status,
    hasUserInfo: !!(status && status.userInfo)
  });
  
  try {
    // Update database info panel
    console.log('🔄 updateStaticUI: updateDatabaseInfo呼び出し');
    updateDatabaseInfo(status);
    console.log('✅ updateStaticUI: updateDatabaseInfo完了');
    
    // Update existing user section
    console.log('🔄 updateStaticUI: updateExistingUserSection呼び出し');
    updateExistingUserSection(status);
    console.log('✅ updateStaticUI: updateExistingUserSection完了');
    
  } catch (error) {
    console.error('❌ updateStaticUI: エラー発生:', error);
    // エラーが発生してもフォールバック処理を実行
    try {
      setFallbackValues();
    } catch (fallbackError) {
      console.error('❌ updateStaticUI: フォールバック処理もエラー:', fallbackError);
    }
  }
  
  // Populate sheet selection - fix property name mismatch
  logDebug('🔍 Debug: Checking sheet data properties', {
    allSheets: status.allSheets,
    sheetNames: status.sheetNames,
    activeSheetName: status.activeSheetName
  });
  
  const sheetsData = status.sheetNames || status.allSheets || [];
  populateSheetSelect(sheetsData, status.activeSheetName);
  
  // Update custom form info
  updateCustomFormInfo(status);
  
  // Check for auto-publish dialog
  checkAutoPublishDialog(status);
}

// =============================================================================
// DATABASE INFO PANEL UPDATES
// =============================================================================

function updateDatabaseInfo(status) {
  console.log('🔍 updateDatabaseInfo: SIMPLIFIED版開始');

  if (!status || !status.userInfo) {
    console.warn('❌ updateDatabaseInfo: 必要なデータなし、フォールバック実行');
    setFallbackValues();
    return;
  }

  console.log('✅ updateDatabaseInfo: データ確認済み、UI更新開始');

  // スプレッドシートURLを設定
  if (status.userInfo.spreadsheetUrl) {
    currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
  }

  const cfg = status.config || {};

  // 🚨 SIMPLIFIED: 基本情報のみ直接更新
  safeSetText('info-admin-email', status.userInfo.adminEmail);
  safeSetText('info-user-id', status.userInfo.userId);
  safeSetText('info-published-sheet', cfg.publishedSheetName || status.publishedSheetName || 'なし');
  safeSetText('info-answer-count', status.answerCount || '0');
  
  // 作成日・最終アクセス日（簡素化）
  if (status.userInfo.createdAt) {
    const createdAt = new Date(status.userInfo.createdAt).toLocaleDateString('ja-JP');
    safeSetText('info-created-at', createdAt);
  }
  
  if (status.userInfo.lastAccessedAt) {
    const lastAccessed = new Date(status.userInfo.lastAccessedAt).toLocaleDateString('ja-JP');
    safeSetText('info-last-access', lastAccessed);
  }

  // 表示モードとカウント表示（簡素化）
  const displayMode = (cfg.showNames || status.showNames) ? '名前表示' : '匿名表示';
  const showCounts = (cfg.showCounts || status.showCounts) ? '表示' : '非表示';
  safeSetText('info-display-mode', displayMode);
  safeSetText('info-show-counts', showCounts);
  
}

// アカウント情報更新関数
function updateAccountInfo(userInfo) {
  if (!userInfo) return;
  
  // 日時フォーマット関数
  const formatDateTime = (dateStr) => {
    if (!dateStr) return '-';
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('ja-JP', { 
        year: 'numeric', month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit'
      });
    } catch {
      return '-';
    }
  };
  
  safeSetText('info-created-at', formatDateTime(userInfo.createdAt));
  safeSetText('info-last-access', formatDateTime(userInfo.lastAccessedAt));
}

// セットアップ進行状況更新関数
function updateSetupProgress(status) {
  const setupStep = status.setupStep || 1;
  const maxSteps = 4; // 最大ステップ数
  const percentage = Math.round((setupStep / maxSteps) * 100);
  
  safeSetText('info-setup-step', `${setupStep}/${maxSteps}`);
  safeSetText('info-setup-percentage', `${percentage}%`);
  
  const progressBar = safeGetElement('info-setup-progress');
  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
    
    // 完了度に応じて色を変更
    if (percentage === 100) {
      progressBar.className = 'bg-gradient-to-r from-green-500 to-green-600 h-2 rounded-full transition-all duration-300';
    } else if (percentage >= 75) {
      progressBar.className = 'bg-gradient-to-r from-blue-500 to-blue-600 h-2 rounded-full transition-all duration-300';
    } else {
      progressBar.className = 'bg-gradient-to-r from-purple-500 to-purple-600 h-2 rounded-full transition-all duration-300';
    }
  }
}

// データ統計更新関数
function updateDataStatistics(status) {
  safeSetText('info-answer-count', status.answerCount || '0');
  
  // アクティブシート数の計算
  const activeSheets = status.allSheets ? status.allSheets.length : 0;
  safeSetText('info-active-sheets', activeSheets.toString());
  
  // 設定済みヘッダー数の計算
  const configuredHeaders = countConfiguredHeaders(status.config);
  safeSetText('info-configured-headers', configuredHeaders.toString());
}

// システム情報更新関数
function updateSystemInfo(status, config) {
  // 最終更新日時
  const lastModified = config.lastModified || status.userInfo?.lastAccessedAt;
  const formatDateTime = (dateStr) => {
    if (!dateStr) return '-';
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('ja-JP', { 
        month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit'
      });
    } catch {
      return '-';
    }
  };
  
  safeSetText('info-last-modified', formatDateTime(lastModified));
  
  // システム健全性の判定
  const healthStatus = determineSystemHealth(status);
  updateSystemHealthUI(healthStatus);
}

// 設定済みヘッダー数をカウント
function countConfiguredHeaders(config) {
  if (!config) return 0;
  
  let count = 0;
  Object.keys(config).forEach(key => {
    if (key.startsWith('sheet_')) {
      const sheetConfig = config[key];
      if (sheetConfig.opinionHeader) count++;
      if (sheetConfig.nameHeader) count++;
      if (sheetConfig.classHeader) count++;
      if (sheetConfig.reasonHeader) count++;
    }
  });
  
  return count;
}

// システム健全性判定
function determineSystemHealth(status) {
  const issues = [];
  
  if (!status.userInfo?.spreadsheetId) issues.push('スプレッドシートID未設定');
  if (!status.config?.publishedSheetName) issues.push('公開シート未設定');
  if (status.answerCount === 0) issues.push('回答データなし');
  
  return {
    level: issues.length === 0 ? 'healthy' : issues.length <= 1 ? 'warning' : 'critical',
    issues: issues
  };
}

// システム健全性UI更新
function updateSystemHealthUI(healthStatus) {
  const indicator = safeGetElement('info-health-indicator');
  const text = safeGetElement('info-health-text');
  
  if (!indicator || !text) return;
  
  switch (healthStatus.level) {
    case 'healthy':
      indicator.className = 'w-2 h-2 rounded-full bg-green-400';
      text.textContent = '正常';
      break;
    case 'warning':
      indicator.className = 'w-2 h-2 rounded-full bg-yellow-400';
      text.textContent = '注意';
      break;
    case 'critical':
      indicator.className = 'w-2 h-2 rounded-full bg-red-400';
      text.textContent = '要対応';
      break;
    default:
      indicator.className = 'w-2 h-2 rounded-full bg-gray-400';
      text.textContent = '不明';
  }
}

// 詳細情報表示関数
function showTechnicalDetails() {
  // モーダルまたはポップアップで詳細情報を表示
  console.log('詳細情報表示機能は今後実装予定');
}

// フォールバック値設定関数
function setFallbackValues() {
  safeSetText('info-admin-email', '取得中...');
  safeSetText('info-user-id', '取得中...');
  safeSetText('info-published-sheet', '取得中...');
  safeSetText('info-answer-count', '取得中...');
  safeSetText('info-created-at', '取得中...');
  safeSetText('info-last-access', '取得中...');
  safeSetText('info-setup-step', '取得中...');
  safeSetText('info-setup-percentage', '取得中...');
  safeSetText('info-active-sheets', '取得中...');
  safeSetText('info-configured-headers', '取得中...');
  safeSetText('info-last-modified', '取得中...');
  safeSetText('info-display-mode', '取得中...');
  safeSetText('info-show-counts', '取得中...');
  
  // プログレスバーリセット
  const progressBar = safeGetElement('info-setup-progress');
  if (progressBar) progressBar.style.width = '0%';
  
  // 公開状態も初期状態に設定
  const publishIndicator = safeGetElement('info-publish-indicator');
  const publishText = safeGetElement('info-publish-text');
  if (publishIndicator) publishIndicator.className = 'w-2 h-2 rounded-full bg-yellow-400';
  if (publishText) publishText.textContent = '確認中';
  
  // システム健全性も初期状態に設定
  const healthIndicator = safeGetElement('info-health-indicator');
  const healthText = safeGetElement('info-health-text');
  if (healthIndicator) healthIndicator.className = 'w-2 h-2 rounded-full bg-yellow-400';
  if (healthText) healthText.textContent = '確認中';
}

// Update publication status UI
function updatePublicationStatusUI(isPublished) {
  const statusElement = safeGetElement('info-publish-status');
  const indicatorElement = safeGetElement('info-publish-indicator');
  const textElement = safeGetElement('info-publish-text');
  
  if (statusElement) {
    if (isPublished) {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      if (textElement) textElement.textContent = '公開中';
    } else {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      if (textElement) textElement.textContent = '非公開';
    }
  }
}

// チェックボックスの状態を同期する関数
function syncCheckboxStates(status) {
  // Priority: Database config (configJson) > status properties > defaults
  let showNames = false;
  let showCounts = false;
  
  // 1. Prefer status.config if available
  if (status.config) {
    if (status.config.showNames !== undefined) showNames = status.config.showNames;
    if (status.config.showCounts !== undefined) showCounts = status.config.showCounts;
  } else if (status.userInfo?.configJson) {
    // 2. Fallback to raw configJson
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.showNames !== undefined) showNames = config.showNames;
      if (config.showCounts !== undefined) showCounts = config.showCounts;
    } catch (e) {
      logWarn('Failed to parse configJson, using status properties');
      if (status.showNames !== undefined) showNames = status.showNames;
      if (status.showCounts !== undefined) showCounts = status.showCounts;
    }
  } else {
    // 3. Use status properties as last resort
    if (status.showNames !== undefined) showNames = status.showNames;
    if (status.showCounts !== undefined) showCounts = status.showCounts;
  }

  // Update checkbox elements
  const showNamesCheckbox = safeGetElement('show-names');
  const showCountsCheckbox = safeGetElement('show-counts');
  
  if (showNamesCheckbox) {
    showNamesCheckbox.checked = showNames;
  }
  
  if (showCountsCheckbox) {
    showCountsCheckbox.checked = showCounts;
  }
}

// =============================================================================
// SHEET SELECTION AND CONFIGURATION
// =============================================================================

// Populate sheet selection dropdown
function populateSheetSelect(sheetNames, activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) {
    logWarn('Sheet select element not found');
    return;
  }

  logDebug('📋 Populating sheet select with data:', {
    sheetNames: sheetNames,
    activeSheetName: activeSheetName,
    dataType: typeof sheetNames,
    isArray: Array.isArray(sheetNames)
  });

  // Clear existing options
  select.innerHTML = '<option value="">-- シートを選択 --</option>';
  
  if (sheetNames && sheetNames.length > 0) {
    logDebug('✅ Adding sheets to dropdown:', sheetNames.length);
    
    sheetNames.forEach((sheet, index) => {
      const option = document.createElement('option');
      
      // Handle both object and string formats
      let sheetName;
      if (typeof sheet === 'object' && sheet.name) {
        sheetName = sheet.name;
        option.value = sheet.name;
        logDebug(`📄 Sheet ${index + 1}: ${sheet.name} (ID: ${sheet.id})`);
      } else if (typeof sheet === 'string') {
        sheetName = sheet;
        option.value = sheet;
        logDebug(`📄 Sheet ${index + 1}: ${sheet}`);
      } else {
        console.warn('⚠️ Unknown sheet format:', sheet);
        return;
      }
      
      // アクティブシートの表示を改善
      if (sheetName === activeSheetName) {
        option.textContent = `${sheetName} (アクティブ)`;
        option.style.fontWeight = 'bold';
        option.style.color = '#10b981'; // 緑色でアクティブを表示
        option.className = 'active-sheet-option';
        logDebug(`✅ Active sheet marked: ${sheetName}`);
      } else {
        option.textContent = sheetName;
      }
      
      select.appendChild(option);
    });
    select.disabled = false;
    logDebug('✅ Sheet dropdown populated successfully');
  } else {
    console.warn('⚠️ No sheets available:', sheetNames);
    select.innerHTML = '<option value="">利用可能なシートがありません</option>';
    select.disabled = true;
  }
  
  // Set active sheet if available
  if (activeSheetName) {
    select.value = activeSheetName;
    selectedSheet = activeSheetName;
    lastSelectedSheetName = activeSheetName; // Update last selected sheet
    logDebug('✅ Active sheet set:', activeSheetName);
  }
  
  // Add change event listener for data preview
  select.removeEventListener('change', handleSheetSelectionChange);
  select.addEventListener('change', handleSheetSelectionChange);
  
  // Update UI for selected sheet and enable spreadsheet button
  updateUIForSelectedSheet();
  updateSpreadsheetButton();
}

// Populate header options for configuration
function populateHeaderOptions(headers) {
  // Throttle function calls to prevent spam
  if (window.populateHeaderOptionsRunning) {
    return;
  }
  window.populateHeaderOptionsRunning = true;
  
  const selects = [
    'opinionHeader',      // Main required field
    'reason-column',     // Optional details field (reason column)
    'name-column', 
    'class-column'
  ];
  
  selects.forEach(selectId => {
    const select = document.getElementById(selectId);
    
    if (select) {
      // Store current value
      const currentValue = select.value;
      
      // Clear and repopulate with appropriate placeholder
      if (headers && headers.length > 0) {
        select.innerHTML = '<option value="">-- 列を選択 --</option>';
        select.disabled = false;
      } else {
        select.innerHTML = '<option value="">-- シートを選択してください --</option>';
        select.disabled = true;
      }
      
      const excludedHeaders = [
        'なるほど！',
        'いいね！',
        'もっと知りたい！',
        'ハイライト',
        'メールアドレス', // フォームで自動収集されるため、マッピング対象から除外
        'タイムスタンプ' // ユーザーの要望により除外
      ];

      const filteredHeaders = headers.filter(header => !excludedHeaders.includes(header));

      filteredHeaders.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        select.appendChild(option);
      });
      
      // Restore previous value if still valid
      if (currentValue && headers.includes(currentValue)) {
        select.value = currentValue;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateHeaderOptionsRunning = false;
  }, 100);
}

// Populate configuration with guessed values
function populateConfig(cfg) {
  if (!cfg) return;
  
  // Throttle function calls to prevent spam
  if (window.populateConfigRunning) {
    return;
  }
  window.populateConfigRunning = true;
  
  const mappings = {
    // Main opinion dropdown (primary target)
    'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
    
    // Detail configuration dropdowns (secondary targets with property name fixes)
    'reason-column': cfg.reasonColumn || cfg.reasonHeader,
    'name-column': cfg.nameColumn || cfg.nameHeader,
    'class-column': cfg.classColumn || cfg.classHeader,
    'show-names': cfg.showNames,
    'show-counts': cfg.showCounts
  };
  
  Object.keys(mappings).forEach(elementId => {
    const element = document.getElementById(elementId);
    const value = mappings[elementId];
    
    if (element && value !== undefined) {
      if (element.type === 'checkbox') {
        element.checked = Boolean(value);
      } else {
        element.value = value;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateConfigRunning = false;
  }, 100);
  
  updateConfigButtons();
}

// Clear configuration fields
function clearConfigFields() {
  const fieldIds = [
    'opinionHeader',      // Main required field
    'reason-column',
    'name-column',
    'class-column'
  ];
  
  fieldIds.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.value = '';
    }
  });
  
  updateConfigButtons();
}

// Build configuration object from form
function buildConfigObject() {
  // Get values from primary elements (with fallback to secondary elements)
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  const nameValue = document.getElementById('name-column')?.value || '';
  const classValue = document.getElementById('class-column')?.value || '';
  const showNames = document.getElementById('show-names')?.checked || false;
  const showCounts = document.getElementById('show-counts')?.checked || false;
  
  return {
    sheetName: selectedSheet,
    // Use property names that match backend expectations (opinionHeader format)
    opinionHeader: opinionValue,
    nameHeader: nameValue,
    classHeader: classValue,
    reasonHeader: document.getElementById('reason-column')?.value || '',
    // Also provide legacy format for backward compatibility
    opinionColumn: opinionValue,
    nameColumn: nameValue,
    classColumn: classValue,
    showNames: showNames,
    showCounts: showCounts
  };
}

// Validate configuration
function validateConfig() {
  // Check primary element first, then fallback to secondary element
  const opinionValue = document.getElementById('opinionHeader')?.value || 
                      document.getElementById('reason-column')?.value || '';
  
  return opinionValue && opinionValue.trim() !== '';
}

// Update configuration buttons state
function updateConfigButtons() {
  const isValid = validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
  
  if (saveBtn) {
    saveBtn.disabled = !isValid;
    if (isValid) {
      saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
      saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
  }
}

// =============================================================================
// STEP INDICATORS AND GUIDANCE
// =============================================================================

// 統一されたステップ完了チェック - 公開状態優先判定対応版
function getStepCompletionFromConfig(status) {
  if (!status?.userInfo?.configJson) {
    return { step1: false, step2: false, step3: false, isPublished: false };
  }

  try {
    const config = typeof status.userInfo.configJson === 'string' 
      ? JSON.parse(status.userInfo.configJson) 
      : status.userInfo.configJson;

    // 公開状態の優先チェック（データ不整合に関係なく公開済みなら全ステップ完了）
    const publicationState = getPublicationState(status);
    if (publicationState.isPublished) {
      return {
        step1: true,
        step2: true,
        step3: true,
        isPublished: true
      };
    }

    // 通常のステップ完了判定
    // Step 1: スプレッドシートIDの存在確認
    const step1Complete = !!(status.userInfo.spreadsheetId);
    
    // Step 2: セットアップ完了状態の確認
    const step2Complete = config.setupStatus === 'completed' && 
                          config.formCreated === true && 
                          config.formUrl && config.formUrl.trim();
    
    // Step 3: 公開状態の確認
    const step3Complete = config.appPublished === true;
    
    return {
      step1: step1Complete,
      step2: step2Complete,
      step3: step3Complete,
      isPublished: step3Complete
    };
  } catch (error) {
    console.warn('❌ configJsonの解析に失敗:', error);
    return { step1: false, step2: false, step3: false, isPublished: false };
  }
}

// Update step indicators - 最適化版（バッチDOM更新）
function updateStepIndicators(currentStep, status = null) {
  const steps = [
    document.getElementById('step-1-indicator'),
    document.getElementById('step-2-indicator'),
    document.getElementById('step-3-indicator')
  ];

  // データベース状態から実際の完了状況を取得
  const completion = getStepCompletionFromConfig(status);
  logDebug('📊 Step completion from database:', completion);

  // DOM更新をバッチ化するための設定配列を作成
  const updates = [];
  
  steps.forEach((step, index) => {
    if (!step) return;
    
    const stepNumber = index + 1;
    const circle = step.querySelector('div');
    const text = step.querySelector('span');

    // 既存のバッジを削除（最適化）
    const existingBadge = step.querySelector('.publication-badge');
    if (existingBadge) {
      existingBadge.remove();
    }

    // データベース状態に基づく完了判定
    const isStepComplete = completion[`step${stepNumber}`];
    
    // 更新情報を配列に追加（実際のDOM更新は後で一括実行）
    updates.push({
      circle,
      text,
      stepNumber,
      isStepComplete,
      isCurrentStep: stepNumber === currentStep
    });
  });
  
  // バッチDOM更新実行（リフローを最小化）
  requestAnimationFrame(() => {
    executeBatchStepUpdates(updates);
    // 進行状況メッセージの更新（同じアニメーションフレーム内で実行）
    updateProgressMessage(currentStep, status, completion);
  });
}

// バッチDOM更新の実行（最適化されたDOM操作）
function executeBatchStepUpdates(updates) {
  const styleConfigs = {
    completed: {
      circleClass: 'w-6 h-6 bg-green-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all',
      circleContent: '✓',
      textClasses: { remove: ['text-gray-500', 'text-cyan-400'], add: ['text-green-400', 'font-medium'] }
    },
    current: {
      circleClass: 'w-6 h-6 bg-cyan-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all ring-2 ring-cyan-400 ring-offset-2 ring-offset-gray-900 animate-pulse',
      textClasses: { remove: ['text-gray-500', 'text-green-400'], add: ['text-cyan-400', 'font-bold'] }
    },
    pending: {
      circleClass: 'w-6 h-6 bg-gray-700 text-gray-500 rounded-full flex items-center justify-center font-bold text-xs transition-all border border-gray-600',
      textClasses: { remove: ['text-white', 'text-green-400', 'text-cyan-400', 'font-bold', 'font-medium'], add: ['text-gray-500'] }
    }
  };

  updates.forEach(({ circle, text, stepNumber, isStepComplete, isCurrentStep }) => {
    let config;
    
    if (isStepComplete) {
      config = styleConfigs.completed;
    } else if (isCurrentStep) {
      config = styleConfigs.current;
    } else {
      config = styleConfigs.pending;
    }

    // Circle要素の更新
    if (circle) {
      circle.className = config.circleClass;
      circle.innerHTML = config.circleContent || stepNumber;
    }

    // Text要素の更新（クラス操作の最適化）
    if (text && config.textClasses) {
      text.classList.remove(...config.textClasses.remove);
      text.classList.add(...config.textClasses.add);
    }
  });
}

function updateProgressMessage(currentStep, status = null, completion = null) {
  const messageElement = document.getElementById('progress-message');
  if (!messageElement) return;
  
  // completionが渡されていない場合は取得
  if (!completion) {
    completion = getStepCompletionFromConfig(status);
  }
  
  // 改善されたメッセージとガイダンス
  const messageData = getEnhancedProgressMessage(currentStep, completion, status);
  
  messageElement.textContent = messageData.message;
  messageElement.className = `text-sm ${messageData.colorClass} font-medium transition-colors duration-300`;
}

// 強化されたプログレスメッセージの生成
function getEnhancedProgressMessage(currentStep, completion, status) {
  const messageConfigs = {
    1: {
      completed: {
        message: '✅ データ準備完了：フォーム・スプレッドシートが利用可能です',
        colorClass: 'text-green-400'
      },
      inProgress: {
        message: '📋 クイックスタート（自動）またはカスタムセットアップ（既存データ）を選択',
        colorClass: 'text-cyan-400'
      }
    },
    2: {
      completed: {
        message: '✅ シート設定完了：回答データの表示準備ができました',
        colorClass: 'text-green-400'  
      },
      inProgress: {
        message: '⚙️ シートを選択して、表示する列（質問・回答など）を設定してください',
        colorClass: 'text-yellow-400'
      }
    },
    3: {
      published: {
        message: '🎉 ボード公開中：参加者が回答を投稿・閲覧できます',
        colorClass: 'text-green-400'
      },
      readyToPublish: {
        message: '🚀 公開準備完了：「ボードを公開」で参加者に共有しましょう',
        colorClass: 'text-purple-400'
      },
      needsConfiguration: {
        message: '🔧 列設定を完了してから公開してください',
        colorClass: 'text-orange-400'
      }
    }
  };
  
  // ステップごとの状態判定とメッセージ選択
  switch (currentStep) {
    case 1:
      return completion.step1 ? 
        messageConfigs[1].completed : 
        messageConfigs[1].inProgress;
        
    case 2:
      return completion.step2 ? 
        messageConfigs[2].completed : 
        messageConfigs[2].inProgress;
        
    case 3:
      if (completion.isPublished) {
        return messageConfigs[3].published;
      } else if (completion.step2) {
        return messageConfigs[3].readyToPublish;
      } else {
        return messageConfigs[3].needsConfiguration;
      }
      
    default:
      return {
        message: '🎉 セットアップ完了：StudyQuestをお楽しみください！',
        colorClass: 'text-green-400'
      };
  }
}

// Update footer and guidance text
function updateFooterAndGuidance(status) {
  console.group('🦶 updateFooterAndGuidance');
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('❌ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }

  // Use normalized publication state from status object with additional validation
  const isPublished = status._normalized?.isPublished || false;
  const viewUrl = status._normalized?.viewUrl;
  
  // Additional strict check: ensure appPublished is explicitly true
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo?.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('❌ Failed to parse configJson for publication check:', configError);
      explicitAppPublished = false;
    }
  }
  
  // Final publication decision: both normalized and explicit checks must agree
  const finalIsPublished = isPublished && explicitAppPublished;
  
  console.log('🔍 Enhanced publication check:', {
    'normalized isPublished': isPublished,
    'explicit appPublished': explicitAppPublished,
    'final decision': finalIsPublished,
    'publish reason': status._normalized?.publishReason,
    'normalized viewUrl': viewUrl,
    'has valid viewUrl': status._normalized?.hasValidViewUrl,
    'will show footer': finalIsPublished
  });

  // Show footer if published (with strict validation)
  if (finalIsPublished) {
    footer.classList.remove('hidden');
    
    // Update board URL using our generated viewUrl (if available)
    const boardUrlInput = document.getElementById('board-url');
    const viewBoardLink = document.getElementById('view-board-link');
    
    if (boardUrlInput) {
      boardUrlInput.value = viewUrl || 'URL生成中...';
      console.log('📝 Board URL input updated:', viewUrl || 'URL generation pending');
    }
    if (viewBoardLink && viewUrl) {
      viewBoardLink.href = viewUrl;
      console.log('🔗 View board link updated:', viewUrl);
    } else if (viewBoardLink) {
      viewBoardLink.removeAttribute('href');
      console.log('🔗 View board link cleared - no URL available');
    }
    
    // Update topic text
    updateTopicText(status);
    
    guidanceText.textContent = '回答ボードは現在公開中です。';
    console.log('✅ Footer shown - board is published');
  } else {
    footer.classList.add('hidden');
    console.log('❌ Footer hidden - board not published');
    
    // Update guidance based on setup step
    updateGuidanceForStep(status.setupStep || 1, guidanceText);
  }
  
  console.groupEnd();
  
  // 自動停止通知の表示チェック
  checkAndShowAutoStopNotification(status);
  
  adjustLayout();
}

// Update UI for selected sheet
function updateUIForSelectedSheet() {
  var hasSelection = selectedSheet && selectedSheet.trim() !== '';
  
  // Update step indicators based on server-provided setupStep
  const currentStep = currentStatus.setupStep || 1;
  updateStepIndicators(currentStep);
  
  // Enable/disable configuration section
  var configSection = document.getElementById('config-section');
  if (configSection) {
    if (hasSelection) {
      configSection.classList.remove('opacity-50', 'pointer-events-none');
      
      // 防御的ロジック: config-areaが確実に表示されるようにする
      var configArea = document.getElementById('config-area');
      if (configArea) {
        configArea.classList.remove('hidden');
        console.log('🛡️ updateUIForSelectedSheet: Config area shown defensively');
      }
    } else {
      configSection.classList.add('opacity-50', 'pointer-events-none');
    }
  }
  
  // Update guidance text
  var guidanceText = document.getElementById('guidance-text');
  if (guidanceText) {
    if (hasSelection) {
      guidanceText.textContent = 'ステップ3: 列を設定してボードを公開しましょう';
    } else {
      guidanceText.textContent = 'ステップ2: 表示したいシートを選択してください。';
    }
  }

  // Toggle placeholder visibility
  var configPlaceholder = document.getElementById('config-placeholder');
  if (configPlaceholder) {
    if (hasSelection) {
      configPlaceholder.classList.add('hidden');
    } else {
      configPlaceholder.classList.remove('hidden');
    }
  }
}

// Update topic text in footer
function updateTopicText(status) {
  const topicTextElement = document.getElementById('current-topic-text');
  const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
  
  if (!topicTextElement) return;

  let topic = '（問題文未設定）';
  // より包括的なconfig取得
  let cfg = status.config || {};
  
  // userInfo.configJsonからも情報を取得
  if (status.userInfo?.configJson) {
    try {
      const fullConfig = JSON.parse(status.userInfo.configJson);
      cfg = { ...cfg, ...fullConfig };
    } catch (e) {
      console.warn('Failed to parse userInfo.configJson:', e);
    }
  }

  if (status.customFormInfo && status.customFormInfo.mainQuestion) {
    topic = status.customFormInfo.mainQuestion;
  } else if (cfg.opinionHeader) {
    topic = cfg.opinionHeader;
  } else {
    const sheetName = cfg.publishedSheetName || status.publishedSheetName;
    if (sheetName) {
      if (status.userInfo?.configJson) {
        try {
          const fullCfg = JSON.parse(status.userInfo.configJson);
          const sheetCfg = fullCfg['sheet_' + sheetName] || {};
          topic = sheetCfg.opinionHeader || sheetName || '（問題文未設定）';
        } catch (e) {
          topic = sheetName || '（問題文未設定）';
        }
      } else {
        topic = sheetName;
      }
    }
  }

  topicTextElement.textContent = topic;
  
  // 予定終了日時の更新
  if (scheduledEndTimeElement) {
    updateScheduledEndTime(cfg, scheduledEndTimeElement);
  }
}

// 予定終了日時を更新する関数
function updateScheduledEndTime(config, element) {
  // 複数のソースから scheduledEndAt を取得を試行
  const scheduledEndAt = config.scheduledEndAt || 
                         config.scheduledEndTime ||  // 古いフィールド名との互換性
                         (window.lastStatusCache?.config?.scheduledEndAt) ||
                         (window.lastStatusCache?.config?.scheduledEndTime);
  
  // scheduledEndAtが設定されていない場合は、publishedAt + autoStopMinutesから計算
  let finalScheduledEndTime = scheduledEndAt;
  
  if (!finalScheduledEndTime && config.publishedAt && config.autoStopMinutes) {
    const publishedTime = new Date(config.publishedAt);
    const autoStopMs = config.autoStopMinutes * 60 * 1000;
    finalScheduledEndTime = new Date(publishedTime.getTime() + autoStopMs).toISOString();
    console.log('🕐 終了予定時刻を計算しました:', finalScheduledEndTime);
  }
  
  if (finalScheduledEndTime) {
    try {
      const endDate = new Date(finalScheduledEndTime);
      const formattedTime = endDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      // 現在時刻との比較
      const now = new Date();
      const isOverdue = endDate < now;
      const timeRemaining = endDate.getTime() - now.getTime();
      const oneHourMs = 60 * 60 * 1000; // 1時間のミリ秒
      
      if (isOverdue) {
        element.textContent = `${formattedTime} (期限切れ)`;
        element.className = 'text-xs font-medium text-red-400';
      } else if (timeRemaining <= oneHourMs) {
        // 1時間以内の場合は警告表示
        const minutesRemaining = Math.floor(timeRemaining / (60 * 1000));
        element.textContent = `${formattedTime} (残り${minutesRemaining}分)`;
        element.className = 'text-xs font-medium text-red-400 animate-pulse';
        console.log('⚠️ 期限まで1時間以内です:', minutesRemaining + '分');
      } else {
        element.textContent = formattedTime;
        element.className = 'text-xs font-medium text-orange-400';
      }
    } catch (e) {
      element.textContent = '設定エラー';
      element.className = 'text-xs font-medium text-gray-400';
    }
  } else {
    element.textContent = '未設定';
    element.className = 'text-xs font-medium text-gray-400';
  }
}

// Update guidance text for specific step
function updateGuidanceForStep(step, guidanceElement) {
  const messages = {
    1: 'ステップ1: ボードを作成または既存のリソースを追加してください。',
    2: 'ステップ2: 表示したいシートを選択してください。',
    3: 'ステップ3: 列を設定してボードを公開しましょう'
  };
  
  // 公開終了後のステップ1では、明確にセットアップ再開のメッセージを表示
  if (step === 1) {
    guidanceElement.textContent = 'セットアップを開始してください';
  } else {
    guidanceElement.textContent = messages[step] || 'セットアップを開始してください';
  }
}

// 自動停止通知の表示チェック
function checkAndShowAutoStopNotification(status) {
  const notificationElement = document.getElementById('auto-stop-notification');
  const autoStoppedTimeElement = document.getElementById('auto-stopped-time');
  
  if (!notificationElement || !autoStoppedTimeElement) return;
  
  const config = status.config || {};
  
  // 自動停止されている場合のみ通知を表示
  if (config.autoStoppedAt && config.autoStopReason === 'scheduled_timeout') {
    console.log('🔔 自動停止通知を表示します:', config.autoStoppedAt);
    
    // 停止時刻を表示
    try {
      const stoppedDate = new Date(config.autoStoppedAt);
      const formattedTime = stoppedDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      autoStoppedTimeElement.textContent = formattedTime;
    } catch (e) {
      autoStoppedTimeElement.textContent = '時刻不明';
    }
    
    // 通知を表示
    notificationElement.classList.remove('hidden');
    
    // 再公開ボタンのイベントリスナーを設定
    const republishBtn = document.getElementById('republish-after-auto-stop-btn');
    if (republishBtn) {
      // 既存のイベントリスナーを削除
      republishBtn.replaceWith(republishBtn.cloneNode(true));
      
      // 新しいイベントリスナーを追加
      const newRepublishBtn = document.getElementById('republish-after-auto-stop-btn');
      newRepublishBtn.addEventListener('click', function() {
        // Step 3に移動して再公開を促す
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 通知を非表示
        notificationElement.classList.add('hidden');
        
        showMessage('表示設定を確認して再公開してください', 'info');
      });
    }
  } else {
    // 自動停止されていない場合は通知を非表示
    notificationElement.classList.add('hidden');
  }
}

// =============================================================================
// SECTION TOGGLE FUNCTIONALITY
// =============================================================================

// Toggle section expansion/collapse
function toggleSection(sectionId) {
  const section = document.getElementById(sectionId);
  if (!section) {
    console.warn('Section not found:', sectionId);
    return;
  }
  
  // Find the toggle button for this section
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  const arrow = toggleBtn ? toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up') : null;
  
  // Toggle the section visibility
  if (section.classList.contains('hidden')) {
    // Show section
    section.classList.remove('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'true');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  } else {
    // Hide section
    section.classList.add('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'false');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
}

// Automatically collapse completed sections
function collapseCompletedSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📁 Auto-collapsing completed step ${stepNumber}`);
  
  // Collapse the section
  section.classList.add('hidden');
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'false');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Automatically expand active section
function expandActiveSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📂 Auto-expanding active step ${stepNumber}`);
  
  // Expand the section
  section.classList.remove('hidden');
  
  // Special handling for Step 3: ensure config-area is visible
  if (stepNumber === 3) {
    const configArea = document.getElementById('config-area');
    if (configArea && currentStatus && currentStatus.activeSheetName) {
      configArea.classList.remove('hidden');
      console.log(`📋 expandActiveSection: Config area shown for Step 3`);
    }
  }
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'true');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Manage section states based on current step (simplified - no visual effects)
function manageSectionStates(currentStep) {
  console.log(`🔄 Managing section states for step ${currentStep}`);
  
  // ステップごとのセクション制御
  for (let i = 1; i <= 3; i++) {
    const sectionId = `step${i}-content`;
    const section = document.getElementById(sectionId);
    
    if (i === currentStep) {
      // 現在のステップ: 展開して有効化
      expandActiveSection(i);
      
      // Step 3の特別処理: config-areaの表示
      if (i === 3) {
        const configArea = document.getElementById('config-area');
        if (configArea && currentStatus && currentStatus.activeSheetName) {
          configArea.classList.remove('hidden');
          console.log(`📋 Step 3: Config area shown for sheet: ${currentStatus.activeSheetName}`);
        }
      }
      
      console.log(`🔄 Step ${i}: Active (current step)`);
    } else if (i < currentStep) {
      // 完了済みステップ: アクセス可能だが、展開は任意
      if (section) {
        section.classList.add('opacity-90'); // 完了した状態を視覚的に示す
      }
      console.log(`✅ Step ${i}: Completed (accessible)`);
    } else {
      // 未来のステップ: Step 1の場合はpending状態でも全て閲覧可能
      if (currentStep === 1) {
        // Step 1では全ステップにアクセス可能（データ確認のため）
        if (section) {
          section.classList.add('opacity-75'); // 未来のステップとして軽く表示
        }
        console.log(`⏭️ Step ${i}: Available for preview`);
      } else {
        // Step 2以降では順次開放
        if (section) {
          section.classList.add('opacity-50'); // 未来のステップとして表示
        }
        console.log(`⏭️ Step ${i}: Future step (available)`);
      }
    }
  }
}

// =============================================================================
// MODAL MANAGEMENT
// =============================================================================

// Show form configuration modal
function showFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.showFormConfig();
    loadSavedClassChoices();
    manageFocusForModal('form-config-modal', true);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      loadSavedClassChoices();
      manageFocusForModal('form-config-modal', true);
    }
  }
}

// Hide form configuration modal
function hideFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.hideModal('form-config-modal');
    manageFocusForModal('form-config-modal', false);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      manageFocusForModal('form-config-modal', false);
    }
  }
}

// Show privacy modal
function showPrivacyModal(onContinue) {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('privacy-modal', true);
    
    // Set up continue handler
    const continueBtn = document.getElementById('privacy-modal-continue');
    if (continueBtn && onContinue) {
      continueBtn.onclick = onContinue;
    }
  }
}

// Hide privacy modal
function hidePrivacyModal() {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('privacy-modal', false);
  }
}

// Show digital citizenship modal
function showDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('digital-citizenship-modal', true);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('digital-citizenship-modal', false);
  }
}

// Show confirmation modal
function showConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  console.log('🔍 showConfirmationModal: 要素検索結果:', {
    modal: !!modal,
    titleElement: !!titleElement,
    messageElement: !!messageElement,
    confirmBtn: !!confirmBtn,
    cancelBtn: !!cancelBtn
  });
  
  if (modal && titleElement && messageElement && confirmBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // 確認ボタンのクリックイベント
    confirmBtn.onclick = function() {
      console.log('✅ 確認ボタンがクリックされました');
      hideConfirmationModal();
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ 確認コールバック実行エラー:', error);
        }
      }
    };
    
    // キャンセルボタンのクリックイベント
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        console.log('❌ キャンセルボタンがクリックされました');
        hideConfirmationModal();
      };
    }
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('confirmation-modal', true);
    console.log('✅ 確認モーダルを表示しました');
  } else {
    console.error('❌ モーダル要素が見つかりません。フォールバックを使用します。');
    // フォールバック: ブラウザ標準の確認ダイアログ
    if (window.confirm(`${title}\n\n${message}`)) {
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ フォールバック確認コールバック実行エラー:', error);
        }
      }
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('confirmation-modal', false);
  }
}

// =============================================================================
// DYNAMIC CONTENT UPDATES
// =============================================================================

// Update dynamic content when board is active
function updateDynamicContent(status) {
  // Enable buttons that require active state
  const buttons = [
    'open-spreadsheet-btn'
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = false;
      button.classList.remove('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update UI when no sheet is active
function updateUIForNoActiveSheet(status) {
  // Disable buttons that require active state
  const buttons = [
    // No form buttons to disable since we only support spreadsheets
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = true;
      button.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update existing user section
function updateExistingUserSection(status) {
  // Update any user-specific UI elements
  if (status.userInfo) {
    // Update user-specific elements here if needed
  }
}

// Update custom form info
function updateCustomFormInfo(status) {
  if (status.customFormInfo) {
    // Update form-related UI elements
    const formTitle = document.getElementById('form-title-display');
    const formQuestion = document.getElementById('form-question-display');
    
    if (formTitle) {
      formTitle.textContent = status.customFormInfo.title || 'フォーム未作成';
    }
    
    if (formQuestion) {
      formQuestion.textContent = status.customFormInfo.mainQuestion || '';
    }
  }
  
  // フォームURL表示の更新（configJsonから確実に取得）
  updateFormUrlDisplay(status);
}

// フォームURL表示を確実に更新
function updateFormUrlDisplay(status = null) {
  const formUrlInput = document.getElementById('form-url-input');
  const formUrlSection = document.getElementById('form-url-section');
  const openFormLink = document.getElementById('open-form-url-link');
  
  if (!formUrlInput) return;
  
  // 現在のstatusの最適化された取得
  const currentStatusToUse = status || currentStatus;
  if (!currentStatusToUse || !currentStatusToUse.userInfo) {
    logWarn('⚠️ updateFormUrlDisplay: status情報が不足しています');
    return;
  }
  
  // フォームURL取得の最適化（優先度順）
  const formUrl = getFormUrlFromStatus(currentStatusToUse);
  
  // UI更新の最適化
  if (formUrl) {
    updateFormUrlElements(formUrlInput, openFormLink, formUrl);
    handleFormUrlSectionVisibility(formUrlSection);
    logDebug('🔗 FormURL UI更新完了:', formUrl);
  } else {
    clearFormUrlElements(formUrlInput, formUrlSection);
    logDebug('📭 FormURL未設定のためUI非表示');
  }
}

// フォームURL取得の最適化されたヘルパー関数
function getFormUrlFromStatus(status) {
  const userInfo = status.userInfo;
  
  // 1. configJsonから直接取得（最も確実）
  if (userInfo.configJson) {
    try {
      const configJson = typeof userInfo.configJson === 'string' 
        ? JSON.parse(userInfo.configJson) 
        : userInfo.configJson;
      
      if (configJson?.formUrl) {
        logDebug('✅ FormURL: configJsonから取得');
        return configJson.formUrl;
      }
    } catch (error) {
      logWarn('⚠️ configJSON解析エラー:', error.message);
    }
  }
  
  // 2. ユーザー情報から直接取得
  if (userInfo.formUrl) {
    logDebug('📋 FormURL: userInfoから取得');
    return userInfo.formUrl;
  }
  
  // 3. カスタムフォーム情報から取得（後方互換性）
  if (status.customFormInfo?.formUrl) {
    logDebug('📄 FormURL: customFormInfoから取得');
    return status.customFormInfo.formUrl;
  }
  
  return null;
}

// フォームURL要素更新の最適化
function updateFormUrlElements(input, link, url) {
  input.value = url;
  if (link) {
    link.href = url;
  }
}

// フォームURL要素クリアの最適化
function clearFormUrlElements(input, section) {
  input.value = '';
  if (section) {
    section.classList.add('hidden');
  }
}

// フォームURLセクション表示制御の最適化
function handleFormUrlSectionVisibility(section) {
  if (!section) return;
  
  const formJustCreated = sessionStorage.getItem('form_just_created');
  if (formJustCreated === 'true') {
    section.classList.remove('hidden');
    logDebug('🆕 新規フォーム作成セクション表示');
    
    // フラグクリアの最適化（タイマー処理）
    setTimeout(() => {
      sessionStorage.removeItem('form_just_created');
      logDebug('🧹 フォーム作成フラグクリア');
    }, 10000);
  } else {
    section.classList.add('hidden');
  }
}

// Check for auto-publish dialog
function checkAutoPublishDialog(status) {
  // Implementation for auto-publish dialog if needed
  if (status.needsAutoPublish) {
    // Show auto-publish confirmation
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Initialize UI components
function initializeUI() {
  console.log('✅ AdminPanel: UI components ready');
  // UI初期化のみ実行、loadStatusは adminPanel-api.js で処理される
}

// =============================================================================
// SHEET SELECTION FUNCTIONALITY  
// =============================================================================

// Handle sheet selection change
function handleSheetSelectionChange(event) {
  const newSelectedSheet = event.target.value;

  // Prevent redundant calls if the selected sheet hasn't actually changed
  if (newSelectedSheet === lastSelectedSheetName) {
    console.log('📊 Sheet selection changed, but value is the same. Skipping redundant processing.');
    return;
  }
  
  console.log('📊 Sheet selection changed:', {
    previousSheet: selectedSheet,
    newSelectedSheet: newSelectedSheet
  });
  
  // Update global selected sheet variable and last selected sheet
  selectedSheet = newSelectedSheet;
  lastSelectedSheetName = newSelectedSheet;
  
  if (newSelectedSheet) {
    console.log('📋 Loading config for sheet:', newSelectedSheet);

    // 1. 即座にシートをアクティブ化
    activateSelectedSheet(newSelectedSheet);

    // Call getSheetDetails once and use its result for config
    if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
      console.error('スプレッドシート情報が見つかりません');
      return;
    }

    // 2. アクティブシートの列データを取得して列選択を更新
    loadConfigForSelected(newSelectedSheet, currentStatus.userInfo.spreadsheetId)
      .then(result => {
        console.log('✅ シート設定読み込み完了:', result);
        // UI更新完了後の処理
        updateUIForSelectedSheet();
      })
      .catch(error => {
        console.error('❌ シート設定読み込み失敗:', error);
        showMessage('シートの設定読み込みに失敗しました', 'error');
        // エラー時もUI状態を更新
        updateUIForSelectedSheet();
      });
  } else {
    // シート選択が解除された場合
    clearColumnSelections();
    updateUIForSelectedSheet();
  }
}

// シートを即座にアクティブ化する関数
function activateSelectedSheet(sheetName) {
  if (!sheetName || !currentStatus || !currentStatus.userInfo) {
    console.warn('⚠️ シートアクティブ化に必要な情報が不足しています');
    return;
  }

  console.log(`🎯 シートを即座にアクティブ化: ${sheetName}`);
  
  // サーバー側でアクティブシートを設定
  runGasWithUserId('setActiveSheet', 'シートをアクティブ化中...', sheetName)
    .then(response => {
      console.log('✅ シートアクティブ化完了:', response);
      
      // currentStatusを更新
      if (currentStatus.userInfo.configJson) {
        try {
          const config = JSON.parse(currentStatus.userInfo.configJson);
          config.publishedSheetName = sheetName;
          currentStatus.userInfo.configJson = JSON.stringify(config);
          currentStatus.activeSheetName = sheetName;
          
          // シートドロップダウンの表示を更新
          updateSheetSelectActiveIndicator(sheetName);
          
          console.log('✅ ローカル状態更新完了');
        } catch (e) {
          console.warn('⚠️ configJson更新に失敗:', e);
        }
      }
    })
    .catch(error => {
      console.error('❌ シートアクティブ化失敗:', error);
      showMessage('シートのアクティブ化に失敗しました', 'warning');
    });
}

// シートドロップダウンのアクティブ表示を更新
function updateSheetSelectActiveIndicator(activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) return;
  
  // 全てのオプションからアクティブ表示を削除
  Array.from(select.options).forEach(option => {
    if (option.value && option.textContent.includes(' (アクティブ)')) {
      option.textContent = option.value;
      option.style.fontWeight = 'normal';
      option.style.color = '';
      option.className = '';
    }
  });
  
  // 新しいアクティブシートに表示を追加
  const activeOption = Array.from(select.options).find(option => option.value === activeSheetName);
  if (activeOption) {
    activeOption.textContent = `${activeSheetName} (アクティブ)`;
    activeOption.style.fontWeight = 'bold';
    activeOption.style.color = '#10b981';
    activeOption.className = 'active-sheet-option';
  }
}

// 列選択をクリアする関数
function clearColumnSelections() {
  console.log('🧹 列選択をクリア');
  
  const columnSelects = [
    'opinion-column',
    'name-column', 
    'reason-column',
    'class-column',
    'timestamp-column'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.innerHTML = '<option value="">-- シートを選択してください --</option>';
      select.disabled = true;
    }
  });
}

// Load configuration for selected sheet - OPTIMIZED
function loadConfigForSelected(sheetName, spreadsheetId, retryCount = 0, maxRetries = 3) {
  console.log('📋 Loading config for:', { selectedSheet: sheetName, spreadsheetId: spreadsheetId, retry: retryCount });

  if (!spreadsheetId || !sheetName) {
    console.error('スプレッドシート情報が不足しています。');
    return Promise.reject(new Error('スプレッドシート情報が不足しています'));
  }

  return new Promise((resolve, reject) => {

  // Check if fresh save protection is active - skip cache if so
  const timeSinceFreshSave = Date.now() - (window.freshSaveTimestamp || 0);
  const isFreshSaveActive = timeSinceFreshSave < 30000; // 30 seconds
  
    // Check if we already have sheet details from integrated API
    if (!isFreshSaveActive && currentStatus && currentStatus.sheetDetails && 
        currentStatus.activeSheetName === sheetName && currentStatus.sheetDetails.allHeaders && currentStatus.sheetDetails.allHeaders.length > 0) {
      console.log('⚡ Using cached sheet details from integrated API');
      try {
        populateHeaderOptions(currentStatus.sheetDetails.allHeaders);
        console.log('✅ Header options populated from cache');
        populateConfig(currentStatus.sheetDetails.guessedConfig);
        console.log('✅ AI configuration applied from cache');
        resolve({ source: 'cache', headers: currentStatus.sheetDetails.allHeaders, config: currentStatus.sheetDetails.guessedConfig });
        return; // Early return - no API call needed
      } catch (error) {
        console.error('Error in cached config population:', error);
        // Fall through to API call if cache fails
      }
    }

  // Force fresh API call if fresh save protection is active or cache unavailable
  if (isFreshSaveActive) {
    console.log('🔄 Fresh save protection active - forcing API call for latest data');
  } else {
    console.log('📞 Making API call for sheet details:', sheetName);
  }
  
    runGasWithUserId('getSheetDetails', 'シート情報を取得中...', spreadsheetId, sheetName)
      .then(function(details) {
        console.log('✅ Sheet details loaded via API:', details);
        
        // If headers are empty, and we have retries left, try again after a delay
        if (details && (!details.allHeaders || details.allHeaders.length === 0) && retryCount < maxRetries) {
          console.warn(`⚠️ No headers found for ${sheetName}. Retrying in 2 seconds... (Attempt ${retryCount + 1}/${maxRetries})`);
          showMessage(`シート情報を再取得中... (${retryCount + 1}/${maxRetries})`, 'info');
          setTimeout(() => {
            loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
              .then(resolve)
              .catch(reject);
          }, 2000); // Retry after 2 seconds
          return;
        }

        try {
          populateHeaderOptions(details.allHeaders);
          console.log('✅ Header options populated from API');
          populateConfig(details.guessedConfig);
          console.log('✅ AI configuration applied from API');
          if (retryCount > 0) {
            showMessage('✅ シート情報が正常に読み込まれました！', 'success');
          }
          resolve({ source: 'api', headers: details.allHeaders, config: details.guessedConfig });
        } catch (error) {
          console.error('Error in API config population sequence:', error);
          showMessage('設定の適用中にエラーが発生しました', 'error');
          reject(error);
        }
      })
      .catch(function(error) {
        console.error('Failed to load sheet config via API:', error);
        
        // より詳細なエラーメッセージの表示
        let errorMessage = 'シート設定の読み込みに失敗しました';
        
        if (error && error.message) {
          if (error.message.includes('が見つかりません')) {
            errorMessage = `指定されたシート "${sheetName}" が見つかりません。`;
          } else if (error.message.includes('ヘッダーが見つかりません')) {
            errorMessage = `シート "${sheetName}" の1行目にヘッダーが見つかりません。`;
          } else if (error.message.includes('アクセス権限')) {
            errorMessage = 'スプレッドシートへのアクセス権限がありません。管理者にお問い合わせください。';
          } else if (error.message.includes('SheetsService')) {
            errorMessage = 'Google Sheets APIサービスでエラーが発生しました。しばらく時間をおいて再試行してください。';
          } else {
            errorMessage = `エラーの詳細: ${error.message}`;
          }
        }
        
        showMessage(errorMessage, 'error');
        
        // エラー時のリトライオプションを提供
        if (retryCount < maxRetries) {
          setTimeout(() => {
            const retryButton = document.createElement('button');
            retryButton.textContent = '再試行';
            retryButton.className = 'ml-2 px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
            retryButton.onclick = () => {
              retryButton.remove();
              loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            };
            
            const messageElement = document.querySelector('.message');
            if (messageElement) {
              messageElement.appendChild(retryButton);
            }
          }, 1000);
        } else {
          reject(error);
        }
      });
  }); // Promise終了
}


// =============================================================================
// SETUP STATUS HANDLING FUNCTIONS
// =============================================================================

/**
 * userInfoからsetupStatusを安全に取得
 * @param {Object} userInfo - ユーザー情報オブジェクト
 * @returns {string} setupStatus ('pending', 'completed', 'error')
 */
function getSetupStatusFromUserInfo(userInfo) {
  try {
    if (!userInfo || !userInfo.configJson) {
      return 'pending'; // ユーザー情報がない場合はセットアップ未完了とみなす
    }

    const config = typeof userInfo.configJson === 'string'
      ? JSON.parse(userInfo.configJson)
      : userInfo.configJson;

    // setupStatusが明示的に設定されている場合はそれを使用
    if (config.setupStatus) {
      console.log('🔧 configJson setupStatus:', config.setupStatus);
      return config.setupStatus;
    }
    
    // setupStatusがない場合、他のフィールドから推測（循環参照回避）
    // Note: この推測ロジックは循環参照を避けるため、formUrlベースに変更
    if (config.formCreated === true && config.formUrl && config.formUrl.trim()) {
      return 'completed';
    }
    
    return 'pending';
    
  } catch (error) {
    console.warn('getSetupStatusFromUserInfo JSON解析エラー:', error.message);
    return 'pending'; // エラー時はセットアップ未完了とみなす
  }
}


/**
 * 初期表示要素をクリアして適切なドメイン表示に切り替え
 */
function clearInitialDisplayElements() {
  // 初期表示を非表示にして、適切なドメイン表示に切り替え
  const initialContainer = document.getElementById('header-domain-initial');
  if (initialContainer) {
    initialContainer.style.display = 'none';
    console.log('✅ 初期ドメイン表示を非表示');
  }
  
  // 適切なドメイン情報を表示
  showAppropriateHeaderStatus();
  
  // 既存のセットアップガイドのみ削除
  const existingGuides = [
    document.getElementById('setup-pending-guide'),
    document.querySelector('.setup-guide')
  ];
  
  existingGuides.forEach(guide => {
    if (guide) {
      guide.remove();
      console.log('✅ 既存セットアップガイドを削除');
    }
  });
}

/**
 * ヘッダーに適切なステータス表示を設定
 */
function showAppropriateHeaderStatus() {
  // ドメイン一致表示（仮）を表示
  const domainMatch = document.getElementById('header-domain-match');
  const domainMismatch = document.getElementById('header-domain-mismatch');
  
  if (domainMatch && domainMismatch) {
    // 現在はドメイン一致として表示（実際のドメインチェックは別途実装）
    domainMatch.style.display = 'block';
    domainMismatch.style.display = 'none';
    
    // ドメイン名を適切に設定
    const domainText = document.getElementById('header-domain-match-text');
    if (domainText) {
      domainText.textContent = 'naha-okinawa.ed.jp';
    }
    
    console.log('✅ ドメイン一致表示を有効化');
  }
}

// ドメイン表示を更新するヘルパー関数
function updateDomainDisplay(type, domainText, statusText) {
  const initialDiv = document.getElementById('header-domain-initial');
  const matchDiv = document.getElementById('header-domain-match');
  const mismatchDiv = document.getElementById('header-domain-mismatch');

  if (initialDiv) initialDiv.classList.add('hidden');
  if (matchDiv) matchDiv.classList.add('hidden');
  if (mismatchDiv) mismatchDiv.classList.add('hidden');

  if (type === 'match' && matchDiv) {
    matchDiv.classList.remove('hidden');
    const textEl = document.getElementById('header-domain-match-text');
    if (textEl) textEl.textContent = domainText;
  } else if (type === 'mismatch' && mismatchDiv) {
    mismatchDiv.classList.remove('hidden');
    const textEl = document.getElementById('header-domain-mismatch-text');
    if (textEl) textEl.textContent = domainText;
  } else if (initialDiv) {
    initialDiv.classList.remove('hidden');
    const domainEl = document.getElementById('header-domain-name-initial');
    const statusEl = document.getElementById('header-status-text-initial');
    if (domainEl) domainEl.textContent = domainText;
    if (statusEl) statusEl.textContent = statusText;
  }
}

/**
 * セットアップ状況に応じてボタン状態を更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateButtonStatesForSetup(status) {
  // より穏やかなUI制御（完全無効化ではなく、適切なガイダンス）
  
  // 最低限無効化すべき公開関連ボタンのみ
  const criticalPublishButtons = [
    'save-publish-btn',
    'unpublish-board-btn'
  ];
  
  criticalPublishButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      // データが不足している場合のみ無効化
      const hasSpreadsheet = status.userInfo && status.userInfo.spreadsheetId;
      const hasActiveSheet = status.activeSheetName;
      
      if (!hasSpreadsheet || !hasActiveSheet) {
        button.disabled = true;
        button.classList.add('opacity-75');
        button.title = '先にデータソースとシートを設定してください';
      } else {
        button.disabled = false;
        button.classList.remove('opacity-75');
        button.title = '';
      }
    }
  });
  
  console.log('✅ ボタン状態を適切に更新しました');
}


/**
 * 基本的な静的UI要素のみ更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateBasicStaticUI(status) {
  // ユーザー情報など最低限の情報のみ更新
  if (status.userInfo) {
    // 既存のupdateDatabaseInfo関数を使用して重複を避ける
    updateDatabaseInfo(status);
  }
}

// Update system status display
function updateSystemStatusDisplay(status) {
  if (!status) return;
  
  // Update publish status
  const publishIndicator = document.getElementById('info-publish-indicator');
  const publishText = document.getElementById('info-publish-text');
  
  if (status.isPublished) {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-green-400';
    publishText.textContent = '公開中';
  } else {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-gray-400';
    publishText.textContent = '非公開';
  }
  
  // Update other status fields
  document.getElementById('info-published-sheet').textContent = status.sheetName || '-';
  document.getElementById('info-display-mode').textContent = status.displayMode || '-';
  document.getElementById('info-show-counts').textContent = status.showCounts ? '表示' : '非表示';
  document.getElementById('info-answer-count').textContent = status.answerCount || '0';
  document.getElementById('info-reaction-count').textContent = status.reactionCount || '0';
  
  // Enable resource buttons if URLs are available
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
  const formBtn = document.getElementById('open-form-btn');
  const resourceBtn = document.getElementById('open-resource-btn');
  
  if (status.spreadsheetUrl) {
    if (spreadsheetBtn) {
      spreadsheetBtn.disabled = false;
      spreadsheetBtn.onclick = () => window.open(status.spreadsheetUrl, '_blank');
    }
  }

  // フォームURLの取得（複数ソースから）
  let formUrl = null;
  
  // 1. configJsonから取得
  if (status.userInfo && status.userInfo.configJson) {
    try {
      const configJson = typeof status.userInfo.configJson === 'string' 
        ? JSON.parse(status.userInfo.configJson) 
        : status.userInfo.configJson;
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        console.log('✅ FormURL found in configJson:', formUrl);
      }
    } catch (error) {
      console.warn('⚠️ configJson parse error:', error);
    }
  }
  
  // 2. userInfo.formUrlから取得（フォールバック）
  if (!formUrl && status.userInfo && status.userInfo.formUrl) {
    formUrl = status.userInfo.formUrl;
    console.log('📋 FormURL found in userInfo:', formUrl);
  }
  
  // 3. customFormInfoから取得（後方互換性）
  if (!formUrl && status.customFormInfo && status.customFormInfo.formUrl) {
    formUrl = status.customFormInfo.formUrl;
    console.log('📄 FormURL found in customFormInfo:', formUrl);
  }
  
  // statusオブジェクトにformUrlを設定
  status.formUrl = formUrl;

  if (status.formUrl) { // statusオブジェクトにformUrlが存在する場合
    if (formBtn) {
      formBtn.disabled = false;
      // onclick は既に adminPanel-events.js で openForm 関数が設定されているため、
      // ここでは disabled 状態とスタイルのみを制御
      formBtn.title = 'フォームを開く';
      formBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      console.log('✅ Form button enabled with URL:', status.formUrl);
    }
  } else { // formUrlが存在しない場合、ボタンを無効化し、メッセージを表示
    if (formBtn) {
      formBtn.disabled = true;
      // onclick イベントは既存のものを保持（openForm関数）
      formBtn.title = 'フォームURLが未設定です。フォームを作成してください。';
      formBtn.classList.add('opacity-50', 'cursor-not-allowed');
      console.log('⚠️ Form button disabled - no URL available');
    }
  }
  
  // Handle generic resource button in Step 1 (spreadsheet only)
  if (resourceBtn && status.spreadsheetUrl) {
    resourceBtn.disabled = false;
    resourceBtn.onclick = () => {
      window.open(status.spreadsheetUrl, '_blank');
    };
    
    // Update button title for spreadsheet only
    resourceBtn.title = 'スプレッドシートを開く';
  }
}

// Navigate to specific step
function navigateToStep(step) {
  currentStep = step;
  
  // Update step indicators
  document.querySelectorAll('.step-indicator').forEach((indicator, index) => {
    const stepNumber = index + 1;
    indicator.classList.toggle('completed', stepNumber < step);
    indicator.classList.toggle('active', stepNumber === step);
  });
  
  // Show/hide step content
  document.querySelectorAll('.step-content').forEach((content, index) => {
    const stepNumber = index + 1;
    content.classList.toggle('hidden', stepNumber !== step);
  });
  
  // Update progress bar
  const progressBar = document.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.width = `${(step / 3) * 100}%`;
  }
  
  validateCurrentStep();
}


// セットアップ状況をグローバルステータスから取得




// Validate configuration
function validateConfiguration() {
  if (!currentConfig || !currentConfig.columnMappings) return false;
  
  const mappings = currentConfig.columnMappings;
  const hasContent = Object.values(mappings).includes('content');
  const hasAuthor = Object.values(mappings).includes('author');
  
  return hasContent && hasAuthor;
}


// =============================================================================
// HISTORY MANAGEMENT FUNCTIONS
// =============================================================================

// 履歴管理の定数
const HISTORY_STORAGE_KEY = 'answerBoardHistory';
const MAX_HISTORY_ITEMS = 10;

/**
 * 回答ボードの履歴を保存
 * @param {Object} historyItem - 保存する履歴アイテム
 */
function saveToHistory(historyItem) {
  try {
    if (!historyItem || !historyItem.questionText) {
      logWarn('Invalid history item, skipping save');
      return;
    }

    const history = getHistoryFromStorage();
    
    // 新しいアイテムを先頭に追加
    const newItem = {
      id: generateHistoryId(),
      timestamp: new Date().toISOString(),
      publishedAt: historyItem.publishedAt || new Date().toISOString(),
      publishedEndAt: historyItem.publishedEndAt || null,
      // 新しいフィールド: 終了関連
      endTime: historyItem.endTime || null, // 実際の終了日時（終了時に記録）
      scheduledEndTime: historyItem.scheduledEndTime || null, // 予定終了日時
      questionText: historyItem.questionText,
      sheetName: historyItem.sheetName || '',
      answerCount: historyItem.answerCount || 0,
      reactionCount: historyItem.reactionCount || 0,
      config: historyItem.config || {},
      formUrl: historyItem.formUrl || '',
      spreadsheetUrl: historyItem.spreadsheetUrl || '',
      setupType: historyItem.setupType || 'unknown', // クイックスタート、カスタムセットアップ、外部リソースを識別
      isActive: historyItem.isActive || false // 現在公開中かどうか
    };
    
    history.unshift(newItem);
    
    // 最大数を超えた場合は古いものを削除
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }
    
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    logDebug('History saved:', newItem);
    
    // UI を更新
    loadSimpleHistoryTable();
    
  } catch (error) {
    logWarn('Failed to save history:', error);
  }
}

/**
 * 履歴を localStorage から取得
 * @returns {Array} 履歴配列
 */
function getHistoryFromStorage() {
  try {
    const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
    return historyJson ? JSON.parse(historyJson) : [];
  } catch (error) {
    logWarn('Failed to parse history from storage:', error);
    return [];
  }
}

/**
 * 履歴用のユニークIDを生成
 * @returns {string} ユニークID
 */
function generateHistoryId() {
  return 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// 旧来のカード形式の履歴表示は削除 - 簡単なテーブル形式のみ使用

/**
 * 簡単な履歴テーブルを表示（新実装）
 */
/**
 * サーバーから履歴を同期してLocalStorageに保存
 */
async function syncHistoryFromServer() {
  try {
    console.log('🔄 サーバーから履歴を同期中...');
    
    const response = await runGasWithUserId('getHistoryFromServerAPI', 'サーバーから履歴を取得中...');
    
    if (response && response.status === 'success' && Array.isArray(response.historyArray)) {
      // サーバーからの履歴をLocalStorageに保存
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(response.historyArray));
      console.log('✅ サーバーから履歴を同期しました:', response.count, '件');
      return response.historyArray;
    } else {
      console.warn('⚠️ サーバーからの履歴取得で警告:', response);
      return [];
    }
  } catch (error) {
    console.error('❌ サーバー履歴同期エラー:', error);
    return [];
  }
}

function loadSimpleHistoryTable() {
  const tableBody = document.getElementById('history-table-body');
  
  if (!tableBody) return;
  
  const history = getHistoryFromStorage();
  
  // テーブルをクリア
  tableBody.innerHTML = '';
  
  if (history.length === 0) {
    // 履歴が空の場合
    const emptyRow = document.createElement('tr');
    emptyRow.innerHTML = `
      <td colspan="4" class="px-3 py-4 text-center text-gray-500 text-sm">
        履歴がありません
      </td>
    `;
    tableBody.appendChild(emptyRow);
    return;
  }
  
  // 履歴アイテムをテーブル行として表示
  history.forEach((item, index) => {
    const row = createHistoryTableRow(item, index);
    tableBody.appendChild(row);
  });
}

/**
 * 履歴テーブル行を作成
 * @param {Object} item - 履歴アイテム
 * @param {number} index - インデックス
 * @returns {HTMLElement} テーブル行要素
 */
function createHistoryTableRow(item, index) {
  const row = document.createElement('tr');
  
  // 公開中の項目は緑色のハイライト
  const isActive = item.isActive || (!item.endTime && item.publishedAt);
  row.className = isActive 
    ? 'hover:bg-green-700/20 cursor-pointer transition-colors bg-green-900/10' 
    : 'hover:bg-gray-700/30 cursor-pointer transition-colors';
  
  row.onclick = () => selectHistoryItem(item.id);
  
  const formatDateTime = (dateString) => {
    if (!dateString) return '未設定';
    const date = new Date(dateString);
    return date.toLocaleString('ja-JP', {
      year: '2-digit',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  // 回答形式の表示ロジック
  const getAnswerFormatDisplay = (item) => {
    // configから回答形式を判定
    if (item.config) {
      const config = item.config;
      if (config.showNames && config.showCounts) {
        return `<span class="text-blue-400">名前・数</span>`;
      } else if (config.showNames) {
        return `<span class="text-green-400">名前表示</span>`;
      } else if (config.showCounts) {
        return `<span class="text-purple-400">数表示</span>`;
      } else {
        return `<span class="text-gray-400">標準</span>`;
      }
    }
    // configがない古いデータの場合
    return `<span class="text-gray-500">不明</span>`;
  };
  
  // 活動状況インジケーター
  const statusIndicator = isActive 
    ? `<div class="w-2 h-2 bg-green-400 rounded-full animate-pulse inline-block mr-2"></div>`
    : `<div class="w-2 h-2 bg-gray-500 rounded-full inline-block mr-2"></div>`;
  
  row.innerHTML = `
    <td class="px-3 py-2 text-xs text-gray-300">${statusIndicator}${formatDateTime(item.publishedAt)}</td>
    <td class="px-3 py-2 text-xs text-gray-300 truncate" title="${escapeHtml(item.questionText)}">${escapeHtml(item.questionText)}</td>
    <td class="px-3 py-2 text-xs text-center">${getAnswerFormatDisplay(item)}</td>
    <td class="px-3 py-2 text-xs text-center ${isActive ? 'text-green-400 font-medium' : 'text-gray-300'}">${item.answerCount || 0}</td>
  `;
  
  return row;
}

/**
 * 履歴選択時の自動フロー処理
 * @param {string} historyId - 履歴ID
 */
function selectHistoryItem(historyId) {
  try {
    const history = getHistoryFromStorage();
    const item = history.find(h => h.id === historyId);
    
    if (!item) {
      showMessage('履歴アイテムが見つかりませんでした', 'error');
      return;
    }
    
    // 自動でシートを選択
    if (item.sheetName) {
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        sheetSelect.value = item.sheetName;
        selectedSheet = item.sheetName;
        
        // シート選択イベントを発生させてプレビューを読み込み
        const changeEvent = new Event('change', { bubbles: true });
        sheetSelect.dispatchEvent(changeEvent);
      }
    }
    
    // 設定を復元
    if (item.config) {
      setTimeout(() => {
        restoreConfigFromHistory(item.config);
        
        // Step 3の表示設定セクションに移動
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 現在のステップを3に更新
        updateStepIndicators(3);
        manageSectionStates(3);
        
        showMessage(`「${item.questionText}」の設定を復元しました`, 'success');
      }, 500); // シート選択処理の完了を待つ
    }
    
  } catch (error) {
    logError('Failed to select history item:', error);
    showMessage('履歴の選択に失敗しました', 'error');
  }
}

/**
 * 履歴から設定を復元
 * @param {Object} config - 設定オブジェクト
 */
function restoreConfigFromHistory(config) {
  try {
    // フォーム設定の復元
    if (config.opinionHeader) {
      const opinionSelect = document.getElementById('opinionHeader');
      if (opinionSelect) opinionSelect.value = config.opinionHeader;
    }
    
    if (config.nameHeader) {
      const nameSelect = document.getElementById('name-column');
      if (nameSelect) nameSelect.value = config.nameHeader;
    }
    
    if (config.classHeader) {
      const classSelect = document.getElementById('class-column');
      if (classSelect) classSelect.value = config.classHeader;
    }
    
    if (config.reasonHeader) {
      const reasonSelect = document.getElementById('reason-column');
      if (reasonSelect) reasonSelect.value = config.reasonHeader;
    }
    
    // チェックボックスの復元
    const showNamesCheckbox = document.getElementById('show-names');
    if (showNamesCheckbox) showNamesCheckbox.checked = config.showNames || false;
    
    const showCountsCheckbox = document.getElementById('show-counts');
    if (showCountsCheckbox) showCountsCheckbox.checked = config.showCounts || false;
    
    // 設定ボタンの状態を更新
    updateConfigButtons();
    
  } catch (error) {
    logError('Failed to restore config from history:', error);
  }
}

// createHistoryItemElement関数は削除 - テーブル形式のcreateHistoryTableRowを使用

/**
 * HTMLエスケープ関数
 * @param {string} text - エスケープするテキスト
 * @returns {string} エスケープされたテキスト
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// 旧来の複雑な履歴管理関数群は削除 - selectHistoryItem()による自動フローのみ使用

// =============================================================================
// CONFIG JSON 正規化・修復システム
// =============================================================================

/**
 * configJsonの整合性を確保し、矛盾した状態を修復する
 * @param {Object} config - 修復対象のconfig
 * @param {Object} userInfo - ユーザー情報
 * @return {Object} 正規化されたconfig
 */
// [DEPRECATED] 統一スキーマのgetConfigJSON()に置き換えられました

/**
 * 冗長フィールドの削除（データ整合性向上）
 * @param {Object} config - 対象config
 * @return {Object} クリーンアップされたconfig
 */
function removeRedundantFields(config) {
  const cleanConfig = { ...config };
  
  // setupStepは計算プロパティのため、保存済みの値を削除
  delete cleanConfig.setupStep;
  
  console.log('🧹 冗長フィールド削除: setupStep');
  
  return cleanConfig;
}

/**
 * ConfigJsonの整合性検証機能（フロントエンド専用）
 * @param {Object} config - 検証対象のconfig
 * @param {Object} userInfo - ユーザー情報
 */
function validateConfigJsonIntegrity(config, userInfo) {
  if (!config || !userInfo) {
    console.warn('⚠️ 整合性検証: 無効なパラメータ');
    return;
  }
  
  const setupStatus = config.setupStatus || 'pending';
  const formCreated = !!config.formCreated;
  const appPublished = !!config.appPublished;
  const hasFormUrl = !!(config.formUrl && config.formUrl.trim());
  const hasPublishedSheet = !!(config.publishedSheetName && config.publishedSheetName.trim());
  const hasSpreadsheet = !!(userInfo.spreadsheetId && userInfo.spreadsheetId.trim());
  
  console.group('🔍 ConfigJson整合性検証');
  
  // 基本状態の表示
  console.log('📊 現在の状態:', {
    setupStatus,
    formCreated,
    appPublished,
    hasFormUrl,
    hasPublishedSheet,
    hasSpreadsheet
  });
  
  // 重要な不整合を検出
  const issues = [];
  
  if (setupStatus === 'completed' && !formCreated) {
    issues.push('❌ setupStatus=completedなのにformCreated=false');
  }
  
  if (formCreated && !hasFormUrl) {
    issues.push('❌ formCreated=trueなのにformUrlが未設定');
  }
  
  if (appPublished && !hasPublishedSheet) {
    issues.push('❌ appPublished=trueなのにpublishedSheetNameが未設定');
  }
  
  if (!hasSpreadsheet && (setupStatus === 'completed' || formCreated || appPublished)) {
    issues.push('❌ データソース未設定なのに高度な設定が有効');
  }
  
  // setupStepが保存されている場合の警告
  if (config.setupStep !== undefined) {
    issues.push('⚠️ setupStepがconfigJsonに保存されています（冗長）');
  }
  
  // 結果表示
  if (issues.length === 0) {
    console.log('✅ 整合性検証完了: 問題なし');
  } else {
    console.warn('⚠️ 整合性問題検出:', issues);
  }
  
  console.groupEnd();
}

/**
 * publishedSheetName修復関数
 * @param {Object} config - 修復対象のconfig
 * @return {Object} 修復されたconfig
 */
function fixPublishedSheetName(config) {
  // publishedSheetNameが空文字または未定義で、sheet固有設定が存在する場合
  if ((!config.publishedSheetName || config.publishedSheetName.trim() === '') && 
      config.publishedSpreadsheetId) {
    
    // sheet_で始まるキーを検索
    const sheetKeys = Object.keys(config).filter(key => key.startsWith('sheet_'));
    
    if (sheetKeys.length > 0) {
      // 最初に見つかったシート名を使用
      const detectedSheetName = sheetKeys[0].replace('sheet_', '');
      config.publishedSheetName = detectedSheetName;
      
      console.log('🔧 publishedSheetName修復:', {
        検出されたシート名: detectedSheetName,
        利用可能なシート設定: sheetKeys
      });
    }
  }
  
  return config;
}





/**
 * グローバル列設定を最新のシート設定と同期
 * @param {Object} config - 同期対象のconfig
 * @return {Object} 同期されたconfig
 */
function syncGlobalColumnSettings(config) {
  if (!config.publishedSheetName) {
    return config; // シート名が不明な場合はスキップ
  }
  
  const sheetConfigKey = `sheet_${config.publishedSheetName}`;
  const sheetConfig = config[sheetConfigKey];
  
  if (sheetConfig && typeof sheetConfig === 'object') {
    // シート固有設定をグローバル設定に同期
    config.opinionHeader = sheetConfig.opinionHeader || config.opinionHeader || '';
    config.nameHeader = sheetConfig.nameHeader || config.nameHeader || '';
    config.reasonHeader = sheetConfig.reasonHeader || config.reasonHeader || '';
    config.classHeader = sheetConfig.classHeader || config.classHeader || '';
    config.timestampHeader = sheetConfig.timestampHeader || config.timestampHeader || '';
    
    // フォームURL同期 - シート固有のformUrlをグローバル設定に同期
    if (sheetConfig.formUrl) {
      config.formUrl = sheetConfig.formUrl;
      console.log('🔗 フォームURL同期:', {
        シート名: config.publishedSheetName,
        フォームURL: config.formUrl
      });
    }
    
    console.log('🔧 グローバル列設定同期完了:', {
      シート名: config.publishedSheetName,
      メイン質問: config.opinionHeader,
      名前列: config.nameHeader
    });
  }
  
  return config;
}

/**
 * 必須フィールドの補完
 * @param {Object} config - 補完対象のconfig
 * @return {Object} 補完されたconfig
 */
function ensureRequiredFields(config) {
  const defaults = {
    showNames: false,
    showCounts: false,
    highlightMode: false,
    autoStopEnabled: true,
    autoStopMinutes: 360
  };
  
  Object.keys(defaults).forEach(key => {
    if (config[key] === undefined) {
      config[key] = defaults[key];
    }
  });
  
  return config;
}


/**
 * 公開済み状態用configJson修復関数
 * @param {Object} config - 修復対象のconfig
 * @return {Object} 修復されたconfig
 */
function fixConfigForPublishedState(config) {
  const fixedConfig = { ...config };
  
  // 公開済み状態の必須フィールドを修復
  if (fixedConfig.setupStatus !== 'completed') {
    console.log('🔧 setupStatusをpendingからcompletedに修復');
    fixedConfig.setupStatus = 'completed';
  }
  
  if (!fixedConfig.formCreated) {
    console.log('🔧 formCreatedをfalseからtrueに修復');
    fixedConfig.formCreated = true;
  }
  
  if (!fixedConfig.appPublished) {
    console.log('🔧 appPublishedをfalseからtrueに修復');
    fixedConfig.appPublished = true;
  }
  
  // formUrlの仮置き（実際のフォームURLが不明な場合）
  if (!fixedConfig.formUrl || fixedConfig.formUrl.trim() === '') {
    console.log('🔧 formUrlを仮設定（公開済み状態維持用）');
    fixedConfig.formUrl = 'https://docs.google.com/temp-form-url'; // 仮ライセンスURL
  }
  
  return fixedConfig;
}


// 簡単な履歴テーブル初期化
document.addEventListener('DOMContentLoaded', function() {
  // 依存関数が利用可能になるまで待機してから実行
  function waitForDependencies(attempts = 0) {
    if (typeof runGasWithUserId === 'function') {
      // サーバーから履歴を同期してからテーブルを読み込み
      syncHistoryFromServer()
        .then(function(syncedHistory) {
          console.log('🔄 ページ読み込み時の履歴同期完了:', syncedHistory.length, '件');
          loadSimpleHistoryTable();
        })
        .catch(function(syncError) {
          console.warn('⚠️ ページ読み込み時の履歴同期に失敗、ローカルデータで表示:', syncError);
          loadSimpleHistoryTable();
        });
      return;
    }
    
    if (attempts < 20) { // 最大2秒待機
      console.log('⏳ runGasWithUserId関数の読み込み待機中...');
      setTimeout(() => waitForDependencies(attempts + 1), 100);
      return;
    }
    
    // タイムアウト後はローカルデータのみで動作
    console.warn('⚠️ runGasWithUserId関数が利用できません。ローカルデータのみで表示します。');
    loadSimpleHistoryTable();
  }
  
  waitForDependencies();
});

// 初期化は adminPanel-core.js の統合初期化システムで管理されます
</script>
