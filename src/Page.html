<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>StudyQuest - みんなのかいとうボード</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"></noscript>
<link rel="dns-prefetch" href="//script.google.com">
<link rel="preconnect" href="https://script.google.com" crossorigin>
<script src="https://cdn.tailwindcss.com" defer></script>
<script>
const __SHOW_COUNTS__ = '<?= typeof showCounts !== "undefined" ? showCounts : false ?>';
const __DISPLAY_MODE__ = '<?= typeof displayMode !== "undefined" ? displayMode : "anonymous" ?>';
const __SHEET_NAME__ = '<?= typeof sheetName !== "undefined" ? sheetName : "" ?>';
const __MAPPING__ = '<?= typeof mapping !== "undefined" ? JSON.stringify(mapping) : "{}" ?>';
const __USER_ID__ = '<?= typeof userId !== "undefined" ? userId : "" ?>';
const __OWNER_NAME__ = '<?= typeof ownerName !== "undefined" ? ownerName : "" ?>';
const __SHOW_ADMIN_FEATURES__ = '<?= typeof showAdminFeatures !== "undefined" ? showAdminFeatures : false ?>';
const __SHOW_HIGHLIGHT_TOGGLE__ = '<?= typeof showHighlightToggle !== "undefined" ? showHighlightToggle : false ?>';
const __SHOW_SCORE_SORT__ = '<?= typeof showScoreSort !== "undefined" ? showScoreSort : false ?>';
const __IS_STUDENT_MODE__ = '<?= typeof isStudentMode !== "undefined" ? isStudentMode : true ?>';
const __IS_ADMIN_USER__ = '<?= typeof isAdminUser !== "undefined" ? isAdminUser : false ?>';
window.showCounts = __SHOW_COUNTS__.startsWith('<') ? false : __SHOW_COUNTS__ === 'true';
window.displayMode = __DISPLAY_MODE__.startsWith('<') ? 'anonymous' : __DISPLAY_MODE__;
window.showAdminFeatures = __SHOW_ADMIN_FEATURES__.startsWith('<') ? false : __SHOW_ADMIN_FEATURES__ === 'true';
window.showHighlightToggle = __SHOW_HIGHLIGHT_TOGGLE__.startsWith('<') ? false : __SHOW_HIGHLIGHT_TOGGLE__ === 'true';
window.showScoreSort = __SHOW_SCORE_SORT__.startsWith('<') ? false : __SHOW_SCORE_SORT__ === 'true';
window.isStudentMode = __IS_STUDENT_MODE__.startsWith('<') ? true : __IS_STUDENT_MODE__ === 'true';
window.isAdminUser = __IS_ADMIN_USER__.startsWith('<') ? false : __IS_ADMIN_USER__ === 'true';
const SHEET_NAME = __SHEET_NAME__.startsWith('<') ? 'テストシート' : __SHEET_NAME__;
const USER_ID = __USER_ID__.startsWith('<') ? '' : __USER_ID__;
const OWNER_NAME = __OWNER_NAME__.startsWith('<') ? '' : __OWNER_NAME__;
let MAPPING;
try {
  if (typeof __MAPPING__ === 'string' && !__MAPPING__.startsWith('<')) {
    MAPPING = JSON.parse(__MAPPING__);
  } else {
    MAPPING = {};
  }
} catch (e) {
  console.warn('Failed to parse MAPPING:', e);
  MAPPING = {};
}
</script>
<style>
:root {
  --color-primary: #8be9fd;
  --color-background: #1a1b26;
  --color-surface: rgba(26, 27, 38, 0.95);
  --color-text: #c0caf5;
  --color-border: rgba(255, 255, 255, 0.1);
  --color-accent: #facc15;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.15);
  --color-success: #10b981;
  --color-error: #ef4444;
  --color-warning: #f59e0b;
  /* Performance variables */
  --transition-duration: 0.2s;
  --transition-easing: ease-out;
  --animation-duration: 0.3s;
  --backdrop-blur: 12px;
}
body {
  color: var(--color-text);
  background-color: var(--color-background);
  margin: 0;
  overflow-x: hidden;
}
.glass-panel { 
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  backdrop-filter: blur(var(--backdrop-blur));
  -webkit-backdrop-filter: blur(var(--backdrop-blur));
  transition: border-color var(--transition-duration) var(--transition-easing);
}
.glass-panel:hover {
  border-color: rgba(255, 255, 255, 0.2);
}
.game-font {
  font-family: 'Press Start 2P', cursive;
}
.game-btn {
  transition: transform var(--transition-duration) var(--transition-easing),
              box-shadow var(--transition-duration) var(--transition-easing),
              border-bottom-width var(--transition-duration) var(--transition-easing);
  border-radius: 0.75rem;
  border-bottom-width: 4px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
  position: relative;
  overflow: hidden;
}
.game-btn:not(:disabled):hover { 
  transform: translate3d(0, -2px, 0); 
  box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}
.game-btn:active:not(:disabled) { 
  transform: translate3d(0, 2px, 0); 
  border-bottom-width: 2px; 
}
.game-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}
#classFilter, #sortOrder { 
  background-color: #6272a4; 
  border: 1px solid var(--color-border); 
  color: var(--color-text); 
  border-radius: 0.75rem; 
  padding: 0.5rem 0.75rem; 
  transition: border-color var(--transition-duration) var(--transition-easing),
              box-shadow var(--transition-duration) var(--transition-easing);
}
#classFilter:focus, #sortOrder:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(139, 233, 253, 0.1);
}
:focus-visible { 
  outline: 3px solid var(--color-primary); 
  outline-offset: 2px; 
  border-radius: 0.75rem; 
}
header { 
  position: sticky; 
  top: 0; 
  z-index: 50; 
  contain: layout;
  backdrop-filter: blur(var(--backdrop-blur));
  -webkit-backdrop-filter: blur(var(--backdrop-blur));
}
.answer-card { 
  transition: transform var(--animation-duration) var(--transition-easing),
              box-shadow var(--animation-duration) var(--transition-easing);
  border-radius: 1rem;
  contain: layout style;
  position: relative;
  overflow: hidden;
}
.answer-card.highlighted {
  border: 4px solid var(--color-accent) !important;
  box-shadow: 0 0 20px rgba(250,204,21,0.4);
  transform: scale(1.02);
}
.answer-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 12px 24px rgba(0,0,0,0.2);
}
.answer-card.loading {
  opacity: 0.7;
  pointer-events: none;
}
.reaction-btn {
  transition: transform var(--transition-duration) var(--transition-easing),
              background-color var(--transition-duration) var(--transition-easing),
              box-shadow var(--transition-duration) var(--transition-easing);
  position: relative;
  overflow: hidden;
}
.reaction-btn:hover {
  transform: scale(1.1);
}
.reaction-btn:active {
  transform: scale(0.95);
}
.reaction-btn.reacted {
  background-color: var(--color-primary) !important;
  color: #000 !important;
  box-shadow: 0 0 10px rgba(139, 233, 253, 0.5);
}
.reaction-btn.loading {
  opacity: 0.6;
  pointer-events: none;
}
.fade-in {
  animation: fadeIn 0.5s ease-out;
}
.slide-in {
  animation: slideIn 0.3s ease-out;
}
.pulse {
  animation: pulse 0.6s ease-out;
}
.shake {
  animation: shake 0.5s ease-out;
}
.admin-toggle {
  transition: background-color var(--animation-duration) var(--transition-easing);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.admin-toggle:hover {
  background-color: rgba(139, 233, 253, 0.1);
}
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(26, 27, 38, 0.8);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(139, 233, 253, 0.3);
  border-top: 4px solid var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes fadeIn {
  from { opacity: 0; will-change: opacity; }
  to { opacity: 1; }
}
@keyframes slideIn {
  from { opacity: 0; will-change: opacity; }
  to { opacity: 1; }
}
@keyframes pulse {
  0% { will-change: transform; }
  50% { transform: scale3d(1.05, 1.05, 1); }
  100% { transform: scale3d(1, 1, 1); }
}
@keyframes shake {
  0%, 100% { will-change: transform; }
  25% { transform: translate3d(-5px, 0, 0); }
  75% { transform: translate3d(5px, 0, 0); }
}
@keyframes spin {
  100% { transform: rotate(360deg); will-change: transform; }
}

/* Performance optimizations */
@media (max-width: 768px) and (max-resolution: 150dpi) {
  :root {
    --backdrop-blur: 0px;
    --transition-duration: 0.1s;
    --animation-duration: 0.15s;
  }
  
  .glass-panel {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    background: var(--color-surface);
  }
  
  .answer-card:hover {
    transform: none;
  }
  
  .reaction-btn:hover {
    transform: scale(1.05);
  }
}

/* Low-end device optimizations */
@media (max-width: 768px), (max-resolution: 120dpi) {
  :root {
    --backdrop-blur: 0px;
    --transition-duration: 0.1s;
    --animation-duration: 0.1s;
  }
}

/* High refresh rate display optimizations */
@media (min-resolution: 120dpi) and (min-width: 1200px) {
  :root {
    --transition-duration: 0.15s;
    --animation-duration: 0.2s;
  }
}

/* Responsive improvements */
@media (max-width: 768px) {
  .answer-card {
    margin-bottom: 1rem;
  }
  .game-btn {
    padding: 0.75rem 1rem;
    font-size: 0.875rem;
  }
  header {
    padding: 1rem;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  :root {
    --color-border: rgba(255, 255, 255, 0.3);
    --color-surface: rgba(26, 27, 38, 0.98);
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  :root {
    --transition-duration: 0.01ms;
    --animation-duration: 0.01ms;
    --backdrop-blur: 0px;
  }
  
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    transform: none !important;
  }
  
  .answer-card:hover,
  .reaction-btn:hover,
  .game-btn:hover {
    transform: none !important;
  }
}

/* Low performance mode styles */
.low-performance .answer-card {
  contain: layout style paint;
}

.low-performance .answer-card:hover {
  transform: none;
  box-shadow: var(--shadow-sm);
}

.low-performance .glass-panel {
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
}

/* Hidden card styles for virtual scrolling */
.hidden-card {
  visibility: hidden;
  pointer-events: none;
}

.visible {
  visibility: visible;
  pointer-events: auto;
}

/* Optimize grid layout for performance */
@supports (container-type: inline-size) {
  #answers {
    container-type: inline-size;
  }
}

/* Optimize for high DPI displays */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .answer-card {
    backface-visibility: hidden;
    perspective: 1000px;
  }
}
.answer-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-md);
}
.answer-card.new-card {
  animation: fadeIn 0.3s ease-out;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.highlight-badge {
  position: absolute;
  top: 0.25rem;
  right: 0.25rem;
  width: 1.5rem;
  height: 1.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #facc15;
}
.answer-card.reaction-bg-like { border-color:#ef4444 !important; }
.answer-card.reaction-bg-understand { border-color:#fbbf24 !important; }
.answer-card.reaction-bg-curious { border-color:#10b981 !important; }
.answer-card.reaction-bg-like-understand { border-image: linear-gradient(45deg, #ef4444, #fbbf24) 1 !important; }
.answer-card.reaction-bg-like-curious { border-image: linear-gradient(45deg, #ef4444, #10b981) 1 !important; }
.answer-card.reaction-bg-understand-curious { border-image: linear-gradient(45deg, #fbbf24, #10b981) 1 !important; }
.answer-card.reaction-bg-like-understand-curious { border-image: linear-gradient(45deg, #ef4444, #fbbf24, #10b981) 1 !important; }
.reaction-border-1 { border-width: 2px; }
.reaction-border-2 { border-width: 4px; }
.reaction-border-3 { border-width: 6px; }
.answer-preview { display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; min-height: 120px; }
.like-btn svg { 
  transition: fill var(--transition-duration) var(--transition-easing),
              transform var(--transition-duration) var(--transition-easing);
  fill: none;
}
.like-btn.liked svg { stroke: transparent; fill: currentColor; transform: scale(1.1); }
.like-btn.loading { opacity: 0.7; position: relative; pointer-events: none; }
.like-btn.loading::after { 
  content: ""; 
  position: absolute; 
  inset: 0; 
  border: 2px solid transparent; 
  border-top: 2px solid currentColor; 
  border-radius: 50%; 
  animation: spin 0.8s linear infinite; 
  width: 16px; 
  height: 16px; 
  margin: auto; 
}
@keyframes spin { to { transform: rotate(360deg); } }
.highlight-btn { 
  transition: background var(--transition-duration) var(--transition-easing),
              transform var(--transition-duration) var(--transition-easing);
  border-radius: 4px;
  padding: 2px;
}
.highlight-btn:hover { 
  background: rgba(250, 204, 21, 0.1);
  transform: scale(1.1);
}
.highlight-btn.liked { color: #facc15; }
#controlsFooter { pointer-events: none; }
#controlsFooter > .glass-panel { pointer-events: auto; }
.skeleton { position: relative; overflow: hidden; background-color: rgba(255,255,255,0.05); }
.skeleton::after { content: ""; position: absolute; inset: 0; background-image: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.2), rgba(255,255,255,0)); animation: skeleton-loading 1.5s infinite; }
@keyframes skeleton-loading { 0% { transform: translate3d(-100%, 0, 0); will-change: transform; } 100% { transform: translate3d(100%, 0, 0); } }
.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
.modal-close-btn { transform: translate(50%, -50%); }
.render-optimized { transform: translateZ(0); }
.modal-fade { animation: modalFade 0.2s ease-out; }
@keyframes modalFade { from { opacity: 0; will-change: opacity; } to { opacity: 1; } }
.modal-scale { animation: modalScale 0.2s ease-out; }
@keyframes modalScale { from { will-change: transform; } to { transform: scale3d(1, 1, 1); } }
</style>
</head>
<body class="bg-[#1a1b26] text-gray-200 font-sans">
<!-- Loading Overlay -->
<div id="loading-overlay" class="loading-overlay hidden">
  <div class="text-center">
    <div class="spinner"></div>
    <p class="mt-4 text-gray-300">読み込み中...</p>
  </div>
</div>

<div id="main-container" class="w-full mx-auto px-4 pt-4 pb-4 md:px-6 md:pt-6 md:pb-6">
<header id="main-header" class="glass-panel rounded-xl p-4 mb-4 flex flex-col lg:flex-row justify-between items-center gap-4 shadow-lg fade-in">
  <!-- Left Section: Controls -->
  <div class="flex items-center gap-4 w-full lg:w-auto">
    <div id="answerCount" class="text-sm text-gray-400 flex items-center gap-2 flex-shrink-0">
      <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
      </svg>
      <span id="answerCountText">0 件の回答</span>
    </div>
    
    <div class="flex items-center gap-2">
      <label for="classFilter" class="sr-only">クラス絞り込み</label>
      <select id="classFilter" class="hidden text-sm bg-gray-700 border border-gray-600 rounded px-2 py-1"></select>
      
      <label for="sortOrder" class="sr-only">並び順</label>
      <div class="relative">
        <select id="sortOrder" class="text-sm bg-gray-700 border border-gray-600 rounded px-3 py-1 pr-8 appearance-none cursor-pointer">
          <option value="newest" selected>新着順</option>
          <option value="random">ランダム順</option>
          <option value="score" id="scoreOption" class="hidden">スコア順</option>
        </select>
        <svg class="absolute right-2 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-400 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </div>
    </div>
  </div>

  <!-- Center Section: Title -->
  <div class="flex-grow text-center w-full min-w-0 px-2">
    <h1 id="siteTitle" class="game-font text-yellow-300 text-base md:text-lg lg:text-xl mb-2 truncate flex items-center justify-center gap-2">
      <svg class="w-5 h-5 text-yellow-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
      </svg>
      みんなの回答ボード
    </h1>
    <div id="headingLabel" class="text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold text-pink-400 leading-tight flex justify-center items-center min-h-[2rem]">
      <svg class="w-5 h-5 md:w-6 md:h-6 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" fill="currentColor"></path>
      </svg>
    </div>
  </div>

  <!-- Right Section: Info & Admin Controls -->
  <div class="w-full lg:w-auto lg:min-w-[150px] text-right space-y-1 px-2">
    <p id="ownerNameText" class="text-xs text-gray-500 h-4 truncate flex items-center justify-end gap-1">
      <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
      </svg>
    </p>
    <p id="sheetNameText" class="text-xs text-gray-400 h-4 truncate flex items-center justify-end gap-1">
      <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
      </svg>
    </p>
    <p id="modeLabel" class="text-xs text-gray-400 truncate"></p>
    <div class="flex justify-end gap-1 flex-wrap">
      <button type="button" id="endPublicationBtn" class="admin-toggle text-xs bg-orange-600 hover:bg-orange-700 text-white px-3 py-1 rounded hidden whitespace-nowrap transition-all flex items-center gap-1" hidden aria-label="公開終了">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728L5.636 5.636m12.728 12.728L5.636 5.636"></path>
        </svg>
        公開終了
      </button>
      <button type="button" id="adminToggleBtn" class="admin-toggle text-xs text-gray-500 hover:text-cyan-400 transition-all opacity-60 hover:opacity-100 hidden whitespace-nowrap flex items-center gap-1 px-2 py-1 rounded" hidden aria-label="管理者モード切り替え">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
      </button>
    </div>
  </div>
</header>
<main id="answers" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" role="main" aria-live="polite" aria-label="回答一覧"></main>
</div>
<div id="answerModalContainer" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 hidden" role="dialog" aria-modal="true">
<div id="answerModalCard" class="glass-panel rounded-xl p-6 flex flex-col shadow-2xl border-2 border-cyan-400/80 w-full max-w-5xl h-auto max-h-[85vh] relative" role="document" aria-labelledby="modalAnswer">
<button type="button" id="answerModalCloseBtn" class="modal-close-btn absolute -top-3 -right-3 bg-red-600 rounded-full p-2 text-white hover:scale-110 transition-transform z-10" aria-label="閉じる">
  <span id="iconClose" class="w-6 h-6"></span>
</button>
<div id="modalAnswer" class="flex-grow min-h-[200px] mb-4 overflow-y-auto pr-4"></div>
<div id="modalFooter" class="text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex justify-between items-center">
<div><span id="modalStudentName" class="font-bold text-2xl text-gray-200"></span></div>
<div id="modalReactions" class="flex items-center gap-2"></div>
</div>
</div>
</div>
<div id="infoModalContainer" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 hidden" role="dialog" aria-modal="true">
<div id="infoModalCard" class="glass-panel rounded-xl p-6 shadow-2xl border-2 border-cyan-400/80 w-full max-w-lg relative" role="document">
<div class="space-y-4 text-gray-200 text-lg leading-relaxed">
<p>みんなの意見を気持ちよく共有するために、リアクションのしかたをおぼえよう！</p>
<ul class="space-y-2">
<li class="flex items-center gap-2"><span id="infoIconLike" class="w-5 h-5 text-red-400"></span>いいね：すてきだと思ったときに押そう</li>
<li class="flex items-center gap-2"><span id="infoIconUnderstand" class="w-5 h-5 text-yellow-400"></span>なるほど：参考になったときに押そう</li>
<li class="flex items-center gap-2"><span id="infoIconCurious" class="w-5 h-5 text-green-400"></span>きになる：もっと知りたいときに押そう</li>
</ul>
<p class="flex items-center gap-2"><span id="infoIconHighlight" class="w-5 h-5 text-yellow-300"></span>先生が注目してほしい意見につけています</p>
<p>責任あるリアクションで、みんなで学びを深めよう！</p>
<div class="text-center mt-6">
<button id="infoModalConfirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">わかった</button>
</div>
</div>
</div>
</div>
<footer id="controlsFooter" class="fixed bottom-0 left-0 right-0 z-40 p-4">
<div class="glass-panel max-w-md mx-auto rounded-xl p-3 flex items-center justify-center gap-3">
<input type="range" id="sizeSlider" min="2" max="6" value="4" class="w-1/2" aria-label="表示列数の変更">
<div class="flex items-center gap-1">
<span id="sliderValue" class="font-bold text-lg">4</span>
<span id="iconGrid" class="w-4 h-4"></span>
</div>
</div>
</footer>
<script>
// Optimize initial render
const RENDER_BATCH_SIZE = 10;
const VIEWPORT_BUFFER = 200; // Viewport buffer for virtual scrolling
const PERFORMANCE_BUDGET = 16; // Maximum ms per frame
const CHUNK_SIZE = 5; // DOM operations per chunk
const IDLE_TIMEOUT = 5000; // Idle timeout for cleanup
const ICONS = {
  'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
  'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
  'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
  'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
  'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
  'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
  'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star-solid': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
  'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
};

class UnifiedCache {
  constructor() {
    this.data = new Map();
    this.timestamps = new Map();
  }
  
  set(key, value, ttl = 300000) { // 5分のデフォルトTTL
    this.data.set(key, value);
    this.timestamps.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (!this.data.has(key)) return undefined;
    
    const expiry = this.timestamps.get(key);
    if (expiry && Date.now() > expiry) {
      this.delete(key);
      return undefined;
    }
    
    return this.data.get(key);
  }
  
  has(key) {
    return this.get(key) !== undefined;
  }
  
  delete(key) {
    this.data.delete(key);
    this.timestamps.delete(key);
  }
  
  clear() {
    this.data.clear();
    this.timestamps.clear();
  }
  
  cleanup() {
    const now = Date.now();
    for (const [key, expiry] of this.timestamps.entries()) {
      if (now > expiry) {
        this.delete(key);
      }
    }
  }
  
  get size() {
    return this.data.size;
  }
}

class StudyQuestApp {
  constructor() {
    this.cache = new UnifiedCache();
    this.weakCache = new WeakMap(); // For DOM element caching
    this.performanceMetrics = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;
    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      modeLabel: document.getElementById('modeLabel'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      ownerNameText: document.getElementById('ownerNameText'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter')
    };
    // サーバーから渡された設定に基づいてモードラベルを設定
    if (this.elements.modeLabel) {
      this.elements.modeLabel.textContent = window.showAdminFeatures ? '管理モード' : '閲覧モード';
    }
    this.state = {
      currentAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      isStudentMode: window.isStudentMode,
      isAdminUser: window.isAdminUser,
      showCounts: window.showCounts,
      showAdminFeatures: window.showAdminFeatures,
      showHighlightToggle: window.isAdminUser, // 管理者なら常に表示
      showScoreSort: window.showScoreSort,
      displayMode: window.displayMode,
      sheetName: SHEET_NAME
    };
    this.serverShowCounts = window.showCounts;
    this.serverDisplayMode = window.displayMode;
    this.pollingInterval = null;
    this.handlers = {};
    this.adminModeVerified = false; // 管理モード切り替え時の権限確認フラグ
    this.reactionDebounce = new Map(); // リアクションのデバウンス処理用
    this.highlightDebounce = new Map(); // ハイライトのデバウンス処理用
    this.pendingReactions = new Set(); // 処理中のリアクション
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];
    this.gas = {
      getPublishedSheetData: (sheetName, classFilter, sort) => this.runGas('getPublishedSheetData', sheetName, classFilter, sort),
      getAvailableSheets: () => this.runGas('getAvailableSheets'),
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('addReaction', rowIndex, reaction, sheetName),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('toggleHighlight', rowIndex, sheetName),
      checkAdmin: () => this.runGas('checkAdmin')
    };
    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
      this.elements.sizeSlider.value = savedCols;
      this.elements.sliderValue.textContent = savedCols;
    }
    this.init();
  }
  init() {
    // Critical path only - non-blocking
    this.setupCriticalElements();
    this.setupOwnerName();
    this.showMinimalSkeleton();
    
    // Apply default low performance tweaks
    this.optimizeForLowPerformance();
    
    // Immediate async loading for data
    this.loadDataImmediate();
    
    // Defer all non-critical operations
    requestIdleCallback(() => {
      this.setupNonCriticalEventListeners();
      this.renderIcons();
      this.adjustLayout();
      this.updateSortOptions();
      this.setupObservers();
      // Initial admin state setup - 管理者であっても最初は閲覧モードで起動、切り替えボタンのみ表示
      if (window.isAdminUser) {
        this.state.isAdminUser = true;
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.classList.remove('hidden');
          this.elements.adminToggleBtn.removeAttribute('hidden');
          this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
        }
      }
      if (!localStorage.getItem('introSeen')) {
        setTimeout(() => this.showInfoModal(), 500);
      }
    }, { timeout: 50 });
  }
  setupOwnerName() {
    if (OWNER_NAME && this.elements.ownerNameText) {
      this.elements.ownerNameText.textContent = `管理者: ${OWNER_NAME}`;
    }
  }
  setupCriticalElements() {
    // Only setup absolutely critical event listeners
    this.setupEventDelegation();
    this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    // Size slider for immediate response with throttling
    const debouncedRender = this.debounce(() => this.renderBoard(true), 200);
    this.handlers.onSizeSliderInput = this.throttle((e) => {
      localStorage.setItem('boardColumns', e.target.value);
      debouncedRender();
    }, 100); // Throttle to 100ms
    
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, { passive: true });
    }
  }
  
  setupNonCriticalEventListeners() {
    // Modal handlers
    this.handlers.onAnswerModalContainerClick = (e) => {
      if (e.target === e.currentTarget) {
        this.hideAnswerModal();
      }
    };
    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn) {
      this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
      this.elements.infoModalConfirmBtn.addEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    this.handlers.onModalReactionClick = (e) => {
      const btn = e.target.closest('.reaction-btn');
      const highlightBtn = e.target.closest('.highlight-btn');
      
      if (highlightBtn) {
        const id = highlightBtn.dataset.rowIndex;
        if (id) {
          this.handleHighlight(id);
        }
      } else if (btn) {
        const id = btn.dataset.rowIndex;
        const reaction = btn.dataset.reaction;
        if (id && reaction) {
          this.handleReaction(id, reaction);
        }
      }
    };
    if (this.elements.modalReactionContainer) {
      this.elements.modalReactionContainer.addEventListener('click', this.handlers.onModalReactionClick);
    }
    this.handlers.onClassFilterChange = () => this.loadSheetData(true);
    this.handlers.onSortOrderChange = () => this.loadSheetData(true);
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.endPublicationBtn) {
      this.handlers.onEndPublicationClick = () => this.endPublication();
      this.elements.endPublicationBtn.addEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.adminToggleBtn) {
      this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
      this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
    }
    this.handlers.onDocumentKeydown = (e) => {
      if (e.key === 'Escape') {
        this.hideAnswerModal();
      }
    };
    document.addEventListener('keydown', this.handlers.onDocumentKeydown);
    this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
    window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
    this.handlers.onVisibilityChange = () => {
      if (document.hidden) {
        this.stopPolling();
        // Cleanup when page is hidden
        this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
      } else {
        this.startPolling();
      }
    };
    document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, { passive: true });
  }
  setupEventDelegation() {
    this.handlers.onAnswersContainerClick = (e) => {
      const answerCard = e.target.closest('.answer-card');
      if (!answerCard) return;
      
      const rowIndex = answerCard.dataset.rowIndex;
      if (!rowIndex) return;
      
      const reactionBtn = e.target.closest('.reaction-btn');
      if (reactionBtn) {
        e.stopPropagation();
        const reactionType = reactionBtn.dataset.reaction;
        if (reactionType && !reactionBtn.disabled) {
          this.handleReaction(rowIndex, reactionType);
        }
        return;
      }
      
      const highlightBtn = e.target.closest('.highlight-btn');
      if (highlightBtn) {
        console.log('ハイライトボタンクリック:', { rowIndex, disabled: highlightBtn.disabled, showHighlightToggle: this.state.showHighlightToggle });
        e.stopPropagation();
        if (!highlightBtn.disabled) {
          this.handleHighlight(rowIndex);
        }
        return;
      }
      
      this.showAnswerModal(rowIndex);
    };
    
    if (this.elements.answersContainer) {
      this.elements.answersContainer.addEventListener('click', this.handlers.onAnswersContainerClick, { passive: false });
    }
    this.handlers.onDocumentClick = (e) => {
      if (e.target.matches('#retryLoadBtn')) {
        e.preventDefault();
        this.loadInitialData();
        return;
      }
    };
    document.addEventListener('click', this.handlers.onDocumentClick, { passive: false });
  }
  adjustLayout() {
    if (this.baseBodyPadding === undefined) {
      this.baseBodyPadding = parseFloat(getComputedStyle(this.elements.body).paddingBottom) || 0;
    }
    const footerHeight = this.elements.footer.offsetHeight;
    this.elements.body.style.paddingBottom = footerHeight + this.baseBodyPadding + 'px';
  }
  runGas(funcName, ...args) {
    // Simple request deduplication for identical calls (except for state-changing operations)
    const cacheKey = funcName + JSON.stringify(args);
    const isStateChanging = ['toggleHighlight', 'addReaction', 'endPublication'].includes(funcName);
    
    if (!isStateChanging) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return Promise.resolve(cached);
      }
    }
    
    console.log('GAS API呼び出し:', { funcName, args, userId: USER_ID, isStateChanging });
    
    return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        const userId = USER_ID || '';
        console.log('Google Apps Script環境検出済み、実際にAPI呼び出し実行中...');
        google.script.run
          .withSuccessHandler((result) => {
            console.log('GAS APIレスポンス受信:', { funcName, args, result, success: true });
            if (!isStateChanging) {
              this.cache.set(cacheKey, result, 1000); // 1秒キャッシュ
            }
            resolve(result);
          })
          .withFailureHandler((error) => {
            console.error('GAS APIエラー受信:', { funcName, args, error, success: false });
            reject(error);
          })
          .withUserObject({ userId: userId })
          [funcName](...args);
      } else {
        console.warn('Google Apps Script environment not detected.');
        this.getMockData(funcName, ...args).then((result) => {
          console.log('モックデータ取得:', { funcName, result });
          if (!isStateChanging) {
            this.cache.set(cacheKey, result, 1000); // 1秒キャッシュ
          }
          resolve(result);
        }).catch(reject);
      }
    });
  }
  async verifyAdminAsync() {
    // Use server-provided flag first (fast)
    if (window.isAdminUser) {
      this.state.isAdminUser = true;
      if (this.elements.adminToggleBtn) {
        this.elements.adminToggleBtn.classList.remove('hidden');
        this.elements.adminToggleBtn.removeAttribute('hidden');
        this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
      }
      return;
    }
    
    // Fallback API call (slower) - defer to idle
    requestIdleCallback(async () => {
      try {
        const isAdmin = await this.gas.checkAdmin();
        if (isAdmin) {
          window.isAdminUser = true;
          this.state.isAdminUser = true;
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
          }
        }
      } catch (e) {
        console.error('Admin check failed', e);
      }
    });
  }
  
  showAdminControls() {
    this.state.isAdminUser = true;
    
    // 管理者切り替えボタンは常に表示
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.classList.remove('hidden');
      this.elements.adminToggleBtn.removeAttribute('hidden');
      this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
    }
    
    // 公開終了ボタンは管理モード時のみ表示
    if (this.elements.endPublicationBtn) {
      if (this.state.showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', '');
      }
    }
    
    if (this.elements.modeLabel) {
      this.elements.modeLabel.textContent = this.state.showAdminFeatures ? '管理モード' : '閲覧モード';
    }
  }
  getMockData(funcName, ...args) {
    return new Promise((resolve) => {
      setTimeout(() => {
        if (funcName === 'getPublishedSheetData') {
          const currentDisplayMode = window.displayMode || this.state.displayMode;
          const studentName1 = currentDisplayMode === 'named' ? '田中太郎' : '';
          const studentName2 = currentDisplayMode === 'named' ? '佐藤花子' : '';
          resolve({
            header: 'テスト問題',
            sheetName: 'テストシート',
            rows: [
              {
                rowIndex: 1,
                name: studentName1,
                class: '3年A組',
                opinion: 'これは素晴らしいアイデアだと思います。',
                reason: '理由は簡潔で分かりやすく、実現可能性が高いからです。',
                reactions: {
                  UNDERSTAND: { count: 5, reacted: false },
                  LIKE: { count: 2, reacted: false },
                  CURIOUS: { count: 1, reacted: false }
                },
                highlight: false
              },
              {
                rowIndex: 2,
                name: studentName2,
                class: '3年B組',
                opinion: '少し改善の余地があると考えます。',
                reason: 'より多くの人の意見を聞く必要があると思います。',
                reactions: {
                  UNDERSTAND: { count: 3, reacted: true },
                  LIKE: { count: 0, reacted: false },
                  CURIOUS: { count: 0, reacted: false }
                },
                highlight: true
              }
            ]
          });
        } else if (funcName === 'addReaction') {
          resolve({
            status: 'ok',
            reactions: {
              UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
            }
          });
        } else if (funcName === 'toggleHighlight') {
          const currentHighlight = args[2] === undefined ? false : !args[2];
          resolve({
            status: 'ok',
            highlight: currentHighlight
          });
        } else if (funcName === 'checkAdmin') {
          resolve(true);
        }
      }, 300);
    });
  }
  startPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    
    const pollInterval = this.isLowPerformanceMode ? 30000 : 15000;
    this.pollingInterval = setInterval(() => this.loadSheetData(false), pollInterval);
    
    // Start automatic cleanup for memory management
    this.cleanupInterval = setInterval(() => {
      this.cache.cleanup();
    }, 5 * 60 * 1000); // Cleanup every 5 minutes
  }
  stopPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
  destroy() {
    this.stopPolling();
    this.cleanup();
    if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
      this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
    }
    if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
      this.elements.answerModalCloseBtn.removeEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
      this.elements.answerModalContainer.removeEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
      this.elements.infoModalConfirmBtn.removeEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
      this.elements.modalReactionContainer.removeEventListener('click', this.handlers.onModalReactionClick);
    }
    if (this.elements.classFilter && this.handlers.onClassFilterChange) {
      this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
      this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
      this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
    }
    if (this.handlers.onDocumentKeydown) {
      document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
    }
    if (this.handlers.onWindowResize) {
      window.removeEventListener('resize', this.handlers.onWindowResize);
    }
    if (this.handlers.onVisibilityChange) {
      document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
    }
    if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
      this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
    }
    if (this.handlers.onDocumentClick) {
      document.removeEventListener('click', this.handlers.onDocumentClick);
    }
    // Cleanup observers
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    // Cancel any pending callbacks
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    // Clear caches
    this.cache.clear();
    this.deferredUpdates.clear();
    this.domFragmentPool.length = 0;
  }
  async loadDataImmediate() {
    // Start loading immediately without waiting
    this.loadSheetData(false, true).then(() => {
      this.startPolling();
    });
    
    // Load sheets in background
    this.loadAvailableSheets();
    
    // Verify admin in background
    this.verifyAdminAsync();
  }
  
  showMinimalSkeleton() {
    // Show only 3 skeletons for immediate visual feedback
    const count = 3;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      frag.appendChild(this.createSkeletonCard());
    }
    this.elements.answersContainer.appendChild(frag);
  }
  async loadSheetData(showLoading = true, isInitialLoad = false, requestedSheetName = null) {
    if (this.state.isLoading && showLoading) return;
    this.state.isLoading = true;
    const selectedClass = isInitialLoad ? 'すべて' : (this.elements.classFilter ? this.elements.classFilter.value : 'すべて');
    const oldAnswers = [...this.state.currentAnswers];
    
    // Show immediate visual feedback
    if (isInitialLoad) {
      this.elements.headingLabel.innerHTML = '<svg class="w-6 h-6 animate-spin inline-block" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" fill="currentColor"></path></svg>';
    }
    
    // Optimized loading state - don't clear if initial load
    if (showLoading && !isInitialLoad) {
      const count = Math.min(parseInt(this.elements.sizeSlider.value, 10) * 2, 8); // Cap at 8
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      const container = this.elements.answersContainer;
      container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      container.innerHTML = '';
      container.appendChild(frag);
    }
    try {
      const sortOrder = this.elements.sortOrder.value;
      const data = await this.gas.getPublishedSheetData(requestedSheetName, selectedClass, sortOrder);
      this.state.sheetName = data.sheetName;
      if (typeof data.showCounts !== 'undefined') {
        this.serverShowCounts = data.showCounts;
      }
      if (typeof data.showNames !== 'undefined') {
        this.serverDisplayMode = data.showNames ? 'named' : 'anonymous';
      }
      if (!this.state.showAdminFeatures) {
        window.showCounts = this.serverShowCounts;
        window.displayMode = this.serverDisplayMode;
        this.updateConfigFromGlobals();
      }
      this.adjustLayout();
      if (!this.state.isAdminUser) {
        this.state.showAdminFeatures = false;
        this.state.showHighlightToggle = false;
      } else {
        // 管理者の場合のハイライトトグルは管理モード時のみ
        this.state.showHighlightToggle = this.state.showAdminFeatures && this.state.isAdminUser;
      }
      if (isInitialLoad) {
        // Add visual feedback that loading is complete
        this.elements.answersContainer.classList.add('render-optimized');
        requestIdleCallback(() => {
          this.populateClassFilter(data.rows);
          this.elements.sheetNameText.textContent = 'シート: ' + this.escapeHtml(data.sheetName || '不明');
        });
      } else {
        // 状態変更時はカードを再描画してハイライトボタンの表示を更新
        this.renderBoard();
      }
      if (JSON.stringify(this.state.currentAnswers) !== JSON.stringify(data.rows)) {
        this.state.currentAnswers = data.rows;
        this.elements.headingLabel.textContent = this.escapeHtml(data.header || '問題');
        
        // デバッグ用: 受信したデータの確認
        console.log('Sheet data received:', {
          totalRows: data.rows.length,
          sampleRow: data.rows[0] || null,
          showAdminFeatures: this.state.showAdminFeatures,
          displayMode: this.state.displayMode
        });
        
        // Use requestAnimationFrame for smooth rendering
        requestAnimationFrame(() => {
          this.renderBoard(false, oldAnswers);
        });
      }
    } catch (error) {
      console.error('Error loading sheet data:', error);
      const errorMessage = this.escapeHtml(error.message || 'Unknown error');
      this.elements.answersContainer.querySelectorAll('.skeleton').forEach(el => el.remove());
      this.elements.answersContainer.innerHTML = '<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">' + '<p class="font-bold">データの読み込みに失敗しました。</p>' + '<p class="text-sm mt-2">' + errorMessage + '</p>' + '<button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">再試行</button>' + '</div>';
    } finally {
      this.state.isLoading = false;
    }
  }
  async loadAvailableSheets() {
    try {
      const sheetsData = await this.gas.getAvailableSheets();
    } catch (error) {
      console.error('Failed to load available sheets:', error);
      this.elements.sheetSelector.innerHTML = '<option value="">エラー: シート読み込み失敗</option>';
    }
  }
  populateSheetSelector(sheetsData) {
    const selector = this.elements.sheetSelector;
    
    if (!sheetsData || !sheetsData.sheets || sheetsData.sheets.length === 0) {
      selector.innerHTML = '<option value="">利用可能なシートがありません</option>';
      selector.disabled = true;
      return;
    }
    
    // シート選択肢を構築
    if (!sheetsData.sheets || !Array.isArray(sheetsData.sheets)) {
      console.error('Invalid sheets data:', sheetsData);
      selector.innerHTML = '<option>シートデータが無効です</option>';
      selector.disabled = true;
      return;
    }
    
    const options = sheetsData.sheets.map(sheet => {
      const selected = sheet.isActive ? 'selected' : '';
      const activeLabel = sheet.isActive ? ' (現在のアクティブシート)' : '';
      return `<option value="${this.escapeHtml(sheet.name)}" ${selected}>${this.escapeHtml(sheet.name)}${activeLabel}</option>`;
    }).join('');
    
    selector.innerHTML = options;
    selector.disabled = false;
    
    // 現在のアクティブシートを記録
    this.state.currentActiveSheet = sheetsData.activeSheetName;
  }
  async switchSheet() {
    const selectedSheet = this.elements.sheetSelector.value;
    if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
      return;
    }
    
    try {
      // 新しいシートのデータを読み込み
      await this.loadSheetData(true, false, selectedSheet);
      this.state.currentActiveSheet = selectedSheet;
      
      // UIを更新
      this.updateSheetSelectorLabels();
    } catch (error) {
      console.error('Failed to switch sheet:', error);
      // エラー時は元のシートに戻す
      this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
    }
  }
  updateSheetSelectorLabels() {
    const selector = this.elements.sheetSelector;
    const options = Array.from(selector.options);
    
    options.forEach(option => {
      const sheetName = option.value;
      const isActive = sheetName === this.state.currentActiveSheet;
      const cleanName = sheetName.replace(/ \(現在のアクティブシート\)$/, '');
      
      if (isActive) {
        option.textContent = `${cleanName} (現在のアクティブシート)`;
      } else {
        option.textContent = cleanName;
      }
    });
  }
  populateClassFilter(rows) {
    const classFilter = this.elements.classFilter;
    const uniqueClasses = ['すべて', ...new Set(rows.map(r => r.class).filter(Boolean))];
    classFilter.innerHTML = uniqueClasses.map(c => '<option value="' + this.escapeHtml(c) + '">' + this.escapeHtml(c) + '</option>').join('');
    classFilter.value = 'すべて';
    classFilter.classList.remove('hidden');
  }
  applyReactionStyles(element, data) {
    if (!element || !data) return;
    
    // 既存のリアクション関連クラスをクリア
    const reactionClasses = [
      'reaction-bg-like', 'reaction-bg-understand', 'reaction-bg-curious',
      'reaction-bg-like-understand', 'reaction-bg-like-curious', 'reaction-bg-understand-curious',
      'reaction-bg-like-understand-curious', 'reaction-border-1', 'reaction-border-2', 'reaction-border-3',
      'highlighted'
    ];
    reactionClasses.forEach(cls => element.classList.remove(cls));
    
    // ハイライト状態を適用
    if (data.highlight) {
      element.classList.add('highlighted');
    }
    
    // アクティブなリアクションを特定
    const active = this.reactionTypes.filter(rt => 
      data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
    ).map(rt => rt.key);
    
    // 背景色クラスを適用
    if (active.length === 1) {
      if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
      else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
      else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
    } else if (active.length === 2) {
      const sorted = active.sort();
      if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE') element.classList.add('reaction-bg-like-curious');
      else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-like-understand');
      else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-understand-curious');
    } else if (active.length === 3) {
      element.classList.add('reaction-bg-like-understand-curious');
    }
    
    // ボーダー幅を適用
    const totalReactions = this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
    if (totalReactions >= 10) {
      element.classList.add('reaction-border-3');
    } else if (totalReactions >= 5) {
      element.classList.add('reaction-border-2');
    } else if (totalReactions > 0) {
      element.classList.add('reaction-border-1');
    }
  }
  renderBoard(isLayoutChange = false, oldRows = []) {
    const container = this.elements.answersContainer;
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    const newRows = this.state.currentAnswers;
    
    // Batch DOM updates using performance-aware batching
    const updates = [];
    if (this.elements.sliderValue && this.elements.sizeSlider && 
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value) {
      updates.push(() => this.elements.sliderValue.textContent = this.elements.sizeSlider.value);
    }
    if (this.elements.sizeSlider) {
      const newClassName = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      if (container.className !== newClassName) {
        updates.push(() => container.className = newClassName);
      }
    }
    if (this.elements.answerCount) {
      const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
      const countHtml = userIcon + '<span>' + newRows.length + '件</span>';
      if (this.elements.answerCount.innerHTML !== countHtml) {
        updates.push(() => this.elements.answerCount.innerHTML = countHtml);
      }
    }
    
    // Apply updates using performance-aware batching
    this.batchDOMUpdates(updates);
    
    if (newRows.length === 0) {
      if (!container.querySelector('.no-answers')) {
        container.innerHTML = '';
        const p = document.createElement('p');
        p.className = 'text-center text-gray-500 col-span-full mt-8 no-answers';
        p.textContent = 'このクラスの回答はありません。';
        container.appendChild(p);
      }
    } else {
      const existingMap = new Map();
      container.querySelectorAll('.answer-card').forEach(card => {
        existingMap.set(card.dataset.rowIndex, card);
      });
      existingMap.forEach((card, id) => {
        if (!newRows.some(r => String(r.rowIndex) === id)) {
          card.remove();
          existingMap.delete(id);
        }
      });
      const changedItems = [];
      let prevNode = null;
      // Enhanced batch processing with virtual scrolling for large datasets
      if (newRows.length > RENDER_BATCH_SIZE) {
        this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, changedItems);
      } else {
        // Process small datasets normally
        const fragment = this.getReusableFragment();
        
        newRows.forEach((row) => {
          const rowId = String(row.rowIndex);
          let card = existingMap.get(rowId);
          const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);
          
          if (!card) {
            card = this.createAnswerCard(row);
            card.classList.add('new-card');
            
            // Add to visibility observer
            if (this.visibilityObserver) {
              this.visibilityObserver.observe(card);
            }
            
            changedItems.push(row);
          } else {
            this.updateExistingCard(card, row, oldData, changedItems);
          }
          
          if (prevNode) {
            fragment.appendChild(card);
          } else {
            fragment.insertBefore(card, fragment.firstChild);
          }
          prevNode = card;
        });
        
        // Append fragment to container
        if (fragment.children.length > 0) {
          container.appendChild(fragment);
        }
        
        // Recycle fragment
        this.recycleFragment(fragment);
      }
      // Defer updates for better performance
      if (changedItems.length) {
        this.deferredRender(() => this.applyUpdates(changedItems));
      }
    }
  }
  
  renderWithVirtualScrolling(newRows, oldRows, container, existingMap, changedItems) {
    const batchSize = this.isLowPerformanceMode ? CHUNK_SIZE : RENDER_BATCH_SIZE;
    let currentIndex = 0;
    let prevNode = null;
    
    const processBatch = () => {
      const startTime = performance.now();
      const endIndex = Math.min(currentIndex + batchSize, newRows.length);
      const batch = newRows.slice(currentIndex, endIndex);
      
      // Use document fragment for efficient DOM manipulation
      const fragment = this.getReusableFragment();
      
      batch.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);
        
        if (!card) {
          card = this.createAnswerCard(row);
          card.classList.add('new-card');
          
          // Add to visibility observer for virtual scrolling
          if (this.visibilityObserver) {
            this.visibilityObserver.observe(card);
          }
          
          changedItems.push(row);
        } else {
          this.updateExistingCard(card, row, oldData, changedItems);
        }
        
        if (prevNode) {
          fragment.appendChild(card);
        } else {
          fragment.insertBefore(card, fragment.firstChild);
        }
        prevNode = card;
      });
      
      // Append fragment to container
      if (fragment.children.length > 0) {
        container.appendChild(fragment);
      }
      
      // Recycle fragment
      this.recycleFragment(fragment);
      
      currentIndex = endIndex;
      
      // Continue processing if there are more items
      if (currentIndex < newRows.length) {
        const elapsed = performance.now() - startTime;
        
        if (elapsed < PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
          // Continue synchronously if we have time budget
          processBatch();
        } else {
          // Defer to next frame/idle callback
          this.deferredRender(processBatch);
        }
      }
    };
    
    processBatch();
  }
  
  updateExistingCard(card, row, oldData, changedItems) {
    if (oldData) {
      let hasChanges = false;
      
      if (oldData.opinion !== row.opinion) {
        const t = card.querySelector('.opinion-text');
        if (t) {
          t.textContent = row.opinion;
          hasChanges = true;
        }
      }
      
      if (oldData.reason !== row.reason) {
        const p = card.querySelector('.answer-preview p');
        if (p) {
          p.textContent = row.reason;
          hasChanges = true;
        }
      }
      
      if (oldData.name !== row.name) {
        const n = card.querySelector('.font-bold');
        if (n) {
          n.textContent = row.name;
          hasChanges = true;
        }
      }
      
      if (JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) || 
          oldData.highlight !== row.highlight) {
        hasChanges = true;
      }
      
      if (hasChanges) {
        changedItems.push(row);
      }
    }
  }
  createAnswerCard(data) {
    // Check cache first for unchanged data
    const cacheKey = JSON.stringify({
      rowIndex: data.rowIndex,
      opinion: data.opinion,
      reason: data.reason,
      name: data.name,
      reactions: data.reactions,
      highlight: data.highlight,
      showCounts: this.state.showCounts,
      displayMode: this.state.displayMode,
      showHighlightToggle: this.state.showHighlightToggle
    });
    
    const cachedCard = this.cache.get(`render-${cacheKey}`);
    if (cachedCard) {
      return cachedCard.cloneNode(true);
    }
    
    const card = document.createElement('div');
    const highlightClass = data.highlight ? ' highlighted' : '';
    card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' + highlightClass;
    card.dataset.rowIndex = data.rowIndex;
    card.setAttribute('role', 'article');
    card.setAttribute('tabindex', '0');
    card.setAttribute('aria-label', '回答カード: ' + (data.opinion || '').substring(0, 50) + (data.opinion && data.opinion.length > 50 ? '...' : ''));
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-yellow-400 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
      console.log('カードハイライトボタン作成:', { 
        rowIndex: data.rowIndex, 
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: this.state.showAdminFeatures
      });
    } else {
      console.log('カードハイライトボタンをスキップ:', { 
        rowIndex: data.rowIndex, 
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: this.state.showAdminFeatures
      });
    }
    const showName = this.state.displayMode === 'named';
    let displayName = '';
    
    if (showName) {
      // 名前が利用可能な場合はそれを使用、なければemailから生成
      if (data.name) {
        displayName = data.name;
      } else if (data.email) {
        displayName = data.email.split('@')[0];
      }
      
    }
    
    const nameHtml = showName && displayName ? '<div><span class="font-bold text-sm text-gray-200">' + this.escapeHtml(displayName) + '</span></div>' : '';
    const containerClass = nameHtml ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-between items-center' : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions ? data.reactions[rt.key] : { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' + (info.count || 0) + '</span>' : '';
      const reactionNames = { 'LIKE': 'いいね', 'UNDERSTAND': 'なるほど', 'CURIOUS': '気になる' };
      const reactionName = reactionNames[rt.key] || rt.key;
      const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count || 0}件)` : ''}`;
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' + colorClass + ' ' + cls + '" data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + ariaLabel + '" aria-pressed="' + info.reacted + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    card.innerHTML = '<div class="relative flex-grow mb-3 answer-preview">' + '<h3 class="opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight">' + this.escapeHtml(data.opinion || '') + '</h3>' + '<p class="text-gray-100 whitespace-pre-wrap break-words mt-4">' + this.escapeHtml(data.reason || '') + '</p>' + '</div>' + '<div class="' + containerClass + '">' + nameHtml + '<div class="flex items-center gap-1" role="group" aria-label="回答への反応">' + reactionButtonsHtml + highlightBtnHtml + '</div>' + '</div>';
    if (data.highlight) {
      const badge = document.createElement('span');
      badge.className = 'highlight-badge';
      badge.innerHTML = this.getIcon('star', '', true);
      card.appendChild(badge);
    }
    
    // 統一されたリアクションスタイルを適用
    this.applyReactionStyles(card, data);
    
    // Cache the card for reuse (limit cache size)
    if (this.cache.size > 100) {
      this.cache.cleanup();
    }
    this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
    
    return card;
  }
  createSkeletonCard() {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
    // Simplified skeleton for faster rendering
    card.innerHTML = '<div class="h-20 w-full rounded bg-gray-500/30 mb-4"></div><div class="h-6 w-full rounded bg-gray-500/20"></div>';
    return card;
  }
  async handleReaction(rowIndex, reaction) {
    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;
    
    // Enhanced debounce - prevent rapid consecutive clicks
    if (this.reactionDebounce.has(reactionKey)) {
      clearTimeout(this.reactionDebounce.get(reactionKey));
      return; // Ignore rapid clicks
    }
    
    // 既に処理中の場合は無視
    if (this.pendingReactions.has(reactionKey)) {
      return;
    }
    
    // Rate limiting - prevent spam
    const now = Date.now();
    const lastReactionTime = this.lastReactionTimes?.get(reactionKey) || 0;
    if (now - lastReactionTime < 300) { // Minimum 300ms between same reactions
      return;
    }
    
    this.pendingReactions.add(reactionKey);
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(reactionKey, now);
    
    const btns = document.querySelectorAll('[data-row-index="' + numericRowIndex + '"][data-reaction="' + reaction + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    
    if (!item || !item.reactions) return;
    
    // 元の状態を保存（ロールバック用）
    const originalReaction = { ...item.reactions[reaction] };
    const originalReactions = { ...item.reactions };
    
    // 楽観的UI更新 - 即座にUIを更新
    const wasReacted = item.reactions[reaction].reacted;
    item.reactions[reaction] = {
      count: wasReacted ? Math.max(0, item.reactions[reaction].count - 1) : item.reactions[reaction].count + 1,
      reacted: !wasReacted
    };
    
    // ローディング状態を設定
    btns.forEach(btn => {
      btn.classList.add('loading');
      btn.disabled = true;
      btn.setAttribute('aria-disabled', 'true');
    });
    
    // UIを即座に更新
    this.applyUpdates([item]);
    
    try {
      // サーバーに送信
      const res = await this.gas.addReaction(numericRowIndex, reaction, this.state.sheetName);
      
      if (res && res.status === 'ok' && res.reactions) {
        // サーバーからの正確な値で更新
        item.reactions = res.reactions;
        this.applyUpdates([item]);
        
        // モーダルが開いている場合は更新
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
          if (modalRowIndex == rowIndex) {
            this.updateModalContent(item);
          }
        }
      } else {
        // エラー時はロールバック
        throw new Error(res?.message || 'リアクションの処理に失敗しました');
      }
    } catch (error) {
      console.error('Failed to add reaction:', error);
      
      // ロールバック - 元の状態に戻す
      item.reactions = originalReactions;
      this.applyUpdates([item]);
      
      // エラーフィードバック
      this.showErrorFeedback(btns[0], 'リアクションに失敗しました');
    } finally {
      // ローディング状態を解除
      btns.forEach(btn => {
        btn.classList.remove('loading');
        btn.disabled = false;
        btn.setAttribute('aria-disabled', 'false');
      });
      
      // 処理完了
      this.pendingReactions.delete(reactionKey);
      
      // Enhanced debounce - 500ms delay to prevent accidental double clicks
      const debounceTimeout = setTimeout(() => {
        this.reactionDebounce.delete(reactionKey);
      }, 500);
      this.reactionDebounce.set(reactionKey, debounceTimeout);
    }
  }
  
  showErrorFeedback(btn, message) {
    if (!btn) return;
    
    // 元のクラスを保存
    const originalClasses = btn.className;
    
    // エラー表示
    btn.classList.add('bg-red-500');
    btn.title = message;
    
    // 2秒後に元に戻す
    setTimeout(() => {
      btn.className = originalClasses;
      btn.title = '';
    }, 2000);
  }
  async handleHighlight(rowIndex) {
    console.log('handleHighlight開始:', { 
      rowIndex, 
      isAdminUser: this.state.isAdminUser, 
      showHighlightToggle: this.state.showHighlightToggle,
      windowIsAdminUser: window.isAdminUser,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      windowShowHighlightToggle: window.showHighlightToggle
    });
    
    // 管理者権限の再確認
    console.log('admin権限再確認中...');
    try {
      const adminCheck = await this.gas.checkAdmin();
      console.log('サーバー側admin確認結果:', adminCheck);
      if (!adminCheck) {
        throw new Error('サーバー側で管理者権限が確認できませんでした。スプレッドシートの所有者でログインしているか確認してください。');
      }
    } catch (adminError) {
      console.error('admin権限確認エラー:', adminError);
      throw new Error('管理者権限の確認に失敗しました: ' + adminError.message);
    }
    
    const numericRowIndex = parseInt(rowIndex, 10);
    const highlightKey = `${numericRowIndex}-highlight`;
    
    // Enhanced debounce for highlight operations
    if (this.highlightDebounce.has(highlightKey)) {
      console.log('デバウンス中、処理をスキップ');
      clearTimeout(this.highlightDebounce.get(highlightKey));
      return; // Ignore rapid highlight clicks
    }
    
    // Rate limiting for highlights
    const now = Date.now();
    const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
    if (now - lastHighlightTime < 500) { // Minimum 500ms between highlights
      console.log('レート制限中、処理をスキップ');
      return;
    }
    
    // 既に処理中の場合は無視
    if (this.pendingReactions.has(highlightKey)) {
      console.log('既に処理中、処理をスキップ');
      return;
    }
    
    this.pendingReactions.add(highlightKey);
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(highlightKey, now);
    
    const btns = document.querySelectorAll('.highlight-btn[data-row-index="' + numericRowIndex + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    
    console.log('ハイライト処理:', { numericRowIndex, btnsFound: btns.length, itemFound: !!item });
    
    if (!item) {
      console.log('対象データが見つからない');
      this.pendingReactions.delete(highlightKey);
      return;
    }
    
    // 元の状態を保存（ロールバック用）
    const originalHighlight = item.highlight;
    
    // 楽観的UI更新 - 即座にUIを更新
    item.highlight = !originalHighlight;
    
    // ローディング状態を設定
    btns.forEach(btn => {
      btn.classList.add('loading');
      btn.disabled = true;
      btn.setAttribute('aria-disabled', 'true');
    });
    
    // UIを即座に更新
    this.applyUpdates([item]);
    
    try {
      // 管理者権限をチェック
      if (!this.state.isAdminUser && !window.isAdminUser) {
        throw new Error('管理者権限が必要です。管理モードを有効にしてください。');
      }
      
      // 管理機能が有効かチェック
      if (!this.state.showAdminFeatures && !window.showAdminFeatures) {
        throw new Error('管理機能が無効になっています。管理モードボタンをクリックして有効にしてください。');
      }
      
      console.log('ハイライト送信中...', { 
        numericRowIndex, 
        sheetName: this.state.sheetName, 
        isAdminUser: this.state.isAdminUser,
        windowIsAdminUser: window.isAdminUser,
        showAdminFeatures: this.state.showAdminFeatures,
        userId: USER_ID,
        ownerName: OWNER_NAME
      });
      const res = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);
      console.log('ハイライトレスポンス:', res);
      
      if (res && res.status === 'ok') {
        // サーバーからの正確な値で更新
        item.highlight = res.highlight;
        this.applyUpdates([item]);
        
        // モーダルが開いている場合は更新
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
          if (modalRowIndex == rowIndex) {
            this.updateModalContent(item);
          }
        }
      } else {
        // エラー時はロールバック
        throw new Error(res?.message || 'ハイライトの処理に失敗しました');
      }
    } catch (error) {
      console.error('Failed to toggle highlight:', error);
      
      // ロールバック - 元の状態に戻す
      item.highlight = originalHighlight;
      this.applyUpdates([item]);
      
      // エラーフィードバック
      this.showErrorFeedback(btns[0], 'ハイライトに失敗しました');
    } finally {
      // ローディング状態を解除
      btns.forEach(btn => {
        btn.classList.remove('loading');
        btn.disabled = false;
        btn.setAttribute('aria-disabled', 'false');
      });
      
      // 処理完了
      this.pendingReactions.delete(highlightKey);
      
      // Enhanced debounce for highlights - 750ms delay
      const debounceTimeout = setTimeout(() => {
        this.reactionDebounce.delete(highlightKey);
      }, 750);
      this.reactionDebounce.set(highlightKey, debounceTimeout);
    }
  }
  async toggleAdminMode() {
    // ボタンを一時的に無効化して重複クリックを防ぐ
    const btn = this.elements.adminToggleBtn;
    if (btn) {
      btn.disabled = true;
    }
    
    try {
      const enable = !this.state.showAdminFeatures;
      
      // 管理者権限チェック
      if (enable) {
        if (!this.state.isAdminUser) {
          console.warn('管理者権限がありません。');
          return;
        }
        
        // 最初の管理モード切り替え時のみサーバー側で再確認（オプション）
        if (!this.adminModeVerified) {
          try {
            const ok = await this.gas.checkAdmin();
            if (!ok) {
              console.warn('サーバー側の権限確認に失敗しました。');
              // ローカルの権限情報を信頼して継続
            }
            this.adminModeVerified = true;
          } catch (e) {
            console.warn('権限確認API呼び出しに失敗しました', e);
            // エラーが発生してもローカルの権限情報を信頼して継続
          }
        }
      }
      
      // グローバル設定を更新
      window.showAdminFeatures = enable;
      window.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
      window.showScoreSort = enable;
      
      console.log('toggleAdminMode状態更新:', {
        enable,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: window.showAdminFeatures,
        showHighlightToggle: window.showHighlightToggle
      });
      if (enable) {
        window.showCounts = true;
        window.displayMode = 'named';
        window.isStudentMode = false;
      } else {
        window.showCounts = this.serverShowCounts;
        window.displayMode = this.serverDisplayMode;
        window.isStudentMode = true;
      }
      this.updateConfigFromGlobals();
      
      // キャッシュをクリアして新しい設定で再描画
      this.cache.clear();
      
      // 管理モード切り替え時は既存のカードを全て削除して強制再生成
      this.elements.answersContainer.innerHTML = '';
      
      // UI状態を更新
      this.showAdminControls();
      this.updateSortOptions();
      // 管理モード切り替え時は設定変更のため再描画が必要
      this.loadSheetData(true, false);
    } finally {
      // ボタンを再度有効化
      if (btn) {
        btn.disabled = false;
      }
    }
  }
  async endPublication() {
    if (!confirm('公開を終了しますか？生徒は回答ボードにアクセスできなくなります。')) {
      return;
    }
    
    try {
      await this.runGas('clearActiveSheet');
      alert('公開を終了しました。管理画面に移動します。');
      this.endAdminMode();
    } catch (error) {
      console.error('公開終了に失敗しました:', error);
      alert('公開終了に失敗しました: ' + (error.message || error));
    }
  }
  endAdminMode() {
    // Redirect to admin URL with mode=admin parameter to show management interface
    const currentUrl = new URL(window.location.href);
    currentUrl.searchParams.set('mode', 'admin');
    window.location.href = currentUrl.toString();
  }
  updateReactionButtonUI(rowIndex, reaction, count, reacted) {
    document.querySelectorAll('[data-row-index="' + rowIndex + '"][data-reaction="' + reaction + '"]').forEach(btn => {
      const countEl = btn.querySelector('.reaction-count');
      if (countEl && this.state.showCounts) {
        countEl.textContent = count;
      }
      const rt = this.reactionTypes.find(r => r.key === reaction);
      const svgEl = btn.querySelector('svg');
      if (svgEl && rt) {
        svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', reacted);
      }
      const colorClass = reaction === 'LIKE' ? 'text-red-500' : reaction === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
      btn.classList.add(colorClass);
      btn.classList.toggle('liked', reacted);
      btn.setAttribute('aria-pressed', reacted.toString());
      const reactionNames = { 'LIKE': 'いいね', 'UNDERSTAND': 'なるほど', 'CURIOUS': '気になる' };
      const reactionName = reactionNames[reaction] || reaction;
      const ariaLabel = `${reactionName}${reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${count}件)` : ''}`;
      btn.setAttribute('aria-label', ariaLabel);
    });
  }
  applyUpdates(items) {
    items.forEach(item => {
      this.reactionTypes.forEach(rt => {
        if (item.reactions && item.reactions[rt.key]) {
          this.updateReactionButtonUI(item.rowIndex, rt.key, item.reactions[rt.key].count, item.reactions[rt.key].reacted);
        }
      });
      const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
      if (card) {
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('liked', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          const label = item.highlight ? 'ハイライトを解除する' : 'ハイライトする';
          highlightBtn.setAttribute('aria-label', label);
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
          }
        }
        let badge = card.querySelector('.highlight-badge');
        if (item.highlight && !badge) {
          badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } else if (!item.highlight && badge) {
          badge.remove();
        }
      }
    });
  }
  showAnswerModal(rowIndex) {
    
    // 最新データを取得（filteredDataとcurrentAnswersの両方から）
    let data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
    if (!data && this.state.filteredData) {
      data = this.state.filteredData.find(r => r.rowIndex == rowIndex);
    }
    if (!data) {
      return;
    }
    this.state.lastFocusedElement = document.activeElement;
    this.elements.modalAnswer.innerHTML = '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + this.escapeHtml(data.opinion || '') + '</p>' + '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + this.escapeHtml(data.reason || '') + '</p>';
    const showName = this.state.displayMode === 'named';
    let modalDisplayName = '';
    
    if (showName) {
      // 名前が利用可能な場合はそれを使用、なければemailから生成
      if (data.name) {
        modalDisplayName = data.name;
      } else if (data.email) {
        modalDisplayName = data.email.split('@')[0];
      }
    }
    
    this.elements.modalStudentName.textContent = modalDisplayName;
    const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
    this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを追加
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-yellow-400 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // リアクションに基づくカード色の適用
    this.applyReactionStyles(this.elements.answerModalCard, data);
    
    this.elements.answerModalContainer.classList.remove('hidden');
    this.elements.answerModalContainer.classList.add('modal-fade');
    this.elements.answerModalCard.classList.add('modal-scale');
    
    this.elements.answerModalCloseBtn.focus();
  }
  updateModalContent(data) {
    if (!data) return;
    
    // リアクションボタンを更新
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを更新
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-yellow-400 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // モーダルカードのスタイルを更新
    this.applyReactionStyles(this.elements.answerModalCard, data);
  }
  hideAnswerModal() {
    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalContainer.classList.remove('modal-fade');
    this.elements.answerModalCard.classList.remove('modal-scale');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  showInfoModal() {
    this.state.lastFocusedElement = document.activeElement;
    this.elements.infoModalContainer.classList.remove('hidden');
    this.elements.infoModalContainer.classList.add('modal-fade');
    this.elements.infoModalCard.classList.add('modal-scale');
    this.elements.infoModalConfirmBtn.focus();
  }
  hideInfoModal() {
    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalContainer.classList.remove('modal-fade');
    this.elements.infoModalCard.classList.remove('modal-scale');
    localStorage.setItem('introSeen', '1');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  getIcon(name, classes = '', solid = false) {
    // Cache icons to avoid repeated string concatenation
    const cacheKey = `icon-${name}-${classes}-${solid}`;
    const cachedIcon = this.cache.get(cacheKey);
    if (cachedIcon) {
      return cachedIcon;
    }
    
    let key = name;
    if (ICONS[name + '-outline'] || ICONS[name + '-solid']) {
      key = solid ? name + '-solid' : name + '-outline';
    }
    const icon = ICONS[key];
    if (!icon) {
      console.warn('Icon not found:', key);
      const fallback = '<span aria-hidden="true" class="' + classes + '">⭐</span>';
      this.cache.set(cacheKey, fallback);
      return fallback;
    }
    const result = '<span aria-hidden="true" class="' + classes + '">' + icon + '</span>';
    this.cache.set(cacheKey, result);
    return result;
  }
  renderIcons() {
    if (this.elements.infoIconLike) {
      this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
    }
    if (this.elements.infoIconUnderstand) {
      this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
    }
    if (this.elements.infoIconCurious) {
      this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
    }
    if (this.elements.infoIconHighlight) {
      this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
    }
    if (this.elements.iconClose) {
      this.elements.iconClose.innerHTML = this.getIcon('x');
    }
    if (this.elements.iconGrid) {
      this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
    }
  }
  debounce(func, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }
  
  throttle(func, delay) {
    let timeoutId;
    let lastExecTime = 0;
    return (...args) => {
      const currentTime = Date.now();
      
      if (currentTime - lastExecTime > delay) {
        func.apply(this, args);
        lastExecTime = currentTime;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecTime = Date.now();
        }, delay - (currentTime - lastExecTime));
      }
    };
  }
  updateSortOptions() {
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.style.display = 'block';
      } else {
        this.elements.scoreOption.style.display = 'none';
        if (this.elements.sortOrder.value === 'score') {
          this.elements.sortOrder.value = 'newest';
        }
      }
    }
  }
  updateConfigFromGlobals() {
    this.state.isStudentMode = window.isStudentMode;
    this.state.showCounts = window.showCounts;
    this.state.showAdminFeatures = window.showAdminFeatures;
    this.state.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
    this.state.showScoreSort = window.showScoreSort;
    this.state.showPublishControls = window.showPublishControls;
    this.state.displayMode = window.displayMode;
  }
  escapeHtml(str) {
    if (!str) return '';
    return str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }

  // Performance optimization methods
  detectLowPerformanceDevice() {
    const userAgent = navigator.userAgent;
    const platform = navigator.platform;
    const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
    const cores = navigator.hardwareConcurrency || 4;
    
    // Detect low-end devices
    if (memory <= 2 || cores <= 2) return true;
    if (userAgent.includes('Mobile') && !userAgent.includes('iPad')) return true;
    if (platform.includes('Win32') && cores <= 4) return true;
    
    return false;
  }

  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measurePerformance = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      if (frameCount > 0) {
        this.performanceMetrics.frameTime = delta;
        
        // If frame time is consistently over 16ms, enable low performance mode
        if (delta > PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
          console.warn('Low performance detected, enabling optimizations');
          this.isLowPerformanceMode = true;
          this.optimizeForLowPerformance();
        }
      }
      
      lastTime = now;
      frameCount++;
      
      if (frameCount < 60) { // Monitor first 60 frames
        requestAnimationFrame(measurePerformance);
      }
    };
    
    requestAnimationFrame(measurePerformance);
  }

  optimizeForLowPerformance() {
    console.log('Enabling low performance optimizations');
    
    // Reduce animation and transition durations
    document.documentElement.style.setProperty('--transition-duration', '0.1s');
    document.documentElement.style.setProperty('--animation-duration', '0.1s');
    document.documentElement.style.setProperty('--backdrop-blur', '4px');
    
    // Create comprehensive low-performance stylesheet
    const style = document.createElement('style');
    style.id = 'low-performance-optimizations';
    style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        backdrop-filter: blur(4px) !important;
        -webkit-backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover {
        transform: scale(1.02) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        box-shadow: 0 0 8px rgba(250,204,21,0.3) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
    document.head.appendChild(style);
    
    // Add low-performance class to body for CSS targeting
    document.body.classList.add('low-performance');
    
    // Reduce polling frequency
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = setInterval(() => this.loadSheetData(false), 30000); // 30s instead of 15s
    }
  }

  setupObservers() {
    // Intersection Observer for virtual scrolling
    if ('IntersectionObserver' in window) {
      this.visibilityObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const card = entry.target;
          if (entry.isIntersecting) {
            card.classList.add('visible');
            card.classList.remove('hidden-card');
          } else {
            card.classList.remove('visible');
            card.classList.add('hidden-card');
          }
        });
      }, {
        rootMargin: `${VIEWPORT_BUFFER}px`,
        threshold: 0.1
      });
    }

    // ResizeObserver for responsive adjustments
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(this.debounce(() => {
        this.adjustLayout();
      }, 100));
      this.resizeObserver.observe(this.elements.answersContainer);
    }
  }

  deferredRender(callback, priority = 'normal') {
    if (this.isLowPerformanceMode) {
      // Use requestIdleCallback for low priority updates
      this.idleCallbackId = requestIdleCallback(callback, { timeout: IDLE_TIMEOUT });
    } else {
      // Use requestAnimationFrame for normal updates
      this.animationFrameId = requestAnimationFrame(callback);
    }
  }

  batchDOMUpdates(updates) {
    const startTime = performance.now();
    let processedCount = 0;
    
    const processBatch = () => {
      while (processedCount < updates.length && (performance.now() - startTime) < PERFORMANCE_BUDGET) {
        updates[processedCount]();
        processedCount++;
      }
      
      if (processedCount < updates.length) {
        // Continue in next frame
        requestAnimationFrame(processBatch);
      }
    };
    
    processBatch();
  }

  getReusableFragment() {
    if (this.domFragmentPool.length > 0) {
      return this.domFragmentPool.pop();
    }
    return document.createDocumentFragment();
  }

  recycleFragment(fragment) {
    // Clear fragment content and reuse
    while (fragment.firstChild) {
      fragment.removeChild(fragment.firstChild);
    }
    if (this.domFragmentPool.length < 10) { // Limit pool size
      this.domFragmentPool.push(fragment);
    }
  }

  throttledUpdate(key, callback, delay = 100) {
    if (this.deferredUpdates.has(key)) {
      return;
    }
    
    this.deferredUpdates.add(key);
    setTimeout(() => {
      callback();
      this.deferredUpdates.delete(key);
    }, delay);
  }

  cleanup() {
    // Consolidated cache cleanup
    this.cache.cleanup();

    // Clear DOM fragment pool
    this.domFragmentPool.length = 0;

    console.log('Cache cleanup completed', {
      cacheSize: this.cache.size
    });
  }
  
  // Enhanced cache methods with timestamp tracking
}
try {
  if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
    window.studyQuestApp.destroy();
  }
  window.studyQuestApp = new StudyQuestApp();
  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
  });
} catch (error) {
  console.error('Error creating StudyQuestApp instance:', error);
  const container = document.getElementById('answers');
  if (container) {
    container.innerHTML = '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + error.message + '</div>';
  }
}
</script>
</body>
</html>
