<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>StudyQuest - みんなのかいとうボード</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GSAPアニメーションライブラリをdefer属性付きで読み込み、HTMLパースをブロックしないようにする -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
  <script>
    // アプリケーション設定とコンフィグ
    const CONFIG = {
      // デフォルト設定（学生モード）
      DEFAULT_MODE: {
        isStudentMode: true,
        showCounts: false,
        showAdminFeatures: false,
        showHighlightToggle: false,
        showScoreSort: false,
        showPublishControls: false,
        displayMode: 'anonymous'
      },
      
      // 管理者モード設定
      ADMIN_MODE: {
        isStudentMode: false,
        showCounts: true,
        showAdminFeatures: true,
        showHighlightToggle: true,
        showScoreSort: true,
        showPublishControls: true,
        displayMode: 'named'
      },
      
      // アニメーション設定
      ANIMATION: {
        CARD_FADE_DURATION: 0.5,
        CARD_MOVE_DURATION: 0.7,
        MODAL_DURATION: 0.3,
        HIGHLIGHT_PULSE_DURATION: 0.3
      },
      
      // ポーリング設定
      POLLING: {
        INTERVAL_MS: 15000,
        DEBOUNCE_MS: 200
      },
      
      // UI設定
      UI: {
        GRID_MIN_COLS: 2,
        GRID_MAX_COLS: 6,
        GRID_DEFAULT_COLS: 4,
        SKELETON_MULTIPLIER: 2
      }
    };

    // デバッグ用フラグ
    const DEBUG = false;

    // プレビューモード検出とモード設定
    const ModeManager = {
      isPreviewMode() {
        return window.location.protocol === 'file:' || 
               window.location.hostname === 'localhost' || 
               window.location.pathname.includes('preview') ||
               window.location.href.includes('preview');
      },
      
      applyMode(modeConfig) {
        Object.assign(window, modeConfig);
      },
      
      initializeMode() {
        // デフォルト設定を適用
        this.applyMode(CONFIG.DEFAULT_MODE);
        
        // プレビューモードの場合、URLハッシュに基づいて調整
        if (this.isPreviewMode()) {
          const targetMode = window.location.hash === '#admin' ? 
                           CONFIG.ADMIN_MODE : CONFIG.DEFAULT_MODE;
          this.applyMode(targetMode);
        }
      }
    };
    
    // モード初期化
    ModeManager.initializeMode();
  </script>
  <script>
    window.showCounts = <?= showCounts ?>;
    window.displayMode = '<?= displayMode ?>';
    const SHEET_NAME = '<?= sheetName ?>';
    const MAPPING = <?= JSON.stringify(mapping) ?>;
  </script>
  <style>
    /* カスタムプロパティ（CSS変数）定義 */
    :root {
      /* カラーパレット */
      --color-primary: #8be9fd;
      --color-primary-dark: #6272a4;
      --color-background: #1a1b26;
      --color-surface: rgba(26, 27, 38, 0.7);
      --color-text: #c0caf5;
      --color-text-secondary: #6272a4;
      --color-text-muted: rgba(255, 255, 255, 0.6);
      --color-border: rgba(255, 255, 255, 0.1);
      --color-accent: #facc15;
      --color-success: #50fa7b;
      --color-warning: #ffb86c;
      --color-error: #ff5555;
      
      /* アニメーション */
      --duration-fast: 0.2s;
      --duration-normal: 0.3s;
      --duration-slow: 0.5s;
      --ease-out: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      --ease-in-out: cubic-bezier(0.645, 0.045, 0.355, 1);
      
      /* サイズ */
      --border-radius: 0.75rem;
      --border-radius-lg: 1rem;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
      --shadow-glow: 0 0 15px var(--color-primary);
      
      /* ガラスエフェクト */
      --glass-bg: var(--color-surface);
      --glass-border: 1px solid var(--color-border);
      --glass-blur: blur(12px);
    }

    /* 基本スタイル */
    body {
      color: var(--color-text);
      background-color: var(--color-background);
      margin: 0; /* remove default margin for minimal top spacing */
    }
    
    /* ガラスパネル効果 */
    .glass-panel { 
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: var(--glass-border);
    }
    /* インタラクティブ要素の共通スタイル */
    .interactive-element {
      transition: all var(--duration-fast) var(--ease-out);
      border-radius: var(--border-radius);
    }
    
    /* ゲームボタンのスタイル */
    .game-btn {
      transition: all var(--duration-fast) var(--ease-out);
      border-radius: var(--border-radius);
      border-bottom-width: 4px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    }
    .game-font {
      font-family: 'Press Start 2P', cursive;
    }
    .game-btn:not(:disabled):hover { 
      transform: translateY(-2px) scale(1.02); 
      box-shadow: var(--shadow-glow); 
    }
    .game-btn:active:not(:disabled) { 
      transform: translateY(2px); 
      border-bottom-width: 2px; 
      box-shadow: none; 
    }
    
    /* フォーム要素 */
    #classFilter, #sortOrder { 
      background-color: var(--color-primary-dark); 
      border: var(--glass-border); 
      color: var(--color-text); 
      border-radius: var(--border-radius); 
      padding: 0.25rem 0.5rem; 
    }
    
    /* フォーカス状態 */
    :focus-visible { 
      outline: 3px solid var(--color-primary); 
      outline-offset: 2px; 
      border-radius: var(--border-radius); 
    }
    
    /* レイアウト */
    header { position: sticky; top: 0; z-index: 5; }
    
    /* 回答カード */
    .answer-card { 
      will-change: transform, opacity;
      transition: all var(--duration-normal) var(--ease-out);
      border-radius: var(--border-radius-lg);
    }
    .answer-card.highlighted { 
      border-color: var(--color-accent); 
      box-shadow: 0 0 15px rgba(250,204,21,0.4); 
      transform: scale(1.02); 
    }
    .answer-card:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 8px 25px rgba(139,233,253,0.3);
    }
    .answer-card:focus-visible {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 8px 25px rgba(139,233,253,0.3);
    }
    .answer-card.highlighted:hover {
      transform: translateY(-4px) scale(1.04);
    }
    /* ハイライトバッジのスタイル */
    .highlight-badge {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      width: 1.5rem;
      height: 1.5rem;
      color: #facc15;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.4);
    }
    /* リアクションボタンの背景グラデーションとボーダーカラー */
    .reaction-bg-like { border-color:#ef4444; border-image: linear-gradient(to bottom,#facc15,#fcd34d) 1; }
    .reaction-bg-understand { border-color:#fbbf24; border-image: linear-gradient(to bottom,#a3e635,#bef264) 1; }
    .reaction-bg-curious { border-color:#10b981; border-image: linear-gradient(to bottom,#34d399,#6ee7b7) 1; }
    .reaction-bg-mixed { border-color:#8b5cf6; border-image: linear-gradient(to bottom,#f59e0b,#10b981,#10b981) 1; }
    .reaction-bg-all { border-color:transparent; border-image: linear-gradient(90deg,#ef4444,#fbbf24,#10b981) 1; }
    /* リアクション総数に応じたボーダー太さ */
    .reaction-border-1 { border-width: 2px; }
    .reaction-border-2 { border-width: 4px; }
    .reaction-border-3 { border-width: 6px; }
    /* 回答プレビューの表示制限と省略 */
    .answer-preview { display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; min-height: 120px; }
    /* いいねボタンのSVGトランジション */
    .like-btn svg { transition: all 0.2s ease-in-out; fill: none; }
    .like-btn.liked svg { stroke: transparent; fill: currentColor; transform: scale(1.1); }
    /* ハイライトボタンのスタイル */
    .highlight-btn {
      transition: all 0.2s ease;
      border-radius: 4px;
      padding: 2px;
    }
    .highlight-btn:hover {
      background: rgba(250, 204, 21, 0.1);
      transform: scale(1.1);
    }
    .highlight-btn.liked {
      color: #facc15;
      filter: drop-shadow(0 0 4px rgba(250, 204, 21, 0.7));
    }
    /* フッターコントロールのポインターイベント */
    #controlsFooter { pointer-events: none; }
    #controlsFooter > .glass-panel { pointer-events: auto; }
    /* スケルトンローディングのスタイル */
    .skeleton { position: relative; overflow: hidden; background-color: rgba(255,255,255,0.05); color: transparent; }
    .skeleton::after { content: ""; position: absolute; inset: 0; background-image: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.3), rgba(255,255,255,0)); animation: skeleton-loading 1.2s infinite; }
    @keyframes skeleton-loading { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
    
    /* スクリーンリーダー専用クラス（アクセシビリティ） */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
  </style>
</head>
<body class="bg-[#1a1b26] text-gray-200 font-sans">
  <div id="main-container" class="w-full mx-auto px-4 pt-4 pb-4 md:px-6 md:pt-6 md:pb-6">
    <header id="main-header" class="glass-panel rounded-xl p-4 mb-4 flex flex-col lg:flex-row justify-between items-center gap-4 shadow-lg">
      <div class="flex items-center gap-4 w-full lg:w-auto">
        <p id="answerCount" class="text-sm text-gray-400 flex items-center gap-2 flex-shrink-0"></p>
        <label for="classFilter" class="sr-only">クラス絞り込み</label>
        <select id="classFilter" class="hidden text-sm"></select>
        <label for="sortOrder" class="sr-only">並び順</label>
        <select id="sortOrder" class="text-sm">
          <option value="newest" selected>新着順</option>
          <option value="random">ランダム順</option>
          <option value="score" id="scoreOption" style="display: none;">スコア順</option>
        </select>
      </div>
      <div class="flex-grow text-center w-full min-w-0">
        <h1 id="siteTitle" class="game-font text-yellow-300 text-lg md:text-xl mb-1">みんなの回答ボード</h1>
        <p id="headingLabel" class="text-2xl md:text-3xl font-bold text-pink-400 leading-tight flex justify-center">
          <svg class="w-6 h-6 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" fill="currentColor"></path>
          </svg>
        </p>
      </div>
      <div class="w-full lg:w-auto lg:min-w-[150px] text-right space-y-1">
        <p id="sheetNameText" class="text-xs text-gray-400 h-4"></p>
        <p id="modeLabel" class="text-xs text-gray-400"></p>
        <button type="button" id="adminToggleBtn" class="text-xs text-cyan-400 underline hidden" hidden aria-label="管理者モード切り替え"></button>
      </div>
    </header>

    <main id="answers" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" role="main" aria-live="polite" aria-label="回答一覧"></main>
  </div>
  
  <div id="answerModalContainer" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 hidden opacity-0 transition-opacity duration-300" role="dialog" aria-modal="true">
    <div id="answerModalCard" class="glass-panel rounded-xl p-6 flex flex-col shadow-2xl border-2 border-cyan-400/80 w-full max-w-5xl h-auto max-h-[85vh] transform scale-95 transition-transform duration-300" role="document" aria-labelledby="modalAnswer">
      <button id="answerModalCloseBtn" class="absolute -top-3 -right-3 bg-red-600 rounded-full p-2 text-white hover:scale-110 transition-transform" aria-label="閉じる"></button>
      <div id="modalAnswer" class="flex-grow min-h-[200px] mb-4 overflow-y-auto pr-4"></div>
      <div id="modalFooter" class="text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex justify-between items-center">
        <div><span id="modalStudentName" class="font-bold text-2xl text-gray-200"></span></div>
        <div id="modalReactions" class="flex items-center gap-2"></div>
      </div>
    </div>
  </div>

  <div id="infoModalContainer" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 hidden opacity-0 transition-opacity duration-300" role="dialog" aria-modal="true">
    <div id="infoModalCard" class="glass-panel rounded-xl p-6 shadow-2xl border-2 border-cyan-400/80 w-full max-w-lg transform scale-95 transition-transform duration-300 relative" role="document">
      <div class="space-y-4 text-gray-200 text-lg leading-relaxed">
        <p>みんなの意見を気持ちよく共有するために、リアクションのしかたをおぼえよう！</p>
        <ul class="space-y-2">
          <li class="flex items-center gap-2"><span id="infoIconLike" class="w-5 h-5 text-red-400"></span>いいね：すてきだと思ったときに押そう</li>
          <li class="flex items-center gap-2"><span id="infoIconUnderstand" class="w-5 h-5 text-yellow-400"></span>なるほど：参考になったときに押そう</li>
          <li class="flex items-center gap-2"><span id="infoIconCurious" class="w-5 h-5 text-green-400"></span>きになる：もっと知りたいときに押そう</li>
        </ul>
        <p class="flex items-center gap-2"><span id="infoIconHighlight" class="w-5 h-5 text-yellow-300"></span>先生が注目してほしい意見につけています</p>
        <p>責任あるリアクションで、みんなで学びを深めよう！</p>
        <div class="text-center mt-6">
          <button id="infoModalConfirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">わかった</button>
        </div>
      </div>
    </div>
  </div>

  <footer id="controlsFooter" class="fixed bottom-0 left-0 right-0 z-40 p-4">
    <div class="glass-panel max-w-md mx-auto rounded-xl p-3 flex items-center justify-center gap-3">
      <input type="range" id="sizeSlider" min="2" max="6" value="4" class="w-1/2" aria-label="表示列数の変更">
      <div class="flex items-center gap-1">
        <span id="sliderValue" class="font-bold text-lg">4</span>
        <span id="footerIcon" class="w-4 h-4"></span>
      </div>
      <button type="button" id="modeToggleBtn" class="ml-4 px-3 py-1 rounded bg-blue-600 hover:bg-blue-700 text-white text-sm" title="プレビューモード切り替え">切替</button>
    </div>
  </footer>

  <script>
    // サーバーからの変数をJavaScriptの定数として利用（プレビューでは無視）
    // プレビューモードでは以下の変数は未定義になるが、window変数から参照
    let showAdminFeatures, showHighlightToggle, isAdminUser;
    try {
      // GAS環境でのみ実行される（プレビューではエラーになるが無視）
      showAdminFeatures = window.showAdminFeatures;
      showHighlightToggle = window.showHighlightToggle;
      isAdminUser = !window.isStudentMode;
    } catch (e) {
      // プレビューモードでは無視
    }
    
    // SVGアイコンの定義
    const ICONS = {
      'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
      'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
      'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
      'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
      'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
      'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
      'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
      'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
      'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
    };

    class StudyQuestApp {
      constructor() {
        try {
        // パフォーマンス最適化のためのキャッシュ
        this.cache = new Map();
        this.memoCache = new Map();
        
        // UI要素への参照を格納
        this.elements = {
          body: document.body,
          mainContainer: document.getElementById('main-container'),
          header: document.getElementById('main-header'),
          answersContainer: document.getElementById('answers'),
          sizeSlider: document.getElementById('sizeSlider'),
          sliderValue: document.getElementById('sliderValue'),
          headingLabel: document.getElementById('headingLabel'),
          sheetNameText: document.getElementById('sheetNameText'),
          modeLabel: document.getElementById('modeLabel'),
          adminToggleBtn: document.getElementById('adminToggleBtn'),
          answerCount: document.getElementById('answerCount'),
          answerModalContainer: document.getElementById('answerModalContainer'),
          answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
          answerModalCard: document.getElementById('answerModalCard'),
          modalAnswer: document.getElementById('modalAnswer'),
          modalStudentName: document.getElementById('modalStudentName'),
          modalReactionContainer: document.getElementById('modalReactions'),
          modalFooter: document.getElementById('modalFooter'),
          infoModalContainer: document.getElementById('infoModalContainer'),
          infoModalCard: document.getElementById('infoModalCard'),
          infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
          infoIconLike: document.getElementById('infoIconLike'),
          infoIconUnderstand: document.getElementById('infoIconUnderstand'),
          infoIconCurious: document.getElementById('infoIconCurious'),
          infoIconHighlight: document.getElementById('infoIconHighlight'),
          classFilter: document.getElementById('classFilter'),
          sortOrder: document.getElementById('sortOrder'),
          scoreOption: document.getElementById('scoreOption'), // スコア順オプション
          footer: document.getElementById('controlsFooter'),
          modeToggleBtn: document.getElementById('modeToggleBtn'), // プレビューモード切り替えボタン
          footerIcon: document.getElementById('footerIcon'),
        };

        if (this.elements.modeLabel) {
          this.elements.modeLabel.textContent = window.showAdminFeatures ? '管理モード' : '閲覧モード';
        }

        // アプリケーションの状態管理
        this.state = {
          currentAnswers: [], // 現在表示されている回答データ
          isLoading: false, // データロード中フラグ
          lastFocusedElement: null, // モーダル表示前のフォーカス要素
          // 初期化時にwindowグローバル変数を参照
          isStudentMode: window.isStudentMode,
          showCounts: window.showCounts,
          showAdminFeatures: window.showAdminFeatures,
          showHighlightToggle: window.showHighlightToggle,
          showScoreSort: window.showScoreSort,
          showPublishControls: window.showPublishControls,
          displayMode: window.displayMode,
        };

        // シート設定による詳細表示フラグを保持
        this.serverShowDetails = window.showCounts;
        
        this.pollingInterval = null; // ポーリングタイマーID

        // リアクションの種類とアイコンのマッピング
        this.reactionTypes = [
          { key: 'LIKE', icon: 'hand-thumb-up' },
          { key: 'UNDERSTAND', icon: 'lightbulb' },
          { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
        ];
        
        // Google Apps Script関数へのラッパー
        this.gas = {
          getPublishedSheetData: (classFilter, sort) => this.runGas('getPublishedSheetData', classFilter, sort),
          addLike: (rowIndex) => this.runGas('addReaction', rowIndex, 'LIKE', SHEET_NAME),
          addReaction: (rowIndex, reaction) => this.runGas('addReaction', rowIndex, reaction, SHEET_NAME),
          toggleHighlight: (rowIndex, current) => this.runGas('toggleHighlight', rowIndex, SHEET_NAME, current),
          checkAdmin: () => this.runGas('checkAdmin')
        };
        
          // GSAPが読み込まれるのを待ってから初期化処理を実行
          this.waitForGSAP().then(() => {
            this.init();
          }).catch(error => {
            console.error('Error waiting for GSAP or during init:', error);
          });

          // 保存された列数をローカルストレージからロード
          const savedCols = localStorage.getItem('boardColumns');
          if (savedCols) {
            this.elements.sizeSlider.value = savedCols;
            this.elements.sliderValue.textContent = savedCols;
          }
          
        } catch (error) {
          console.error('Error in StudyQuestApp constructor:', error);
          throw error;
        }
      }

      // パフォーマンス最適化ユーティリティ
      memoize(fn, keyGenerator) {
        const kg = keyGenerator || ((...args) => JSON.stringify(args));
        return (...args) => {
          const key = kg(...args);
          if (this.memoCache.has(key)) {
            return this.memoCache.get(key);
          }
          const result = fn.apply(this, args);
          this.memoCache.set(key, result);
          return result;
        };
      }

      // RequestAnimationFrameベースのスケジューラ
      scheduleUpdate(callback) {
        if (this.updateScheduled) return;
        this.updateScheduled = true;
        requestAnimationFrame(() => {
          callback();
          this.updateScheduled = false;
        });
      }

      // ファクトリーパターンでDOM要素作成を最適化
      createElementWithClasses(tag, classes, content = '') {
        const cacheKey = `${tag}-${classes}`;
        let element;
        
        if (this.cache.has(cacheKey)) {
          element = this.cache.get(cacheKey).cloneNode(true);
        } else {
          element = document.createElement(tag);
          element.className = classes;
          this.cache.set(cacheKey, element.cloneNode(true));
        }
        
        if (content) element.textContent = content;
        return element;
      }

      /**
       * GSAPライブラリが利用可能になるまで待機する
       * @returns {Promise<void>}
       */
      waitForGSAP() {
        return new Promise(resolve => {
          if (typeof gsap !== 'undefined') {
            resolve();
          } else {
            // GSAPが読み込まれるまでポーリング
            const checkGSAP = setInterval(() => {
              if (typeof gsap !== 'undefined') {
                clearInterval(checkGSAP);
                resolve();
              }
            }, 50); // 50msごとにチェック
          }
        });
      }

      /**
       * アプリケーションの初期化処理
       */
      init() {
        if (DEBUG) console.log('StudyQuestApp init() called');
        if (DEBUG) console.log('Current state:', this.state);
        if (DEBUG) console.log('Elements check:', {
          answersContainer: !!this.elements.answersContainer,
          headingLabel: !!this.elements.headingLabel,
          answerCount: !!this.elements.answerCount
        });
        this.renderIcons(); // アイコンのレンダリング
        this.setupEventListeners(); // イベントリスナーの設定
        this.verifyAdmin(); // 管理者権限の確認
        this.adjustLayout(); // レイアウト調整
        this.loadInitialData(); // 初期データのロード
        this.setupInitialModeButton(); // モード切り替えボタンの初期設定
        this.updateSortOptions(); // ソートオプションの更新（スコア順の表示/非表示）
        if (!localStorage.getItem('introSeen')) {
          this.showInfoModal();
        }
      }

      /**
       * イベントリスナーの設定（イベント委譲で最適化）
       */
      setupEventListeners() {
        // スライダーの変更をデバウンスしてレンダリング
        const debouncedRender = this.debounce(() => this.renderBoard(true), CONFIG.POLLING.DEBOUNCE_MS);
        this.elements.sizeSlider.addEventListener('input', () => {
          localStorage.setItem('boardColumns', this.elements.sizeSlider.value);
          debouncedRender();
        });

        // メインコンテナでイベント委譲を使用（パフォーマンス最適化）
        this.setupEventDelegation();
        // モーダルの閉じるボタンと背景クリック
        this.elements.answerModalCloseBtn.addEventListener('click', () => this.hideAnswerModal());
        this.elements.answerModalContainer.addEventListener('click', (e) => {
          if (e.target === e.currentTarget) {
            this.hideAnswerModal();
          }
        });
        if (this.elements.infoModalConfirmBtn) {
          this.elements.infoModalConfirmBtn.addEventListener('click', () => this.hideInfoModal());
        }
        // モーダル内のリアクションボタン
        this.elements.modalReactionContainer.addEventListener('click', (e) => {
          const btn = e.target.closest('.reaction-btn');
          if (btn) {
            const id = btn.dataset.rowIndex;
            const reaction = btn.dataset.reaction;
            if (id && reaction) {
              this.handleReaction(id, reaction);
            }
          }
        });
        // クラスフィルターとソート順の変更
        this.elements.classFilter.addEventListener('change', () => this.loadSheetData(true));
        this.elements.sortOrder.addEventListener('change', () => this.loadSheetData(true));
        // 管理者モード切り替えボタン
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.addEventListener('click', () => this.toggleAdminMode());
        }
        // Escapeキーでモーダルを閉じる
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.hideAnswerModal();
          }
        });
        // ウィンドウリサイズ時のレイアウト調整をデバウンス
        window.addEventListener('resize', this.debounce(() => this.adjustLayout(), 100));
        
        // プレビューモード切り替えボタンのイベントリスナー
        if (this.elements.modeToggleBtn) {
          this.elements.modeToggleBtn.addEventListener('click', () => this.togglePreviewMode());
        }
        
        // ブラウザタブの表示状態変更時のポーリング制御
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            this.stopPolling();
          } else {
            this.startPolling();
          }
        });
      }

      /**
       * イベント委譲の設定（パフォーマンス最適化）
       * 個別のカードにイベントリスナーを追加する代わりに、親コンテナで一括処理
       */
      setupEventDelegation() {
        // メインの回答コンテナでイベント委譲
        this.elements.answersContainer.addEventListener('click', (e) => {
          const answerCard = e.target.closest('.answer-card');
          if (!answerCard) return;

          const rowIndex = answerCard.dataset.rowIndex;
          if (!rowIndex) return;

          // リアクションボタンのクリック処理
          const reactionBtn = e.target.closest('.reaction-btn');
          if (reactionBtn) {
            e.stopPropagation();
            const reactionType = reactionBtn.dataset.reaction;
            if (reactionType) {
              this.handleReaction(rowIndex, reactionType);
            }
            return;
          }

          // ハイライトボタンのクリック処理
          const highlightBtn = e.target.closest('.highlight-btn');
          if (highlightBtn) {
            e.stopPropagation();
            this.handleHighlight(rowIndex);
            return;
          }

          // カード本体のクリック処理（モーダル表示）
          this.showAnswerModal(rowIndex);
        });

        // キーボードナビゲーション対応
        this.elements.answersContainer.addEventListener('keydown', (e) => {
          const answerCard = e.target.closest('.answer-card');
          if (!answerCard) return;

          const rowIndex = answerCard.dataset.rowIndex;
          if (!rowIndex) return;

          // Enterキーまたはスペースキーでカード選択
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            
            // フォーカスがボタン上にある場合は、そのボタンをクリック
            const focusedBtn = document.activeElement;
            if (focusedBtn.matches('.reaction-btn')) {
              const reactionType = focusedBtn.dataset.reaction;
              if (reactionType) {
                this.handleReaction(rowIndex, reactionType);
              }
              return;
            }
            
            if (focusedBtn.matches('.highlight-btn')) {
              this.handleHighlight(rowIndex);
              return;
            }
            
            // それ以外の場合はモーダルを表示
            this.showAnswerModal(rowIndex);
          }
        });

        // 動的に追加される要素用のイベント委譲（document レベル）
        document.addEventListener('click', (e) => {
          // 再試行ボタンの処理
          if (e.target.matches('#retryLoadBtn')) {
            e.preventDefault();
            this.loadInitialData();
            return;
          }

          // その他の動的ボタンがあれば追加
        });
      }

      /**
       * ヘッダーとフッターの高さに基づいてメインコンテンツのパディングを調整
       */
      adjustLayout() {
        if (this.baseMainPadding === undefined) {
          this.baseMainPadding = parseFloat(
            getComputedStyle(this.elements.mainContainer).paddingTop
          ) || 0;
        }
        if (this.baseBodyPadding === undefined) {
          this.baseBodyPadding = parseFloat(
            getComputedStyle(this.elements.body).paddingBottom
          ) || 0;
        }

        const footerHeight = this.elements.footer.offsetHeight;

        // Keep original padding only, removing extra space above the header
        this.elements.mainContainer.style.paddingTop =
          this.baseMainPadding + 'px';
        // Reserve only footer height so content ends right above the slider
        this.elements.body.style.paddingBottom =
          footerHeight + this.baseBodyPadding + 'px';
      }

      /**
       * Google Apps Script関数を実行
       * @param {string} funcName - 実行するGAS関数の名前
       * @param {...any} args - GAS関数に渡す引数
       * @returns {Promise<any>} GAS関数の結果を解決するPromise
       */
      runGas(funcName, ...args) {
        return new Promise((resolve, reject) => {
          // Google Apps Script環境で実行されているかチェック
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run
              .withSuccessHandler(resolve) // 成功時のハンドラ
              .withFailureHandler(reject) // 失敗時のハンドラ
              [funcName](...args); // GAS関数を実行
          } else {
            // GAS環境がない場合は、デバッグ用のモックデータを使用
            console.warn('Google Apps Script environment not detected. Using mock data.');
            this.getMockData(funcName, ...args).then(resolve).catch(reject);
          }
        });
      }

      /**
       * 管理者権限を確認し、管理者モードボタンの表示を制御
       */
      async verifyAdmin() {
        try {
          const ok = await this.gas.checkAdmin();
          if (ok && this.elements.adminToggleBtn) {
            this.state.isAdminUser = true; // 管理者フラグを更新
            this.elements.adminToggleBtn.classList.remove('hidden'); // ボタンを表示
            this.elements.adminToggleBtn.removeAttribute('hidden');
            // 現在の管理者機能表示状態に基づいてボタンテキストを設定
            this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
            if (this.elements.modeLabel) {
              this.elements.modeLabel.textContent = this.state.showAdminFeatures ? '管理モード' : '閲覧モード';
            }
          }
        } catch (e) {
          console.error('Admin check failed', e);
        }
      }
      
      /**
       * デバッグ用のモックデータを生成
       * @param {string} funcName - 呼び出されたGAS関数の名前
       * @param {...any} args - 渡された引数
       * @returns {Promise<any>} モックデータを解決するPromise
       */
      getMockData(funcName, ...args) {
        if (DEBUG) console.log('getMockData called with:', funcName, args);
        return new Promise((resolve) => {
          setTimeout(() => {
            if (funcName === 'getPublishedSheetData') {
              // 現在の状態を最新のwindow変数から取得してから名前を切り替える
              const currentDisplayMode = window.displayMode || this.state.displayMode;
              const studentName1 = currentDisplayMode === 'named' ? '田中太郎' : '';
              const studentName2 = currentDisplayMode === 'named' ? '佐藤花子' : '';
              
              resolve({
                header: 'テスト問題',
                sheetName: 'テストシート',
                rows: [
                  {
                    rowIndex: 1,
                    name: studentName1,
                    class: '3年A組',
                    opinion: 'これは素晴らしいアイデアだと思います。',
                    reason: '理由は簡潔で分かりやすく、実現可能性が高いからです。',
                    reactions: {
                      UNDERSTAND: { count: 5, reacted: false },
                      LIKE: { count: 2, reacted: false },
                      CURIOUS: { count: 1, reacted: false }
                    },
                    highlight: false
                  },
                  {
                    rowIndex: 2,
                    name: studentName2,
                    class: '3年B組',
                    opinion: '少し改善の余地があると考えます。',
                    reason: 'より多くの人の意見を聞く必要があると思います。',
                    reactions: {
                      UNDERSTAND: { count: 3, reacted: true },
                      LIKE: { count: 0, reacted: false },
                      CURIOUS: { count: 0, reacted: false }
                    },
                    highlight: true
                  },
                  {
                    rowIndex: 3,
                    name: studentName1,
                    class: '3年A組',
                    opinion: '新たな視点が得られました。',
                    reason: 'この考え方は今までになかったもので、深く考察する価値があります。',
                    reactions: {
                      UNDERSTAND: { count: 1, reacted: false },
                      LIKE: { count: 1, reacted: false },
                      CURIOUS: { count: 5, reacted: true }
                    },
                    highlight: false
                  },
                  {
                    rowIndex: 4,
                    name: studentName2,
                    class: '3年C組',
                    opinion: '具体的な解決策が見えました。',
                    reason: 'データに基づいた分析がされており、実行に移しやすいと感じました。',
                    reactions: {
                      UNDERSTAND: { count: 4, reacted: true },
                      LIKE: { count: 3, reacted: false },
                      CURIOUS: { count: 0, reacted: false }
                    },
                    highlight: false
                  }
                ]
              });
            } else if (funcName === 'addReaction') {
              // リアクション追加のモック
              resolve({
                status: 'ok',
                reactions: {
                  UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
                  LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
                  CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
                }
              });
            } else if (funcName === 'toggleHighlight') {
              // ハイライトトグルのモック
              const currentHighlight = args[2] === undefined ? (args[1] === undefined ? false : !args[1]) : !args[2];
              resolve({
                status: 'ok',
                highlight: currentHighlight
              });
            } else if (funcName === 'checkAdmin') {
              // 管理者チェックのモック (開発用に常にtrueを返す)
              resolve(true); 
            }
          }, 500); // 500msの遅延をシミュレート
        });
      }

      /**
       * データポーリングを開始
       */
      startPolling() {
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
        }
        this.pollingInterval = setInterval(() => this.loadSheetData(false), 15000); // 15秒ごとに更新
      }

      /**
       * データポーリングを停止
       */
      stopPolling() {
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        }
      }

      /**
       * 初期データをロードし、ポーリングを開始
       */
      async loadInitialData() {
        if (DEBUG) console.log('DEBUG: loadInitialData started');
        
        // 強制的にシンプルなテストカードを表示
        this.elements.answersContainer.innerHTML = '<div class="glass-panel rounded-xl p-4 text-white">テストカード表示中...</div>';
        
        await this.loadSheetData(true, true);
        this.startPolling();
      }

      /**
       * スプレッドシートデータをロード
       * @param {boolean} showLoading - ローディング表示を行うか
       * @param {boolean} isInitialLoad - 初回ロードかどうか
       */
      async loadSheetData(showLoading = true, isInitialLoad = false) {
        if (DEBUG) console.log('loadSheetData called', { showLoading, isInitialLoad });
        if (this.state.isLoading && showLoading) return; // すでにロード中の場合は何もしない
        this.state.isLoading = true;
        
        const selectedClass = isInitialLoad ? 'すべて' : this.elements.classFilter.value;
        const oldAnswers = [...this.state.currentAnswers]; // 現在のデータをバックアップ

        if (showLoading) {
          // スケルトンカードを表示
          const count = parseInt(this.elements.sizeSlider.value, 10) * 2; // 表示列数に基づいてスケルトン数を決定
          const frag = document.createDocumentFragment();
          for (let i = 0; i < count; i++) {
            frag.appendChild(this.createSkeletonCard());
          }
          const container = this.elements.answersContainer;
          // Gridクラスを更新
          container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
          container.innerHTML = '';
          container.appendChild(frag);
        }
        
        try {
          const sortOrder = this.elements.sortOrder.value;
          if (DEBUG) console.log('Calling getPublishedSheetData with:', { selectedClass, sortOrder });
          const data = await this.gas.getPublishedSheetData(selectedClass, sortOrder); // GASからデータを取得
          if (DEBUG) console.log('Received data:', data);
          if (typeof data.showDetails !== 'undefined') {
            this.serverShowDetails = data.showDetails;
            if (!this.state.showAdminFeatures) {
              window.showCounts = data.showDetails;
              window.displayMode = data.showDetails ? 'named' : 'anonymous';
              this.updateConfigFromGlobals();
            }
          }
          this.adjustLayout(); // レイアウト調整

          // 管理者権限がない場合は管理機能を無効化
          if (!this.state.isAdminUser) {
            this.state.showAdminFeatures = false;
            this.state.showHighlightToggle = false;
          }
          
          if (isInitialLoad) {
            this.populateClassFilter(data.rows); // クラスフィルターを生成
            this.elements.sheetNameText.textContent = 'シート: ' + this.escapeHtml(data.sheetName || '不明');
          }

          // データが変更された場合のみボードをレンダリング
          if (DEBUG) console.log('Comparing data:', {
            currentAnswers: this.state.currentAnswers.length,
            newRows: data.rows.length,
            dataChanged: JSON.stringify(this.state.currentAnswers) !== JSON.stringify(data.rows)
          });
          if (JSON.stringify(this.state.currentAnswers) !== JSON.stringify(data.rows)) {
            if (DEBUG) console.log('Data changed, rendering board with', data.rows.length, 'rows');
            this.state.currentAnswers = data.rows;
            this.elements.headingLabel.textContent = this.escapeHtml(data.header || '問題');
            this.renderBoard(false, oldAnswers); // ボードをレンダリング
          } else {
            if (DEBUG) console.log('Data unchanged, skipping render');
          }
        } catch (error) {
          console.error('Error loading sheet data:', error);
          const errorMessage = this.escapeHtml(error.message || 'Unknown error');
          // エラーメッセージを表示
          this.elements.answersContainer.innerHTML = 
            '<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">' +
            '<p class="font-bold">データの読み込みに失敗しました。</p>' +
            '<p class="text-sm mt-2">' + errorMessage + '</p>' +
            '<button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">再試行</button>' +
            '</div>';
          
          // 再試行ボタンのイベントリスナーは setupEventDelegation() で処理済み
        } finally {
          this.state.isLoading = false; // ロード完了
        }
      }

      /**
       * クラスフィルターのドロップダウンをデータで埋める
       * @param {Array<Object>} rows - 回答データの配列
       */
      populateClassFilter(rows) {
        const classFilter = this.elements.classFilter;
        // ユニークなクラス名を取得し、「すべて」を追加
        const uniqueClasses = ['すべて', ...new Set(rows.map(r => r.class).filter(Boolean))];
        classFilter.innerHTML = uniqueClasses.map(c => 
          '<option value="' + this.escapeHtml(c) + '">' + this.escapeHtml(c) + '</option>'
        ).join('');
        classFilter.value = 'すべて'; // デフォルト値を「すべて」に設定
        classFilter.classList.remove('hidden'); // 非表示クラスを削除
      }

      /**
       * 回答ボードをレンダリングまたは更新する
       * @param {boolean} isLayoutChange - レイアウト変更による再レンダリングか
       * @param {Array<Object>} oldRows - 前回の回答データの配列
       */
      renderBoard(isLayoutChange = false, oldRows = []) {
        if (DEBUG) console.log('renderBoard called with:', { isLayoutChange, newRowsCount: this.state.currentAnswers.length });
        const container = this.elements.answersContainer;
        const newRows = this.state.currentAnswers;
        
        // 旧い要素の位置を記録
        const oldPositions = new Map();
        container.querySelectorAll('.answer-card').forEach(card => {
          oldPositions.set(card.dataset.rowIndex, card.getBoundingClientRect());
        });

        this.elements.sliderValue.textContent = this.elements.sizeSlider.value;
        // グリッド列数を更新
        container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
        
        // 回答数表示の更新
        const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
        this.elements.answerCount.innerHTML = userIcon + '<span>' + newRows.length + '件</span>';
        
        if (newRows.length === 0) {
          if (!container.querySelector('.no-answers')) {
            container.innerHTML = '';
            const p = document.createElement('p');
            p.className = 'text-center text-gray-500 col-span-full mt-8 no-answers';
            p.textContent = 'このクラスの回答はありません。';
            container.appendChild(p);
          }
        } else {
          const existingMap = new Map();
          container.querySelectorAll('.answer-card').forEach(card => {
            existingMap.set(card.dataset.rowIndex, card);
          });

          // 不要になったカードを削除
          existingMap.forEach((card, id) => {
            if (!newRows.some(r => String(r.rowIndex) === id)) {
              card.remove();
              existingMap.delete(id);
            }
          });

          const changedItems = [];
          let prevNode = null;

          newRows.forEach((row) => {
            const rowId = String(row.rowIndex);
            let card = existingMap.get(rowId);
            const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);

            if (!card) {
              card = this.createAnswerCard(row);
              if (prevNode) {
                container.insertBefore(card, prevNode.nextSibling);
              } else {
                container.insertBefore(card, container.firstChild);
              }
              changedItems.push(row);
            } else {
              if (prevNode && card.previousSibling !== prevNode) {
                container.insertBefore(card, prevNode.nextSibling);
              } else if (!prevNode && card !== container.firstChild) {
                container.insertBefore(card, container.firstChild);
              }

              if (oldData) {
                if (oldData.opinion !== row.opinion) {
                  const t = card.querySelector('.opinion-text');
                  if (t) t.textContent = row.opinion;
                }
                if (oldData.reason !== row.reason) {
                  const p = card.querySelector('.answer-preview p');
                  if (p) p.textContent = row.reason;
                }
                if (oldData.name !== row.name) {
                  const n = card.querySelector('.font-bold');
                  if (n) n.textContent = row.name;
                }
                if (JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) ||
                    oldData.highlight !== row.highlight) {
                  changedItems.push(row);
                }
              }
            }
            prevNode = card;
          });

          if (changedItems.length) {
            this.applyUpdates(changedItems);
          }

          if (DEBUG) console.log('DOM updated. Cards in container:', container.querySelectorAll('.answer-card').length);
        }

        // カードのアニメーション（FLIPテクニック）
        container.querySelectorAll('.answer-card').forEach((card) => {
          const rowIndex = card.dataset.rowIndex;
          const oldPos = oldPositions.get(rowIndex);
          
          if (isLayoutChange || !oldPos) {
            // レイアウト変更時や新規カードはフェードイン
            gsap.fromTo(card, 
              { opacity: 0, y: 30 }, 
              { opacity: 1, y: 0, duration: 0.5, ease: 'power3.out' }
            );
          } else {
            const newPos = card.getBoundingClientRect();
            const deltaX = oldPos.left - newPos.left;
            const deltaY = oldPos.top - newPos.top;
            
            // 初期の位置をセットし、現在の位置へアニメーション
            if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) { // わずかな移動は無視
              gsap.fromTo(card, 
                { x: deltaX, y: deltaY, opacity: 1 }, 
                { x: 0, y: 0, opacity: 1, duration: 0.7, ease: 'power3.inOut' }
              );
            } else {
              // 移動がない場合もopacityを確実に1に設定
              gsap.set(card, { opacity: 1 });
            }

            // リアクション数変更時のアニメーション
            const oldData = oldRows.find(r => String(r.rowIndex) === rowIndex);
            const newData = newRows.find(r => String(r.rowIndex) === rowIndex);
            if (oldData && newData) {
              const oldTotal = this.reactionTypes.reduce((sum, rt) => sum + (oldData.reactions?.[rt.key]?.count || 0), 0);
              const newTotal = this.reactionTypes.reduce((sum, rt) => sum + (newData.reactions?.[rt.key]?.count || 0), 0);
              if (oldTotal !== newTotal) {
                gsap.fromTo(card,
                  { backgroundColor: 'rgba(250, 204, 21, 0.4)' }, // 黄色く光る
                  { backgroundColor: 'rgba(26, 27, 38, 0.7)', duration: 0.8, ease: 'expo.out' }
                );
              }
            }
          }
        });
      }

      /**
       * 回答カード要素を生成
       * @param {Object} data - 回答データ
       * @returns {HTMLElement} 生成されたカード要素
       */
      createAnswerCard(data) {
        if (DEBUG) console.log('createAnswerCard called with data:', data);
        const card = document.createElement('div');
        const highlightClass = data.highlight ? ' highlighted' : '';
        card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer opacity-0' + highlightClass;
        card.dataset.rowIndex = data.rowIndex;

        // アクセシビリティ属性を追加
        card.setAttribute('role', 'article');
        card.setAttribute('tabindex', '0');
        card.setAttribute('aria-label', '回答カード: ' + (data.opinion || '').substring(0, 50) + (data.opinion && data.opinion.length > 50 ? '...' : ''));
        const instructionId = 'detail-instruction-' + data.rowIndex;
        let describedBy = instructionId;
        if (data.highlight) {
          describedBy += ' highlight-status-' + data.rowIndex;
        }
        card.setAttribute('aria-describedby', describedBy);

        // アクティブなリアクションタイプに基づいて背景クラスを設定
        const active = this.reactionTypes
          .filter(rt => data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0)
          .map(rt => rt.key);
        if (active.length === 1) {
          if (active[0] === 'LIKE') card.classList.add('reaction-bg-like');
          if (active[0] === 'UNDERSTAND') card.classList.add('reaction-bg-understand');
          if (active[0] === 'CURIOUS') card.classList.add('reaction-bg-curious');
        } else if (active.length === 2) {
          card.classList.add('reaction-bg-mixed');
        } else if (active.length > 2) {
          card.classList.add('reaction-bg-all');
        }

        // リアクション総数に応じてボーダークラスを追加
        const totalReactions = this.reactionTypes.reduce((sum, rt) =>
          sum + (data.reactions?.[rt.key]?.count || 0), 0);
        if (totalReactions >= 10) {
          card.classList.add('reaction-border-3');
        } else if (totalReactions >= 5) {
          card.classList.add('reaction-border-2');
        } else if (totalReactions > 0) {
          card.classList.add('reaction-border-1');
        }

        let highlightBtnHtml = '';
        // ハイライトトグル機能が有効な場合のみボタンを生成
        if (this.state.showHighlightToggle) {
          const cls = data.highlight ? 'liked' : '';
          const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
          highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-yellow-400 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' +
                             this.getIcon('star', 'w-5 h-5') +
                             '</button>';
        }
        
        // 名前表示設定に基づき学生名を表示
        const showName = this.state.displayMode === 'named';
        const nameHtml = showName ? '<div><span class="font-bold text-sm text-gray-200">' + this.escapeHtml(data.name) + '</span></div>' : '';
        const containerClass = nameHtml ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-between items-center' : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';

        // リアクションボタンのHTMLを生成（アクセシビリティ強化）
        const reactionButtonsHtml = this.reactionTypes.map(rt => {
          const info = data.reactions ? data.reactions[rt.key] : { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
          
          // showCountsがtrueの場合のみカウントを表示
          const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' + (info.count || 0) + '</span>' : '';
          
          // アクセシビリティ向上のためのaria-label
          const reactionNames = {
            'LIKE': 'いいね',
            'UNDERSTAND': 'なるほど',
            'CURIOUS': '気になる'
          };
          const reactionName = reactionNames[rt.key] || rt.key;
          const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count || 0}件)` : ''}`;
          
          return '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' + colorClass + ' ' + cls + '" data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + ariaLabel + '" aria-pressed="' + info.reacted + '">' +
                   this.getIcon(rt.icon, 'w-5 h-5', info.reacted) +
                   countSpan +
                   '</button>';
        }).join('');

        // ハイライト状態を隠れた要素で通知（スクリーンリーダー用）
        const highlightStatusHtml = data.highlight ?
          '<div id="highlight-status-' + data.rowIndex + '" class="sr-only">この回答はハイライトされています</div>' : '';
        // 詳細表示のヒントを隠れた要素で提供
        const instructionHtml = '<div id="' + instructionId + '" class="sr-only">Enter または Space で詳細表示</div>';
        
        card.innerHTML =
          '<div class="relative flex-grow mb-3 answer-preview">' +
          '<h3 class="opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight">' +
          this.escapeHtml(data.opinion || '') + '</h3>' +
          '<p class="text-gray-100 whitespace-pre-wrap break-words mt-4">' +
          this.escapeHtml(data.reason || '') + '</p>' +
          '</div>' +
          '<div class="' + containerClass + '">' +
          nameHtml + // 学生名（管理者モードのみ）
          '<div class="flex items-center gap-1" role="group" aria-label="回答への反応">' +
          reactionButtonsHtml + // リアクションボタン群
          highlightBtnHtml + // ハイライトボタン（管理者モードのみ）
          '</div>' +
          '</div>' +
          highlightStatusHtml + // ハイライト状態通知
          instructionHtml; // 詳細表示ヒント

        // ハイライトバッジを動的に追加
        if (data.highlight) {
          const badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star');
          card.appendChild(badge);
          this.animateHighlightBadge(badge); // バッジのアニメーション
        }
        
        // カードクリックイベントリスナーは setupEventDelegation() で一括処理されるため不要
        // 個別のイベントリスナー追加を削除してパフォーマンスを向上
        
        // 以下のコードは setupEventDelegation() に移行済み:
        // - リアクションボタンのクリック処理
        // - ハイライトボタンのクリック処理  
        // - カード本体のクリック処理（モーダル表示）

        if (DEBUG) console.log('Card created successfully:', card);
        return card;
      }

      /**
       * スケルトンローディングカードを生成
       * @returns {HTMLElement} 生成されたスケルトンカード要素
       */
      createSkeletonCard() {
        const card = document.createElement('div');
        card.className = 'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
        card.innerHTML =
          '<div class="flex-1 space-y-3">' +
          '<div class="h-6 w-3/4 rounded bg-gray-500/30"></div>' +
          '<div class="h-4 w-full rounded bg-gray-500/20"></div>' +
          '<div class="h-4 w-5/6 rounded bg-gray-500/20"></div>' +
          '</div>' +
          '<div class="mt-4 h-8 rounded bg-gray-500/20"></div>';
        return card;
      }

      /**
       * リアクションを処理
       * @param {number} rowIndex - 回答の行インデックス
       * @param {string} reaction - リアクションタイプ ('LIKE', 'UNDERSTAND', 'CURIOUS')
       */
      async handleReaction(rowIndex, reaction) {
        // リアクションボタンのアニメーション
        const btns = document.querySelectorAll('[data-row-index="' + rowIndex + '"][data-reaction="' + reaction + '"]');
        if (typeof gsap !== 'undefined') {
          btns.forEach(btn => {
            gsap.fromTo(btn,
              { scale: 1 },
              { scale: 1.3, yoyo: true, repeat: 1, duration: 0.2, ease: 'power2.inOut' }
            );
          });
        }
        try {
          // GAS関数を呼び出し、リアクションを更新
          const res = await this.gas.addReaction(rowIndex, reaction);
          if (res && res.status === 'ok') {
            const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
            if (item && res.reactions) {
              item.reactions = res.reactions; // 最新のリアクションデータで更新
              this.applyUpdates([item]); // UIを更新
            }
          } else if (res && res.message) {
            // エラーメッセージがあれば表示（カスタムモーダルに置き換えるべき）
            console.error('Failed to add reaction:', res.message);
            // alert(res.message); 開発用の仮メッセージ
          }
        } catch (error) {
          console.error('Failed to add reaction:', error);
        }
      }

      /**
       * 回答のハイライト状態を切り替える
       * @param {number} rowIndex - 回答の行インデックス
       */
      async handleHighlight(rowIndex) {
        try {
          const item = this.state.currentAnswers.find(i => i.rowIndex == rowIndex);
          // GAS関数を呼び出し、ハイライト状態を切り替える
          const res = await this.gas.toggleHighlight(rowIndex, item.highlight); // 現在のハイライト状態をGASに渡す
          if (res && res.status === 'ok') {
            if (item) {
              item.highlight = res.highlight; // 最新のハイライト状態で更新
            }
            this.applyUpdates([item]); // UIを更新
          } else if (res && res.message) {
            // エラーメッセージがあれば表示（カスタムモーダルに置き換えるべき）
            console.error('Failed to toggle highlight:', res.message);
            // alert(res.message); 開発用の仮メッセージ
          }
        } catch (error) {
          console.error('Failed to toggle highlight:', error);
        }
      }

      /**
       * 管理者モードと閲覧モードを切り替える
       */
      async toggleAdminMode() {
        if (DEBUG) console.log('toggleAdminMode: start, current state:', {
          showAdminFeatures: this.state.showAdminFeatures,
          showHighlightToggle: this.state.showHighlightToggle
        });
        const enable = !this.state.showAdminFeatures; // 現在の状態を反転
        if (DEBUG) console.log('toggleAdminMode: enable =', enable);
        if (enable) {
          try {
            const ok = await this.gas.checkAdmin(); // 管理者権限を再度チェック
            if (!ok) {
              // alert('管理者権限がありません。'); // 権限がない場合は警告
              console.warn('管理者権限がありません。');
              return;
            }
          } catch (e) {
            console.error('権限確認に失敗しました', e);
            // alert('権限確認に失敗しました');
            return;
          }
        }
        // グローバル変数と状態を更新
        window.showAdminFeatures = enable;
        window.showHighlightToggle = enable;
        window.showScoreSort = enable;
        if (enable) {
          // 管理者モードでは常に詳細表示
          window.showCounts = true;
          window.displayMode = 'named';
          window.isStudentMode = false;
        } else {
          // 閲覧モードではシート設定を適用
          window.showCounts = this.serverShowDetails;
          window.displayMode = this.serverShowDetails ? 'named' : 'anonymous';
          window.isStudentMode = true;
        }

        this.updateConfigFromGlobals(); // グローバル変数から状態を同期
        
        if (DEBUG) console.log('toggleAdminMode: state after update:', {
          showHighlightToggle: this.state.showHighlightToggle,
          showAdminFeatures: this.state.showAdminFeatures,
          showCounts: this.state.showCounts,
          isStudentMode: this.state.isStudentMode,
          displayMode: this.state.displayMode
        });
        
        if (this.elements.adminToggleBtn) {
          this.elements.adminToggleBtn.textContent = enable ? '閲覧モード' : '管理モード';
        }
        if (this.elements.modeLabel) {
          this.elements.modeLabel.textContent = this.state.showAdminFeatures ? '管理モード' : '閲覧モード';
        }
        this.updateSortOptions(); // ソートオプションの表示を更新
        
        
        this.loadSheetData(true, true); // データとUIを再ロード
      }

      /**
       * リアクションボタンのUIを更新
       * @param {number} rowIndex - 回答の行インデックス
       * @param {string} reaction - リアクションタイプ
       * @param {number} count - リアクション数
       * @param {boolean} reacted - ユーザーがリアクションしたか
       */
      updateReactionButtonUI(rowIndex, reaction, count, reacted) {
        document.querySelectorAll('[data-row-index="' + rowIndex + '"][data-reaction="' + reaction + '"]').forEach(btn => {
          const countEl = btn.querySelector('.reaction-count');
          if (countEl && this.state.showCounts) { // showCountsがtrueの場合のみカウントを更新
            countEl.textContent = count;
          }
          const rt = this.reactionTypes.find(r => r.key === reaction);
          const svgEl = btn.querySelector('svg');
          if (svgEl && rt) {
            // アイコンを更新（solid/outline切り替え）
            svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', reacted);
          }
          btn.classList.toggle('liked', reacted); // likedクラスを切り替え
          
          // アクセシビリティ属性を更新
          btn.setAttribute('aria-pressed', reacted.toString());
          
          // aria-labelを現在の状態で更新
          const reactionNames = {
            'LIKE': 'いいね',
            'UNDERSTAND': 'なるほど',
            'CURIOUS': '気になる'
          };
          const reactionName = reactionNames[reaction] || reaction;
          const ariaLabel = `${reactionName}${reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${count}件)` : ''}`;
          btn.setAttribute('aria-label', ariaLabel);
        });
      }

      /**
       * データ変更に基づいてUIを部分的に更新する
       * @param {Array<Object>} items - 更新する回答データの配列
       */
      applyUpdates(items) {
        items.forEach(item => {
          // 各リアクションボタンのUIを更新
          this.reactionTypes.forEach(rt => {
            if (item.reactions && item.reactions[rt.key]) {
              this.updateReactionButtonUI(item.rowIndex, rt.key, item.reactions[rt.key].count, item.reactions[rt.key].reacted);
            }
          });
          
          const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
          if (card) {
            card.classList.toggle('highlighted', item.highlight); // ハイライトクラスを切り替え

            // アクティブなリアクションタイプを再計算し、背景クラスを更新
            const active = this.reactionTypes
                .filter(rt => item.reactions && item.reactions[rt.key] && item.reactions[rt.key].count > 0)
                .map(rt => rt.key);

            // 既存のリアクション背景クラスを全て削除
            [
              'reaction-bg-like',
              'reaction-bg-understand',
              'reaction-bg-curious',
              'reaction-bg-mixed',
              'reaction-bg-all'
            ].forEach(cls => card.classList.remove(cls));

            // 新しいリアクション背景クラスを追加
            if (active.length === 1) {
              if (active[0] === 'LIKE') card.classList.add('reaction-bg-like');
              if (active[0] === 'UNDERSTAND') card.classList.add('reaction-bg-understand');
              if (active[0] === 'CURIOUS') card.classList.add('reaction-bg-curious');
            } else if (active.length === 2) {
              card.classList.add('reaction-bg-mixed');
            } else if (active.length > 2) {
              card.classList.add('reaction-bg-all');
            }

            // 総リアクション数によるボーダークラスの更新
            const total = this.reactionTypes.reduce((sum, rt) =>
              sum + (item.reactions?.[rt.key]?.count || 0), 0);
            ['reaction-border-1','reaction-border-2','reaction-border-3']
              .forEach(cls => card.classList.remove(cls));
            if (total >= 10) {
              card.classList.add('reaction-border-3');
            } else if (total >= 5) {
              card.classList.add('reaction-border-2');
            } else if (total > 0) {
              card.classList.add('reaction-border-1');
            }

            // ハイライトボタンのUI更新
            const highlightBtn = card.querySelector('.highlight-btn');
            if (highlightBtn) {
              highlightBtn.classList.toggle('liked', item.highlight);
              highlightBtn.setAttribute('aria-pressed', String(item.highlight));
              const label = item.highlight ? 'ハイライトを解除する' : 'ハイライトする';
              highlightBtn.setAttribute('aria-label', label);
            }

            // ハイライトバッジの表示/非表示を制御
            let badge = card.querySelector('.highlight-badge');
            if (item.highlight && !badge) {
              badge = document.createElement('span');
              badge.className = 'highlight-badge';
              badge.innerHTML = this.getIcon('star');
              // card.querySelector('.answer-preview')が存在する場合のみinsertBeforeを使用
              const previewEl = card.querySelector('.answer-preview');
              if (previewEl) {
                previewEl.insertBefore(badge, previewEl.firstChild);
              } else {
                card.appendChild(badge); // フォールバック
              }
              this.animateHighlightBadge(badge);
            } else if (!item.highlight && badge) {
              gsap.to(badge, { scale: 0, opacity: 0, duration: 0.3, onComplete: () => badge.remove() });
            }
          }
        });
      }

      /**
       * ハイライトバッジのアニメーション
       * @param {HTMLElement} el - アニメーションする要素
       */
      animateHighlightBadge(el) {
        if (typeof gsap === 'undefined' || !el) return;
        gsap.fromTo(el, { scale: 0, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out(1.7)' });
      }
      
      /**
       * 回答モーダルを表示
       * @param {number} rowIndex - 表示する回答の行インデックス
       */
      showAnswerModal(rowIndex) {
        const data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
        if (!data) return;
        
        this.state.lastFocusedElement = document.activeElement; // モーダル表示前のフォーカス要素を記憶
        
        // モーダル内のコンテンツを設定
        this.elements.modalAnswer.innerHTML = 
          '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + 
          this.escapeHtml(data.opinion || '') + '</p>' +
          '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + 
          this.escapeHtml(data.reason || '') + '</p>';
        
        // 名前表示設定に基づき学生名を表示
        const showName = this.state.displayMode === 'named';
        this.elements.modalStudentName.textContent = showName ? data.name : '';
        const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
        this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');

        // モーダル内のリアクションボタンを生成
        const reactionButtonsHtml = this.reactionTypes.map(rt => {
          const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
          const cls = info.reacted ? 'liked' : '';
          const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
          // showCountsがtrueの場合のみカウントを表示
          const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
          return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' +
                   'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' +
                   this.getIcon(rt.icon, 'w-5 h-5', info.reacted) +
                   countSpan +
                   '</button>';
        }).join('');
        this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml;

        // モーダル表示のアニメーション
        this.elements.answerModalContainer.classList.remove('hidden');
        gsap.to(this.elements.answerModalContainer, { opacity: 1, duration: 0.3 });
        gsap.fromTo(this.elements.answerModalCard, 
          { scale: 0.95 }, 
          { 
            scale: 1, 
            duration: 0.3, 
            ease: 'back.out', 
            onComplete: () => this.elements.answerModalCloseBtn.focus() // モーダル表示後、閉じるボタンにフォーカス
          }
        );
      }

      /**
       * 回答モーダルを非表示
       */
      hideAnswerModal() {
        // モーダル非表示のアニメーション
        gsap.to(this.elements.answerModalContainer, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => this.elements.answerModalContainer.classList.add('hidden')
        });
        gsap.to(this.elements.answerModalCard, {
          scale: 0.95,
          duration: 0.3,
          ease: 'power2.in',
          onComplete: () => {
            if (this.state.lastFocusedElement) {
              this.state.lastFocusedElement.focus(); // モーダル表示前の要素にフォーカスを戻す
            }
          }
        });
      }

      /**
       * 情報モーダルを表示
       */
      showInfoModal() {
        this.state.lastFocusedElement = document.activeElement;
        this.elements.infoModalContainer.classList.remove('hidden');
        gsap.to(this.elements.infoModalContainer, { opacity: 1, duration: 0.3 });
        gsap.fromTo(this.elements.infoModalCard,
          { scale: 0.95 },
          {
            scale: 1,
            duration: 0.3,
            ease: 'back.out',
            onComplete: () => this.elements.infoModalConfirmBtn.focus()
          }
        );
      }

      /**
       * 情報モーダルを非表示
       */
      hideInfoModal() {
        gsap.to(this.elements.infoModalContainer, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => this.elements.infoModalContainer.classList.add('hidden')
        });
        gsap.to(this.elements.infoModalCard, { scale: 0.95, duration: 0.3, ease: 'power2.in' });
        localStorage.setItem('introSeen', '1');
        if (this.state.lastFocusedElement) {
          this.state.lastFocusedElement.focus();
        }
      }
      
      /**
       * SVGアイコンのHTML文字列を取得
       * @param {string} name - アイコンの名前 (例: 'star', 'users')
       * @param {string} classes - 追加するCSSクラス
       * @param {boolean} solid - ソリッド（塗りつぶし）アイコンを使用するか
       * @returns {string} アイコンのHTML文字列
       */
      getIcon(name, classes = '', solid = false) {
        // アイコンキーの優先順位: solid版 > outline版 > プレーン版
        let key;
        if (solid && ICONS[name + '-solid']) {
          key = name + '-solid';
        } else if (ICONS[name + '-outline']) {
          key = name + '-outline';
        } else if (ICONS[name]) {
          key = name;
        } else {
          console.warn('Icon not found:', name);
          return '<span aria-hidden="true" class="' + classes + '">⭐</span>'; // フォールバック
        }
        if (DEBUG) console.log('getIcon: using key', key, 'for name', name);
        // 存在するアイコンを返す
        return '<span aria-hidden="true" class="' + classes + '">' + ICONS[key] + '</span>';
      }
      
      /**
       * 主要なアイコンをレンダリング（初期設定）
       */
      renderIcons() {
        this.elements.answerModalCloseBtn.innerHTML = this.getIcon('x', 'w-6 h-6');
        this.elements.footerIcon.innerHTML = this.getIcon('grid-2x2');
        if (this.elements.infoIconLike) {
          this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
        }
        if (this.elements.infoIconUnderstand) {
          this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
        }
        if (this.elements.infoIconCurious) {
          this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
        }
        if (this.elements.infoIconHighlight) {
          this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
        }
      }

      /**
       * デバウンス関数
       * @param {Function} func - デバウンスする関数
       * @param {number} delay - 遅延時間 (ms)
       * @returns {Function} デバウンスされた関数
       */
      debounce(func, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), delay);
        };
      }

      /**
       * スコア順ソートオプションの表示/非表示を更新
       */
      updateSortOptions() {
        if (this.elements.scoreOption) {
          if (this.state.showScoreSort) {
            this.elements.scoreOption.style.display = 'block';
          } else {
            this.elements.scoreOption.style.display = 'none';
            // スコア順が非表示になった場合、現在選択されていれば新着順に戻す
            if (this.elements.sortOrder.value === 'score') {
              this.elements.sortOrder.value = 'newest';
            }
          }
        }
      }

      /**
       * プレビューモードを切り替える
       */
      togglePreviewMode() {
        const currentDisplayMode = this.state.displayMode;
        
        if (currentDisplayMode === 'anonymous') {
          // 学生モードから管理者モードへ
          window.isStudentMode = false;
          window.showCounts = true;
          window.showAdminFeatures = true;
          window.showHighlightToggle = true;
          window.showScoreSort = true;
          window.showPublishControls = true;
          window.displayMode = 'named';
          this.elements.modeToggleBtn.textContent = '学生';
          this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-red-600 hover:bg-red-700 text-white text-sm';
        } else {
          // 管理者モードから学生モードへ
          window.isStudentMode = true;
          window.showCounts = false;
          window.showAdminFeatures = false;
          window.showHighlightToggle = false;
          window.showScoreSort = false;
          window.showPublishControls = false;
          window.displayMode = 'anonymous';
          this.elements.modeToggleBtn.textContent = '管理者';
          this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-blue-600 hover:bg-blue-700 text-white text-sm';
        }
        
        // グローバル変数から設定を更新
        this.updateConfigFromGlobals();
        
        // UIを更新し、データを再ロード
        this.updateSortOptions();
        this.loadSheetData(true);
      }
      
      /**
       * プレビューモード切り替えボタンの初期表示設定
       */
      setupInitialModeButton() {
        if (this.elements.modeToggleBtn) {
          // プレビューモード検出
          const isPreviewMode = window.location.protocol === 'file:' || 
                               window.location.hostname === 'localhost' || 
                               window.location.pathname.includes('preview') ||
                               window.location.href.includes('preview');
          
          if (isPreviewMode) {
            // プレビューモードの場合、ボタンを表示
            this.elements.modeToggleBtn.style.display = 'block';
            const currentMode = this.state.displayMode;
            if (currentMode === 'named') {
              this.elements.modeToggleBtn.textContent = '学生';
              this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-red-600 hover:bg-red-700 text-white text-sm';
            } else {
              this.elements.modeToggleBtn.textContent = '管理者';
              this.elements.modeToggleBtn.className = 'ml-4 px-3 py-1 rounded bg-blue-600 hover:bg-blue-700 text-white text-sm';
            }
          } else {
            // 本番環境では切り替えボタンを非表示
            this.elements.modeToggleBtn.style.display = 'none';
          }
        }
      }
      
      /**
       * グローバル変数からStudyQuestAppの状態を更新
       */
      updateConfigFromGlobals() {
        this.state.isStudentMode = window.isStudentMode;
        this.state.showCounts = window.showCounts;
        this.state.showAdminFeatures = window.showAdminFeatures;
        this.state.showHighlightToggle = window.showHighlightToggle;
        this.state.showScoreSort = window.showScoreSort;
        this.state.showPublishControls = window.showPublishControls;
        this.state.displayMode = window.displayMode;

        // 必要に応じて他のUI要素の表示も更新
        // 例えば、showPublishControlsがfalseの場合に発行ボタンを非表示にするなど
        // if (this.elements.unpublishBtn) {
        //   this.elements.unpublishBtn.style.display = this.state.showPublishControls ? 'block' : 'none';
        // }
      }

      /**
       * HTMLエスケープ処理
       * @param {string} str - エスケープする文字列
       * @returns {string} エスケープされた文字列
       */
      escapeHtml(str) {
        if (!str) return '';
        return str.toString()
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
    }
    
    // アプリケーションインスタンスを作成
    if (DEBUG) console.log('Creating StudyQuestApp instance...');
    if (DEBUG) console.log('Window variables:', {
      isStudentMode: window.isStudentMode,
      showCounts: window.showCounts,
      showAdminFeatures: window.showAdminFeatures,
      showHighlightToggle: window.showHighlightToggle,
      showScoreSort: window.showScoreSort,
      showPublishControls: window.showPublishControls,
      displayMode: window.displayMode
    });
    
    try {
      const app = new StudyQuestApp();
      if (DEBUG) console.log('StudyQuestApp instance created successfully');
    } catch (error) {
      console.error('Error creating StudyQuestApp instance:', error);
      
      // エラー時の緊急表示
      const container = document.getElementById('answers');
      if (container) {
        container.innerHTML = '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + error.message + '</div>';
      }
    }
  </script>
</body>
</html>
