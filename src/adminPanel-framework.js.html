<script>
// Unified Admin Panel Namespace and Management Classes
// Generated to address function interference issues and centralize state, events,
// asynchronous operations, and DOM handling.

window.AdminPanel = window.AdminPanel || {
  errors: {},
  ui: {},
  state: {
    current: null,
    selectedSheet: '',
    updateStatus(status) {
      this.current = status;
    }
  },
  // Initialization state tracking to prevent redundant calls
  initialization: {
    isInProgress: false,
    isCompleted: false,
    completedPhases: new Set(),
    startTime: null,
    lastLoadStatusCall: null,
    loadStatusCallCount: 0
  }
};

// -----------------------------------------------------------------------------
// State Manager
// -----------------------------------------------------------------------------
class AdminPanelStateManager {
  constructor() {
    this.state = {
      currentStatus: null,
      selectedSheet: '',
      isLoading: false
    };
    this.subscribers = new Map();
  }

  setState(key, value) {
    this.state[key] = value;
    this.notifySubscribers(key, value);
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, []);
    }
    this.subscribers.get(key).push(callback);
  }

  notifySubscribers(key, value) {
    const subs = this.subscribers.get(key) || [];
    subs.forEach(cb => {
      try {
        cb(value);
      } catch (e) {
        console.warn('Subscriber callback failed', e);
      }
    });
  }
}

// -----------------------------------------------------------------------------
// Event Manager
// -----------------------------------------------------------------------------
class AdminPanelEventManager {
  constructor() {
    this.listeners = new Map();
  }

  addListener(element, event, handler, options = {}) {
    if (!element || !event || !handler) return;
    const key = (element.id || 'anonymous') + '-' + event;
    if (this.listeners.has(key)) {
      console.warn('Duplicate listener for ' + key);
      return;
    }
    element.addEventListener(event, handler, options);
    this.listeners.set(key, { element, event, handler, options });
  }
}

// -----------------------------------------------------------------------------
// Async Manager
// -----------------------------------------------------------------------------
class AdminPanelAsyncManager {
  constructor() {
    this.runningOperations = new Map();
  }

  async executeExclusive(operationId, operation) {
    if (this.runningOperations.has(operationId)) {
      return this.runningOperations.get(operationId);
    }
    const promise = Promise.resolve().then(operation);
    this.runningOperations.set(operationId, promise);
    try {
      return await promise;
    } finally {
      this.runningOperations.delete(operationId);
    }
  }
}

// -----------------------------------------------------------------------------
// DOM Manager
// -----------------------------------------------------------------------------
class AdminPanelDOMManager {
  constructor() {
    this.elementCache = new Map();
    this.operationQueue = [];
  }

  getElement(id) {
    if (!this.elementCache.has(id)) {
      this.elementCache.set(id, document.getElementById(id));
    }
    return this.elementCache.get(id);
  }

  queueOperation(operation) {
    this.operationQueue.push(operation);
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        const op = this.operationQueue.shift();
        resolve(op());
      });
    });
  }
}

// Instantiate managers and expose via namespace
window.AdminPanel.stateManager = new AdminPanelStateManager();
window.AdminPanel.eventManager = new AdminPanelEventManager();
window.AdminPanel.asyncManager = new AdminPanelAsyncManager();
window.AdminPanel.domManager = new AdminPanelDOMManager();

// Link legacy globals to state manager for compatibility
Object.defineProperties(window, {
  currentStatus: {
    get() { return window.AdminPanel.stateManager.state.currentStatus; },
    set(v) { window.AdminPanel.stateManager.setState('currentStatus', v); }
  },
  selectedSheet: {
    get() { return window.AdminPanel.stateManager.state.selectedSheet; },
    set(v) { window.AdminPanel.stateManager.setState('selectedSheet', v); }
  }
});

// =============================================================================
// INITIALIZATION FUNCTIONS - Moved from various adminPanel files
// =============================================================================

// Simple logging utility with conditional output based on DEBUG mode
// DEBUG_MODE is defined in constants.js.html

function adminLog(level, ...args) {
  if (!(window.DEBUG_MODE || (window.SYSTEM_CONSTANTS && window.SYSTEM_CONSTANTS.DEBUG_MODE))) return;
  
  switch (level) {
    case 'error':
      console.error('[AdminPanel]', ...args);
      break;
    case 'warn':
      console.warn('[AdminPanel]', ...args);
      break;
    case 'info':
      console.log('[AdminPanel]', ...args);
      break;
    case 'debug':
      if (window.DEBUG_MODE || (window.SYSTEM_CONSTANTS && window.SYSTEM_CONSTANTS.DEBUG_MODE)) console.log('[AdminPanel:DEBUG]', ...args);
      break;
    default:
      console.log('[AdminPanel]', ...args);
  }
}

// Convenience functions for different log levels
function logError(...args) { adminLog('error', ...args); }
function logWarn(...args) { adminLog('warn', ...args); }
function logInfo(...args) { adminLog('info', ...args); }
function logDebug(...args) { adminLog('debug', ...args); }

// =============================================================================
// USER AUTHENTICATION INITIALIZATION
// =============================================================================

// ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ: ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®å®‰å…¨ãªåˆæœŸåŒ–
var userId = '';

// ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰å®‰å…¨ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—
function initializeUserId() {
  console.group('ğŸ” Initializing UserId');
  logDebug('ğŸ“ About to call getCurrentUserStatus');
  
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(response => {
        logDebug('ğŸ“¥ getCurrentUserStatus response:', response);
        
        if (response && response.status === 'success' && response.userInfo && response.userInfo.userId) {
          userId = response.userInfo.userId;
          logDebug('âœ… AdminPanel: User authenticated, userId:', userId);
          console.groupEnd();
          resolve(userId);
        } else {
          console.error('âŒ Failed to get userId from backend:', response);
          console.error('âŒ Expected: {status: "success", userInfo: {userId: "..."}}');
          console.groupEnd();
          reject(new Error('ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'));
        }
      })
      .withFailureHandler(error => {
        console.error('âŒ Backend error getting userId:', error);
        console.error('âŒ Error type:', typeof error);
        console.error('âŒ Error details:', error);
        console.groupEnd();
        reject(error);
      })
      .getCurrentUserStatus();
  });
}

// ãƒªãƒˆãƒ©ã‚¤ä»˜ããƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—
async function initializeUserIdWithRetry(maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await initializeUserId();
    } catch (error) {
      console.warn(`âš ï¸ UserId initialization failed (attempt ${i + 1}/${maxRetries}):`, error.message);
      if (i < maxRetries - 1) {
        console.log(`ğŸ”„ Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        delay = Math.min(delay * 1.5, 5000); // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ï¼ˆæœ€å¤§5ç§’ï¼‰
      } else {
        console.error('âŒ All userId initialization attempts failed');
        throw error;
      }
    }
  }
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—ã®å®Œäº†ã‚’å¾…ã¤Promiseï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿæ§‹ä»˜ãï¼‰
const userIdPromise = initializeUserIdWithRetry();

// =============================================================================
// CORE INITIALIZATION FUNCTIONS
// =============================================================================

// Layout adjustment for responsive design
function adjustLayout() {
  var isMobile = window.innerWidth < 768;
  var body = document.body;
  
  if (isMobile) {
    body.classList.add('mobile-layout');
    body.classList.remove('desktop-layout');
  } else {
    body.classList.add('desktop-layout');
    body.classList.remove('mobile-layout');
  }
}

// Initialize core functionality
function initCore() {
  adjustLayout();
}

// Initialize message area
function initializeMessageArea() {
  var messageArea = document.getElementById('message-area');
  if (!messageArea) {
    // Create message area if it doesn't exist
    messageArea = document.createElement('div');
    messageArea.id = 'message-area';
    messageArea.className = 'fixed top-32 right-4 z-50 max-w-sm';
    document.body.appendChild(messageArea);
  }
}

// Initialize UI components
function initializeUI() {
  // UIåˆæœŸåŒ–ã®ã¿å®Ÿè¡Œã€loadStatusã¯ adminPanel-api.js ã§å‡¦ç†ã•ã‚Œã‚‹
}

// Initialize API functionality
function initializeAPI() {
  logDebug('ğŸ”§ APIåˆæœŸåŒ–é–‹å§‹');
  
  // Start background status updates with safe calling
  if (checkFunctionAvailability('startSystemStatusUpdate')) {
    safeCallFunction('startSystemStatusUpdate');
  } else {
    console.warn('âš ï¸ startSystemStatusUpdate not available - background updates disabled');
  }
  
  // Setup user activity tracking
  document.addEventListener('click', updateUserActivity);
  document.addEventListener('keypress', updateUserActivity);
  document.addEventListener('scroll', updateUserActivity);

  // åˆæœŸåŒ–æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ­ãƒ¼ãƒ‰ - ã‚¿ã‚¤ãƒŸãƒ³ã‚°èª¿æ•´ç‰ˆ
  logDebug('ğŸš€ åˆæœŸåŒ–æ™‚loadStatus(true)å‘¼ã³å‡ºã—ï¼ˆé…å»¶ã‚ã‚Šï¼‰');
  setTimeout(() => {
    if (checkFunctionAvailability('loadStatus')) {
      window.loadStatus(true);
    } else {
      console.warn('âš ï¸ loadStatus not available');
    }
  }, 500); // 500msé…å»¶ã§ã‚ˆã‚Šå®‰å…¨ãªåˆæœŸåŒ–
  
  logDebug('âœ… APIåˆæœŸåŒ–å®Œäº†');
}

// Update user activity timestamp for polling optimization
function updateUserActivity() {
  if (typeof lastUserActivity !== 'undefined') {
    lastUserActivity = Date.now();
  }
}

// Initialize event listeners
function initializeEventListeners() {
  
  // Use safe function calling with availability checks
  if (checkFunctionAvailability('setupEventListeners')) {
    safeCallFunction('setupEventListeners');
  } else {
    console.warn('âš ï¸ setupEventListeners function not available, attempting graceful degradation');
    
    // Basic fallback event listener setup
    if (checkFunctionAvailability('setupRealtimeValidation')) {
      safeCallFunction('setupRealtimeValidation');
    } else {
      console.warn('âš ï¸ setupRealtimeValidation not available - real-time validation disabled');
    }
  }
}

// Setup character counters
function setupCharacterCounters() {
  const questionTextarea = document.getElementById('custom-main-question');
  const questionCounter = document.getElementById('question-counter');

  if (questionTextarea && questionCounter) {
    questionTextarea.addEventListener('input', function() {
      const count = this.value.length;
      questionCounter.textContent = count + '/500';
      questionCounter.className = count > 450 ? 'text-xs text-red-400' : 'text-xs text-gray-500';
    });
  }
}

// Setup modal character counter observers
function setupModalCharacterCounters() {
  // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒè¡¨ç¤ºã•ã‚Œã‚‹ãŸã³ã«ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
        const modal = document.getElementById('form-config-modal');
        if (modal && !modal.classList.contains('hidden')) {
          setTimeout(setupCharacterCounters, 100);
        }
      }
    });
  });
  
  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ç›£è¦–ã‚’é–‹å§‹
  const modal = document.getElementById('form-config-modal');
  if (modal) {
    observer.observe(modal, { attributes: true });
  }
}

// Navigate to specific step in admin panel
function navigateToStep(step) {
  if (typeof currentStep !== 'undefined') {
    currentStep = step;
  } else {
    // Define currentStep if not already defined
    window.currentStep = step;
  }
  
  // Update step indicators
  document.querySelectorAll('.step-indicator').forEach((indicator, index) => {
    const stepNumber = index + 1;
    indicator.classList.toggle('completed', stepNumber < step);
    indicator.classList.toggle('active', stepNumber === step);
  });
  
  // Show/hide step content
  document.querySelectorAll('.step-content').forEach((content, index) => {
    const stepNumber = index + 1;
    content.classList.toggle('hidden', stepNumber !== step);
  });
  
  // Update progress bar
  const progressBar = document.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.width = ((step / 3) * 100) + '%';
  }
  
  if (typeof validateCurrentStep === 'function') {
    validateCurrentStep();
  }
}

// Make navigateToStep globally available
window.navigateToStep = navigateToStep;

// Initialize main admin panel
function initializeAdminPanel(incomingUserId) {
  // userId is now managed globally by adminPanel-core.js
  if (typeof loadUserInfo === 'function') loadUserInfo();
  if (typeof loadSystemStatus === 'function') loadSystemStatus();
  if (typeof setupEventListeners === 'function') setupEventListeners();
  if (typeof setupRealtimeUpdates === 'function') setupRealtimeUpdates();
  if (typeof validateCurrentStep === 'function') validateCurrentStep();
}

// Make initializeAdminPanel globally available
window.initializeAdminPanel = initializeAdminPanel;

// =============================================================================
// CRITICAL UI FUNCTIONS - Moved from adminPanel-ui.js.html for early availability
// =============================================================================

// Toggle section visibility
function toggleSection(sectionId) {
  const section = document.getElementById(sectionId);
  if (!section) {
    console.warn('Section not found:', sectionId);
    return;
  }
  
  // Find the toggle button for this section
  const toggleBtn = document.querySelector('[onclick*="' + sectionId + '"]');
  const arrow = toggleBtn ? toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up') : null;
  
  // Toggle the section visibility
  if (section.classList.contains('hidden')) {
    // Show section
    section.classList.remove('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'true');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  } else {
    // Hide section
    section.classList.add('hidden');
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', 'false');
    }
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
}

// Hide privacy modal
function hidePrivacyModal() {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('privacy-modal', false);
    }
  }
}

// Show form configuration modal
function showFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.showFormConfig();
    if (typeof loadSavedClassChoices === 'function') {
      loadSavedClassChoices();
    }
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('form-config-modal', true);
    }
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      if (typeof loadSavedClassChoices === 'function') {
        loadSavedClassChoices();
      }
      if (typeof manageFocusForModal === 'function') {
        manageFocusForModal('form-config-modal', true);
      }
    }
  }
}

// Enhanced updateUIWithNewStatus that works with both minimal and full implementations
function updateUIWithNewStatus(status) {
  if (!status) {
    console.warn('updateUIWithNewStatus: Invalid status received');
    return;
  }
  
  // Store for later use
  window.currentStatus = status;
  
  // Enhanced full implementation detection with multiple retries
  if (typeof window._fullUpdateUIWithNewStatus === 'function') {
    try {
      // æœ¬ç•ªç’°å¢ƒã§ã®ãƒ­ã‚°é‡ã‚’æ¸›ã‚‰ã™
      if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
        console.log('updateUIWithNewStatus: Using full implementation');
      }
      return window._fullUpdateUIWithNewStatus(status);
    } catch (error) {
      console.warn('Full updateUIWithNewStatus failed, using fallback:', error);
      // Continue with minimal implementation below
    }
  } else {
    // Enhanced retry mechanism with multiple attempts
    let retryCount = 0;
    const maxRetries = 3;
    const retryDelays = [200, 500, 1000]; // Progressive delays
    
    const tryFullImplementation = () => {
      if (typeof window._fullUpdateUIWithNewStatus === 'function') {
        console.log(`updateUIWithNewStatus: Full implementation now available (retry ${retryCount + 1})`);
        try {
          window._fullUpdateUIWithNewStatus(status);
          return;
        } catch (error) {
          console.warn('Retried full updateUIWithNewStatus failed:', error);
        }
      }
      
      if (retryCount < maxRetries) {
        retryCount++;
        setTimeout(tryFullImplementation, retryDelays[retryCount - 1] || 1000);
      } else {
        console.log('updateUIWithNewStatus: Max retries exceeded, using minimal implementation only');
      }
    };
    
    // Start retry sequence
    setTimeout(tryFullImplementation, retryDelays[0]);
  }
  
  // Enhanced minimal implementation for comprehensive UI updates
  console.log('updateUIWithNewStatus: Using enhanced minimal implementation');
  
  // Update essential UI elements with comprehensive information
  try {
    // 1. Update publication status with indicators
    if (status._normalized && typeof status._normalized.isPublished !== 'undefined') {
      const publishStatus = status._normalized.isPublished ? 'å…¬é–‹ä¸­' : 'åœæ­¢ä¸­';
      const publishElement = document.getElementById('info-publish-text');
      if (publishElement) {
        publishElement.textContent = publishStatus;
      }
      
      // Update publish indicator
      const indicatorElement = document.getElementById('info-publish-indicator');
      const statusElement = document.getElementById('info-publish-status');
      if (status._normalized.isPublished) {
        if (statusElement) statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
        if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      } else {
        if (statusElement) statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
        if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      }
    }
    
    // 2. Update user information section
    if (status.userInfo) {
      const adminEmailEl = document.getElementById('info-admin-email');
      const userIdEl = document.getElementById('info-user-id');
      
      if (adminEmailEl && status.userInfo.adminEmail) {
        adminEmailEl.textContent = status.userInfo.adminEmail;
      }
      if (userIdEl && status.userInfo.userId) {
        userIdEl.textContent = status.userInfo.userId;
      }
      
      // Update spreadsheet access
      if (status.userInfo.spreadsheetUrl) {
        const spreadsheetBtn = document.getElementById('open-spreadsheet-btn-step2');
        if (spreadsheetBtn) {
          spreadsheetBtn.disabled = false;
          spreadsheetBtn.onclick = () => window.open(status.userInfo.spreadsheetUrl, '_blank');
        }
      }
    }
    
    // 3. Update configuration display
    if (status.config || (status.userInfo && status.userInfo.configJson)) {
      let config = status.config;
      if (!config && status.userInfo.configJson) {
        try {
          config = typeof status.userInfo.configJson === 'string' 
            ? JSON.parse(status.userInfo.configJson) 
            : status.userInfo.configJson;
        } catch (e) {
          console.warn('Failed to parse configJson in minimal implementation');
        }
      }
      
      if (config) {
        // Update published sheet name
        const publishedSheetEl = document.getElementById('info-published-sheet');
        if (publishedSheetEl) {
          publishedSheetEl.textContent = config.publishedSheetName || status.activeSheetName || 'ãªã—';
        }
        
        // Update display mode
        const displayModeEl = document.getElementById('info-display-mode');
        if (displayModeEl) {
          displayModeEl.textContent = config.showNames ? 'åå‰è¡¨ç¤º' : 'åŒ¿åè¡¨ç¤º';
        }
        
        // Update show counts setting
        const showCountsEl = document.getElementById('info-show-counts');
        if (showCountsEl) {
          showCountsEl.textContent = config.showCounts ? 'è¡¨ç¤º' : 'éè¡¨ç¤º';
        }
      }
    }
    
    // 4. Update answer count if available
    if (status.answerCount !== undefined) {
      const answerCountElement = document.getElementById('answer-count');
      if (answerCountElement) {
        answerCountElement.textContent = status.answerCount || '0';
      }
    }
    
    // 5. Update active sheet information
    if (status.activeSheetName) {
      const sheetNameElements = document.querySelectorAll('.active-sheet-name');
      sheetNameElements.forEach(element => {
        element.textContent = status.activeSheetName;
      });
    }
    
    
  } catch (error) {
    console.error('Error in enhanced minimal updateUIWithNewStatus:', error);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('digital-citizenship-modal', false);
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('confirmation-modal', false);
    }
  }
}

// Unified showMessage function - uses SharedUtilities MessageManager
function showMessage(message, type = 'info', duration = 5000) {
  console.log(`[${type.toUpperCase()}] ${message}`);
  
  // Use SharedUtilities MessageManager if available
  if (window.sharedUtilities?.messages?.show) {
    return window.sharedUtilities.messages.show(message, type, duration);
  }
  
  // Fallback for cases where SharedUtilities is not loaded
  console.warn('âš ï¸ SharedUtilities MessageManager not available, using console fallback');
}

// =============================================================================
// VALIDATION FUNCTIONS - Moved from adminPanel-ui.js.html for early availability
// =============================================================================

// Validate configuration with fallback logic
function validateConfig() {
  // Try to use the full implementation if available
  if (typeof window._fullValidateConfig === 'function') {
    try {
      return window._fullValidateConfig();
    } catch (error) {
      console.warn('Full validateConfig failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential validation
  console.log('validateConfig: Using minimal implementation');
  
  try {
    // Check primary element first, then fallback to secondary element
    const opinionValueEl1 = document.getElementById('opinionHeader');
    const opinionValueEl2 = document.getElementById('reason-column');
    const opinionValue = (opinionValueEl1 && opinionValueEl1.value) || 
                        (opinionValueEl2 && opinionValueEl2.value) || '';
    
    return opinionValue && opinionValue.trim() !== '';
  } catch (error) {
    console.error('Error in minimal validateConfig:', error);
    return false;
  }
}

// Update configuration buttons state with fallback logic
function updateConfigButtons() {
  // Try to use the full implementation if available
  if (typeof window._fullUpdateConfigButtons === 'function') {
    try {
      return window._fullUpdateConfigButtons();
    } catch (error) {
      console.warn('Full updateConfigButtons failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential button updates
  console.log('updateConfigButtons: Using minimal implementation');
  
  try {
    const isValid = validateConfig();
    const saveBtn = document.getElementById('save-publish-btn');
    
    if (saveBtn) {
      saveBtn.disabled = !isValid;
      if (isValid) {
        saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      } else {
        saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
      }
    }
  } catch (error) {
    console.error('Error in minimal updateConfigButtons:', error);
  }
}

// =============================================================================
// FUNCTION AVAILABILITY MANAGEMENT
// =============================================================================

// Central function availability checker
function checkFunctionAvailability(functionName) {
  const isAvailable = typeof window[functionName] === 'function';
  if (!isAvailable) {
    console.warn(`âš ï¸ Function ${functionName} is not available`);
  }
  return isAvailable;
}

// Safe function caller with fallback handling
function safeCallFunction(functionName, ...args) {
  try {
    if (checkFunctionAvailability(functionName)) {
      return window[functionName](...args);
    } else {
      console.warn(`âš ï¸ Cannot call ${functionName} - function not available`);
      return null;
    }
  } catch (error) {
    console.error(`âŒ Error calling ${functionName}:`, error);
    return null;
  }
}

// Enhanced function registry with full implementation tracking
window.AdminPanel.functionRegistry = {
  available: new Set(),
  pending: new Set(),
  fullImplementations: new Set(),
  
  register(functionName) {
    if (typeof window[functionName] === 'function') {
      this.available.add(functionName);
      this.pending.delete(functionName);
    } else {
      this.pending.add(functionName);
      console.warn(`âš ï¸ Function pending: ${functionName}`);
    }
  },
  
  registerFullImplementation(functionName) {
    const fullFuncName = `_full${functionName.charAt(0).toUpperCase()}${functionName.slice(1)}`;
    if (typeof window[fullFuncName] === 'function') {
      this.fullImplementations.add(functionName);
      // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®ã¿ãƒ­ã‚°å‡ºåŠ›ï¼ˆæœ¬ç•ªã§ã®é‡è¤‡ãƒ­ã‚°ã‚’æ¸›ã‚‰ã™ï¼‰
      if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
        console.log(`ğŸ”§ Full implementation registered: ${fullFuncName}`);
      }
    }
  },
  
  hasFullImplementation(functionName) {
    const fullFuncName = `_full${functionName.charAt(0).toUpperCase()}${functionName.slice(1)}`;
    return typeof window[fullFuncName] === 'function';
  },
  
  isAvailable(functionName) {
    return this.available.has(functionName);
  },
  
  // Enhanced full implementation detection
  checkForFullImplementations() {
    const functionsToCheck = [
      'updateUIWithNewStatus', 'populateHeaderOptions', 'populateConfig', 
      'updateFormUrlDisplay', 'validateConfig', 'updateConfigButtons'
    ];
    
    let foundCount = 0;
    functionsToCheck.forEach(funcName => {
      if (this.hasFullImplementation(funcName)) {
        this.registerFullImplementation(funcName);
        foundCount++;
      }
    });
    
    // æœ¬ç•ªç’°å¢ƒã§ã®ãƒ­ã‚°é‡ã‚’æ¸›ã‚‰ã™
    if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
      console.log(`ğŸ” Full implementations check: ${foundCount}/${functionsToCheck.length} available`);
    }
    return foundCount;
  },
  
  waitFor(functionName, timeout = 5000) {
    return new Promise((resolve, reject) => {
      if (this.isAvailable(functionName)) {
        resolve(window[functionName]);
        return;
      }
      
      const startTime = Date.now();
      const checkInterval = setInterval(() => {
        if (this.isAvailable(functionName)) {
          clearInterval(checkInterval);
          resolve(window[functionName]);
        } else if (Date.now() - startTime > timeout) {
          clearInterval(checkInterval);
          reject(new Error(`Function ${functionName} not available after ${timeout}ms`));
        }
      }, 100);
    });
  }
};

// =============================================================================
// ADDITIONAL UI FUNCTIONS - Critical functions that were missing
// =============================================================================

// Update form URL display (minimal implementation)
function updateFormUrlDisplay(status = null) {
  // Try to use the full implementation if available
  if (typeof window._fullUpdateFormUrlDisplay === 'function') {
    try {
      return window._fullUpdateFormUrlDisplay(status);
    } catch (error) {
      console.warn('Full updateFormUrlDisplay failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential form URL updates
  console.log('updateFormUrlDisplay: Using minimal implementation');
  
  try {
    const formUrlInput = document.getElementById('form-url-input');
    if (!formUrlInput) return;
    
    const currentStatusToUse = status || window.currentStatus;
    if (!currentStatusToUse || !currentStatusToUse.userInfo) {
      console.warn('âš ï¸ updateFormUrlDisplay: statusæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
      return;
    }
    
    // Simple form URL extraction
    let formUrl = null;
    if (currentStatusToUse.userInfo.configJson) {
      try {
        const config = typeof currentStatusToUse.userInfo.configJson === 'string' 
          ? JSON.parse(currentStatusToUse.userInfo.configJson) 
          : currentStatusToUse.userInfo.configJson;
        formUrl = config.formUrl;
      } catch (e) {
        console.warn('Failed to parse configJson for form URL');
      }
    }
    
    if (formUrl) {
      formUrlInput.value = formUrl;
      const openFormLink = document.getElementById('open-form-url-link');
      if (openFormLink) {
        openFormLink.href = formUrl;
      }
    }
  } catch (error) {
    console.error('Error in minimal updateFormUrlDisplay:', error);
  }
}

// Populate header options (minimal implementation)
function populateHeaderOptions(headers) {
  // Try to use the full implementation if available
  if (typeof window._fullPopulateHeaderOptions === 'function') {
    try {
      return window._fullPopulateHeaderOptions(headers);
    } catch (error) {
      console.warn('Full populateHeaderOptions failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential header population
  console.log('populateHeaderOptions: Using minimal implementation');
  
  try {
    if (window.populateHeaderOptionsRunning) {
      return;
    }
    window.populateHeaderOptionsRunning = true;
    
    const selects = ['opinionHeader', 'reason-column', 'name-column', 'class-column'];
    
    selects.forEach(selectId => {
      const select = document.getElementById(selectId);
      if (select) {
        const currentValue = select.value;
        
        if (headers && headers.length > 0) {
          select.innerHTML = '<option value="">-- åˆ—ã‚’é¸æŠ --</option>';
          headers.forEach(header => {
            if (header && typeof header === 'string' && header.trim()) {
              const option = document.createElement('option');
              option.value = header;
              option.textContent = header;
              select.appendChild(option);
            }
          });
          select.disabled = false;
          if (currentValue) {
            select.value = currentValue;
          }
        } else {
          select.innerHTML = '<option value="">-- ã‚·ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ --</option>';
          select.disabled = true;
        }
      }
    });
    
    setTimeout(() => {
      window.populateHeaderOptionsRunning = false;
    }, 100);
  } catch (error) {
    console.error('Error in minimal populateHeaderOptions:', error);
    window.populateHeaderOptionsRunning = false;
  }
}

// Make all critical functions globally available immediately
window.toggleSection = toggleSection;
window.hidePrivacyModal = hidePrivacyModal;
window.hideDigitalCitizenshipModal = hideDigitalCitizenshipModal;
window.hideConfirmationModal = hideConfirmationModal;
window.showFormConfigModal = showFormConfigModal;
window.showMessage = showMessage; // Unified with SharedUtilities MessageManager
window.updateUIWithNewStatus = updateUIWithNewStatus;
window.validateConfig = validateConfig;
window.updateConfigButtons = updateConfigButtons;
// Populate configuration (minimal implementation)
function populateConfig(cfg) {
  // Try to use the full implementation if available
  if (typeof window._fullPopulateConfig === 'function') {
    try {
      return window._fullPopulateConfig(cfg);
    } catch (error) {
      console.warn('Full populateConfig failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential config population
  console.log('populateConfig: Using minimal implementation');
  
  try {
    if (!cfg) return;
    
    if (window.populateConfigRunning) {
      return;
    }
    window.populateConfigRunning = true;
    
    const mappings = {
      'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
      'reason-column': cfg.reasonColumn || cfg.reasonHeader,
      'name-column': cfg.nameColumn || cfg.nameHeader,
      'class-column': cfg.classColumn || cfg.classHeader,
      'show-names': cfg.showNames,
      'show-counts': cfg.showCounts
    };
    
    Object.keys(mappings).forEach(elementId => {
      const element = document.getElementById(elementId);
      const value = mappings[elementId];
      
      if (element && value !== undefined) {
        if (element.type === 'checkbox') {
          element.checked = Boolean(value);
        } else {
          element.value = value;
        }
      }
    });
    
    setTimeout(() => {
      window.populateConfigRunning = false;
    }, 100);
  } catch (error) {
    console.error('Error in minimal populateConfig:', error);
    window.populateConfigRunning = false;
  }
}

window.updateFormUrlDisplay = updateFormUrlDisplay;
window.populateHeaderOptions = populateHeaderOptions;
window.populateConfig = populateConfig;
window.checkFunctionAvailability = checkFunctionAvailability;
window.safeCallFunction = safeCallFunction;

// Register all critical functions
const criticalFunctions = [
  'toggleSection', 'hidePrivacyModal', 'hideDigitalCitizenshipModal', 
  'hideConfirmationModal', 'showFormConfigModal', 'showMessage', 
  'updateUIWithNewStatus', 'validateConfig', 'updateConfigButtons', 
  'updateFormUrlDisplay', 'populateHeaderOptions', 'populateConfig',
  'navigateToStep', 'initializeAdminPanel'
];

criticalFunctions.forEach(funcName => {
  window.AdminPanel.functionRegistry.register(funcName);
});

// Full implementation monitoring with periodic checks
let fullImplCheckCount = 0;
const maxFullImplChecks = 10;

function checkFullImplementationsAvailability() {
  fullImplCheckCount++;
  const foundCount = window.AdminPanel.functionRegistry.checkForFullImplementations();
  
  if (foundCount > 0) {
    console.log(`ğŸ‰ Found ${foundCount} full implementations on attempt ${fullImplCheckCount}`);
    
    // Force retry of UI updates with full implementations now available
    if (window.currentStatus && foundCount >= 3) {
      console.log('ğŸ”„ Retrying UI updates with full implementations');
      setTimeout(() => {
        if (typeof window._fullUpdateUIWithNewStatus === 'function') {
          window._fullUpdateUIWithNewStatus(window.currentStatus);
        }
      }, 100);
    }
  } else if (fullImplCheckCount < maxFullImplChecks) {
    // Continue checking for full implementations
    setTimeout(checkFullImplementationsAvailability, 500);
  } else {
    console.warn('âš ï¸ Full implementations not found after maximum attempts');
  }
}

// Start monitoring for full implementations after a delay
setTimeout(checkFullImplementationsAvailability, 300);

// =============================================================================
// SYSTEM STATUS AND USER INTERACTION MANAGEMENT
// =============================================================================

// ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ç”¨ã®çŠ¶æ…‹ç®¡ç†
window.systemStatus = {
  initializationStarted: false,
  coreInitialized: false,
  apiInitialized: false,
  uiInitialized: false,
  eventsInitialized: false,
  initializationComplete: false,
  userDataSyncComplete: false,
  errors: [],
  lastActivity: Date.now()
};

// åˆæœŸåŒ–ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œé˜²æ­¢ - DOMæº–å‚™å®Œäº†å¾Œã«å®Ÿè¡Œ
if (document.body) {
  document.body.style.pointerEvents = 'none';
  console.log('ğŸ›¡ï¸ User interaction disabled during initialization');
} else {
  // DOMèª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã£ã¦ã‹ã‚‰å®Ÿè¡Œ
  document.addEventListener('DOMContentLoaded', function() {
    if (document.body) {
      document.body.style.pointerEvents = 'none';
      console.log('ğŸ›¡ï¸ User interaction disabled during initialization (delayed)');
    }
  });
}

// ä¸»è¦ãªUIè¦ç´ ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹é–¢æ•°
function disableUserInteraction() {
  // DOMæº–å‚™å®Œäº†ãƒã‚§ãƒƒã‚¯
  if (!document || !document.body) {
    console.warn('âš ï¸ DOM not ready for disableUserInteraction');
    return;
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã®ç„¡åŠ¹åŒ–
  const forms = document.querySelectorAll('form, input, button, select, textarea');
  forms.forEach(element => {
    element.disabled = true;
    element.style.opacity = '0.6';
  });
  
  // ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ãªè¦ç´ ã®ç„¡åŠ¹åŒ–
  const clickables = document.querySelectorAll('[onclick], .btn, .button');
  clickables.forEach(element => {
    element.style.pointerEvents = 'none';
    element.style.opacity = '0.6';
  });
  
  // bodyè¦ç´ ã®ç„¡åŠ¹åŒ–
  document.body.style.pointerEvents = 'none';
  
  console.log('ğŸ›¡ï¸ All interactive elements disabled');
}

// UIè¦ç´ ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹é–¢æ•°
function enableUserInteraction() {
  // DOMæº–å‚™å®Œäº†ãƒã‚§ãƒƒã‚¯
  if (!document || !document.body) {
    console.warn('âš ï¸ DOM not ready for enableUserInteraction');
    return;
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã®æœ‰åŠ¹åŒ–
  const forms = document.querySelectorAll('form, input, button, select, textarea');
  forms.forEach(element => {
    element.disabled = false;
    element.style.opacity = '';
  });
  
  // ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ãªè¦ç´ ã®æœ‰åŠ¹åŒ–
  const clickables = document.querySelectorAll('[onclick], .btn, .button');
  clickables.forEach(element => {
    element.style.pointerEvents = '';
    element.style.opacity = '';
  });
  
  // bodyè¦ç´ ã‚‚æœ‰åŠ¹åŒ–
  document.body.style.pointerEvents = 'auto';
  
  console.log('âœ… All interactive elements enabled');
}

// DOMèª­ã¿è¾¼ã¿å¾Œã«è¦ç´ ã‚’ç„¡åŠ¹åŒ–
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', disableUserInteraction);
} else {
  disableUserInteraction();
}

function updateSystemStatus(component, status, error = null) {
  window.systemStatus[component] = status;
  window.systemStatus.lastActivity = Date.now();
  if (error) {
    window.systemStatus.errors.push({ component, error: error.toString(), timestamp: Date.now() });
  }
  logDebug(`ğŸ“Š System Status: ${component} = ${status}`);
}

// å…¬é–‹åœæ­¢å¾Œã®å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹å‡¦ç†
function checkAndExpandAllSections() {
  try {
    const expandAllFlag = localStorage.getItem('expandAllSections');
    if (expandAllFlag === 'true') {
      logInfo('ğŸ“‚ å…¬é–‹åœæ­¢å¾Œã®ãŸã‚å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å±•é–‹ã—ã¾ã™');
      
      // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å±•é–‹ï¼ˆDOMè¦ç´ ã®æº–å‚™ã‚’å¾…ã¤ï¼‰
      setTimeout(() => {
        const sectionIds = ['step1-content', 'step2-content', 'step3-content'];
        let expandedCount = 0;
        
        sectionIds.forEach(sectionId => {
          const section = document.getElementById(sectionId);
          if (section) {
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒæŠ˜ã‚ŠãŸãŸã¾ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿å±•é–‹
            if (section.classList.contains('hidden')) {
              if (typeof toggleSection === 'function') {
                toggleSection(sectionId);
                expandedCount++;
                logDebug(`âœ… ã‚»ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹: ${sectionId}`);
              }
            }
          }
        });
        
        if (expandedCount > 0) {
          logInfo(`ğŸ“‚ ${expandedCount}å€‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å±•é–‹ã—ã¾ã—ãŸ`);
        }
        
        // ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢ï¼ˆä¸€åº¦ã ã‘å®Ÿè¡Œï¼‰
        localStorage.removeItem('expandAllSections');
        logDebug('ğŸ§¹ å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
      }, 500);
    }
  } catch (error) {
    logWarn('âš ï¸ å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:', error);
  }
}

// =============================================================================
// MASTER INITIALIZATION SYSTEM
// =============================================================================

function initializeAdminPanelMaster() {
  // ã‚·ãƒ³ãƒ—ãƒ«åŒ–: é‡è¤‡åˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯ã‚’ç°¡ç´ åŒ–
  if (window.AdminPanel.initialization.isCompleted) {
    logDebug('âœ… AdminPanel already initialized');
    return;
  }
  
  window.AdminPanel.initialization.isInProgress = true;
  logInfo('ğŸš€ AdminPanel Master Initialization Started');
  
  // Phase 1: CoreåˆæœŸåŒ–
  try {
    initCore();
  } catch (error) {
    console.error('âŒ Core initialization failed:', error);
  }
  
  // å…¬é–‹åœæ­¢å¾Œã®å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹å‡¦ç†
  checkAndExpandAllSections();
  
  // ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆå®Œäº†è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢ï¼ˆæ–°è¦ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§éè¡¨ç¤ºï¼‰
  setTimeout(() => {
    const formJustCreated = sessionStorage.getItem('form_just_created');
    if (formJustCreated !== 'true') {
      // æ–°è¦ä½œæˆã§ã¯ãªã„å ´åˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éè¡¨ç¤ºã«ã™ã‚‹
      const formUrlSection = document.getElementById('form-url-section');
      if (formUrlSection && !formUrlSection.classList.contains('hidden')) {
        formUrlSection.classList.add('hidden');
        logDebug('ğŸ“‹ æ—¢å­˜ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã¯ãƒ•ã‚©ãƒ¼ãƒ å®Œäº†ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éè¡¨ç¤º');
      }
    }
  }, 100);
  
  // Phase 2: å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¸¦åˆ—åˆæœŸåŒ– (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š)
  // é…å»¶ã‚’æœ€å°é™ã«æŠ‘åˆ¶ã—ã¦å³åº§ã«åˆæœŸåŒ–
  setTimeout(() => {
    logDebug('ğŸ”§ Phase 2: ä¸¦åˆ—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–é–‹å§‹');
    
    // Statusç®¡ç†åˆæœŸåŒ–
    try {
      initializeMessageArea();
      logDebug('âœ… Status module initialized');
    } catch (error) {
      logError('âŒ Status module initialization failed:', error);
    }
    
    // APIé€šä¿¡åˆæœŸåŒ–
    try {
      logDebug('ğŸš€ API module initialization...');
      initializeAPI();
      logDebug('âœ… API module initialized');
    } catch (error) {
      console.error('âŒ API initialization failed:', error);
    }
    
    // UIåˆæœŸåŒ–
    try {
      initializeUI();
      logDebug('âœ… UI module initialized');
    } catch (error) {
      console.error('âŒ UI initialization failed:', error);
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ ç®¡ç†åˆæœŸåŒ–
    try {
      setupCharacterCounters();
      setupModalCharacterCounters();
      logDebug('âœ… Forms module initialized');
    } catch (error) {
      logError('âŒ Forms module initialization failed:', error);
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†åˆæœŸåŒ–ï¼ˆæœ€å¾Œã«å®Ÿè¡Œï¼‰
    setTimeout(() => {
      try {
        initializeEventListeners();
        logDebug('âœ… Events module initialized');
        logInfo('ğŸ‰ AdminPanel Master Initialization Complete');
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®åŒæœŸã¨æœ€çµ‚å‡¦ç†
        finalizeInitialization();
        
      } catch (error) {
        updateSystemStatus('eventsInitialized', false, error);
        console.error('âŒ Events initialization failed:', error);
        
        // ã‚¨ãƒ©ãƒ¼ã§ã‚‚æœ€çµ‚å‡¦ç†ã¯å®Ÿè¡Œ
        finalizeInitialization();
      }
    }, 100);
    
  }, 10);
}

// Finalize initialization and enable user interaction
async function finalizeInitialization() {
  setTimeout(async () => {
    try {
      console.log('ğŸ”„ Final initialization steps...');
      
      // ã™ã¹ã¦ã®åŒæœŸãŒå®Œäº†ã—ãŸã‚‰ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éè¡¨ç¤º
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›´æ¥DOMæ“ä½œ
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('hidden');
        }
      }
      
      // UIè¦ç´ ã®æœ‰åŠ¹åŒ–
      enableUserInteraction();
      
      // Initialize and load history table after all initialization is complete
      try {
        console.log('ğŸ”„ Initializing HistoryManager...');
        if (window.HistoryManager) {
          window.HistoryManager.initialize();
          console.log('ğŸ”„ Loading history table after initialization...');
          window.HistoryManager.renderTable();
        } else {
          console.warn('âš ï¸ HistoryManager not available yet');
        }
      } catch (historyError) {
        console.warn('âš ï¸ History initialization/loading failed:', historyError);
      }
      
      // Draft recovery after initialization complete
      try {
        console.log('ğŸ”„ Checking for draft recovery...');
        if (typeof recoverDraftIfAvailable === 'function') {
          recoverDraftIfAvailable();
        }
      } catch (draftError) {
        console.warn('âš ï¸ Draft recovery failed:', draftError);
      }
      
      // åˆæœŸåŒ–å®Œäº†
      window.AdminPanel.initialization.isInProgress = false;
      window.AdminPanel.initialization.isCompleted = true;
      logInfo('âœ… AdminPanel Master Initialization Completed');
      
    } catch (error) {
      console.error('âŒ Final sync error:', error);
      // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯è§£é™¤
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      }
      enableUserInteraction();
      
      // åˆæœŸåŒ–å®Œäº†ï¼ˆã‚¨ãƒ©ãƒ¼ã‚ã‚Šã§ã‚‚ï¼‰
      window.AdminPanel.initialization.isInProgress = false;
      window.AdminPanel.initialization.isCompleted = true;
      logWarn('âš ï¸ AdminPanel initialization completed with errors');
    }
  }, 500);
}

// å˜ä¸€DOMContentLoadedãƒãƒ³ãƒ‰ãƒ©ãƒ¼
if (document.readyState !== 'loading') {
  initializeAdminPanelMaster();
} else {
  document.addEventListener('DOMContentLoaded', initializeAdminPanelMaster);
}

// Update layout on resize
window.addEventListener('resize', function() {
  if (typeof debounce === 'function') {
    debounce(adjustLayout, 250, 'layout-resize')();
  } else {
    // Fallback without debounce
    adjustLayout();
  }
});

// Account management modal functionality has been removed
// Individual user access control is now handled in AppSetupPage.html
/*
  
  // Setup event listeners
  setupEventListeners: function() {
    const accountBtn = document.getElementById('account-management-btn');
    const closeBtn = document.getElementById('account-modal-close');
    const cancelBtn = document.getElementById('account-modal-cancel');
    const saveBtn = document.getElementById('save-access-settings');
    const deleteBtn = document.getElementById('delete-account-btn');
    const toggle = document.getElementById('user-access-toggle');
    
    if (accountBtn) {
      accountBtn.addEventListener('click', () => this.openModal());
    }
    
    if (closeBtn) {
      closeBtn.addEventListener('click', () => this.closeModal());
    }
    
    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => this.closeModal());
    }
    
    if (saveBtn) {
      saveBtn.addEventListener('click', () => this.saveAccessSettings());
    }
    
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => this.handleDeleteAccount());
    }
    
    if (toggle) {
      toggle.addEventListener('change', () => this.onToggleChange());
    }
    
    // Close modal on backdrop click
    if (this.modal) {
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal) {
          this.closeModal();
        }
      });
    }
  },
  
  // Open modal and load current status
  openModal: function() {
    if (!this.modal) return;
    
    this.modal.classList.remove('hidden');
    this.modal.classList.add('flex');
    this.modal.setAttribute('aria-hidden', 'false');
    
    // Focus management for accessibility
    const firstFocusable = this.modal.querySelector('button, input, textarea, select, [tabindex]:not([tabindex="-1"])');
    if (firstFocusable) {
      setTimeout(() => firstFocusable.focus(), 100);
    }
    
    // Load current user access status
    this.loadCurrentStatus();
    
    logDebug('ğŸ“ Account management modal opened');
  },
  
  // Close modal
  closeModal: function() {
    if (!this.modal) return;
    
    this.modal.classList.add('hidden');
    this.modal.classList.remove('flex');
    this.modal.setAttribute('aria-hidden', 'true');
    
    // Reset form state
    this.resetForm();
    
    logDebug('âŒ Account management modal closed');
  },
  
  // Load current user access status
  loadCurrentStatus: function() {
    const statusElement = document.getElementById('user-access-status');
    const toggle = document.getElementById('user-access-toggle');
    
    if (statusElement) {
      statusElement.textContent = 'ğŸ”„ èª­ã¿è¾¼ã¿ä¸­...';
      statusElement.className = 'ml-2 px-2 py-1 rounded-full text-xs font-medium bg-gray-600 text-gray-300';
    }
    
    if (toggle) {
      toggle.disabled = true;
    }
    
    // Get current user status from the global status
    if (window.currentStatus && window.currentStatus.userInfo) {
      const userInfo = window.currentStatus.userInfo;
      const isActive = userInfo.isActive !== false; // Default to true if not specified
      
      this.updateStatusDisplay(isActive);
      
      if (toggle) {
        toggle.checked = isActive;
        toggle.disabled = false;
      }
      
      this.currentUserStatus = isActive;
      logDebug(`ğŸ“Š Current user isActive status: ${isActive}`);
    } else {
      // Fallback: call API to get current status
      if (typeof runGasWithUserId === 'function') {
        runGasWithUserId('getUserActiveStatus')
          .then((result) => {
            if (result && typeof result.isActive === 'boolean') {
              const isActive = result.isActive;
              this.updateStatusDisplay(isActive);
              
              if (toggle) {
                toggle.checked = isActive;
                toggle.disabled = false;
              }
              
              this.currentUserStatus = isActive;
            } else {
              this.showStatusError('ãƒ¦ãƒ¼ã‚¶ãƒ¼çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
          })
          .catch((error) => {
            console.error('â— Failed to load user status:', error);
            this.showStatusError('ãƒ¦ãƒ¼ã‚¶ãƒ¼çŠ¶æ…‹ã®å–å¾—ã‚¨ãƒ©ãƒ¼');
          });
      } else {
        this.showStatusError('APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
      }
    }
  },
  
  // Update status display
  updateStatusDisplay: function(isActive) {
    const statusElement = document.getElementById('user-access-status');
    if (!statusElement) return;
    
    if (isActive) {
      statusElement.textContent = 'âœ… æœ‰åŠ¹';
      statusElement.className = 'ml-2 px-2 py-1 rounded-full text-xs font-medium bg-green-600 text-white';
    } else {
      statusElement.textContent = 'âŒ ç„¡åŠ¹';
      statusElement.className = 'ml-2 px-2 py-1 rounded-full text-xs font-medium bg-red-600 text-white';
    }
  },
  
  // Show status error
  showStatusError: function(message) {
    const statusElement = document.getElementById('user-access-status');
    const toggle = document.getElementById('user-access-toggle');
    
    if (statusElement) {
      statusElement.textContent = `â— ${message}`;
      statusElement.className = 'ml-2 px-2 py-1 rounded-full text-xs font-medium bg-yellow-600 text-white';
    }
    
    if (toggle) {
      toggle.disabled = true;
    }
  },
  
  // Handle toggle change
  onToggleChange: function() {
    const toggle = document.getElementById('user-access-toggle');
    const saveBtn = document.getElementById('save-access-settings');
    
    if (toggle && saveBtn) {
      const hasChanges = toggle.checked !== this.currentUserStatus;
      saveBtn.disabled = !hasChanges;
      
      if (hasChanges) {
        saveBtn.textContent = 'è¨­å®šã‚’ä¿å­˜';
        saveBtn.classList.remove('bg-gray-600', 'cursor-not-allowed');
        saveBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
      } else {
        saveBtn.textContent = 'å¤‰æ›´ãªã—';
        saveBtn.classList.add('bg-gray-600', 'cursor-not-allowed');
        saveBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
      }
    }
  },
  
  // Save access settings
  saveAccessSettings: function() {
    const toggle = document.getElementById('user-access-toggle');
    const saveBtn = document.getElementById('save-access-settings');
    
    if (!toggle || toggle.disabled) return;
    
    const newStatus = toggle.checked;
    const originalText = saveBtn.textContent;
    
    // Update UI
    saveBtn.disabled = true;
    saveBtn.textContent = 'ğŸ”„ ä¿å­˜ä¸­...';
    
    if (typeof runGasWithUserId === 'function') {
      runGasWithUserId('updateSelfActiveStatus', false, userId, newStatus)
        .then((result) => {
          if (result && result.success) {
            this.currentUserStatus = newStatus;
            this.updateStatusDisplay(newStatus);
            
            // Show success message
            if (window.showMessage) {
              showMessage(`âœ… ã‚¢ã‚¯ã‚»ã‚¹è¨­å®šã‚’${newStatus ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}ã«å¤‰æ›´ã—ã¾ã—ãŸ`, 'success');
            }
            
            // Close modal after short delay
            setTimeout(() => {
              this.closeModal();
            }, 1500);
            
          } else {
            throw new Error(result.message || 'è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
          }
        })
        .catch((error) => {
          console.error('â— Failed to save access settings:', error);
          
          // Revert toggle state
          toggle.checked = this.currentUserStatus;
          
          // Show error message
          if (window.showMessage) {
            showMessage(`âŒ è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message || error}`, 'error');
          }
        })
        .finally(() => {
          // Reset button state
          saveBtn.textContent = originalText;
          this.onToggleChange(); // Re-evaluate button state
        });
    } else {
      console.error('â— runGasWithUserId function not available');
      saveBtn.textContent = originalText;
      saveBtn.disabled = false;
      
      if (window.showMessage) {
        showMessage('âŒ APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“', 'error');
      }
    }
  },
  
  // Handle account deletion
  handleDeleteAccount: function() {
    // Use existing delete account functionality
    if (typeof handleDeleteRequest === 'function') {
      this.closeModal(); // Close the modal first
      setTimeout(() => {
        handleDeleteRequest(); // Call existing delete function
      }, 300);
    } else {
      console.error('â— handleDeleteRequest function not available');
      if (window.showMessage) {
        showMessage('âŒ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆå‰Šé™¤æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“', 'error');
      }
    }
  },
  
  // Reset form state
  resetForm: function() {
    const toggle = document.getElementById('user-access-toggle');
    const saveBtn = document.getElementById('save-access-settings');
    
    if (toggle && this.currentUserStatus !== null) {
      toggle.checked = this.currentUserStatus;
      toggle.disabled = false;
    }
    
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'è¨­å®šã‚’ä¿å­˜';
      saveBtn.classList.add('bg-gray-600', 'cursor-not-allowed');
      saveBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
    }
  }
};

*/
// Account management initialization has been removed

// =============================================================================
// UNIFIED HISTORY MANAGEMENT SYSTEM 
// =============================================================================

/**
 * Unified History Manager - Simple, Error-Resilient, Single Responsibility
 */
window.HistoryManager = {
  // Constants
  STORAGE_KEY: 'answerBoardHistory',
  OLD_STORAGE_KEY: 'adminPanelHistory', // For migration
  MAX_ITEMS: 5,
  
  // Initialization state
  _initialized: false,
  
  /**
   * Initialize the History Manager
   */
  initialize() {
    try {
      if (this._initialized) {
        console.log('ğŸ”„ HistoryManager already initialized');
        return true;
      }
      
      console.log('ğŸš€ HistoryManager initializing...');
      
      // Migrate old data if exists
      this._migrateOldData();
      
      this._initialized = true;
      return true;
      
    } catch (error) {
      console.error('âŒ HistoryManager initialization failed:', error);
      return false;
    }
  },
  
  /**
   * Migrate data from old storage key to new key
   */
  _migrateOldData() {
    try {
      const oldData = localStorage.getItem(this.OLD_STORAGE_KEY);
      const newData = localStorage.getItem(this.STORAGE_KEY);
      
      if (oldData && !newData) {
        console.log('ğŸ”„ Migrating history data from old key...');
        localStorage.setItem(this.STORAGE_KEY, oldData);
        localStorage.removeItem(this.OLD_STORAGE_KEY);
      }
    } catch (error) {
      console.warn('âš ï¸ History data migration failed:', error);
    }
  },
  
  /**
   * Load history from localStorage with error handling
   */
  load() {
    try {
      console.log('ğŸ”„ Loading history from localStorage...');
      const data = localStorage.getItem(this.STORAGE_KEY);
      const parsed = data ? JSON.parse(data) : [];
      const validated = Array.isArray(parsed) ? parsed : [];
      console.log(`âœ… Loaded ${validated.length} history items`);
      return validated;
    } catch (error) {
      console.error('âŒ Failed to load history:', error);
      return [];
    }
  },
  
  /**
   * Save history to localStorage with error handling
   */
  save(items) {
    try {
      const safeItems = Array.isArray(items) ? items : [];
      const limitedItems = safeItems.slice(0, this.MAX_ITEMS);
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(limitedItems));
      console.log(`âœ… Saved ${limitedItems.length} history items`);
      return true;
    } catch (error) {
      console.error('âŒ Failed to save history:', error);
      return false;
    }
  },
  
  /**
   * Add new item to history
   */
  add(newItem) {
    try {
      if (!newItem || !newItem.id) {
        console.warn('âš ï¸ Invalid history item provided');
        return false;
      }
      
      const history = this.load();
      history.unshift(newItem);
      return this.save(history);
    } catch (error) {
      console.error('âŒ Failed to add history item:', error);
      return false;
    }
  },
  
  /**
   * Clear all history
   */
  clear() {
    try {
      localStorage.removeItem(this.STORAGE_KEY);
      localStorage.removeItem(this.OLD_STORAGE_KEY); // Clean old key too
      return true;
    } catch (error) {
      console.error('âŒ Failed to clear history:', error);
      return false;
    }
  },
  /**
   * Format date for created date column (æ—¥ä»˜ã®ã¿è¡¨ç¤º)
   */
  _formatCreatedDate(dateStr) {
    if (!dateStr) return 'æœªè¨­å®š';
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('ja-JP', {
        month: '2-digit',
        day: '2-digit'
      }).replace(/\//g, '/');  // "08/12" å½¢å¼
    } catch {
      return dateStr;
    }
  },

  /**
   * Format date for published date column (å¹´2æ¡çœç•¥ + æ™‚é–“ä»˜ã)
   */
  _formatPublishedDate(dateStr) {
    if (!dateStr) return 'æœªè¨­å®š';
    try {
      const date = new Date(dateStr);
      return date.toLocaleString('ja-JP', {
        year: '2-digit',  // 25å¹´è¡¨ç¤º
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).replace(/\//g, '/');  // "25/08/12 08:45" å½¢å¼
    } catch {
      return dateStr;
    }
  },

  /**
   * Format settings display with icons and clear meanings (showNames/showCounts based)
   */
  _formatSettingsDisplay(item) {
    // showNamesãƒ™ãƒ¼ã‚¹ã®åˆ¤å®šï¼ˆä¸‹ä½äº’æ›æ€§ã‚‚è€ƒæ…®ï¼‰
    let isShowNames = false;
    if (item.showNames !== undefined) {
      isShowNames = item.showNames;
    } else if (item.displayMode !== undefined) {
      // æ—§ãƒ‡ãƒ¼ã‚¿å¯¾å¿œ
      isShowNames = item.displayMode === 'named';
    }
    
    const displayPart = isShowNames ? 'ğŸ‘¥é€šå¸¸' : 'ğŸ­åŒ¿å';
    const countPart = item.showCounts ? 'ğŸ”¢è¡¨ç¤º' : 'ğŸš«éè¡¨ç¤º';
    return `${displayPart}/${countPart}`;
  },

  /**
   * Render history table in the UI
   */
  renderTable() {
    try {
      if (!this._initialized) {
        console.warn('âš ï¸ HistoryManager not initialized, initializing now...');
        if (!this.initialize()) {
          console.error('âŒ Cannot render table - initialization failed');
          return false;
        }
      }
      
      console.log('ğŸ”„ Rendering history table...');
      const tableBody = document.getElementById('history-table-body');
      
      if (!tableBody) {
        console.warn('âŒ History table body element not found');
        return false;
      }
      
      // Show loading state
      tableBody.innerHTML = `
        <tr>
          <td colspan="4" class="px-3 py-6 text-center text-gray-500 text-sm">
            <div class="flex flex-col items-center justify-center">
              <div class="spinner mb-3"></div>
              <div>å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
          </td>
        </tr>
      `;
      
      // Load and display history
      const history = this.load();
      tableBody.innerHTML = '';
      
      if (history.length === 0) {
        this._renderEmptyState(tableBody);
        return true;
      }
      
      // Render history items
      let successCount = 0;
      history.forEach((item, index) => {
        try {
          const row = this._createHistoryTableRow(item, index);
          if (row) {
            tableBody.appendChild(row);
            successCount++;
          }
        } catch (error) {
          console.warn('âš ï¸ Failed to render history item:', error);
        }
      });
      
      return true;
      
    } catch (error) {
      console.error('âŒ Failed to render history table:', error);
      this._renderErrorState();
      return false;
    }
  },
  
  /**
   * Render empty state for history table
   */
  _renderEmptyState(tableBody) {
    const emptyRow = document.createElement('tr');
    emptyRow.innerHTML = `
      <td colspan="4" class="px-3 py-8 text-center text-gray-500 text-sm">
        <div class="flex flex-col items-center">
          <div class="text-4xl mb-2">ğŸ“</div>
          <div class="font-medium mb-1">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>
          <div class="text-xs text-gray-600">ãƒ•ã‚©ãƒ¼ãƒ ã‚’å…¬é–‹ã™ã‚‹ã¨å±¥æ­´ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
        </div>
      </td>
    `;
    tableBody.appendChild(emptyRow);
  },
  
  /**
   * Render error state for history table
   */
  _renderErrorState() {
    const tableBody = document.getElementById('history-table-body');
    if (tableBody) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="4" class="px-3 py-4 text-center text-red-500 text-sm">
            å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ
          </td>
        </tr>
      `;
    }
  },
  
  /**
   * Create a table row for a history item
   */
  _createHistoryTableRow(item, index) {
    try {
      const row = document.createElement('tr');
      
      // æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆä»•æ§˜ã«åˆã‚ã›ã¦ä¿®æ­£ï¼‰
      const createdDate = this._formatCreatedDate(item.createdDate);      // "08/12"
      const publishedDate = this._formatPublishedDate(item.publishedAt);  // "25/08/12 08:45"
      
      // å•é¡Œæ–‡å‡¦ç†
      const question = this._escapeHtml(item.questionText || 'æœªè¨­å®š');
      const truncated = question.length > 30 ? question.substring(0, 30) + '...' : question;
      
      // è¨­å®šè¡¨ç¤ºï¼ˆã‚¢ã‚¤ã‚³ãƒ³/æ„å‘³æ˜ç¢ºåŒ–ï¼‰
      const settingsDisplay = this._formatSettingsDisplay(item);
      
      // 4åˆ—HTMLç”Ÿæˆ
      row.innerHTML = `
        <td class="px-3 py-2 text-sm">${createdDate}</td>
        <td class="px-3 py-2 text-sm">${publishedDate}</td>
        <td class="px-3 py-2 text-sm" title="${question}">${truncated}</td>
        <td class="px-3 py-2 text-xs text-white">${settingsDisplay}</td>
      `;
      
      // è¡Œã‚¯ãƒªãƒƒã‚¯å¾©å…ƒæ©Ÿèƒ½ï¼ˆç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ä»˜ãï¼‰
      row.style.cursor = 'pointer';
      row.classList.add('hover:bg-gray-700', 'transition-colors');
      row.addEventListener('click', () => {
        this._showRestoreConfirmationModal(item);
      });
      
      return row;
    } catch (error) {
      console.error('âŒ Failed to create history table row:', error);
      return null;
    }
  },
  
  /**
   * Show restore confirmation modal
   */
  showRestoreModal(itemId) {
    try {
      const history = this.load();
      const item = history.find(h => h.id === itemId);
      
      if (!item) {
        console.error('âŒ History item not found:', itemId);
        return;
      }
      
      if (typeof showMessage === 'function') {
        showMessage('ğŸ”„ è¨­å®šã‚’å¾©å…ƒä¸­...', 'info');
      }
      
      // Perform restoration
      this._restoreHistoryItem(item);
      
    } catch (error) {
      console.error('âŒ Failed to show restore modal:', error);
    }
  },

  /**
   * Show restore confirmation modal before actually restoring
   */
  _showRestoreConfirmationModal(item) {
    try {
      console.log('ğŸ”„ Showing restore confirmation modal for:', item.questionText);
      
      // å¾©å…ƒã™ã‚‹è¨­å®šã®è©³ç´°æƒ…å ±ã‚’æº–å‚™
      const formattedDate = this._formatCreatedDate(item.createdDate);
      const truncatedQuestion = item.questionText && item.questionText.length > 50 
        ? item.questionText.substring(0, 50) + '...' 
        : (item.questionText || 'æœªè¨­å®š');
      
      // ç¾åœ¨ã®ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæƒ…å ±ã‚’å–å¾—
      const currentSpreadsheetId = window.currentStatus?.userInfo?.spreadsheetId || null;
      const targetSpreadsheetId = item.spreadsheetId || null;
      const hasSpreadsheetDifference = currentSpreadsheetId && targetSpreadsheetId && 
                                     currentSpreadsheetId !== targetSpreadsheetId;
      
      // æ‹¡å¼µã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ€ãƒ«HTMLã‚’ç”Ÿæˆ
      this._showEnhancedRestoreModal(item, {
        truncatedQuestion,
        formattedDate,
        hasSpreadsheetDifference,
        currentSpreadsheetId,
        targetSpreadsheetId
      });
      
    } catch (error) {
      console.error('âŒ Failed to show restore confirmation modal:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…ƒã®ã‚·ãƒ³ãƒ—ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«
      this._showFallbackRestoreModal(item);
    }
  },

  /**
   * Show enhanced restore confirmation modal with detailed layout
   */
  _showEnhancedRestoreModal(item, details) {
    const modal = document.getElementById('confirmation-modal');
    if (!modal) {
      console.warn('âš ï¸ confirmation-modal not found, using fallback');
      this._showFallbackRestoreModal(item);
      return;
    }

    // ã‚«ã‚¹ã‚¿ãƒ HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
    const modalContent = this._generateRestoreModalHTML(item, details);
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å†…å®¹ã‚’ä¸€æ™‚çš„ã«ç½®ãæ›ãˆ
    const glassPanel = modal.querySelector('.glass-panel');
    const originalContent = glassPanel.innerHTML;
    glassPanel.innerHTML = modalContent;
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
    modal.classList.remove('hidden');
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­å®š
    const confirmBtn = modal.querySelector('#restore-confirm-btn');
    const cancelBtn = modal.querySelector('#restore-cancel-btn');
    
    const cleanup = () => {
      // å…ƒã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«æˆ»ã™
      glassPanel.innerHTML = originalContent;
      modal.classList.add('hidden');
    };
    
    if (confirmBtn) {
      confirmBtn.onclick = () => {
        const autoPublishEl = modal.querySelector('#restore-auto-publish');
        const autoPublish = !!(autoPublishEl && autoPublishEl.checked);
        cleanup();
        console.log('âœ… User confirmed restoration', { autoPublish });
        this._restoreHistoryItem(item, { autoPublish });
      };
    }
    
    if (cancelBtn) {
      cancelBtn.onclick = () => {
        cleanup();
        console.log('âŒ User cancelled restoration');
      };
    }
  },

  /**
   * Generate HTML content for enhanced restore modal
   */
  _generateRestoreModalHTML(item, details) {
    const { truncatedQuestion, formattedDate, hasSpreadsheetDifference, currentSpreadsheetId, targetSpreadsheetId } = details;
    
    // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDã‚’ãƒã‚¹ã‚¯è¡¨ç¤ºç”¨ã«å¤‰æ›
    const maskSpreadsheetId = (id) => {
      if (!id || id.length < 8) return id || 'æœªè¨­å®š';
      return '...' + id.slice(-6);
    };
    
    const spreadsheetDiffSection = hasSpreadsheetDifference ? `
      <div class="bg-yellow-500/10 border border-yellow-400/30 rounded-lg p-4 mb-4">
        <h4 class="text-sm font-semibold text-yellow-400 mb-2 flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4V2a1 1 0 011-1h4a1 1 0 011 1v2h4a1 1 0 011 1v1a1 1 0 01-1 1H3a1 1 0 01-1-1V5a1 1 0 011-1h4zM7 8v8a2 2 0 002 2h2a2 2 0 002-2V8M7 8H5a2 2 0 00-2 2v6a2 2 0 002 2h2M13 8h2a2 2 0 012 2v6a2 2 0 01-2 2h-2"></path>
          </svg>
          ğŸ“ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆå¤‰æ›´
        </h4>
        <div class="text-xs text-yellow-100 space-y-1">
          <div><span class="text-yellow-200 font-medium">ç¾åœ¨:</span> ${maskSpreadsheetId(currentSpreadsheetId)}</div>
          <div><span class="text-yellow-200 font-medium">å¾©å…ƒå¾Œ:</span> ${maskSpreadsheetId(targetSpreadsheetId)}</div>
        </div>
      </div>
    ` : '';
    
    // å·®åˆ†ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆ
    const getCurrentBool = (id) => {
      const el = document.getElementById(id);
      return el ? !!el.checked : undefined;
    };
    const getCurrentVal = (id) => {
      const el = document.getElementById(id);
      return el ? (el.value || '') : '';
    };
    const currentSheet = window.selectedSheet || window.currentStatus?.activeSheetName || '';
    const diffs = [];
    if ((currentSheet || '') !== (item.sheetName || '')) {
      diffs.push(`ã‚·ãƒ¼ãƒˆ: <span class=\"text-red-300\">${currentSheet || 'æœªè¨­å®š'}</span> â†’ <span class=\"text-green-300\">${item.sheetName || 'æœªè¨­å®š'}</span>`);
    }
    const curShowNames = getCurrentBool('show-names');
    if (item.showNames !== undefined && curShowNames !== undefined && curShowNames !== item.showNames) {
      diffs.push(`åå‰è¡¨ç¤º: <span class=\"text-red-300\">${curShowNames ? 'ON' : 'OFF'}</span> â†’ <span class=\"text-green-300\">${item.showNames ? 'ON' : 'OFF'}</span>`);
    }
    const curShowCounts = getCurrentBool('show-counts');
    if (item.showCounts !== undefined && curShowCounts !== undefined && curShowCounts !== item.showCounts) {
      diffs.push(`ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º: <span class=\"text-red-300\">${curShowCounts ? 'è¡¨ç¤º' : 'éè¡¨ç¤º'}</span> â†’ <span class=\"text-green-300\">${item.showCounts ? 'è¡¨ç¤º' : 'éè¡¨ç¤º'}</span>`);
    }
    const curOpinion = getCurrentVal('opinion-column') || getCurrentVal('opinionHeader');
    if (item.opinionColumn && curOpinion !== item.opinionColumn) {
      diffs.push(`å›ç­”åˆ—: <span class=\"text-red-300\">${curOpinion || 'æœªè¨­å®š'}</span> â†’ <span class=\"text-green-300\">${item.opinionColumn}</span>`);
    }
    const curName = getCurrentVal('name-column');
    if (item.nameColumn && curName !== item.nameColumn) {
      diffs.push(`åå‰åˆ—: <span class=\"text-red-300\">${curName || 'æœªè¨­å®š'}</span> â†’ <span class=\"text-green-300\">${item.nameColumn}</span>`);
    }
    const curClass = getCurrentVal('class-column');
    if (item.classColumn && curClass !== item.classColumn) {
      diffs.push(`ã‚¯ãƒ©ã‚¹åˆ—: <span class=\"text-red-300\">${curClass || 'æœªè¨­å®š'}</span> â†’ <span class=\"text-green-300\">${item.classColumn}</span>`);
    }
    const curReason = getCurrentVal('reason-column');
    if (item.reasonColumn && curReason !== item.reasonColumn) {
      diffs.push(`ç†ç”±åˆ—: <span class=\"text-red-300\">${curReason || 'æœªè¨­å®š'}</span> â†’ <span class=\"text-green-300\">${item.reasonColumn}</span>`);
    }
    const diffsHtml = diffs.length > 0 ? `<ul class=\"list-disc list-inside text-xs space-y-1\">${diffs.map(x => `<li>${x}</li>`).join('')}</ul>` : '<div class=\"text-xs text-gray-300\">å·®åˆ†ã¯ã‚ã‚Šã¾ã›ã‚“</div>';

    return `
      <h3 class="text-xl font-bold text-orange-400 mb-4 flex items-center gap-2">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        ğŸ“‹ å±¥æ­´å¾©å…ƒã®ç¢ºèª
      </h3>
      <p class="text-gray-300 mb-4">
        ä»¥ä¸‹ã®è¨­å®šã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®è¨­å®šãŒä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚
      </p>
      
      <!-- å¾©å…ƒäºˆå®šã®è¨­å®šæƒ…å ± -->
      <div class="bg-orange-500/10 border border-orange-400/30 rounded-lg p-4 mb-4">
        <h4 class="text-sm font-semibold text-orange-400 mb-3 flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
          </svg>
          ğŸ“ å¾©å…ƒäºˆå®šã®è¨­å®š
        </h4>
        <div class="space-y-2 text-xs text-orange-100">
          <div><span class="text-orange-200 font-medium">å•é¡Œæ–‡:</span> ${truncatedQuestion}</div>
          <div><span class="text-orange-200 font-medium">ã‚·ãƒ¼ãƒˆå:</span> ${item.sheetName || 'æœªè¨­å®š'}</div>
          <div><span class="text-orange-200 font-medium">ä½œæˆæ—¥:</span> ${formattedDate}</div>
        </div>
      </div>
      
      ${spreadsheetDiffSection}

      <div class="bg-indigo-500/10 border border-indigo-400/30 rounded-lg p-4 mb-4">
        <h4 class="text-sm font-semibold text-indigo-300 mb-2">ğŸ” å·®åˆ†ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h4>
        ${diffsHtml}
      </div>
      
      <!-- è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
      <div class="bg-red-500/10 border border-red-400/30 rounded-lg p-3 mb-6">
        <p class="text-xs text-red-200 flex items-center gap-2">
          <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
          </svg>
          ã“ã®æ“ä½œã«ã‚ˆã‚Šç¾åœ¨ã®æœªä¿å­˜ã®è¨­å®šå†…å®¹ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚
        </p>
      </div>
      
      <div class="bg-green-500/10 border border-green-400/30 rounded-lg p-3 mb-4">
        <label class="flex items-center gap-2 text-sm text-green-200">
          <input id="restore-auto-publish" type="checkbox" class="w-4 h-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-green-500">
          å¾©å…ƒå¾Œã«è‡ªå‹•ã§å…¬é–‹ã¾ã§è¡Œã†
        </label>
      </div>

      <div class="flex justify-end gap-3">
        <button type="button" id="restore-cancel-btn" class="btn btn-secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button type="button" id="restore-confirm-btn" class="btn btn-primary">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
          </svg>
          å¾©å…ƒã™ã‚‹
        </button>
      </div>
    `;
  },

  /**
   * Fallback restore modal for compatibility
   */
  _showFallbackRestoreModal(item) {
    const formattedDate = this._formatCreatedDate(item.createdDate);
    const truncatedQuestion = item.questionText && item.questionText.length > 50 
      ? item.questionText.substring(0, 50) + '...' 
      : (item.questionText || 'æœªè¨­å®š');
    
    const title = 'å±¥æ­´å¾©å…ƒã®ç¢ºèª';
    const message = `ä»¥ä¸‹ã®è¨­å®šã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®è¨­å®šãŒä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚

ğŸ“ å•é¡Œæ–‡: ${truncatedQuestion}
ğŸ“Š ã‚·ãƒ¼ãƒˆå: ${item.sheetName || 'æœªè¨­å®š'}  
ğŸ“… ä½œæˆæ—¥: ${formattedDate}

âš ï¸ ã“ã®æ“ä½œã«ã‚ˆã‚Šç¾åœ¨ã®è¨­å®šå†…å®¹ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚`;

    // SharedModalsã‚·ã‚¹ãƒ†ãƒ ã‚’å„ªå…ˆçš„ã«ä½¿ç”¨
    if (window.sharedModals && typeof window.sharedModals.showConfirmation === 'function') {
      console.log('âœ… Using sharedModals.showConfirmation fallback');
      window.sharedModals.showConfirmation(
        title,
        message,
        () => {
          console.log('âœ… User confirmed restoration');
          this._restoreHistoryItem(item);
        },
        () => {
          console.log('âŒ User cancelled restoration');
        }
      );
    } else if (typeof showConfirmationModal === 'function') {
      console.log('âœ… Using showConfirmationModal fallback');
      showConfirmationModal(
        title,
        message,
        () => {
          console.log('âœ… User confirmed restoration');
          this._restoreHistoryItem(item);
        }
      );
    } else {
      console.warn('âš ï¸ No confirmation modal system available, using browser confirm');
      if (confirm(`${title}\n\n${message.replace(/ğŸ“|ğŸ“Š|ğŸ“…|âš ï¸/g, '')}`)) {
        console.log('âœ… User confirmed restoration via browser confirm');
        this._restoreHistoryItem(item);
      } else {
        console.log('âŒ User cancelled restoration via browser confirm');
      }
    }
  },
  
  /**
   * Restore configuration from history item
   */
  async _restoreHistoryItem(item, options = {}) {
    try {
      console.log('ğŸ”„ Restoring history:', item.questionText);
      console.log('ğŸ“Š History item details:', {
        id: item.id,
        questionText: item.questionText,
        sheetName: item.sheetName,
        spreadsheetId: item.spreadsheetId,
        opinionHeader: item.opinionHeader,
        nameHeader: item.nameHeader
      });
      
      // AIåˆ—åˆ¤å®šã«ã‚ˆã‚‹ä¸Šæ›¸ãã‚’é˜²æ­¢ã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
      window._historyRestoreInProgress = true;
      console.log('ğŸ›¡ï¸ AIåˆ—åˆ¤å®šã‚¹ã‚­ãƒƒãƒ—ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¾ã—ãŸ');
      
      // 1. ãƒ†ã‚­ã‚¹ãƒˆè¨­å®šå¾©å…ƒ
      if (item.opinionHeader) {
        const opinionInput = document.getElementById('opinion-header');
        if (opinionInput) opinionInput.value = item.opinionHeader;
      }
      
      if (item.nameHeader) {
        const nameInput = document.getElementById('name-header');
        if (nameInput) nameInput.value = item.nameHeader;
      }
      
      // 1.5. åˆ—é¸æŠã®å¾©å…ƒï¼ˆå±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ï¼‰ - å¼·åŒ–ç‰ˆ
      console.log('ğŸ”„ Restoring column selections from history');
      
      // åˆ—é¸æŠè‚¢ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹é–¢æ•°
      const waitForColumnOptions = async (selectId, targetValue, maxWait = 3000) => {
        const startTime = Date.now();
        const checkInterval = 200;
        
        return new Promise((resolve) => {
          const checkOptions = () => {
            const select = document.getElementById(selectId);
            if (!select) {
              console.warn(`âš ï¸ Select element not found: ${selectId}`);
              resolve(false);
              return;
            }
            
            // é¸æŠè‚¢ã®ä¸­ã«ç›®æ¨™å€¤ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const options = Array.from(select.options);
            const hasTargetOption = options.some(option => option.value === targetValue);
            
            if (hasTargetOption) {
              console.log(`âœ… Column option found for ${selectId}: ${targetValue}`);
              select.value = targetValue;
              
              // å€¤ãŒæ­£ã—ãè¨­å®šã•ã‚ŒãŸã‹ãƒ€ãƒ–ãƒ«ãƒã‚§ãƒƒã‚¯
              if (select.value === targetValue) {
                console.log(`âœ… ${selectId} value successfully set to: ${targetValue}`);
                resolve(true);
              } else {
                console.warn(`âš ï¸ ${selectId} value setting failed. Expected: ${targetValue}, Actual: ${select.value}`);
                resolve(false);
              }
              return;
            }
            
            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
            const elapsed = Date.now() - startTime;
            if (elapsed >= maxWait) {
              console.warn(`âš ï¸ Timeout waiting for column option ${selectId}:${targetValue} (${elapsed}ms). Available: ${options.map(o => o.value).join(', ')}`);
              // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã§ã‚‚å€¤ã®è¨­å®šã¯è©¦è¡Œ
              select.value = targetValue;
              resolve(false);
              return;
            }
            
            // å†ãƒã‚§ãƒƒã‚¯
            setTimeout(checkOptions, checkInterval);
          };
          
          checkOptions();
        });
      };
      
      // ä¸¦åˆ—ã§åˆ—é¸æŠã‚’å¾©å…ƒ
      const columnRestorations = [];
      
      if (item.opinionColumn) {
        columnRestorations.push(
          waitForColumnOptions('opinion-column', item.opinionColumn)
            .then(success => ({ type: 'opinion', value: item.opinionColumn, success }))
        );
      }
      
      if (item.nameColumn) {
        columnRestorations.push(
          waitForColumnOptions('name-column', item.nameColumn)
            .then(success => ({ type: 'name', value: item.nameColumn, success }))
        );
      }
      
      if (item.classColumn) {
        columnRestorations.push(
          waitForColumnOptions('class-column', item.classColumn)
            .then(success => ({ type: 'class', value: item.classColumn, success }))
        );
      }
      
      if (item.reasonColumn) {
        columnRestorations.push(
          waitForColumnOptions('reason-column', item.reasonColumn)
            .then(success => ({ type: 'reason', value: item.reasonColumn, success }))
        );
      }
      
      // ã™ã¹ã¦ã®åˆ—å¾©å…ƒã‚’å¾…æ©Ÿ
      if (columnRestorations.length > 0) {
        console.log(`ğŸ”„ Waiting for ${columnRestorations.length} column selections to restore...`);
        try {
          const results = await Promise.all(columnRestorations);
          const successCount = results.filter(r => r.success).length;
          console.log(`âœ… Column restoration completed: ${successCount}/${results.length} successful`);
          
          results.forEach(result => {
            if (result.success) {
              console.log(`âœ… ${result.type} column restored: ${result.value}`);
            } else {
              console.warn(`âš ï¸ ${result.type} column restoration failed: ${result.value}`);
            }
          });
        } catch (restorationError) {
          console.warn('âš ï¸ Column restoration error:', restorationError);
        }
      }
      
      // 2. åå‰è¡¨ç¤ºè¨­å®šå¾©å…ƒï¼ˆshowNamesãƒ™ãƒ¼ã‚¹ï¼‰
      const showNamesCheckbox = document.getElementById('show-names');
      if (showNamesCheckbox) {
        if (item.showNames !== undefined) {
          showNamesCheckbox.checked = item.showNames;
        } else if (item.displayMode !== undefined) {
          // æ—§ãƒ‡ãƒ¼ã‚¿å¯¾å¿œ
          showNamesCheckbox.checked = (item.displayMode === 'named');
        }
      }
      
      // 3. ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°è¡¨ç¤ºå¾©å…ƒ
      const showCountsCheckbox = document.getElementById('show-counts');
      if (showCountsCheckbox) {
        showCountsCheckbox.checked = (item.showCounts === true);
      }
      
      // 4. å®Œå…¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå¾©å…ƒï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ + ã‚·ãƒ¼ãƒˆï¼‰
      console.log('ğŸ” Restore conditions check:', {
        hasSpreadsheetId: !!item.spreadsheetId,
        hasSheetName: !!item.sheetName,
        spreadsheetId: item.spreadsheetId,
        sheetName: item.sheetName
      });
      
      if (item.spreadsheetId && item.sheetName) {
        console.log('âœ… Full project restore path selected');
        await this._restoreFullProject(item.spreadsheetId, item.sheetName);
      } else if (item.sheetName) {
        console.log('âœ… Sheet-only restore path selected');
        // ã‚·ãƒ¼ãƒˆã®ã¿å¾©å…ƒï¼ˆä¸‹ä½äº’æ›æ€§ï¼‰
        await this._restoreSheetSelection(item.sheetName);
      } else {
        console.warn('âš ï¸ No valid restoration path found - missing sheet or spreadsheet info');
        console.warn('ğŸ”§ Attempting fallback: trying to find sheet by question text');
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å•é¡Œæ–‡ã‹ã‚‰ã‚·ãƒ¼ãƒˆåã‚’æ¨æ¸¬
        const fallbackSheetName = await this._findSheetByQuestionText(item.questionText);
        if (fallbackSheetName) {
          console.log(`âœ… Fallback found sheet: ${fallbackSheetName}`);
          await this._restoreSheetSelection(fallbackSheetName);
        } else {
          console.error('âŒ Fallback failed: unable to determine correct sheet');
        }
      }
      
      // 5. è¨­å®šã®æ°¸ç¶šåŒ–ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸åŒæœŸï¼‰
      try {
        if (typeof buildConfigObject === 'function' && typeof runGasWithUserId === 'function') {
          const configToPersist = buildConfigObject();
          // å¾©å…ƒã—ãŸã‚·ãƒ¼ãƒˆåã‚’å¼·åˆ¶é©ç”¨
          if (item.sheetName) configToPersist.sheetName = item.sheetName;
          // å¾©å…ƒã®æ„å›³ã‚’æ˜ç¢ºåŒ–ã™ã‚‹ãŸã‚flowTypeã¯ 'custom'
          const syncResult = await runGasWithUserId('syncConfigurationState', 'è¨­å®šã‚’å¾©å…ƒä¸­...', configToPersist, 'custom');
          if (syncResult && syncResult.status === 'success') {
            console.log('âœ… Configuration synchronized after restore');
          } else {
            console.warn('âš ï¸ Configuration sync after restore reported:', syncResult && syncResult.message);
          }
        } else {
          console.warn('âš ï¸ Unable to persist configuration after restore (missing helpers)');
        }
      } catch (persistError) {
        console.warn('âš ï¸ Configuration persistence warning:', persistError);
      }

      // 6. UIå®Œå…¨æ›´æ–°
      await this._refreshAfterRestore();

      // 7. ã‚ªãƒ—ã‚·ãƒ§ãƒ³: å¾©å…ƒå¾Œã«è‡ªå‹•ã§å…¬é–‹
      if (options.autoPublish && typeof saveAndPublish === 'function') {
        try {
          console.log('ğŸ“¤ Auto-publishing after restore...');
          saveAndPublish();
        } catch (pubError) {
          console.warn('âš ï¸ Auto publish failed:', pubError);
        }
      }
      
      // Success message
      if (typeof showMessage === 'function') {
        showMessage('âœ… å±¥æ­´ã‹ã‚‰è¨­å®šã‚’å¾©å…ƒã—ã¾ã—ãŸ', 'success');
      }
      console.log('âœ… Complete restore finished');
      
    } catch (error) {
      console.error('âŒ History restore failed:', error);
      if (typeof showMessage === 'function') {
        showMessage('âŒ è¨­å®šå¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
      }
    } finally {
      // AIåˆ—åˆ¤å®šã‚¹ã‚­ãƒƒãƒ—ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
      if (window._historyRestoreInProgress) {
        window._historyRestoreInProgress = false;
        console.log('ğŸ›¡ï¸ AIåˆ—åˆ¤å®šã‚¹ã‚­ãƒƒãƒ—ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
      }
    }
  },

  /**
   * Find sheet by question text as fallback mechanism
   */
  async _findSheetByQuestionText(questionText) {
    try {
      console.log(`ğŸ” Searching for sheet with question: "${questionText}"`);
      
      // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‹ã‚‰è¨­å®šæƒ…å ±ã‚’å–å¾—
      if (window.AdminPanel?.currentStatus?.configJson) {
        const configJson = window.AdminPanel.currentStatus.configJson;
        
        // å„ã‚·ãƒ¼ãƒˆè¨­å®šã‚’ç¢ºèª
        for (const [key, sheetConfig] of Object.entries(configJson)) {
          if (key.startsWith('sheet_') && sheetConfig.opinionHeader) {
            if (sheetConfig.opinionHeader === questionText) {
              const sheetName = sheetConfig.sheetName || key.replace('sheet_', '');
              console.log(`âœ… Found matching sheet: ${sheetName}`);
              return sheetName;
            }
          }
        }
      }
      
      console.warn('âš ï¸ No matching sheet found for question text');
      return null;
      
    } catch (error) {
      console.error('âŒ Error in _findSheetByQuestionText:', error);
      return null;
    }
  },

  /**
   * Restore full project (spreadsheet + sheet) from history
   */
  async _restoreFullProject(spreadsheetId, sheetName) {
    try {
      console.log(`ğŸ”„ Restoring full project: ${spreadsheetId}/${sheetName}`);
      
      // ç¾åœ¨ã®ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDã‚’å–å¾—
      const getCurrentSpreadsheetId = () => {
        // status ã‹ã‚‰ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèª
        if (window.AdminPanel?.currentStatus?.userInfo?.spreadsheetId) {
          return window.AdminPanel.currentStatus.userInfo.spreadsheetId;
        }
        return null;
      };
      
      const currentSpreadsheetId = getCurrentSpreadsheetId();
      
      // ç•°ãªã‚‹ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®å ´åˆã®ã¿åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
      if (spreadsheetId !== currentSpreadsheetId) {
        console.log(`ğŸ”„ Switching spreadsheet: ${currentSpreadsheetId} â†’ ${spreadsheetId}`);
        
        // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆã®é€šçŸ¥
        if (typeof showMessage === 'function') {
          showMessage('ğŸ”„ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã„ã¾ã™...', 'info', 3000);
        }
        
        // å®Ÿéš›ã®ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆã‚’å®Ÿè¡Œ
        await this._performSpreadsheetSwitch(spreadsheetId);
        
        // UIæ›´æ–°å®Œäº†ã‚’å¾…æ©Ÿã—ã¦ã‹ã‚‰ã‚·ãƒ¼ãƒˆé¸æŠå¾©å…ƒ
        console.log(`ğŸ”„ Waiting for sheet options to include: ${sheetName}`);
        const sheetFound = await this._waitForSheetOptionsUpdate(sheetName);
        if (!sheetFound) {
          console.warn(`âš ï¸ Sheet ${sheetName} not found in options after waiting, proceeding with fallback`);
        }
      }
      
      // ã‚·ãƒ¼ãƒˆé¸æŠå¾©å…ƒ
      await this._restoreSheetSelection(sheetName);
      
      console.log(`âœ… Full project restore completed`);
      
    } catch (error) {
      console.warn('âš ï¸ Full project restore failed:', error);
      if (typeof showMessage === 'function') {
        showMessage('âš ï¸ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå¾©å…ƒã§å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'warning');
      }
    }
  },

  /**
   * Restore sheet selection from history
   */
  async _restoreSheetSelection(sheetName) {
    try {
      console.log(`ğŸ”„ Restoring sheet selection: ${sheetName}`);
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹æ›´æ–°
      window.AdminPanel.selectedSheet = sheetName;
      if (window.AdminPanel.stateManager) {
        window.AdminPanel.stateManager.setState('selectedSheet', sheetName);  
      }
      
      // ã‚·ãƒ¼ãƒˆé¸æŠUIæ›´æ–°
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        // ã‚·ãƒ¼ãƒˆé¸æŠã‚’å®Ÿè¡Œ
        if (sheetSelect.value !== sheetName) {
          sheetSelect.value = sheetName;
          console.log(`âœ… Sheet select value updated to: ${sheetName}`);
        }
        
        // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³è¡¨ç¤ºã®å¼·åˆ¶æ›´æ–°
        if (typeof updateSheetSelectActiveIndicator === 'function') {
          updateSheetSelectActiveIndicator(sheetName);
          console.log(`âœ… Sheet active indicator updated`);
        }
        
        // ã‚·ãƒ¼ãƒˆå¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆåˆ—ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ãƒˆãƒªã‚¬ãƒ¼ï¼‰
        const changeEvent = new Event('change', { bubbles: true });
        sheetSelect.dispatchEvent(changeEvent);
        console.log(`âœ… Sheet change event dispatched`);
        
        // ã‚·ãƒ¼ãƒˆé¸æŠå¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ç›´æ¥å‘¼ã³å‡ºã—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        if (typeof handleSheetSelectionChange === 'function') {
          const mockEvent = { target: { value: sheetName } };
          await handleSheetSelectionChange(mockEvent);
          console.log(`âœ… Sheet selection change handler called directly`);
        }
        
        // å°‘ã—å¾…æ©Ÿã—ã¦ã‹ã‚‰UIæ›´æ–°ã‚’ç¢ºèª
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // selectedSheet ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚‚æ›´æ–°ï¼ˆäº’æ›æ€§ç¢ºä¿ï¼‰
        if (typeof window.selectedSheet !== 'undefined') {
          window.selectedSheet = sheetName;
        }
      }
      
      console.log(`âœ… Sheet restored: ${sheetName}`);
    } catch (error) {
      console.warn('âš ï¸ Sheet restore warning:', error);
    }
  },

  /**
   * Refresh UI after history restore
   */
  async _refreshAfterRestore() {
    try {
      console.log('ğŸ”„ Refreshing UI after history restore...');
      
      // ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã®å†èª­ã¿è¾¼ã¿ï¼ˆã‚·ãƒ¼ãƒˆå¤‰æ›´å¾Œã®åˆ—ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼‰
      if (typeof loadSheetDetailsAPI === 'function' && window.AdminPanel.selectedSheet) {
        console.log('ğŸ“Š Reloading sheet details for column data...');
        try {
          await loadSheetDetailsAPI(window.AdminPanel.selectedSheet);
          console.log('âœ… Sheet details reloaded successfully');
        } catch (sheetError) {
          console.warn('âš ï¸ Sheet details reload failed:', sheetError);
        }
      }
      
      // åˆ—é¸æŠè‚¢ã®æ›´æ–°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
      if (typeof handleSheetSelectionChange === 'function' && window.AdminPanel.selectedSheet) {
        console.log('ğŸ“‹ Updating column options via sheet selection handler...');
        try {
          const mockEvent = { target: { value: window.AdminPanel.selectedSheet } };
          await handleSheetSelectionChange(mockEvent);
          console.log('âœ… Column options updated via handler');
        } catch (handlerError) {
          console.warn('âš ï¸ Sheet selection handler failed:', handlerError);
        }
      }
      
      // UIçŠ¶æ…‹ã®æœ€çµ‚èª¿æ•´
      if (typeof updateUIForSelectedSheet === 'function') {
        console.log('ğŸ¯ Updating UI for selected sheet...');
        try {
          updateUIForSelectedSheet();
          console.log('âœ… UI updated for selected sheet');
        } catch (uiError) {
          console.warn('âš ï¸ UI update failed:', uiError);
        }
      }
      
      // è¨­å®šãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
      if (typeof updateConfigButtons === 'function') {
        console.log('ğŸ”˜ Updating config buttons state...');
        try {
          updateConfigButtons();
          console.log('âœ… Config buttons updated');
        } catch (buttonError) {
          console.warn('âš ï¸ Config buttons update failed:', buttonError);
        }
      }
      
      console.log('âœ… UI refresh completed successfully');
    } catch (error) {
      console.warn('âš ï¸ UI refresh warning:', error);
    }
  },

  /**
   * Perform actual spreadsheet switching
   */
  async _performSpreadsheetSwitch(targetSpreadsheetId) {
    try {
      // 1. Update user's active spreadsheet in database
      if (typeof runGasWithUserId === 'function') {
        const updateResult = await runGasWithUserId('updateUserAPI', false, {
          spreadsheetId: targetSpreadsheetId
        });
        
        if (updateResult && updateResult.status === 'success') {
          console.log('âœ… Spreadsheet switched successfully in database');
        } else {
          throw new Error('Database update failed: ' + (updateResult?.message || 'Unknown error'));
        }
      } else {
        throw new Error('runGasWithUserId function not available');
      }

      // 2. Clear caches to force reload with new spreadsheet
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
        window.gasOptimizer.clearCache();
      }

      // 3. Reload application state with new spreadsheet
      if (typeof loadStatus === 'function') {
        await loadStatus(true); // Force reload bypassing cache
        console.log('âœ… Application state reloaded with new spreadsheet');
        
        // 4. Force update currentSpreadsheetUrl after state reload
        if (window.currentStatus?.userInfo?.spreadsheetUrl) {
          currentSpreadsheetUrl = window.currentStatus.userInfo.spreadsheetUrl;
          console.log('âœ… currentSpreadsheetUrl force updated after switch:', currentSpreadsheetUrl);
        } else {
          console.warn('âš ï¸ No spreadsheetUrl available in reloaded currentStatus');
        }
      } else {
        console.warn('âš ï¸ loadStatus function not available for state reload');
      }

    } catch (error) {
      console.error('âŒ Spreadsheet switching failed:', error);
      if (typeof showMessage === 'function') {
        showMessage('âŒ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message, 'error');
      }
      throw error; // Re-throw to be handled by caller
    }
  },

  /**
   * Wait for sheet options to be updated with target sheet
   */
  async _waitForSheetOptionsUpdate(targetSheetName, maxWaitTime = 3000) {
    const startTime = Date.now();
    const checkInterval = 100; // Check every 100ms
    
    return new Promise((resolve, reject) => {
      const checkSheetOptions = () => {
        const select = document.getElementById('sheet-select');
        if (!select) {
          console.warn('âš ï¸ Sheet select element not found during wait');
          resolve(false);
          return;
        }
        
        // Check if target sheet is in options
        const options = Array.from(select.options);
        const hasTargetSheet = options.some(option => option.value === targetSheetName);
        
        if (hasTargetSheet) {
          console.log(`âœ… Target sheet found in options: ${targetSheetName}`);
          resolve(true);
          return;
        }
        
        // Check timeout
        const elapsed = Date.now() - startTime;
        if (elapsed >= maxWaitTime) {
          console.warn(`âš ï¸ Timeout waiting for sheet options update (${elapsed}ms). Available: ${options.map(o => o.value).join(', ')}`);
          resolve(false); // Don't reject, allow fallback
          return;
        }
        
        // Continue checking
        setTimeout(checkSheetOptions, checkInterval);
      };
      
      // Start checking
      checkSheetOptions();
    });
  },
  
  /**
   * Generate unique history ID
   */
  generateId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  },
  
  /**
   * HTML escape utility
   */
  _escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
  }
};

// Create compatibility layer for legacy code
window.AdminPanel.historyManager = {
  loadSimpleHistoryTable: () => window.HistoryManager.renderTable(),
  restoreFromSimpleHistory: (item) => window.HistoryManager._restoreHistoryItem(item)
};

// Register global functions for backward compatibility
window.loadSimpleHistoryTable = () => window.HistoryManager.renderTable();

//# sourceURL=adminPanel-framework.js.html
</script>
