<script>
/**
 * æ§‹é€ çš„ã«å …ç‰¢ãªã‚·ã‚¹ãƒ†ãƒ  - ã‚¨ãƒ©ãƒ¼ã®èµ·ãã‚ˆã†ãŒãªã„ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
 * 
 * è¨­è¨ˆåŸå‰‡:
 * 1. ã™ã¹ã¦ã®çŠ¶æ…‹ã«é©åˆ‡ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
 * 2. ã™ã¹ã¦ã®å¤–éƒ¨ä¾å­˜ã«è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
 * 3. ã™ã¹ã¦ã®æ“ä½œã«è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
 * 4. ã™ã¹ã¦ã®ã‚¨ãƒ©ãƒ¼ã«è‡ªå‹•å›å¾©æ©Ÿèƒ½
 * 5. ã™ã¹ã¦ã®è¨­å®šã«è‡ªå‹•æ¤œè¨¼ã¨ä¿®å¾©æ©Ÿèƒ½
 */

// =============================================================================
// å …ç‰¢ãªè¨­å®šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - è‡ªå‹•æ¤œè¨¼ãƒ»ä¿®å¾©ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
// =============================================================================

class RobustConfigManager {
  constructor() {
    this.configCache = new Map();
    this.defaultConfigs = this.getDefaultConfigs();
    this.initializationState = 'pending';
    this.lastSuccessfulConfig = null;
  }

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š - ã™ã¹ã¦ã«å®‰å…¨ãªåˆæœŸå€¤ã‚’è¨­å®š
  getDefaultConfigs() {
    return {
      system: {
        initialized: false,
        databaseSpreadsheetId: null,
        serviceAccountCreds: null,
        debugMode: false,
        autoRecovery: true,
        maxRetries: 3,
        retryDelay: 1000
      },
      ui: {
        displayMode: 'ANONYMOUS',
        showReactionCounts: true,
        loadingTimeout: 30000,
        refreshInterval: 5000,
        errorDisplayDuration: 5000
      },
      cache: {
        ttl: 300000, // 5 minutes
        maxSize: 100,
        autoCleanup: true,
        compressionEnabled: false
      },
      security: {
        validateAccess: true,
        enforceHttps: true,
        sanitizeInputs: true,
        enableAuditLog: true
      }
    };
  }

  // å …ç‰¢ãªè¨­å®šå–å¾— - å¿…ãšæˆåŠŸã™ã‚‹
  async getConfig(category, key, useCache = true) {
    try {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
      const cacheKey = `${category}.${key}`;
      if (useCache && this.configCache.has(cacheKey)) {
        const cached = this.configCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 60000) { // 1åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
          return cached.value;
        }
      }

      // è¨­å®šå–å¾—ã‚’è©¦è¡Œï¼ˆè¤‡æ•°ã‚½ãƒ¼ã‚¹ï¼‰
      let value = await this.tryGetConfigFromSources(category, key);
      
      // å€¤ãŒå–å¾—ã§ããªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
      if (value === null || value === undefined) {
        value = this.getDefaultValue(category, key);
        console.warn(`Using default config for ${category}.${key}:`, value);
      }

      // å€¤ã‚’æ¤œè¨¼ãƒ»ä¿®æ­£
      value = this.validateAndFixConfig(category, key, value);

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      this.configCache.set(cacheKey, {
        value: value,
        timestamp: Date.now()
      });

      return value;
    } catch (error) {
      console.error(`Config retrieval failed for ${category}.${key}:`, error);
      return this.getDefaultValue(category, key);
    }
  }

  // è¤‡æ•°ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨­å®šã‚’è©¦è¡Œå–å¾—
  async tryGetConfigFromSources(category, key) {
    const sources = [
      () => this.getFromScriptProperties(category, key),
      () => this.getFromUserProperties(category, key),
      () => this.getFromDocumentProperties(category, key),
      () => this.getFromLocalStorage(category, key),
      () => this.getFromLastSuccessful(category, key)
    ];

    for (const source of sources) {
      try {
        const value = await source();
        if (value !== null && value !== undefined) {
          return value;
        }
      } catch (error) {
        console.debug(`Config source failed for ${category}.${key}:`, error);
      }
    }

    return null;
  }

  // Script Properties ã‹ã‚‰å–å¾—
  async getFromScriptProperties(category, key) {
    if (typeof PropertiesService === 'undefined') return null;
    
    try {
      const properties = PropertiesService.getScriptProperties();
      const value = properties.getProperty(`${category}_${key}`);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      return null;
    }
  }

  // User Properties ã‹ã‚‰å–å¾—
  async getFromUserProperties(category, key) {
    if (typeof PropertiesService === 'undefined') return null;
    
    try {
      const properties = PropertiesService.getUserProperties();
      const value = properties.getProperty(`${category}_${key}`);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      return null;
    }
  }

  // Document Properties ã‹ã‚‰å–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  async getFromDocumentProperties(category, key) {
    if (typeof PropertiesService === 'undefined') return null;
    
    try {
      const properties = PropertiesService.getDocumentProperties();
      const value = properties.getProperty(`${category}_${key}`);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      return null;
    }
  }

  // LocalStorage ã‹ã‚‰å–å¾—ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼‰
  async getFromLocalStorage(category, key) {
    if (typeof window === 'undefined' || !window.localStorage) return null;
    
    try {
      const value = localStorage.getItem(`config_${category}_${key}`);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      return null;
    }
  }

  // æœ€å¾Œã«æˆåŠŸã—ãŸè¨­å®šã‹ã‚‰å–å¾—
  async getFromLastSuccessful(category, key) {
    if (!this.lastSuccessfulConfig) return null;
    
    try {
      return this.lastSuccessfulConfig[category]?.[key] || null;
    } catch (error) {
      return null;
    }
  }

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤å–å¾—
  getDefaultValue(category, key) {
    return this.defaultConfigs[category]?.[key] || null;
  }

  // è¨­å®šå€¤ã®æ¤œè¨¼ã¨è‡ªå‹•ä¿®æ­£
  validateAndFixConfig(category, key, value) {
    try {
      // å‹æ¤œè¨¼ã¨ä¿®æ­£
      const expectedType = typeof this.getDefaultValue(category, key);
      if (typeof value !== expectedType) {
        console.warn(`Config type mismatch for ${category}.${key}. Expected: ${expectedType}, Got: ${typeof value}`);
        
        // è‡ªå‹•å‹å¤‰æ›ã‚’è©¦è¡Œ
        switch (expectedType) {
          case 'boolean':
            value = Boolean(value);
            break;
          case 'number':
            value = Number(value) || this.getDefaultValue(category, key);
            break;
          case 'string':
            value = String(value);
            break;
          default:
            value = this.getDefaultValue(category, key);
        }
      }

      // å€¤ã®ç¯„å›²ãƒã‚§ãƒƒã‚¯ã¨ä¿®æ­£
      value = this.applyValueConstraints(category, key, value);

      return value;
    } catch (error) {
      console.error(`Config validation failed for ${category}.${key}:`, error);
      return this.getDefaultValue(category, key);
    }
  }

  // å€¤ã®åˆ¶ç´„é©ç”¨
  applyValueConstraints(category, key, value) {
    const constraints = {
      cache: {
        ttl: { min: 1000, max: 3600000 }, // 1ç§’ - 1æ™‚é–“
        maxSize: { min: 10, max: 1000 }
      },
      ui: {
        loadingTimeout: { min: 5000, max: 60000 }, // 5ç§’ - 1åˆ†
        refreshInterval: { min: 1000, max: 30000 }
      }
    };

    const constraint = constraints[category]?.[key];
    if (constraint && typeof value === 'number') {
      if (value < constraint.min) return constraint.min;
      if (value > constraint.max) return constraint.max;
    }

    return value;
  }

  // å …ç‰¢ãªè¨­å®šä¿å­˜
  async saveConfig(category, key, value, persistent = true) {
    try {
      const validatedValue = this.validateAndFixConfig(category, key, value);
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
      const cacheKey = `${category}.${key}`;
      this.configCache.set(cacheKey, {
        value: validatedValue,
        timestamp: Date.now()
      });

      if (persistent) {
        // è¤‡æ•°ã®å ´æ‰€ã«ä¿å­˜ï¼ˆå†—é•·åŒ–ï¼‰
        const savePromises = [
          this.saveToScriptProperties(category, key, validatedValue),
          this.saveToUserProperties(category, key, validatedValue),
          this.saveToLocalStorage(category, key, validatedValue)
        ];

        // æœ€ä½1ã¤ã®ä¿å­˜ãŒæˆåŠŸã™ã‚Œã°OK
        const results = await Promise.allSettled(savePromises);
        const successCount = results.filter(r => r.status === 'fulfilled').length;
        
        if (successCount === 0) {
          throw new Error('All save operations failed');
        }

        console.log(`Config saved to ${successCount}/3 locations: ${category}.${key}`);
      }

      return true;
    } catch (error) {
      console.error(`Config save failed for ${category}.${key}:`, error);
      return false;
    }
  }

  // Script Properties ã«ä¿å­˜
  async saveToScriptProperties(category, key, value) {
    if (typeof PropertiesService === 'undefined') return false;
    
    try {
      const properties = PropertiesService.getScriptProperties();
      properties.setProperty(`${category}_${key}`, JSON.stringify(value));
      return true;
    } catch (error) {
      console.debug(`Failed to save to Script Properties: ${error.message}`);
      return false;
    }
  }

  // User Properties ã«ä¿å­˜
  async saveToUserProperties(category, key, value) {
    if (typeof PropertiesService === 'undefined') return false;
    
    try {
      const properties = PropertiesService.getUserProperties();
      properties.setProperty(`${category}_${key}`, JSON.stringify(value));
      return true;
    } catch (error) {
      console.debug(`Failed to save to User Properties: ${error.message}`);
      return false;
    }
  }

  // LocalStorage ã«ä¿å­˜
  async saveToLocalStorage(category, key, value) {
    if (typeof window === 'undefined' || !window.localStorage) return false;
    
    try {
      localStorage.setItem(`config_${category}_${key}`, JSON.stringify(value));
      return true;
    } catch (error) {
      console.debug(`Failed to save to LocalStorage: ${error.message}`);
      return false;
    }
  }

  // ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨åˆæœŸåŒ– - å¿…ãšæˆåŠŸã™ã‚‹
  async initializeSystem() {
    try {
      this.initializationState = 'initializing';
      
      // å¿…é ˆè¨­å®šã‚’è‡ªå‹•æ¤œè¨¼ãƒ»è¨­å®š
      const criticalConfigs = [
        { category: 'system', key: 'initialized', defaultValue: false },
        { category: 'ui', key: 'displayMode', defaultValue: 'ANONYMOUS' },
        { category: 'cache', key: 'ttl', defaultValue: 300000 },
        { category: 'security', key: 'validateAccess', defaultValue: true }
      ];

      for (const config of criticalConfigs) {
        const value = await this.getConfig(config.category, config.key, false);
        if (value === null || value === undefined) {
          await this.saveConfig(config.category, config.key, config.defaultValue, true);
        }
      }

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚’æ¤œè¨¼ãƒ»è¨­å®š
      await this.verifyAndSetupDatabase();

      // ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¤œè¨¼ãƒ»è¨­å®š
      await this.verifyAndSetupServiceAccount();

      this.initializationState = 'completed';
      console.log('âœ… System initialization completed successfully');
      return true;
    } catch (error) {
      console.error('System initialization failed:', error);
      // æœ€å°é™ãƒ¢ãƒ¼ãƒ‰ã§ç¶™ç¶š
      this.initializationState = 'minimal';
      await this.initializeMinimalMode();
      return true; // æœ€å°é™ã§ã‚‚å‹•ä½œã™ã‚‹ãŸã‚æˆåŠŸã¨ã™ã‚‹
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œè¨¼ãƒ»è‡ªå‹•ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  async verifyAndSetupDatabase() {
    try {
      let dbId = await this.getConfig('system', 'databaseSpreadsheetId');
      
      if (!dbId) {
        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒãªã„å ´åˆã¯è‡ªå‹•ä½œæˆ
        dbId = await this.createDefaultDatabase();
        if (dbId) {
          await this.saveConfig('system', 'databaseSpreadsheetId', dbId, true);
        }
      }

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ†ã‚¹ãƒˆ
      if (dbId) {
        const isAccessible = await this.testDatabaseAccess(dbId);
        if (!isAccessible) {
          // ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„å ´åˆã¯æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½œæˆ
          const newDbId = await this.createDefaultDatabase();
          if (newDbId) {
            await this.saveConfig('system', 'databaseSpreadsheetId', newDbId, true);
          }
        }
      }

      return true;
    } catch (error) {
      console.error('Database setup failed:', error);
      return false;
    }
  }

  // ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ¤œè¨¼ãƒ»è¨­å®š
  async verifyAndSetupServiceAccount() {
    try {
      let creds = await this.getConfig('system', 'serviceAccountCreds');
      
      if (!creds) {
        // ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãªã„å ´åˆã¯ä»£æ›¿èªè¨¼ã‚’è¨­å®š
        creds = await this.setupAlternativeAuth();
        if (creds) {
          await this.saveConfig('system', 'serviceAccountCreds', creds, true);
        }
      }

      return true;
    } catch (error) {
      console.error('Service account setup failed:', error);
      return false;
    }
  }

  // æœ€å°é™ãƒ¢ãƒ¼ãƒ‰ã§åˆæœŸåŒ–
  async initializeMinimalMode() {
    try {
      // æœ€ä½é™å¿…è¦ãªè¨­å®šã‚’å¼·åˆ¶è¨­å®š
      const minimalConfig = {
        system: { initialized: true, debugMode: true },
        ui: { displayMode: 'ANONYMOUS', showReactionCounts: false },
        cache: { ttl: 60000, maxSize: 10 }
      };

      for (const [category, configs] of Object.entries(minimalConfig)) {
        for (const [key, value] of Object.entries(configs)) {
          this.configCache.set(`${category}.${key}`, {
            value: value,
            timestamp: Date.now()
          });
        }
      }

      console.log('âš ï¸ System running in minimal mode');
      return true;
    } catch (error) {
      console.error('Minimal mode initialization failed:', error);
      return false;
    }
  }

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½œæˆ
  async createDefaultDatabase() {
    try {
      if (typeof SpreadsheetApp === 'undefined') return null;

      const ss = SpreadsheetApp.create('ã¿ã‚“ãªã®å›ç­”ãƒœãƒ¼ãƒ‰ - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹');
      const sheet = ss.getActiveSheet();
      sheet.setName('USER_INFO');
      
      // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
      const headers = ['userId', 'adminEmail', 'spreadsheetId', 'configJson', 'createdAt', 'lastAccessedAt', 'isActive'];
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]);

      console.log('âœ… Default database created:', ss.getId());
      return ss.getId();
    } catch (error) {
      console.error('Failed to create default database:', error);
      return null;
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ
  async testDatabaseAccess(spreadsheetId) {
    try {
      if (typeof SpreadsheetApp === 'undefined') return false;

      const ss = SpreadsheetApp.openById(spreadsheetId);
      const sheets = ss.getSheets();
      return sheets.length > 0;
    } catch (error) {
      console.debug('Database access test failed:', error);
      return false;
    }
  }

  // ä»£æ›¿èªè¨¼è¨­å®š
  async setupAlternativeAuth() {
    try {
      // ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨
      if (typeof Session === 'undefined') return null;
      
      return {
        type: 'session',
        email: Session.getActiveUser().getEmail(),
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('Alternative auth setup failed:', error);
      return null;
    }
  }
}

// =============================================================================
// å …ç‰¢ãªå®Ÿè¡Œç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - å¿…ãšæˆåŠŸã™ã‚‹ã‹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹
// =============================================================================

class RobustExecutionManager {
  constructor() {
    this.pendingOperations = new Map();
    this.retryQueues = new Map();
    this.circuitBreakers = new Map();
  }

  // å …ç‰¢ãªéåŒæœŸå®Ÿè¡Œ - å¿…ãšä½•ã‚‰ã‹ã®çµæœã‚’è¿”ã™
  async executeRobustly(operation, options = {}) {
    const config = {
      maxRetries: options.maxRetries || 3,
      retryDelay: options.retryDelay || 1000,
      timeout: options.timeout || 30000,
      fallback: options.fallback || null,
      circuitBreakerKey: options.circuitBreakerKey || 'default',
      ...options
    };

    const operationId = this.generateOperationId();
    
    try {
      // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãƒã‚§ãƒƒã‚¯
      if (this.isCircuitBreakerOpen(config.circuitBreakerKey)) {
        console.warn(`Circuit breaker open for ${config.circuitBreakerKey}, using fallback`);
        return this.executeFallback(config.fallback, 'Circuit breaker open');
      }

      // é‡è¤‡å®Ÿè¡Œé˜²æ­¢
      if (options.deduplicationKey) {
        const existing = this.pendingOperations.get(options.deduplicationKey);
        if (existing) {
          console.log(`Reusing pending operation: ${options.deduplicationKey}`);
          return existing;
        }
      }

      // å®Ÿè¡Œé–‹å§‹
      const promise = this.executeWithRetry(operation, config, operationId);
      
      if (options.deduplicationKey) {
        this.pendingOperations.set(options.deduplicationKey, promise);
      }

      const result = await promise;
      
      // æˆåŠŸæ™‚ã®å‡¦ç†
      this.recordSuccess(config.circuitBreakerKey);
      if (options.deduplicationKey) {
        this.pendingOperations.delete(options.deduplicationKey);
      }
      
      return result;
    } catch (error) {
      console.error(`Operation ${operationId} failed:`, error);
      
      // å¤±æ•—æ™‚ã®å‡¦ç†
      this.recordFailure(config.circuitBreakerKey);
      if (options.deduplicationKey) {
        this.pendingOperations.delete(options.deduplicationKey);
      }
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
      return this.executeFallback(config.fallback, error.message);
    }
  }

  // ãƒªãƒˆãƒ©ã‚¤ä»˜ãå®Ÿè¡Œ
  async executeWithRetry(operation, config, operationId) {
    let lastError = null;
    
    for (let attempt = 1; attempt <= config.maxRetries; attempt++) {
      try {
        console.debug(`Operation ${operationId}, attempt ${attempt}/${config.maxRetries}`);
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ
        const result = await this.executeWithTimeout(operation, config.timeout);
        
        console.debug(`Operation ${operationId} succeeded on attempt ${attempt}`);
        return result;
      } catch (error) {
        lastError = error;
        console.warn(`Operation ${operationId} failed on attempt ${attempt}:`, error.message);
        
        // æœ€å¾Œã®è©¦è¡Œä»¥å¤–ã¯ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿ
        if (attempt < config.maxRetries) {
          const delay = config.retryDelay * Math.pow(2, attempt - 1); // Exponential backoff
          console.debug(`Waiting ${delay}ms before retry...`);
          await this.delay(delay);
        }
      }
    }
    
    throw lastError;
  }

  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ
  async executeWithTimeout(operation, timeout) {
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Operation timed out after ${timeout}ms`));
      }, timeout);

      try {
        const result = await operation();
        clearTimeout(timeoutId);
        resolve(result);
      } catch (error) {
        clearTimeout(timeoutId);
        reject(error);
      }
    });
  }

  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
  async executeFallback(fallback, reason) {
    try {
      if (typeof fallback === 'function') {
        console.log(`Executing fallback function due to: ${reason}`);
        return await fallback(reason);
      } else if (fallback !== null && fallback !== undefined) {
        console.log(`Using fallback value due to: ${reason}`);
        return fallback;
      } else {
        console.log(`No fallback available for: ${reason}`);
        return {
          success: false,
          error: reason,
          fallback: true,
          timestamp: Date.now()
        };
      }
    } catch (error) {
      console.error('Fallback execution failed:', error);
      return {
        success: false,
        error: `Fallback failed: ${error.message}`,
        fallback: true,
        timestamp: Date.now()
      };
    }
  }

  // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ç®¡ç†
  isCircuitBreakerOpen(key) {
    const breaker = this.circuitBreakers.get(key);
    if (!breaker) return false;
    
    const now = Date.now();
    if (breaker.state === 'open' && now - breaker.lastFailure > 60000) {
      // 1åˆ†å¾Œã«åŠé–‹çŠ¶æ…‹ã«ç§»è¡Œ
      breaker.state = 'half-open';
      console.log(`Circuit breaker ${key} moved to half-open state`);
    }
    
    return breaker.state === 'open';
  }

  recordSuccess(key) {
    const breaker = this.circuitBreakers.get(key) || { failures: 0, state: 'closed' };
    breaker.failures = 0;
    breaker.state = 'closed';
    this.circuitBreakers.set(key, breaker);
  }

  recordFailure(key) {
    const breaker = this.circuitBreakers.get(key) || { failures: 0, state: 'closed' };
    breaker.failures += 1;
    breaker.lastFailure = Date.now();
    
    if (breaker.failures >= 5) {
      breaker.state = 'open';
      console.warn(`Circuit breaker ${key} opened after ${breaker.failures} failures`);
    }
    
    this.circuitBreakers.set(key, breaker);
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  generateOperationId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// =============================================================================
// ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆæœŸåŒ– - ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å …ç‰¢æ€§ã‚’ä¿è¨¼
// =============================================================================

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
window.robustConfig = new RobustConfigManager();
window.robustExecution = new RobustExecutionManager();

// ã‚·ã‚¹ãƒ†ãƒ è‡ªå‹•åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', async () => {
  try {
    console.log('ğŸ”„ Initializing robust system...');
    await window.robustConfig.initializeSystem();
    console.log('âœ… Robust system initialized successfully');
    
    // ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
    const event = new CustomEvent('robustSystemReady', {
      detail: { timestamp: Date.now() }
    });
    document.dispatchEvent(event);
  } catch (error) {
    console.error('Robust system initialization failed:', error);
    // å¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼ˆæœ€å°é™ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œï¼‰
  }
});

// æœªå‡¦ç†ä¾‹å¤–ã®ã‚­ãƒ£ãƒƒãƒ
window.addEventListener('error', (event) => {
  console.error('Unhandled error caught by robust system:', event.error);
  // ã‚¨ãƒ©ãƒ¼ã‚’è¨˜éŒ²ã—ã€ã‚·ã‚¹ãƒ†ãƒ ç¶™ç¶š
  if (window.robustConfig) {
    window.robustConfig.saveConfig('system', 'lastError', {
      message: event.error?.message,
      timestamp: Date.now()
    }, false);
  }
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection caught by robust system:', event.reason);
  event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‡¦ç†ã‚’é˜²æ­¢
});

console.log('âœ… RobustSystemCore loaded - Error-proof architecture enabled');
</script>