<script>
/**
 * Backend Progress Sync System
 * Real-time synchronization between frontend progress display and backend processing
 */

class BackendProgressSync {
  constructor() {
    this.progressCallbacks = new Map();
    this.pollingIntervals = new Map();
    this.activeFlows = new Set();
    this.progressCache = new Map();
    this.isEnabled = true;
  }

  /**
   * Start progress synchronization
   * @param {string} flowId - Flow identifier
   * @param {Function} callback - Progress update callback
   */
  startSync(flowId, callback) {
    if (!this.isEnabled) {
      console.log('üîï BackendProgressSync is disabled');
      return;
    }

    console.log(`üîÑ Starting progress sync for flow: ${flowId}`);
    
    this.progressCallbacks.set(flowId, callback);
    this.activeFlows.add(flowId);
    this.beginPolling(flowId);
  }

  /**
   * Start backend polling
   * @param {string} flowId - Flow identifier
   */
  beginPolling(flowId) {
    // Stop existing polling
    this.stopPolling(flowId);

    const pollingInterval = setInterval(async () => {
      try {
        const progress = await this.fetchBackendProgress(flowId);
        const callback = this.progressCallbacks.get(flowId);
        
        if (callback && progress) {
          // Execute callback only when progress has changed
          const cachedProgress = this.progressCache.get(flowId);
          if (!cachedProgress || this.hasProgressChanged(cachedProgress, progress)) {
            callback(progress);
            this.progressCache.set(flowId, { ...progress });
          }
        }

        // Stop polling when flow is completed
        if (progress && (progress.completed || progress.error)) {
          this.stopSync(flowId);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Progress polling error for ${flowId}:`, error);
        
        // Stop polling if consecutive errors occur
        if (this.shouldStopOnError(flowId, error)) {
          this.stopSync(flowId);
        }
      }
    }, SYSTEM_CONSTANTS.TIMEOUTS.POLLING_INTERVAL);

    this.pollingIntervals.set(flowId, pollingInterval);
  }

  /**
   * Fetch progress from backend
   * @param {string} flowId - Flow identifier
   * @returns {Promise<Object>} Progress information
   */
  async fetchBackendProgress(flowId) {
    try {
      // Google Apps Script progress fetch implementation
      const response = await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error('Progress fetch timeout'));
        }, 10000); // 10 second timeout

        google.script.run
          .withSuccessHandler((result) => {
            clearTimeout(timeoutId);
            resolve(result);
          })
          .withFailureHandler((error) => {
            clearTimeout(timeoutId);
            reject(error);
          })
          .getFlowProgress(flowId);
      });

      return this.parseProgressResponse(response);
    } catch (error) {
      // Special handling when getFlowProgress function doesn't exist
      if (error.message && error.message.includes('getFlowProgress is not a function')) {
        console.log(`‚ÑπÔ∏è Backend progress sync not available for ${flowId}, using fallback mode`);
        this.isEnabled = false; // Disable future requests
        return null;
      }
      
      console.warn(`‚ö†Ô∏è Failed to fetch progress for ${flowId}:`, error);
      return null;
    }
  }

  /**
   * Parse progress response
   * @param {Object} response - Response from backend
   * @returns {Object} Parsed progress information
   */
  parseProgressResponse(response) {
    if (!response || typeof response !== 'object') {
      return null;
    }

    return {
      flowId: response.flowId,
      currentStep: response.currentStep || 0,
      totalSteps: response.totalSteps || 7,
      stepName: response.stepName || '',
      stepDetail: response.stepDetail || '',
      progress: response.progress || 0,
      estimatedTimeRemaining: response.estimatedTimeRemaining || 0,
      completed: response.completed || false,
      error: response.error || false,
      errorMessage: response.errorMessage || '',
      timestamp: response.timestamp || Date.now()
    };
  }

  /**
   * Check if progress has changed
   * @param {Object} oldProgress - Previous progress
   * @param {Object} newProgress - New progress
   * @returns {boolean} True if there was a change
   */
  hasProgressChanged(oldProgress, newProgress) {
    if (!oldProgress || !newProgress) return true;
    
    return (
      oldProgress.currentStep !== newProgress.currentStep ||
      oldProgress.progress !== newProgress.progress ||
      oldProgress.stepName !== newProgress.stepName ||
      oldProgress.completed !== newProgress.completed ||
      oldProgress.error !== newProgress.error
    );
  }

  /**
   * Check if polling should be stopped on error
   * @param {string} flowId - Flow identifier
   * @param {Error} error - Error object
   * @returns {boolean} True if should stop
   */
  shouldStopOnError(flowId, error) {
    // Continue polling for specific error types
    const continuableErrors = [
      'Network error',
      'Temporary unavailable',
      'Rate limit exceeded'
    ];

    const errorMessage = error.message || '';
    return !continuableErrors.some(continuableError => 
      errorMessage.includes(continuableError)
    );
  }

  /**
   * Stop progress synchronization
   * @param {string} flowId - Flow identifier
   */
  stopSync(flowId) {
    console.log(`üõë Stopping progress sync for flow: ${flowId}`);

    this.stopPolling(flowId);
    this.progressCallbacks.delete(flowId);
    this.activeFlows.delete(flowId);
    this.progressCache.delete(flowId);
  }

  /**
   * Stop polling
   * @param {string} flowId - Flow identifier
   */
  stopPolling(flowId) {
    const intervalId = this.pollingIntervals.get(flowId);
    if (intervalId) {
      clearInterval(intervalId);
      this.pollingIntervals.delete(flowId);
    }
  }

  /**
   * Stop all synchronization
   */
  stopAllSync() {
    console.log('üõë Stopping all progress sync');

    for (const flowId of this.activeFlows) {
      this.stopSync(flowId);
    }
  }

  /**
   * Disable system
   */
  disable() {
    this.isEnabled = false;
    this.stopAllSync();
  }

  /**
   * Enable system
   */
  enable() {
    this.isEnabled = true;
  }

  /**
   * Get number of active flows
   * @returns {number} Active flow count
   */
  getActiveFlowCount() {
    return this.activeFlows.size;
  }

  /**
   * Get debug information
   * @returns {Object} Debug information
   */
  getDebugInfo() {
    return {
      isEnabled: this.isEnabled,
      activeFlows: Array.from(this.activeFlows),
      activeCallbacks: this.progressCallbacks.size,
      activePolling: this.pollingIntervals.size,
      cachedProgress: Object.fromEntries(this.progressCache)
    };
  }
}

// Create global instance
window.backendProgressSync = new BackendProgressSync();

// Export convenience functions
window.startProgressSync = (flowId, callback) => {
  return window.backendProgressSync.startSync(flowId, callback);
};

window.stopProgressSync = (flowId) => {
  return window.backendProgressSync.stopSync(flowId);
};

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  window.backendProgressSync.stopAllSync();
});

console.log('‚úÖ BackendProgressSync initialized');
</script>