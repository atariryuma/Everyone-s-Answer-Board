<script>
/**
 * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é€²æ—åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
 * ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å‡¦ç†ã®å®Ÿæ™‚é–“åŒæœŸã‚’å®Ÿç¾
 */

class BackendProgressSync {
  constructor() {
    this.progressCallbacks = new Map();
    this.pollingIntervals = new Map();
    this.activeFlows = new Set();
    this.progressCache = new Map();
    this.isEnabled = true;
  }

  /**
   * é€²æ—åŒæœŸã‚’é–‹å§‹
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   * @param {Function} callback - é€²æ—æ›´æ–°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
   */
  startSync(flowId, callback) {
    if (!this.isEnabled) {
      console.log('ğŸ”• BackendProgressSync is disabled');
      return;
    }

    console.log(`ğŸ”„ Starting progress sync for flow: ${flowId}`);
    
    this.progressCallbacks.set(flowId, callback);
    this.activeFlows.add(flowId);
    this.beginPolling(flowId);
  }

  /**
   * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’é–‹å§‹
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   */
  beginPolling(flowId) {
    // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’åœæ­¢
    this.stopPolling(flowId);

    const pollingInterval = setInterval(async () => {
      try {
        const progress = await this.fetchBackendProgress(flowId);
        const callback = this.progressCallbacks.get(flowId);
        
        if (callback && progress) {
          // é€²æ—ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã¿ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
          const cachedProgress = this.progressCache.get(flowId);
          if (!cachedProgress || this.hasProgressChanged(cachedProgress, progress)) {
            callback(progress);
            this.progressCache.set(flowId, { ...progress });
          }
        }

        // ãƒ•ãƒ­ãƒ¼ãŒå®Œäº†ã—ãŸå ´åˆã¯ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
        if (progress && (progress.completed || progress.error)) {
          this.stopSync(flowId);
        }
      } catch (error) {
        console.warn(`âš ï¸ Progress polling error for ${flowId}:`, error);
        
        // é€£ç¶šã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒãƒ¼ãƒªãƒ³ã‚°åœæ­¢
        if (this.shouldStopOnError(flowId, error)) {
          this.stopSync(flowId);
        }
      }
    }, SYSTEM_CONSTANTS.TIMEOUTS.POLLING_INTERVAL);

    this.pollingIntervals.set(flowId, pollingInterval);
  }

  /**
   * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰é€²æ—ã‚’å–å¾—
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   * @returns {Promise<Object>} é€²æ—æƒ…å ±
   */
  async fetchBackendProgress(flowId) {
    try {
      // Google Apps Scriptã§ã®progresså–å¾—å®Ÿè£…
      const response = await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error('Progress fetch timeout'));
        }, 10000); // 10ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

        google.script.run
          .withSuccessHandler((result) => {
            clearTimeout(timeoutId);
            resolve(result);
          })
          .withFailureHandler((error) => {
            clearTimeout(timeoutId);
            reject(error);
          })
          .getFlowProgress(flowId);
      });

      return this.parseProgressResponse(response);
    } catch (error) {
      // getFlowProgressé–¢æ•°ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ç‰¹åˆ¥ãªãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
      if (error.message && error.message.includes('getFlowProgress is not a function')) {
        console.log(`â„¹ï¸ Backend progress sync not available for ${flowId}, using fallback mode`);
        this.isEnabled = false; // å°†æ¥ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ç„¡åŠ¹åŒ–
        return null;
      }
      
      console.warn(`âš ï¸ Failed to fetch progress for ${flowId}:`, error);
      return null;
    }
  }

  /**
   * é€²æ—ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
   * @param {Object} response - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   * @returns {Object} ãƒ‘ãƒ¼ã‚¹æ¸ˆã¿é€²æ—æƒ…å ±
   */
  parseProgressResponse(response) {
    if (!response || typeof response !== 'object') {
      return null;
    }

    return {
      flowId: response.flowId,
      currentStep: response.currentStep || 0,
      totalSteps: response.totalSteps || 7,
      stepName: response.stepName || '',
      stepDetail: response.stepDetail || '',
      progress: response.progress || 0,
      estimatedTimeRemaining: response.estimatedTimeRemaining || 0,
      completed: response.completed || false,
      error: response.error || false,
      errorMessage: response.errorMessage || '',
      timestamp: response.timestamp || Date.now()
    };
  }

  /**
   * é€²æ—ãŒå¤‰åŒ–ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
   * @param {Object} oldProgress - å‰å›ã®é€²æ—
   * @param {Object} newProgress - æ–°ã—ã„é€²æ—
   * @returns {boolean} å¤‰åŒ–ãŒã‚ã£ãŸå ´åˆtrue
   */
  hasProgressChanged(oldProgress, newProgress) {
    if (!oldProgress || !newProgress) return true;
    
    return (
      oldProgress.currentStep !== newProgress.currentStep ||
      oldProgress.progress !== newProgress.progress ||
      oldProgress.stepName !== newProgress.stepName ||
      oldProgress.completed !== newProgress.completed ||
      oldProgress.error !== newProgress.error
    );
  }

  /**
   * ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’åœæ­¢ã™ã¹ãã‹ãƒã‚§ãƒƒã‚¯
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   * @param {Error} error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @returns {boolean} åœæ­¢ã™ã¹ãå ´åˆtrue
   */
  shouldStopOnError(flowId, error) {
    // ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã§ã¯ãƒãƒ¼ãƒªãƒ³ã‚°ç¶™ç¶š
    const continuableErrors = [
      'Network error',
      'Temporary unavailable',
      'Rate limit exceeded'
    ];

    const errorMessage = error.message || '';
    return !continuableErrors.some(continuableError => 
      errorMessage.includes(continuableError)
    );
  }

  /**
   * é€²æ—åŒæœŸã‚’åœæ­¢
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   */
  stopSync(flowId) {
    console.log(`ğŸ›‘ Stopping progress sync for flow: ${flowId}`);

    this.stopPolling(flowId);
    this.progressCallbacks.delete(flowId);
    this.activeFlows.delete(flowId);
    this.progressCache.delete(flowId);
  }

  /**
   * ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’åœæ­¢
   * @param {string} flowId - ãƒ•ãƒ­ãƒ¼è­˜åˆ¥å­
   */
  stopPolling(flowId) {
    const intervalId = this.pollingIntervals.get(flowId);
    if (intervalId) {
      clearInterval(intervalId);
      this.pollingIntervals.delete(flowId);
    }
  }

  /**
   * å…¨ã¦ã®åŒæœŸã‚’åœæ­¢
   */
  stopAllSync() {
    console.log('ğŸ›‘ Stopping all progress sync');

    for (const flowId of this.activeFlows) {
      this.stopSync(flowId);
    }
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ ã‚’ç„¡åŠ¹åŒ–
   */
  disable() {
    this.isEnabled = false;
    this.stopAllSync();
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–
   */
  enable() {
    this.isEnabled = true;
  }

  /**
   * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ•ãƒ­ãƒ¼æ•°ã‚’å–å¾—
   * @returns {number} ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ­ãƒ¼æ•°
   */
  getActiveFlowCount() {
    return this.activeFlows.size;
  }

  /**
   * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å–å¾—
   * @returns {Object} ãƒ‡ãƒãƒƒã‚°æƒ…å ±
   */
  getDebugInfo() {
    return {
      isEnabled: this.isEnabled,
      activeFlows: Array.from(this.activeFlows),
      activeCallbacks: this.progressCallbacks.size,
      activePolling: this.pollingIntervals.size,
      cachedProgress: Object.fromEntries(this.progressCache)
    };
  }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
window.backendProgressSync = new BackendProgressSync();

// ä¾¿åˆ©ãªé–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
window.startProgressSync = (flowId, callback) => {
  return window.backendProgressSync.startSync(flowId, callback);
};

window.stopProgressSync = (flowId) => {
  return window.backendProgressSync.stopSync(flowId);
};

// ãƒšãƒ¼ã‚¸ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
window.addEventListener('beforeunload', () => {
  window.backendProgressSync.stopAllSync();
});

console.log('âœ… BackendProgressSync initialized');
</script>