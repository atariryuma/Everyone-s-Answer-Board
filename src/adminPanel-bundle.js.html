<script>

/**
 * Admin Panel Bundle - 統合されたAdminPanelコンポーネント
 * 
 * このファイルは管理パネルの全JavaScriptコンポーネントを統合しています。
 * 読み込み順序と依存関係の問題を解決するため、単一ファイルに統合されました。
 */

// インクルード順序:
// 1. adminPanel-framework.js.html
// 2. adminPanel-core.js.html  
// 3. adminPanel-api.js.html
// 4. adminPanel-ui.js.html
// 5. adminPanel-events.js.html
// 6. admin-consolidated.js.html
// 7. adminPanel-simple-history.js.html
// 8. adminPanel-simple-history-compat.js.html


// Unified Admin Panel Namespace and Management Classes
// Generated to address function interference issues and centralize state, events,
// asynchronous operations, and DOM handling.

window.AdminPanel = window.AdminPanel || {
  errors: {},
  ui: {},
  state: {
    current: null,
    selectedSheet: '',
    updateStatus(status) {
      this.current = status;
    }
  },
  // Initialization state tracking to prevent redundant calls
  initialization: {
    isInProgress: false,
    isCompleted: false,
    completedPhases: new Set(),
    startTime: null,
    lastLoadStatusCall: null,
    loadStatusCallCount: 0
  }
};

// -----------------------------------------------------------------------------
// State Manager
// -----------------------------------------------------------------------------
class AdminPanelStateManager {
  constructor() {
    this.state = {
      currentStatus: null,
      selectedSheet: '',
      isLoading: false,
      debugMode: false // DEBUG_MODE状態を追加
    };
    this.subscribers = new Map();
  }

  setState(key, value) {
    this.state[key] = value;
    this.notifySubscribers(key, value);
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, []);
    }
    this.subscribers.get(key).push(callback);
  }

  notifySubscribers(key, value) {
    const subs = this.subscribers.get(key) || [];
    subs.forEach((cb) => {
      try {
        cb(value);
      } catch (e) {
        console.warn('Subscriber callback failed', e);
      }
    });
  }
}

// -----------------------------------------------------------------------------
// Event Manager
// -----------------------------------------------------------------------------
class AdminPanelEventManager {
  constructor() {
    this.listeners = new Map();
  }

  addListener(element, event, handler, options = {}) {
    if (!element || !event || !handler) return;
    const key = `${element.id || 'anonymous'}-${event}`;
    if (this.listeners.has(key)) {
      console.warn(`Duplicate listener for ${key}`);
      return;
    }
    element.addEventListener(event, handler, options);
    this.listeners.set(key, { element, event, handler, options });
  }
}

// -----------------------------------------------------------------------------
// Async Manager
// -----------------------------------------------------------------------------
class AdminPanelAsyncManager {
  constructor() {
    this.runningOperations = new Map();
  }

  executeExclusive(operationId, operation) {
    if (this.runningOperations.has(operationId)) {
      return this.runningOperations.get(operationId);
    }
    const promise = Promise.resolve().then(operation);
    this.runningOperations.set(operationId, promise);
    return promise.then((result) => {
      this.runningOperations.delete(operationId);
      return result;
    }).catch((error) => {
      this.runningOperations.delete(operationId);
      throw error;
    });
  }
}

// -----------------------------------------------------------------------------
// DOM Manager
// -----------------------------------------------------------------------------
class AdminPanelDOMManager {
  constructor() {
    this.elementCache = new Map();
    this.operationQueue = [];
  }

  getElement(id) {
    if (!this.elementCache.has(id)) {
      this.elementCache.set(id, document.getElementById(id));
    }
    return this.elementCache.get(id);
  }

  queueOperation(operation) {
    this.operationQueue.push(operation);
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        const op = this.operationQueue.shift();
        resolve(op());
      });
    });
  }
}

// -----------------------------------------------------------------------------
// Core Business Logic Class
// -----------------------------------------------------------------------------
class AdminPanelCore {
  static validateConfig() {
    const requiredElements = ['opinionHeader', 'sheet-select'];
    const missingElements = [];
    
    requiredElements.forEach(id => {
      if (!document.getElementById(id)) {
        missingElements.push(id);
      }
    });
    
    if (missingElements.length > 0) {
      console.warn('Missing required elements:', missingElements);
      return false;
    }
    return true;
  }
  
  static showMessage(message, type = 'info', duration = 5000) {
    console.log(`[${type.toUpperCase()}] ${message}`);
    // Could be extended to show UI notifications
  }
  
  static checkFunctionAvailability(functionName) {
    const func = window[functionName];
    if (typeof func !== 'function') {
      console.warn(`⚠️ Function ${functionName} is not available`);
      return false;
    }
    return true;
  }
  
  static safeCallFunction(functionName, ...args) {
    try {
      if (!AdminPanelCore.checkFunctionAvailability(functionName)) {
        console.warn(`⚠️ Cannot call ${functionName} - function not available`);
        return null;
      }
      return window[functionName](...args);
    } catch (error) {
      console.error(`❌ Error calling ${functionName}:`, error);
      return null;
    }
  }
}

// -----------------------------------------------------------------------------
// UI Management Class
// -----------------------------------------------------------------------------
class AdminPanelUI {
  static toggleSection(sectionId) {
    const section = window.AdminPanel.domManager.getElement(sectionId);
    const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
    
    if (!section) return;
    
    const isExpanded = section.classList.contains('expanded');
    section.classList.toggle('expanded', !isExpanded);
    section.classList.toggle('collapsed', isExpanded);
    
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', (!isExpanded).toString());
    }
  }
  
  static showFormConfigModal() {
    const modal = window.AdminPanel.domManager.getElement('form-config-modal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }
  }
  
  static hideDigitalCitizenshipModal() {
    const modal = document.getElementById('digital-citizenship-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }
  }
  
  static hideConfirmationModal() {
    const modal = document.getElementById('confirmation-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }
  }
  
  static populateHeaderOptions(headers) {
    if (!headers || !Array.isArray(headers)) return;
    
    const opinionSelect = document.getElementById('opinionHeader');
    const nameColumnSelect = document.getElementById('name-column');
    
    if (opinionSelect) {
      opinionSelect.innerHTML = '<option value="">意見列を選択</option>';
      headers.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        opinionSelect.appendChild(option);
      });
    }
    
    if (nameColumnSelect) {
      nameColumnSelect.innerHTML = '<option value="">名前列を選択（オプション）</option>';
      headers.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        nameColumnSelect.appendChild(option);
      });
    }
  }
}

// -----------------------------------------------------------------------------
// API Communication Class
// -----------------------------------------------------------------------------
class AdminPanelAPI {
  static updateFormUrlDisplay(status = null) {
    try {
      const formUrlInput = window.AdminPanel.domManager.getElement('form-url');
      const viewFormBtn = window.AdminPanel.domManager.getElement('view-form-btn');
      
      if (!status && window.AdminPanel?.stateManager?.state?.currentStatus) {
        status = window.AdminPanel.stateManager.state.currentStatus;
      }
      
      if (status?.formUrl && formUrlInput) {
        formUrlInput.value = status.formUrl;
        if (viewFormBtn) {
          viewFormBtn.href = status.formUrl;
          viewFormBtn.classList.remove('hidden');
        }
      }
    } catch (error) {
      console.error('Error updating form URL display:', error);
    }
  }
}

// Instantiate managers and expose via namespace
window.AdminPanel.stateManager = new AdminPanelStateManager();
window.AdminPanel.eventManager = new AdminPanelEventManager();
window.AdminPanel.asyncManager = new AdminPanelAsyncManager();
window.AdminPanel.domManager = new AdminPanelDOMManager();

// Expose new classes
window.AdminPanel.Core = AdminPanelCore;
window.AdminPanel.UI = AdminPanelUI;
window.AdminPanel.API = AdminPanelAPI;

// Link legacy globals to state manager for compatibility
Object.defineProperties(window, {
  currentStatus: {
    get: () => window.AdminPanel.stateManager.state.currentStatus,
    set: (v) => window.AdminPanel.stateManager.setState('currentStatus', v)
  },
  selectedSheet: {
    get: () => window.AdminPanel.stateManager.state.selectedSheet,
    set: (v) => window.AdminPanel.stateManager.setState('selectedSheet', v)
  }
});

// Initialization functions

// Simple logging utility with conditional output based on DEBUG mode
// DEBUG_MODE is defined in constants.js.html

const adminLog = (level, ...args) => {
  // Only show errors and critical warnings - disable verbose logging
  switch (level) {
    case 'error':
      console.error('[AdminPanel]', ...args);
      break;
    case 'warn':
      // Only show warnings in debug mode
      if (window.DEBUG_MODE) console.warn('[AdminPanel]', ...args);
      break;
    case 'info':
    case 'debug':
    default:
      // All info/debug logs disabled for performance
      return;
  }
};

// Convenience functions for different log levels
const logError = (...args) => adminLog('error', ...args);
const logWarn = (...args) => adminLog('warn', ...args);
const logInfo = (...args) => adminLog('info', ...args);
const logDebug = (...args) => adminLog('debug', ...args);

// =============================================================================
// USER AUTHENTICATION INITIALIZATION
// =============================================================================

// マルチテナント対応: ユーザーIDの安全な初期化
let userId = '';

// マルチテナント対応: バックエンドから安全にユーザーIDを取得
const initializeUserId = () => {
  console.group('🔐 Initializing UserId');
  logDebug('📞 About to call getCurrentUserStatus');
  
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler((response) => {
        logDebug('📥 getCurrentUserStatus response:', response);
        
        if (response && response.status === 'success' && response.userInfo && response.userInfo.userId) {
          userId = response.userInfo.userId;
          logDebug('✅ AdminPanel: User authenticated, userId:', userId);
          console.groupEnd();
          resolve(userId);
        } else {
          console.error('❌ Failed to get userId from backend:', response);
          console.error('❌ Expected: {status: "success", userInfo: {userId: "..."}}');
          console.groupEnd();
          reject(new Error('ユーザーIDの取得に失敗しました'));
        }
      })
      .withFailureHandler((error) => {
        console.error('❌ Backend error getting userId:', error);
        console.error('❌ Error type:', typeof error);
        console.error('❌ Error details:', error);
        console.groupEnd();
        reject(error);
      })
      .getCurrentUserStatus();
  });
}

// リトライ付きユーザーID取得
const initializeUserIdWithRetry = async (maxRetries = 3, delay = 1000) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await initializeUserId();
    } catch (error) {
      console.warn(`⚠️ UserId initialization failed (attempt ${i + 1}/${maxRetries}):`, error.message);
      if (i < maxRetries - 1) {
        console.log(`🔄 Retrying in ${delay}ms...`);
        await new Promise((resolve) => { setTimeout(resolve, delay); });
        delay = Math.min(delay * 1.5, 5000); // 指数バックオフ（最大5秒）
      } else {
        logError(error, 'All userId initialization attempts failed');
        throw error;
      }
    }
  }
};

// ユーザーID取得の完了を待つPromise（リトライ機構付き）
const userIdPromise = initializeUserIdWithRetry();

// =============================================================================
// CORE INITIALIZATION FUNCTIONS
// =============================================================================

// Layout adjustment for responsive design
const adjustLayout = () => {
  const isMobile = window.innerWidth < 768;
  const body = document.body;
  
  if (isMobile) {
    body.classList.add('mobile-layout');
    body.classList.remove('desktop-layout');
  } else {
    body.classList.add('desktop-layout');
    body.classList.remove('mobile-layout');
  }
};

// Initialize core functionality
const initCore = () => {
  adjustLayout();
};

// Initialize message area
const initializeMessageArea = () => {
  let messageArea = document.getElementById('message-area');
  if (!messageArea) {
    // Create message area if it doesn't exist
    messageArea = document.createElement('div');
    messageArea.id = 'message-area';
    messageArea.className = 'fixed top-32 right-4 z-50 max-w-sm';
    document.body.appendChild(messageArea);
  }
};

// Initialize UI components
const initializeUI = () => {
  // UI初期化のみ実行、loadStatusは adminPanel-api.js で処理される
};

// Initialize API functionality
const initializeAPI = () => {
  logDebug('🔧 API初期化開始');
  
  // Start background status updates with safe calling
  if (checkFunctionAvailability('startSystemStatusUpdate')) {
    safeCallFunction('startSystemStatusUpdate');
  } else {
    console.warn('⚠️ startSystemStatusUpdate not available - background updates disabled');
  }
  
  // Setup user activity tracking
  document.addEventListener('click', updateUserActivity);
  document.addEventListener('keypress', updateUserActivity);
  document.addEventListener('scroll', updateUserActivity);

  // 初期化時のステータスロード - タイミング調整版
  logDebug('🚀 初期化時loadStatus(true)呼び出し（遅延あり）');
  setTimeout(() => {
    if (checkFunctionAvailability('loadStatus')) {
      window.loadStatus(true);
    } else {
      console.warn('⚠️ loadStatus not available');
    }
  }, 500); // 500ms遅延でより安全な初期化
  
  logDebug('✅ API初期化完了');
};

// Update user activity timestamp for polling optimization
const updateUserActivity = () => {
  if (typeof lastUserActivity !== 'undefined') {
    lastUserActivity = Date.now();
  }
};

// Initialize event listeners
const initializeEventListeners = () => {
  
  // Use safe function calling with availability checks
  if (checkFunctionAvailability('setupEventListeners')) {
    safeCallFunction('setupEventListeners');
  } else {
    console.warn('⚠️ setupEventListeners function not available, attempting graceful degradation');
    
    // Basic fallback event listener setup
    if (checkFunctionAvailability('setupRealtimeValidation')) {
      safeCallFunction('setupRealtimeValidation');
    } else {
      console.warn('⚠️ setupRealtimeValidation not available - real-time validation disabled');
    }
  }
};

// Setup character counters
const setupCharacterCounters = () => {
  const questionTextarea = document.getElementById('custom-main-question');
  const questionCounter = document.getElementById('question-counter');

  if (questionTextarea && questionCounter) {
    questionTextarea.addEventListener('input', function() {
      const count = this.value.length;
      questionCounter.textContent = `${count}/500`;
      questionCounter.className = count > 450 ? 'text-xs text-red-400' : 'text-xs text-gray-500';
    });
  }
};

// Setup modal character counter observers
const setupModalCharacterCounters = () => {
  // モーダルが表示されるたびにカウンターをセットアップ
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
        const modal = document.getElementById('form-config-modal');
        if (modal && !modal.classList.contains('hidden')) {
          setTimeout(setupCharacterCounters, 100);
        }
      }
    });
  });
  
  // モーダルの監視を開始
  const modal = document.getElementById('form-config-modal');
  if (modal) {
    observer.observe(modal, { attributes: true });
  }
};

// Navigate to specific step in admin panel
const navigateToStep = (step) => {
  if (typeof currentStep !== 'undefined') {
    currentStep = step;
  } else {
    // Define currentStep if not already defined
    window.currentStep = step;
  }
  
  // Update step indicators
  document.querySelectorAll('.step-indicator').forEach((indicator, index) => {
    const stepNumber = index + 1;
    indicator.classList.toggle('completed', stepNumber < step);
    indicator.classList.toggle('active', stepNumber === step);
  });
  
  // Show/hide step content
  document.querySelectorAll('.step-content').forEach((content, index) => {
    const stepNumber = index + 1;
    content.classList.toggle('hidden', stepNumber !== step);
  });
  
  // Update progress bar
  const progressBar = document.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.width = `${(step / 3) * 100}%`;
  }
  
  if (typeof validateCurrentStep === 'function') {
    validateCurrentStep();
  }
};

// Make navigateToStep globally available
window.navigateToStep = navigateToStep;

// Initialize main admin panel
function initializeAdminPanel(incomingUserId) {
  // userId is now managed globally by adminPanel-core.js
  if (typeof loadUserInfo === 'function') loadUserInfo();
  if (typeof loadSystemStatus === 'function') loadSystemStatus();
  if (typeof setupEventListeners === 'function') setupEventListeners();
  if (typeof setupRealtimeUpdates === 'function') setupRealtimeUpdates();
  if (typeof validateCurrentStep === 'function') validateCurrentStep();
}

// Make initializeAdminPanel globally available
window.initializeAdminPanel = initializeAdminPanel;

// Critical UI functions

// Toggle section visibility
// Legacy global function - redirects to class method
const toggleSection = (sectionId) => window.AdminPanel.UI.toggleSection(sectionId);

// Hide privacy modal
const hidePrivacyModal = () => {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('privacy-modal', false);
    }
  }
};

// Show form configuration modal
// Legacy global function - redirects to class method with enhanced functionality
const showFormConfigModal = () => {
  window.AdminPanel.UI.showFormConfigModal();
  // Additional legacy functionality
  if (typeof loadSavedClassChoices === 'function') {
    loadSavedClassChoices();
  }
  if (typeof manageFocusForModal === 'function') {
    manageFocusForModal('form-config-modal', true);
  }
};

// Enhanced updateUIWithNewStatus that works with both minimal and full implementations
function updateUIWithNewStatus(status) {
  if (!status) {
    console.warn('updateUIWithNewStatus: Invalid status received');
    return;
  }
  
  // Store for later use
  window.currentStatus = status;
  
  // Enhanced full implementation detection with multiple retries
  if (typeof window._fullUpdateUIWithNewStatus === 'function') {
    try {
      // 本番環境でのログ量を減らす
      if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
        console.log('updateUIWithNewStatus: Using full implementation');
      }
      return window._fullUpdateUIWithNewStatus(status);
    } catch (error) {
      console.warn('Full updateUIWithNewStatus failed, using fallback:', error);
      // Continue with minimal implementation below
    }
  } else {
    // Enhanced retry mechanism with multiple attempts
  const retryCount = 0;
  const maxRetries = 3;
  const retryDelays = [200, 500, 1000]; // Progressive delays
    
  const tryFullImplementation = function() {
      if (typeof window._fullUpdateUIWithNewStatus === 'function') {
        console.log(`updateUIWithNewStatus: Full implementation now available (retry ${retryCount + 1})`);
        try {
          window._fullUpdateUIWithNewStatus(status);
          return;
        } catch (error) {
          console.warn('Retried full updateUIWithNewStatus failed:', error);
        }
      }
      
      if (retryCount < maxRetries) {
        retryCount++;
        setTimeout(tryFullImplementation, retryDelays[retryCount - 1] || 1000);
      } else {
        console.log('updateUIWithNewStatus: Max retries exceeded, using minimal implementation only');
      }
    };
    
    // Start retry sequence
    setTimeout(tryFullImplementation, retryDelays[0]);
  }
  
  // Enhanced minimal implementation for comprehensive UI updates
  console.log('updateUIWithNewStatus: Using enhanced minimal implementation');
  
  // Update essential UI elements with comprehensive information
  try {
    // 1. Update publication status with indicators
    if (status._normalized && typeof status._normalized.isPublished !== 'undefined') {
  const publishStatus = status._normalized.isPublished ? '公開中' : '停止中';
  const publishElement = document.getElementById('info-publish-text');
      if (publishElement) {
        publishElement.textContent = publishStatus;
      }
      
      // Update publish indicator
  const indicatorElement = document.getElementById('info-publish-indicator');
  const statusElement = document.getElementById('info-publish-status');
      if (status._normalized.isPublished) {
        if (statusElement) statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
        if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      } else {
        if (statusElement) statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
        if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      }
    }
    
    // 2. Update user information section
    if (status.userInfo) {
  const adminEmailEl = document.getElementById('info-admin-email');
  const userIdEl = document.getElementById('info-user-id');
      
      if (adminEmailEl && status.userInfo.adminEmail) {
        adminEmailEl.textContent = status.userInfo.adminEmail;
      }
      if (userIdEl && status.userInfo.userId) {
        userIdEl.textContent = status.userInfo.userId;
      }
      
      // Update spreadsheet access
      if (status.userInfo.spreadsheetUrl) {
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn-step2');
        if (spreadsheetBtn) {
          spreadsheetBtn.disabled = false;
          spreadsheetBtn.onclick = function() { window.open(status.userInfo.spreadsheetUrl, '_blank'); };
        }
      }
    }
    
    // 3. Update configuration display
    if (status.config || (status.userInfo && status.userInfo.configJson)) {
  const config = status.config;
      if (!config && status.userInfo.configJson) {
        try {
          config = typeof status.userInfo.configJson === 'string' 
            ? JSON.parse(status.userInfo.configJson) 
            : status.userInfo.configJson;
        } catch (e) {
          console.warn('Failed to parse configJson in minimal implementation');
        }
      }
      
      if (config) {
        // Update published sheet name
  const publishedSheetEl = document.getElementById('info-published-sheet');
        if (publishedSheetEl) {
          publishedSheetEl.textContent = config.publishedSheetName || status.activeSheetName || 'なし';
        }
        
        // Update display mode
  const displayModeEl = document.getElementById('info-display-mode');
        if (displayModeEl) {
          displayModeEl.textContent = config.showNames ? '名前表示' : '匿名表示';
        }
        
        // Update show counts setting
  const showCountsEl = document.getElementById('info-show-counts');
        if (showCountsEl) {
          showCountsEl.textContent = config.showCounts ? '表示' : '非表示';
        }
      }
    }
    
    // 4. Update answer count if available
    if (status.answerCount !== undefined) {
  const answerCountElement = document.getElementById('answer-count');
      if (answerCountElement) {
        answerCountElement.textContent = status.answerCount || '0';
      }
    }
    
    // 5. Update active sheet information
    if (status.activeSheetName) {
  const sheetNameElements = document.querySelectorAll('.active-sheet-name');
      sheetNameElements.forEach(function(element) {
        element.textContent = status.activeSheetName;
      });
    }
    
    
  } catch (error) {
    console.error('Error in enhanced minimal updateUIWithNewStatus:', error);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('digital-citizenship-modal', false);
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    if (typeof manageFocusForModal === 'function') {
      manageFocusForModal('confirmation-modal', false);
    }
  }
}

// Unified showMessage function - uses SharedUtilities MessageManager
function showMessage(message, type = 'info', duration = 5000) {
  console.log(`[${type.toUpperCase()}] ${message}`);
  
  // Use SharedUtilities MessageManager if available
  if (window.sharedUtilities?.messages?.show) {
    return window.sharedUtilities.messages.show(message, type, duration);
  }
  
  // Fallback for cases where SharedUtilities is not loaded
  console.warn('⚠️ SharedUtilities MessageManager not available, using console fallback');
}

// =============================================================================
// VALIDATION FUNCTIONS - Moved from adminPanel-ui.js.html for early availability
// =============================================================================

// Validate configuration with fallback logic
function validateConfig() {
  // Try to use the full implementation if available
  if (typeof window._fullValidateConfig === 'function') {
    try {
      return window._fullValidateConfig();
    } catch (error) {
      console.warn('Full validateConfig failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential validation
  console.log('validateConfig: Using minimal implementation');
  
  try {
    // Check primary element first, then fallback to secondary element
  const opinionValueEl1 = document.getElementById('opinionHeader');
  const opinionValueEl2 = document.getElementById('reason-column');
  const opinionValue = (opinionValueEl1 && opinionValueEl1.value) || 
                        (opinionValueEl2 && opinionValueEl2.value) || '';
    
    return opinionValue && opinionValue.trim() !== '';
  } catch (error) {
    console.error('Error in minimal validateConfig:', error);
    return false;
  }
}

// Update configuration buttons state with fallback logic
function updateConfigButtons() {
  // Try to use the full implementation if available
  if (typeof window._fullUpdateConfigButtons === 'function') {
    try {
      return window._fullUpdateConfigButtons();
    } catch (error) {
      console.warn('Full updateConfigButtons failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential button updates
  console.log('updateConfigButtons: Using minimal implementation');
  
  try {
  const isValid = validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
    
    if (saveBtn) {
      saveBtn.disabled = !isValid;
      if (isValid) {
        saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      } else {
        saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
      }
    }
  } catch (error) {
    console.error('Error in minimal updateConfigButtons:', error);
  }
}

// =============================================================================
// FUNCTION AVAILABILITY MANAGEMENT
// =============================================================================

// Central function availability checker
function checkFunctionAvailability(functionName) {
  const isAvailable = typeof window[functionName] === 'function';
  if (!isAvailable) {
    console.warn(`⚠️ Function ${functionName} is not available`);
  }
  return isAvailable;
}

// Safe function caller with fallback handling
function safeCallFunction(functionName, ...args) {
  try {
    if (checkFunctionAvailability(functionName)) {
      return window[functionName](...args);
    } else {
      console.warn(`⚠️ Cannot call ${functionName} - function not available`);
      return null;
    }
  } catch (error) {
    console.error(`❌ Error calling ${functionName}:`, error);
    return null;
  }
}

// Enhanced function registry with full implementation tracking
window.AdminPanel.functionRegistry = {
  available: new Set(),
  pending: new Set(),
  fullImplementations: new Set(),
  
  register(functionName) {
    if (typeof window[functionName] === 'function') {
      this.available.add(functionName);
      this.pending.delete(functionName);
    } else {
      this.pending.add(functionName);
      console.warn('⚠️ Function pending: ' + functionName);
    }
  },
  
  registerFullImplementation(functionName) {
  const fullFuncName = '_full' + functionName.charAt(0).toUpperCase() + functionName.slice(1);
    if (typeof window[fullFuncName] === 'function') {
      this.fullImplementations.add(functionName);
      // Verbose implementation logging disabled for performance
    }
  },
  
  hasFullImplementation(functionName) {
  const fullFuncName = '_full' + functionName.charAt(0).toUpperCase() + functionName.slice(1);
    return typeof window[fullFuncName] === 'function';
  },
  
  isAvailable(functionName) {
    return this.available.has(functionName);
  },
  
  // Enhanced full implementation detection
  checkForFullImplementations() {
  const functionsToCheck = [
      'updateUIWithNewStatus', 'populateHeaderOptions', 'populateConfig', 
      'updateFormUrlDisplay', 'validateConfig', 'updateConfigButtons'
    ];
    
  const foundCount = 0;
  const self = this;
    functionsToCheck.forEach(function(funcName) {
      if (self.hasFullImplementation(funcName)) {
        self.registerFullImplementation(funcName);
        foundCount++;
      }
    });
    
    // 本番環境でのログ量を減らす
    if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
      console.log(`🔍 Full implementations check: ${foundCount}/${functionsToCheck.length} available`);
    }
    return foundCount;
  },
  
  waitFor(functionName, timeout = 5000) {
    return new Promise(function(resolve, reject) {
      if (this.isAvailable(functionName)) {
        resolve(window[functionName]);
        return;
      }
      
  const startTime = Date.now();
  const checkInterval = setInterval(function() {
        if (this.isAvailable(functionName)) {
          clearInterval(checkInterval);
          resolve(window[functionName]);
        } else if (Date.now() - startTime > timeout) {
          clearInterval(checkInterval);
          reject(new Error(`Function ${functionName} not available after ${timeout}ms`));
        }
      }, 100);
    });
  }
};

// =============================================================================
// ADDITIONAL UI FUNCTIONS - Critical functions that were missing
// =============================================================================

// Update form URL display (minimal implementation)
function updateFormUrlDisplay(status = null) {
  // Try to use the full implementation if available
  if (typeof window._fullUpdateFormUrlDisplay === 'function') {
    try {
      return window._fullUpdateFormUrlDisplay(status);
    } catch (error) {
      console.warn('Full updateFormUrlDisplay failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential form URL updates
  console.log('updateFormUrlDisplay: Using minimal implementation');
  
  try {
  const formUrlInput = document.getElementById('form-url-input');
    if (!formUrlInput) return;
    
  const currentStatusToUse = status || window.currentStatus;
    if (!currentStatusToUse || !currentStatusToUse.userInfo) {
      console.warn('⚠️ updateFormUrlDisplay: status情報が不足しています');
      return;
    }
    
    // Simple form URL extraction
  const formUrl = null;
    if (currentStatusToUse.userInfo.configJson) {
      try {
  const config = typeof currentStatusToUse.userInfo.configJson === 'string' 
          ? JSON.parse(currentStatusToUse.userInfo.configJson) 
          : currentStatusToUse.userInfo.configJson;
        formUrl = config.formUrl;
      } catch (e) {
        console.warn('Failed to parse configJson for form URL');
      }
    }
    
    if (formUrl) {
      formUrlInput.value = formUrl;
  const openFormLink = document.getElementById('open-form-url-link');
      if (openFormLink) {
        openFormLink.href = formUrl;
      }
    }
  } catch (error) {
    console.error('Error in minimal updateFormUrlDisplay:', error);
  }
}

// Populate header options (minimal implementation)
function populateHeaderOptions(headers) {
  // Try to use the full implementation if available
  if (typeof window._fullPopulateHeaderOptions === 'function') {
    try {
      return window._fullPopulateHeaderOptions(headers);
    } catch (error) {
      console.warn('Full populateHeaderOptions failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential header population
  console.log('populateHeaderOptions: Using minimal implementation');
  
  try {
    if (window.populateHeaderOptionsRunning) {
      return;
    }
    window.populateHeaderOptionsRunning = true;
    
  const selects = ['opinionHeader', 'reason-column', 'name-column', 'class-column'];
    
    selects.forEach(function(selectId) {
  const select = document.getElementById(selectId);
      if (select) {
  const currentValue = select.value;
        
        if (headers && headers.length > 0) {
          select.innerHTML = '<option value="">-- 列を選択 --</option>';
          headers.forEach(function(header) {
            if (header && typeof header === 'string' && header.trim()) {
  const option = document.createElement('option');
              option.value = header;
              option.textContent = header;
              select.appendChild(option);
            }
          });
          select.disabled = false;
          if (currentValue) {
            select.value = currentValue;
          }
        } else {
          select.innerHTML = '<option value="">-- シートを選択してください --</option>';
          select.disabled = true;
        }
      }
    });
    
    setTimeout(function() {
      window.populateHeaderOptionsRunning = false;
    }, 100);
  } catch (error) {
    console.error('Error in minimal populateHeaderOptions:', error);
    window.populateHeaderOptionsRunning = false;
  }
}

// Make all critical functions globally available immediately
window.toggleSection = toggleSection;
window.hidePrivacyModal = hidePrivacyModal;
window.hideDigitalCitizenshipModal = hideDigitalCitizenshipModal;
window.hideConfirmationModal = hideConfirmationModal;
window.showFormConfigModal = showFormConfigModal;
window.showMessage = showMessage; // Unified with SharedUtilities MessageManager
window.updateUIWithNewStatus = updateUIWithNewStatus;
window.validateConfig = validateConfig;
window.updateConfigButtons = updateConfigButtons;
// Populate configuration (minimal implementation)
function populateConfig(cfg) {
  // 履歴復元中はスキップ（ただし、ドラフトモードの場合は除く）
  if ((window._historyRestoreInProgress || window._historyColumnSelections) && !window._draftModeActive) {
    console.log('🛡️ populateConfig: 履歴復元中のため処理をスキップしました');
    return;
  }
  
  // ドラフトモード時のログ出力
  if (window._draftModeActive) {
    console.log('📝 populateConfig: ドラフトモードで設定を反映中');
  }
  
  // Try to use the full implementation if available
  if (typeof window._fullPopulateConfig === 'function') {
    try {
      return window._fullPopulateConfig(cfg);
    } catch (error) {
      console.warn('Full populateConfig failed, using fallback:', error);
    }
  }
  
  // Minimal implementation for essential config population
  console.log('populateConfig: Using minimal implementation');
  
  try {
    if (!cfg) return;
    
    if (window.populateConfigRunning) {
      return;
    }
    window.populateConfigRunning = true;
    
  const mappings = {
      'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
      'reason-column': cfg.reasonColumn || cfg.reasonHeader,
      'name-column': cfg.nameColumn || cfg.nameHeader,
      'class-column': cfg.classColumn || cfg.classHeader,
      'show-names': cfg.showNames,
      'show-counts': cfg.showCounts
    };
    
    Object.keys(mappings).forEach(function(elementId) {
  const element = document.getElementById(elementId);
  const value = mappings[elementId];
      
      if (element && value !== undefined) {
        if (element.type === 'checkbox') {
          element.checked = Boolean(value);
        } else {
          element.value = value;
        }
      }
    });
    
    setTimeout(function() {
      window.populateConfigRunning = false;
    }, 100);
  } catch (error) {
    console.error('Error in minimal populateConfig:', error);
    window.populateConfigRunning = false;
  }
}

window.updateFormUrlDisplay = updateFormUrlDisplay;
window.populateHeaderOptions = populateHeaderOptions;
window.populateConfig = populateConfig;
window.checkFunctionAvailability = checkFunctionAvailability;
window.safeCallFunction = safeCallFunction;

// Register all critical functions
  const criticalFunctions = [
  'toggleSection', 'hidePrivacyModal', 'hideDigitalCitizenshipModal', 
  'hideConfirmationModal', 'showFormConfigModal', 'showMessage', 
  'updateUIWithNewStatus', 'validateConfig', 'updateConfigButtons', 
  'updateFormUrlDisplay', 'populateHeaderOptions', 'populateConfig',
  'navigateToStep', 'initializeAdminPanel'
];

criticalFunctions.forEach(function(funcName) {
  window.AdminPanel.functionRegistry.register(funcName);
});

// Full implementation monitoring with periodic checks
  const fullImplCheckCount = 0;
  const maxFullImplChecks = 10;

function checkFullImplementationsAvailability() {
  fullImplCheckCount++;
  const foundCount = window.AdminPanel.functionRegistry.checkForFullImplementations();
  
  if (foundCount > 0) {
    console.log(`🎉 Found ${foundCount} full implementations on attempt ${fullImplCheckCount}`);
    
    // Force retry of UI updates with full implementations now available
    if (window.currentStatus && foundCount >= 3) {
      console.log('🔄 Retrying UI updates with full implementations');
      setTimeout(function() {
        if (typeof window._fullUpdateUIWithNewStatus === 'function') {
          window._fullUpdateUIWithNewStatus(window.currentStatus);
        }
      }, 100);
    }
  } else if (fullImplCheckCount < maxFullImplChecks) {
    // Continue checking for full implementations
    setTimeout(checkFullImplementationsAvailability, 500);
  } else {
    console.warn('⚠️ Full implementations not found after maximum attempts');
  }
}

// Start monitoring for full implementations after a delay
setTimeout(checkFullImplementationsAvailability, 300);

// =============================================================================
// SYSTEM STATUS AND USER INTERACTION MANAGEMENT
// =============================================================================

// システム監視用の状態管理
window.systemStatus = {
  initializationStarted: false,
  coreInitialized: false,
  apiInitialized: false,
  uiInitialized: false,
  eventsInitialized: false,
  initializationComplete: false,
  userDataSyncComplete: false,
  errors: [],
  lastActivity: Date.now()
};

// 初期化中のユーザー操作防止 - DOM準備完了後に実行
if (document.body) {
  document.body.style.pointerEvents = 'none';
  console.log('🛡️ User interaction disabled during initialization');
} else {
  // DOM読み込み完了を待ってから実行
  document.addEventListener('DOMContentLoaded', function() {
    if (document.body) {
      document.body.style.pointerEvents = 'none';
      console.log('🛡️ User interaction disabled during initialization (delayed)');
    }
  });
}

// 主要なUI要素を無効化する関数
function disableUserInteraction() {
  // DOM準備完了チェック
  if (!document || !document.body) {
    console.warn('⚠️ DOM not ready for disableUserInteraction');
    return;
  }
  
  // フォーム要素の無効化
  const forms = document.querySelectorAll('form, input, button, select, textarea');
  forms.forEach(function(element) {
    element.disabled = true;
    element.style.opacity = '0.6';
  });
  
  // クリック可能な要素の無効化
  const clickables = document.querySelectorAll('[onclick], .btn, .button');
  clickables.forEach(function(element) {
    element.style.pointerEvents = 'none';
    element.style.opacity = '0.6';
  });
  
  // body要素の無効化
  document.body.style.pointerEvents = 'none';
  
  console.log('🛡️ All interactive elements disabled');
}

// UI要素を有効化する関数
function enableUserInteraction() {
  // DOM準備完了チェック
  if (!document || !document.body) {
    console.warn('⚠️ DOM not ready for enableUserInteraction');
    return;
  }
  
  // フォーム要素の有効化
  const forms = document.querySelectorAll('form, input, button, select, textarea');
  forms.forEach(function(element) {
    element.disabled = false;
    element.style.opacity = '';
  });
  
  // クリック可能な要素の有効化
  const clickables = document.querySelectorAll('[onclick], .btn, .button');
  clickables.forEach(function(element) {
    element.style.pointerEvents = '';
    element.style.opacity = '';
  });
  
  // body要素も有効化
  document.body.style.pointerEvents = 'auto';
  
  console.log('✅ All interactive elements enabled');
}

// DOM読み込み後に要素を無効化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', disableUserInteraction);
} else {
  disableUserInteraction();
}

function updateSystemStatus(component, status, error = null) {
  window.systemStatus[component] = status;
  window.systemStatus.lastActivity = Date.now();
  if (error) {
    window.systemStatus.errors.push({ component, error: error.toString(), timestamp: Date.now() });
  }
  logDebug(`📊 System Status: ${component} = ${status}`);
}

// 公開停止後の全セクション展開処理
function checkAndExpandAllSections() {
  try {
  const expandAllFlag = localStorage.getItem('expandAllSections');
    if (expandAllFlag === 'true') {
      logInfo('📂 公開停止後のため全セクションを展開します');
      
      // 少し遅延してからセクションを展開（DOM要素の準備を待つ）
      setTimeout(function() {
  const sectionIds = ['step1-content', 'step2-content', 'step3-content'];
  const expandedCount = 0;
        
        sectionIds.forEach(function(sectionId) {
  const section = document.getElementById(sectionId);
          if (section) {
            // セクションが折りたたまれている場合のみ展開
            if (section.classList.contains('hidden')) {
              if (typeof toggleSection === 'function') {
                toggleSection(sectionId);
                expandedCount++;
                logDebug('✅ セクション展開: ' + sectionId);
              }
            }
          }
        });
        
        if (expandedCount > 0) {
          logInfo('📂 ' + expandedCount + '個のセクションを展開しました');
        }
        
        // フラグをクリア（一度だけ実行）
        localStorage.removeItem('expandAllSections');
        logDebug('🧹 全セクション展開フラグをクリアしました');
      }, 500);
    }
  } catch (error) {
    logWarn('⚠️ 全セクション展開処理でエラー:', error);
  }
}

// =============================================================================
// MASTER INITIALIZATION SYSTEM
// =============================================================================

function initializeAdminPanelMaster() {
  // シンプル化: 重複初期化チェックを簡素化
  if (window.AdminPanel.initialization.isCompleted) {
    logDebug('✅ AdminPanel already initialized');
    return;
  }
  
  window.AdminPanel.initialization.isInProgress = true;
  logInfo('🚀 AdminPanel Master Initialization Started');
  
  // Phase 1: Core初期化
  try {
    initCore();
  } catch (error) {
    console.error('❌ Core initialization failed:', error);
  }
  
  // 公開停止後の全セクション展開処理
  checkAndExpandAllSections();
  
  // フォーム作成完了表示をクリア（新規アクセス時はデフォルトで非表示）
  setTimeout(function() {
  const formJustCreated = sessionStorage.getItem('form_just_created');
    if (formJustCreated !== 'true') {
      // 新規作成ではない場合、セクションを非表示にする
  const formUrlSection = document.getElementById('form-url-section');
      if (formUrlSection && !formUrlSection.classList.contains('hidden')) {
        formUrlSection.classList.add('hidden');
        logDebug('📋 既存アクセス時はフォーム完了セクションを非表示');
      }
    }
  }, 100);
  
  // Phase 2: 各モジュールを並列初期化 (パフォーマンス向上)
  // 遅延を最小限に抑制して即座に初期化
  setTimeout(function() {
    logDebug('🔧 Phase 2: 並列モジュール初期化開始');
    
    // Status管理初期化
    try {
      initializeMessageArea();
      logDebug('✅ Status module initialized');
    } catch (error) {
      logError('❌ Status module initialization failed:', error);
    }
    
    // API通信初期化
    try {
      logDebug('🚀 API module initialization...');
      initializeAPI();
      logDebug('✅ API module initialized');
    } catch (error) {
      console.error('❌ API initialization failed:', error);
    }
    
    // UI初期化
    try {
      initializeUI();
      logDebug('✅ UI module initialized');
    } catch (error) {
      console.error('❌ UI initialization failed:', error);
    }
    
    // フォーム管理初期化
    try {
      setupCharacterCounters();
      setupModalCharacterCounters();
      logDebug('✅ Forms module initialized');
    } catch (error) {
      logError('❌ Forms module initialization failed:', error);
    }
    
    // イベント管理初期化（最後に実行）
    setTimeout(function() {
      try {
        initializeEventListeners();
        logDebug('✅ Events module initialized');
        logInfo('🎉 AdminPanel Master Initialization Complete');
        
        // ユーザー情報の同期と最終処理
        finalizeInitialization();
        
      } catch (error) {
        updateSystemStatus('eventsInitialized', false, error);
        console.error('❌ Events initialization failed:', error);
        
        // エラーでも最終処理は実行
        finalizeInitialization();
      }
    }, 100);
    
  }, 10);
}

// Finalize initialization and enable user interaction
async function finalizeInitialization() {
  setTimeout(function() {
    try {
      console.log('🔄 Final initialization steps...');
      
      // すべての同期が完了したらローディングオーバーレイを非表示
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      } else {
        // フォールバック: 直接DOM操作
  const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('hidden');
        }
      }
      
      // UI要素の有効化
      enableUserInteraction();
      
      // Initialize and load history table after all initialization is complete
      try {
        console.log('🔄 Initializing HistoryManager...');
        if (window.HistoryManager) {
          window.HistoryManager.initialize();
          console.log('🔄 Loading history table after initialization...');
          window.HistoryManager.renderTable();
        } else {
          console.warn('⚠️ HistoryManager not available yet');
        }
      } catch (historyError) {
        console.warn('⚠️ History initialization/loading failed:', historyError);
      }
      
      // Draft recovery after initialization complete
      try {
        console.log('🔄 Checking for draft recovery...');
        if (typeof recoverDraftIfAvailable === 'function') {
          recoverDraftIfAvailable();
        }
      } catch (draftError) {
        console.warn('⚠️ Draft recovery failed:', draftError);
      }
      
      // 追加の初期化タスク
      // アプリ設定ボタンのイベントリスナー追加
      const appSetupBtn = document.getElementById('app-setup-btn');
      if (appSetupBtn && typeof openAppSetupPage === 'function') {
        appSetupBtn.addEventListener('click', function(e) {
          e.preventDefault();
          openAppSetupPage();
        });
      }
      if (window.sharedModals) {
        window.sharedModals.loadAdminModals();
      }
      // 履歴テーブル更新
      setTimeout(() => {
        if (typeof updateHistoryTable === 'function') updateHistoryTable();
      }, 100);
      
      // 初期化完了
      window.AdminPanel.initialization.isInProgress = false;
      window.AdminPanel.initialization.isCompleted = true;
      logInfo('✅ AdminPanel Master Initialization Completed');
      
    } catch (error) {
      console.error('❌ Final sync error:', error);
      // エラーでもローディングは解除
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      }
      enableUserInteraction();
      
      // 初期化完了（エラーありでも）
      window.AdminPanel.initialization.isInProgress = false;
      window.AdminPanel.initialization.isCompleted = true;
      logWarn('⚠️ AdminPanel initialization completed with errors');
    }
  }, 500);
}

// 単一DOMContentLoadedハンドラー
if (document.readyState !== 'loading') {
  initializeAdminPanelMaster();
} else {
  document.addEventListener('DOMContentLoaded', initializeAdminPanelMaster);
}

// Update layout on resize
window.addEventListener('resize', function() {
  if (typeof debounce === 'function') {
    debounce(adjustLayout, 250, 'layout-resize')();
  } else {
    // Fallback without debounce
    adjustLayout();
  }
});

// Individual user access control is now handled in AppSetupPage.html

// History management system

/**
 * Unified History Manager - Simple, Error-Resilient, Single Responsibility
 */
window.HistoryManager = {
  // Constants
  STORAGE_KEY: 'answerBoardHistory',
  OLD_STORAGE_KEY: 'adminPanelHistory', // For migration
  MAX_ITEMS: 5,
  
  // Initialization state
  _initialized: false,
  
  /**
   * Initialize the History Manager
   */
  initialize() {
    try {
      if (this._initialized) {
        console.log('🔄 HistoryManager already initialized');
        return true;
      }
      
      console.log('🚀 HistoryManager initializing...');
      
      // Migrate old data if exists
      this._migrateOldData();
      
      this._initialized = true;
      return true;
      
    } catch (error) {
      console.error('❌ HistoryManager initialization failed:', error);
      return false;
    }
  },
  
  /**
   * Migrate data from old storage key to new key
   */
  _migrateOldData() {
    try {
  const oldData = localStorage.getItem(this.OLD_STORAGE_KEY);
  const newData = localStorage.getItem(this.STORAGE_KEY);
      
      if (oldData && !newData) {
        console.log('🔄 Migrating history data from old key...');
        localStorage.setItem(this.STORAGE_KEY, oldData);
        localStorage.removeItem(this.OLD_STORAGE_KEY);
      }
    } catch (error) {
      console.warn('⚠️ History data migration failed:', error);
    }
  },
  
  /**
   * Load history from localStorage with error handling
   */
  load() {
    try {
      console.log('🔄 Loading history from localStorage...');
  const data = localStorage.getItem(this.STORAGE_KEY);
  const parsed = data ? JSON.parse(data) : [];
  const validated = Array.isArray(parsed) ? parsed : [];
      console.log('✅ Loaded ' + validated.length + ' history items');
      return validated;
    } catch (error) {
      console.error('❌ Failed to load history:', error);
      return [];
    }
  },
  
  /**
   * Save history to localStorage with error handling
   */
  save(items) {
    try {
  const safeItems = Array.isArray(items) ? items : [];
  const limitedItems = safeItems.slice(0, this.MAX_ITEMS);
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(limitedItems));
      console.log('✅ Saved ' + limitedItems.length + ' history items');
      return true;
    } catch (error) {
      console.error('❌ Failed to save history:', error);
      return false;
    }
  },
  
  /**
   * Add new item to history
   */
  add(newItem) {
    try {
      if (!newItem || !newItem.id) {
        console.warn('⚠️ Invalid history item provided');
        return false;
      }
      
  const history = this.load();
      history.unshift(newItem);
      return this.save(history);
    } catch (error) {
      console.error('❌ Failed to add history item:', error);
      return false;
    }
  },
  
  /**
   * Clear all history
   */
  clear() {
    try {
      localStorage.removeItem(this.STORAGE_KEY);
      localStorage.removeItem(this.OLD_STORAGE_KEY); // Clean old key too
      return true;
    } catch (error) {
      console.error('❌ Failed to clear history:', error);
      return false;
    }
  },
  /**
   * Format date for created date column (日付のみ表示)
   */
  _formatCreatedDate(dateStr) {
    if (!dateStr) return '未設定';
    try {
  const date = new Date(dateStr);
      return date.toLocaleDateString('ja-JP', {
        month: '2-digit',
        day: '2-digit'
      }).replace(/\//g, '/');  // "08/12" 形式
    } catch {
      return dateStr;
    }
  },

  /**
   * Format date for published date column (年2桁省略 + 時間付き)
   */
  _formatPublishedDate(dateStr) {
    if (!dateStr) return '未設定';
    try {
  const date = new Date(dateStr);
      return date.toLocaleString('ja-JP', {
        year: '2-digit',  // 25年表示
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).replace(/\//g, '/');  // "25/08/12 08:45" 形式
    } catch {
      return dateStr;
    }
  },

  /**
   * Format settings display with icons and clear meanings (showNames/showCounts based)
   */
  _formatSettingsDisplay(item) {
    // showNamesベースの判定（下位互換性も考慮）
  const isShowNames = false;
    if (item.showNames !== undefined) {
      isShowNames = item.showNames;
    } else if (item.displayMode !== undefined) {
      // 旧データ対応
      isShowNames = item.displayMode === 'named';
    }
    
  const displayPart = isShowNames ? '👥通常' : '🎭匿名';
  const countPart = item.showCounts ? '🔢表示' : '🚫非表示';
    return displayPart + '/' + countPart;
  },

  /**
   * Render history table in the UI
   */
  renderTable() {
    try {
      if (!this._initialized) {
        console.warn('⚠️ HistoryManager not initialized, initializing now...');
        if (!this.initialize()) {
          console.error('❌ Cannot render table - initialization failed');
          return false;
        }
      }
      
      console.log('🔄 Rendering history table...');
  const tableBody = document.getElementById('history-table-body');
      
      if (!tableBody) {
        console.warn('❌ History table body element not found');
        return false;
      }
      
      // Show loading state
      tableBody.innerHTML = `
        <tr>
          <td colspan="4" class="px-3 py-6 text-center text-gray-500 text-sm">
            <div class="flex flex-col items-center justify-center">
              <div class="spinner mb-3"></div>
              <div>履歴を読み込み中...</div>
            </div>
          </td>
        </tr>
      `;
      
      // Load and display history
  const history = this.load();
      tableBody.innerHTML = '';
      
      if (history.length === 0) {
        this._renderEmptyState(tableBody);
        return true;
      }
      
      // Render history items
  const successCount = 0;
      history.forEach(function(item, index) {
        try {
  const row = this._createHistoryTableRow(item, index);
          if (row) {
            tableBody.appendChild(row);
            successCount++;
          }
        } catch (error) {
          console.warn('⚠️ Failed to render history item:', error);
        }
      });
      
      return true;
      
    } catch (error) {
      console.error('❌ Failed to render history table:', error);
      this._renderErrorState();
      return false;
    }
  },
  
  /**
   * Render empty state for history table
   */
  _renderEmptyState(tableBody) {
  const emptyRow = document.createElement('tr');
    emptyRow.innerHTML = `
      <td colspan="4" class="px-3 py-8 text-center text-gray-500 text-sm">
        <div class="flex flex-col items-center">
          <div class="text-4xl mb-2">📝</div>
          <div class="font-medium mb-1">履歴がありません</div>
          <div class="text-xs text-gray-600">フォームを公開すると履歴が表示されます</div>
        </div>
      </td>
    `;
    tableBody.appendChild(emptyRow);
  },
  
  /**
   * Render error state for history table
   */
  _renderErrorState() {
  const tableBody = document.getElementById('history-table-body');
    if (tableBody) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="4" class="px-3 py-4 text-center text-red-500 text-sm">
            履歴の読み込みに失敗しました
          </td>
        </tr>
      `;
    }
  },
  
  /**
   * Create a table row for a history item
   */
  _createHistoryTableRow(item, index) {
    try {
  const row = document.createElement('tr');
      
      // 日付フォーマット（仕様に合わせて修正）
  const createdDate = this._formatCreatedDate(item.createdDate);      // "08/12"
  const publishedDate = this._formatPublishedDate(item.publishedAt);  // "25/08/12 08:45"
      
      // 問題文処理
  const question = this._escapeHtml(item.questionText || '未設定');
  const truncated = question.length > 30 ? question.substring(0, 30) + '...' : question;
      
      // 設定表示（アイコン/意味明確化）
  const settingsDisplay = this._formatSettingsDisplay(item);
      
      // 4列HTML生成
      row.innerHTML = `
        <td class="px-3 py-2 text-sm">${createdDate}</td>
        <td class="px-3 py-2 text-sm">${publishedDate}</td>
        <td class="px-3 py-2 text-sm" title="${question}">${truncated}</td>
        <td class="px-3 py-2 text-xs text-white">${settingsDisplay}</td>
      `;
      
      // 行クリック復元機能（確認モーダル付き）
      row.style.cursor = 'pointer';
      row.classList.add('hover:bg-gray-700', 'transition-colors');
      row.addEventListener('click', function() {
        this._showRestoreConfirmationModal(item);
      });
      
      return row;
    } catch (error) {
      console.error('❌ Failed to create history table row:', error);
      return null;
    }
  },
  
  /**
   * Show restore confirmation modal
   */
  showRestoreModal(itemId) {
    try {
  const history = this.load();
  const item = history.find(function(h) { return h.id === itemId; });
      
      if (!item) {
        console.error('❌ History item not found:', itemId);
        return;
      }
      
      if (typeof showMessage === 'function') {
        showMessage('🔄 設定を復元中...', 'info');
      }
      
      // Perform restoration
      this._restoreHistoryItem(item);
      
    } catch (error) {
      console.error('❌ Failed to show restore modal:', error);
    }
  },

  /**
   * Show restore confirmation modal before actually restoring
   */
  _showRestoreConfirmationModal(item) {
    try {
      // 重複実行防止
      if (this._isRestoreInProgress) {
        console.log('⚠️ Restore already in progress, ignoring duplicate request');
        return;
      }
      
      console.log('🔄 Showing restore confirmation modal for:', item.questionText);
      
      // 復元する設定の詳細情報を準備
  const formattedDate = this._formatCreatedDate(item.createdDate);
  const truncatedQuestion = item.questionText && item.questionText.length > 50 
        ? item.questionText.substring(0, 50) + '...' 
        : (item.questionText || '未設定');
      
      // 現在のスプレッドシート情報を取得
  const currentSpreadsheetId = window.currentStatus?.userInfo?.spreadsheetId || null;
  const targetSpreadsheetId = item.spreadsheetId || null;
  const hasSpreadsheetDifference = currentSpreadsheetId && targetSpreadsheetId && 
                                     currentSpreadsheetId !== targetSpreadsheetId;
      
      // 拡張されたモーダルHTMLを生成
      this._showEnhancedRestoreModal(item, {
        truncatedQuestion,
        formattedDate,
        hasSpreadsheetDifference,
        currentSpreadsheetId,
        targetSpreadsheetId
      });
      
    } catch (error) {
      console.error('❌ Failed to show restore confirmation modal:', error);
      // フォールバック: 元のシンプルモーダル
      this._showFallbackRestoreModal(item);
    }
  },

  /**
   * Show enhanced restore confirmation modal with detailed layout
   */
  _showEnhancedRestoreModal(item, details) {
  const modal = document.getElementById('confirmation-modal');
    if (!modal) {
      console.warn('⚠️ confirmation-modal not found, using fallback');
      this._showFallbackRestoreModal(item);
      return;
    }

    // カスタムHTMLコンテンツを生成
  const modalContent = this._generateRestoreModalHTML(item, details);
    
    // モーダルの内容を一時的に置き換え
  const glassPanel = modal.querySelector('.glass-panel');
  const originalContent = glassPanel.innerHTML;
    glassPanel.innerHTML = modalContent;
    
    // モーダルを表示
    modal.classList.remove('hidden');
    
    // イベントハンドラーを設定
  const confirmBtn = modal.querySelector('#restore-confirm-btn');
  const cancelBtn = modal.querySelector('#restore-cancel-btn');
    
  const cleanup = function() {
      // 元のコンテンツに戻す
      glassPanel.innerHTML = originalContent;
      modal.classList.add('hidden');
    };
    
    if (confirmBtn) {
      confirmBtn.onclick = function() {
        cleanup();
        console.log('✅ User confirmed restoration');
        this._restoreHistoryItem(item);
      };
    }
    
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        cleanup();
        console.log('❌ User cancelled restoration');
      };
    }
  },

  /**
   * Generate HTML content for enhanced restore modal
   */
  _generateRestoreModalHTML(item, details) {
  const truncatedQuestion = details.truncatedQuestion;
  const formattedDate = details.formattedDate;
  const hasSpreadsheetDifference = details.hasSpreadsheetDifference;
  const currentSpreadsheetId = details.currentSpreadsheetId;
  const targetSpreadsheetId = details.targetSpreadsheetId;
    
    // スプレッドシートIDをマスク表示用に変換
  const maskSpreadsheetId = function(id) {
      if (!id || id.length < 8) return id || '未設定';
      return '...' + id.slice(-6);
    };
    
  const spreadsheetDiffSection = hasSpreadsheetDifference ? `
      <div class="bg-yellow-500/10 border border-yellow-400/30 rounded-lg p-4 mb-4">
        <h4 class="text-sm font-semibold text-yellow-400 mb-2 flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4V2a1 1 0 011-1h4a1 1 0 011 1v2h4a1 1 0 011 1v1a1 1 0 01-1 1H3a1 1 0 01-1-1V5a1 1 0 011-1h4zM7 8v8a2 2 0 002 2h2a2 2 0 002-2V8M7 8H5a2 2 0 00-2 2v6a2 2 0 002 2h2M13 8h2a2 2 0 012 2v6a2 2 0 01-2 2h-2"></path>
          </svg>
          📁 スプレッドシート変更
        </h4>
        <div class="text-xs text-yellow-100 space-y-1">
          <div><span class="text-yellow-200 font-medium">現在:</span> ${maskSpreadsheetId(currentSpreadsheetId)}</div>
          <div><span class="text-yellow-200 font-medium">復元後:</span> ${maskSpreadsheetId(targetSpreadsheetId)}</div>
        </div>
      </div>
    ` : '';
    
    return `
      <h3 class="text-xl font-bold text-orange-400 mb-4 flex items-center gap-2">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        📋 履歴復元の確認
      </h3>
      <p class="text-gray-300 mb-4">
        以下の設定を復元しますか？現在の設定が上書きされます。
      </p>
      
      <!-- 復元予定の設定情報 -->
      <div class="bg-orange-500/10 border border-orange-400/30 rounded-lg p-4 mb-4">
        <h4 class="text-sm font-semibold text-orange-400 mb-3 flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
          </svg>
          📝 復元予定の設定
        </h4>
        <div class="space-y-2 text-xs text-orange-100">
          <div><span class="text-orange-200 font-medium">問題文:</span> ${truncatedQuestion}</div>
          <div><span class="text-orange-200 font-medium">シート名:</span> ${item.sheetName || '未設定'}</div>
          <div><span class="text-orange-200 font-medium">作成日:</span> ${formattedDate}</div>
        </div>
      </div>
      
      ${spreadsheetDiffSection}
      
      <!-- 警告メッセージ -->
      <div class="bg-red-500/10 border border-red-400/30 rounded-lg p-3 mb-6">
        <p class="text-xs text-red-200 flex items-center gap-2">
          <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
          </svg>
          この操作により現在の未保存の設定内容が変更されます。
        </p>
      </div>
      
      <div class="flex justify-end gap-3">
        <button type="button" id="restore-cancel-btn" class="btn btn-secondary">キャンセル</button>
        <button type="button" id="restore-confirm-btn" class="btn btn-primary">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
          </svg>
          復元する
        </button>
      </div>
    `;
  },

  /**
   * Fallback restore modal for compatibility
   */
  _showFallbackRestoreModal(item) {
  const formattedDate = this._formatCreatedDate(item.createdDate);
  const truncatedQuestion = item.questionText && item.questionText.length > 50 
      ? item.questionText.substring(0, 50) + '...' 
      : (item.questionText || '未設定');
    
  const title = '履歴復元の確認';
  const message = `以下の設定を復元しますか？現在の設定が上書きされます。

📝 問題文: ${truncatedQuestion}
📊 シート名: ${item.sheetName || '未設定'}  
📅 作成日: ${formattedDate}

⚠️ この操作により現在の設定内容が変更されます。`;

    // SharedModalsシステムを優先的に使用
    if (window.sharedModals && typeof window.sharedModals.showConfirmation === 'function') {
      console.log('✅ Using sharedModals.showConfirmation fallback');
      window.sharedModals.showConfirmation(
        title,
        message,
        function() {
          console.log('✅ User confirmed restoration');
          this._restoreHistoryItem(item);
        },
        function() {
          console.log('❌ User cancelled restoration');
        }
      );
    } else if (typeof showConfirmationModal === 'function') {
      console.log('✅ Using showConfirmationModal fallback');
      showConfirmationModal(
        title,
        message,
        function() {
          console.log('✅ User confirmed restoration');
          this._restoreHistoryItem(item);
        }
      );
    } else {
      console.warn('⚠️ No confirmation modal system available, using browser confirm');
      if (confirm(title + '\n\n' + message.replace(/📝|📊|📅|⚠️/g, ''))) {
        console.log('✅ User confirmed restoration via browser confirm');
        this._restoreHistoryItem(item);
      } else {
        console.log('❌ User cancelled restoration via browser confirm');
      }
    }
  },
  
  /**
   * Restore configuration from history item
   */
  async _restoreHistoryItem(item) {
    try {
      // 重複実行防止
      if (this._isRestoreInProgress) {
        console.log('⚠️ Restore already in progress, skipping duplicate request');
        return;
      }
      
      this._isRestoreInProgress = true;
      
      console.log('🔄 Restoring history:', item.questionText);
      console.log('📊 History item details:', {
        id: item.id,
        questionText: item.questionText,
        sheetName: item.sheetName,
        spreadsheetId: item.spreadsheetId,
        opinionHeader: item.opinionHeader,
        nameHeader: item.nameHeader
      });
      
      // AI列判定による上書きを防止するフラグを設定（ドラフトモード）
      window._historyRestoreInProgress = true;
      window._draftModeActive = true;
      console.log('🛡️ AI列判定スキップフラグを設定しました（ドラフトモード）');
      
      // 1. テキスト設定復元（実在する要素IDに修正）
      // 必須: 回答データ列（opinionHeader セレクト）
      (function restoreOpinionHeader() {
  const value = item.opinionHeader || item.opinionColumn || item.questionText || '';
  const opinionSelect = document.getElementById('opinionHeader');
        if (opinionSelect && value) {
          opinionSelect.value = value;
          console.log('✅ Opinion header restored: ' + value);
        }
      })();
      
      // 参考: 名前列は name-column セレクトを使用（name-header要素は存在しない）
      if (item.nameHeader) {
  const nameSelectEl = document.getElementById('name-column');
        if (nameSelectEl) nameSelectEl.value = item.nameHeader;
      }
      
      // 1.5. 列選択の復元（履歴データから）- 強化版
      console.log('🔄 Restoring column selections from history');
      
      // 復元する列選択データを準備し、保護用に保存
  const columnSelections = {
        opinionHeader: item.opinionHeader || item.opinionColumn || item.questionText || '',
        nameColumn: item.nameHeader || item.nameColumn || '',
        classColumn: item.classColumn || '',
        reasonHeader: item.reasonHeader || ''
      };
      
      // グローバルに保存してAI推定による上書きを防ぐ
      window._historyColumnSelections = columnSelections;
      
      // DOM要素への値設定を関数化して確実に実行
  const setSelectValue = function(elementId, value, description) {
        if (!value) return;
  const element = document.getElementById(elementId);
        if (element) {
          element.value = value;
          // change イベントを発火して、UIの更新をトリガー
          element.dispatchEvent(new Event('change', { bubbles: true }));
          console.log('✅ ' + description + ' restored: ' + value);
        } else {
          console.warn('⚠️ Element not found: ' + elementId);
        }
      };
      
      // 各列の復元を実行（ドラフトモードで）
      setSelectValue('opinionHeader', columnSelections.opinionHeader, 'Opinion header');
      setSelectValue('name-column', columnSelections.nameColumn, 'Name column');
      setSelectValue('class-column', columnSelections.classColumn, 'Class column');
      setSelectValue('reasonHeader', columnSelections.reasonHeader, 'Reason header');
      
      // 2. 名前表示設定復元（showNamesベース）
  const showNamesCheckbox = document.getElementById('show-names');
      if (showNamesCheckbox) {
        if (item.showNames !== undefined) {
          showNamesCheckbox.checked = item.showNames;
        } else if (item.displayMode !== undefined) {
          // 旧データ対応
          showNamesCheckbox.checked = (item.displayMode === 'named');
        }
      }
      
      // 3. リアクション数表示復元
  const showCountsCheckbox = document.getElementById('show-counts');
      if (showCountsCheckbox) {
        showCountsCheckbox.checked = (item.showCounts === true);
      }
      
      // 4. 完全プロジェクト復元（スプレッドシート + シート）
      console.log('🔍 Restore conditions check:', {
        hasSpreadsheetId: !!item.spreadsheetId,
        hasSheetName: !!item.sheetName,
        spreadsheetId: item.spreadsheetId,
        sheetName: item.sheetName
      });
      
      if (item.spreadsheetId && item.sheetName) {
        console.log('✅ Full project restore path selected');
        await this._restoreFullProject(item.spreadsheetId, item.sheetName);
      } else if (item.sheetName) {
        console.log('✅ Sheet-only restore path selected');
        // シートのみ復元
        await this._restoreSheetSelection(item.sheetName);
      } else {
        console.warn('⚠️ No valid restoration path found - missing sheet or spreadsheet info');
        console.warn('🔧 Attempting fallback: trying to find sheet by question text');
        
        // フォールバック: 問題文からシート名を推測
  const fallbackSheetName = await this._findSheetByQuestionText(item.questionText);
        if (fallbackSheetName) {
          console.log('✅ Fallback found sheet: ' + fallbackSheetName);
          await this._restoreSheetSelection(fallbackSheetName);
        } else {
          console.error('❌ Fallback failed: unable to determine correct sheet');
        }
      }
      
      // 5. UI完全更新
      await this._refreshAfterRestore();
      
      // 復元完了後に少し待ってからフラグをクリア（UI反映完了を待つ）
      await new Promise(function(resolve) { setTimeout(resolve, 500); });
      
      // Success message with specific details
      if (typeof showMessage === 'function') {
  const sheetInfo = item.sheetName ? 'シート「' + item.sheetName + '」' : '設定';
        showMessage('✅ 履歴から' + sheetInfo + 'を復元しました', 'success');
      }
      console.log('✅ Complete restore finished successfully');
      
    } catch (error) {
      console.error('❌ History restore failed:', error);
      
      // Enhanced error handling with rollback capability
  const errorMessage = '❌ 設定復元に失敗しました';
  const shouldAttemptRollback = false;
      
      if (error.message?.includes('Unable to parse range') || error.message?.includes('Invalid range')) {
        errorMessage = '❌ シート名の形式に問題があります。管理者にご連絡ください。';
      } else if (error.message?.includes('spreadsheet') || error.message?.includes('spreadsheetId')) {
        errorMessage = '❌ スプレッドシートへのアクセスに失敗しました。権限を確認してください。';
        shouldAttemptRollback = true;
      } else if (error.message?.includes('sheet') || error.message?.includes('sheetName')) {
        errorMessage = '❌ 指定されたシートが見つかりません。';
      } else if (error.message?.includes('verification failed')) {
        errorMessage = '❌ データベース更新の検証に失敗しました。しばらく待ってから再試行してください。';
        shouldAttemptRollback = true;
      }
      
      // Attempt rollback if appropriate
      if (shouldAttemptRollback) {
        try {
          console.log('🔄 Attempting rollback...');
          // Reload current status to restore previous state
          if (typeof loadStatus === 'function') {
            await loadStatus(true);
            console.log('✅ Rollback completed');
            errorMessage += ' 前の状態に復元しました。';
          }
        } catch (rollbackError) {
          console.warn('⚠️ Rollback failed:', rollbackError);
          errorMessage += ' 手動でページを再読み込みしてください。';
        }
      }
      
      if (typeof showMessage === 'function') {
        showMessage(errorMessage, 'error');
      }
      
      // Log technical details for debugging but don't show to user
      console.error('Technical details:', {
        itemId: item.id,
        sheetName: item.sheetName,
        spreadsheetId: item.spreadsheetId,
        errorMessage: error.message,
        errorStack: error.stack
      });
    } finally {
      // 遅延してフラグをクリア（UI更新が完全に完了するのを待つ）
      setTimeout(function() {
        // AI列判定スキップフラグをクリア
        if (window._historyRestoreInProgress) {
          window._historyRestoreInProgress = false;
          console.log('🛡️ AI列判定スキップフラグをクリアしました');
        }
        
        // 履歴列選択保護フラグもクリア
        if (window._historyColumnSelections) {
          window._historyColumnSelections = null;
          console.log('🛡️ 履歴列選択保護フラグをクリアしました');
        }
        
        // ドラフトモードでの設定反映を実行
        if (window._draftModeActive) {
          window.HistoryManager._applyDraftUIUpdates();
        }
      }, 1000); // 1秒後にクリア
      
      // 重複実行防止フラグをリセット
      this._isRestoreInProgress = false;
    }
  },

  /**
   * Find sheet by question text as fallback mechanism
   */
  async _findSheetByQuestionText(questionText) {
    try {
      console.log('🔍 Searching for sheet with question: "' + questionText + '"');
      
      // 現在のステータスから設定情報を取得
      if (window.AdminPanel?.currentStatus?.configJson) {
  const configJson = window.AdminPanel.currentStatus.configJson;
        
        // 各シート設定を確認
        for (const [key, sheetConfig] of Object.entries(configJson)) {
          if (key.startsWith('sheet_') && sheetConfig.opinionHeader) {
            if (sheetConfig.opinionHeader === questionText) {
  const sheetName = sheetConfig.sheetName || key.replace('sheet_', '');
              console.log('✅ Found matching sheet: ' + sheetName);
              return sheetName;
            }
          }
        }
      }
      
      console.warn('⚠️ No matching sheet found for question text');
      return null;
      
    } catch (error) {
      console.error('❌ Error in _findSheetByQuestionText:', error);
      return null;
    }
  },

  /**
   * Sanitize sheet name for safe API usage
   */
  _sanitizeSheetName(sheetName) {
    if (!sheetName) return '';
    
    // Remove potentially problematic characters but preserve most Unicode
    // Keep: letters, numbers, spaces, basic punctuation
  const sanitized = sheetName
      .replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF-]/g, '') // Keep alphanumeric, spaces, and Japanese characters
      .trim();
    
    return sanitized;
  },

  /**
   * Restore full project (spreadsheet + sheet) from history
   */
  async _restoreFullProject(spreadsheetId, sheetName) {
    try {
      // シート名をサニタイズ
  const sanitizedSheetName = this._sanitizeSheetName(sheetName);
      console.log('🔄 Restoring full project: ' + spreadsheetId + '/' + sheetName + ' (sanitized: ' + sanitizedSheetName + ')');
      
      // 現在のスプレッドシートIDを取得
  const getCurrentSpreadsheetId = function() {
        if (window.AdminPanel?.currentStatus?.userInfo?.spreadsheetId) {
          return window.AdminPanel.currentStatus.userInfo.spreadsheetId;
        }
        return null;
      };
      
  const currentSpreadsheetId = getCurrentSpreadsheetId();
      
      // 異なるスプレッドシートの場合のみ切り替え処理
      if (spreadsheetId !== currentSpreadsheetId) {
        console.log('🔄 Switching spreadsheet: ' + currentSpreadsheetId + ' → ' + spreadsheetId);
        
        // スプレッドシート切り替えの通知
        if (typeof showMessage === 'function') {
          showMessage('🔄 プロジェクトを切り替えています...', 'info', 3000);
        }
        
        // 実際のスプレッドシート切り替えを実行
        await this._performSpreadsheetSwitch(spreadsheetId);
        
        // スプレッドシート切り替え後の安定化待機
        console.log('⏳ Waiting for spreadsheet switch to stabilize...');
        await new Promise(function(resolve) { setTimeout(resolve, 1500); });
        
        // UI更新完了を待機してからシート選択復元
        console.log('🔄 Waiting for sheet options to include: ' + sanitizedSheetName);
  const sheetFound = await this._waitForSheetOptionsUpdate(sanitizedSheetName);
        if (!sheetFound) {
          console.warn('⚠️ Sheet ' + sanitizedSheetName + ' not found in options after waiting, proceeding with fallback');
        }
        
        // **CRITICAL**: Force correct the activeSheetName in loaded status
        console.log('🔧 Force correcting activeSheetName after spreadsheet switch');
        if (window.currentStatus) {
          window.currentStatus.activeSheetName = sanitizedSheetName;
        }
        if (window.AdminPanel?.currentStatus) {
          window.AdminPanel.currentStatus.activeSheetName = sanitizedSheetName;
        }
      }
      
      // シート選択復元と公開情報更新（サニタイズされた名前を使用）
      await this._restoreSheetSelection(sanitizedSheetName);
      
      // ドラフトモードでは公開シート情報を更新しない
      if (!window._draftModeActive) {
        console.log('🔄 公開シート情報を強制更新');
        await this._updatePublishedSheetInfo(sanitizedSheetName);
      } else {
        console.log('📝 ドラフトモード: 公開シート情報の更新をスキップ');
      }
      
      console.log(`✅ Full project restore completed`);
      
    } catch (error) {
      console.warn('⚠️ Full project restore failed:', error);
      if (typeof showMessage === 'function') {
        showMessage('⚠️ プロジェクト復元で問題が発生しました', 'warning');
      }
    }
  },

  /**
   * Restore sheet selection from history
   */
  async _restoreSheetSelection(sheetName) {
    try {
      // サニタイズされたシート名を使用
  const sanitizedSheetName = this._sanitizeSheetName(sheetName);
      console.log('🔄 Restoring sheet selection: "' + sheetName + '" (sanitized: "' + sanitizedSheetName + '")');
      
      // グローバル状態更新（サニタイズされた名前を使用）
      window.AdminPanel.selectedSheet = sanitizedSheetName;
      if (window.AdminPanel.stateManager) {
        window.AdminPanel.stateManager.setState('selectedSheet', sanitizedSheetName);  
      }
      
      // シート選択UI更新
  const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        // Find the option that matches either the original or sanitized name
  const options = Array.from(sheetSelect.options);
  const matchingOption = options.find(function(option) { 
          return option.value === sheetName || option.value === sanitizedSheetName;
        });
        
        if (matchingOption && sheetSelect.value !== matchingOption.value) {
          sheetSelect.value = matchingOption.value;
          sheetSelect.dispatchEvent(new Event('change'));
          
          // プルダウン表示の強制更新
          if (typeof updateSheetSelectActiveIndicator === 'function') {
            updateSheetSelectActiveIndicator(matchingOption.value);
          }
          
          console.log('✅ Sheet selection UI updated to: ' + matchingOption.value);
        } else if (!matchingOption) {
          console.warn('⚠️ Sheet "' + sheetName + '" not found in options. Available: ' + options.map(function(o) { return o.value; }).join(', '));
        }
      }
      
      console.log('✅ Sheet restored: ' + sanitizedSheetName);
    } catch (error) {
      console.warn('⚠️ Sheet restore warning:', error);
    }
  },

  /**
   * Refresh UI after history restore with enhanced error handling
   */
  async _refreshAfterRestore() {
  const refreshSteps = [
      { name: 'データ再読込', fn: function() { return typeof loadData === 'function' ? loadData() : Promise.resolve(); } }
      // 列判定更新は履歴復元時はスキップ（復元した設定値を保持するため）
    ];
    
    // Execute each step with individual error handling
    for (const step of refreshSteps) {
      try {
        console.log('🔄 Executing refresh step: ' + step.name);
        await step.fn();
        console.log('✅ ' + step.name + ' completed');
      } catch (error) {
        console.warn('⚠️ ' + step.name + ' failed, continuing with next step:', error);
        // Continue with other steps even if one fails
      }
    }
    
    // 履歴復元時は列選択を永続化（最小保存） - with enhanced retry logic
    if (window._historyRestoreInProgress) {
      try {
        // ヘッダー描画・選択反映完了を少し待ってから保存
        await new Promise(function(resolve) { setTimeout(resolve, 600); }); // Increased wait time
        
  const sheetName = (window.AdminPanel && window.AdminPanel.selectedSheet) || (document.getElementById('sheet-select')?.value) || '';
  const spreadsheetId = (window.currentStatus && window.currentStatus.userInfo && window.currentStatus.userInfo.spreadsheetId) || null;
        
        if (sheetName && spreadsheetId && typeof buildConfigObject === 'function' && typeof runGasWithUserId === 'function') {
  const config = buildConfigObject();
          console.log('🔄 Saving restored configuration for sheet: ' + sheetName);
          
          // Save sheet configuration with retry
          await this._saveConfigWithRetry(spreadsheetId, sheetName, config);
          
          // Activate sheet with retry
          await this._activateSheetWithRetry(spreadsheetId, sheetName);
          
        } else {
          console.warn('⚠️ 自動保存スキップ（必要情報不足）:', { 
            sheetName, 
            hasSpreadsheetId: !!spreadsheetId,
            hasBuildConfigObject: typeof buildConfigObject === 'function',
            hasRunGasWithUserId: typeof runGasWithUserId === 'function'
          });
        }
      } catch (autoSaveErr) {
        console.warn('⚠️ 自動保存処理で警告:', autoSaveErr?.message || autoSaveErr);
        // Show user-friendly message but don't block the restore process
        if (typeof showMessage === 'function') {
          showMessage('⚠️ 設定保存で問題が発生しましたが、復元は完了しました', 'warning');
        }
      }
    }

    console.log('✅ UI refresh completed');
  },

  /**
   * Save configuration with retry mechanism
   */
  async _saveConfigWithRetry(spreadsheetId, sheetName, config, maxRetries = 2) {
    for (let i = 0; i <= maxRetries; i++) {
      try {
        await runGasWithUserId('saveSheetConfig', '設定保存中...', spreadsheetId, sheetName, config);
        console.log('✅ Configuration saved successfully for sheet: ' + sheetName);
        return;
      } catch (error) {
        console.warn('❌ Save config attempt ' + (i + 1) + ' failed:', error);
        if (i === maxRetries) {
          throw error; // Re-throw on final attempt
        }
        await new Promise(function(resolve) { setTimeout(resolve, 1000 * (i + 1)); }); // Progressive delay
      }
    }
  },

  /**
   * Activate sheet with retry mechanism
   */
  async _activateSheetWithRetry(spreadsheetId, sheetName, maxRetries = 2) {
    for (let i = 0; i <= maxRetries; i++) {
      try {
        await runGasWithUserId('switchToSheet', false, spreadsheetId, sheetName);
        console.log('✅ Sheet activated successfully: ' + sheetName);
        return;
      } catch (error) {
        console.warn('❌ Activate sheet attempt ' + (i + 1) + ' failed:', error);
        if (i === maxRetries) {
          console.warn('⚠️ Failed to activate sheet after all retries, but continuing');
          return; // Don't throw for sheet activation failure
        }
        await new Promise(function(resolve) { setTimeout(resolve, 1000 * (i + 1)); }); // Progressive delay
      }
    }
  },

  /**
   * Perform actual spreadsheet switching
   */
  async _performSpreadsheetSwitch(targetSpreadsheetId) {
    try {
      // 1. Update user's active spreadsheet in database
      if (typeof runGasWithUserId === 'function') {
  const updateResult = await runGasWithUserId('updateUserAPI', false, {
          spreadsheetId: targetSpreadsheetId
        });
        
        if (updateResult && updateResult.status === 'success') {
          console.log('✅ Spreadsheet switched successfully in database');
        } else {
          throw new Error('Database update failed: ' + (updateResult?.message || 'Unknown error'));
        }
      } else {
        throw new Error('runGasWithUserId function not available');
      }

      // 2. Clear caches to force reload with new spreadsheet
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
        window.gasOptimizer.clearCache();
      }

      // 3. Reload application state with new spreadsheet
      if (typeof loadStatus === 'function') {
        await loadStatus(true); // Force reload bypassing cache
        // Application state reloaded - verbose logging disabled
        
        // 4. Force update currentSpreadsheetUrl after state reload
        if (window.currentStatus?.userInfo?.spreadsheetUrl) {
          currentSpreadsheetUrl = window.currentStatus.userInfo.spreadsheetUrl;
          console.log('✅ currentSpreadsheetUrl force updated after switch:', currentSpreadsheetUrl);
        } else {
          console.warn('⚠️ No spreadsheetUrl available in reloaded currentStatus');
        }
        
        // 5. **CRITICAL**: Verify spreadsheet consistency after loadStatus
        await this._verifySpreadsheetConsistency(targetSpreadsheetId);
        
      } else {
        console.warn('⚠️ loadStatus function not available for state reload');
      }

    } catch (error) {
      console.error('❌ Spreadsheet switching failed:', error);
      if (typeof showMessage === 'function') {
        showMessage('❌ プロジェクト切り替えに失敗しました: ' + error.message, 'error');
      }
      throw error; // Re-throw to be handled by caller
    }
  },

  /**
   * Verify spreadsheet consistency after restoration - ENHANCED
   * Ensures both client and server state are properly synchronized
   */
  async _verifySpreadsheetConsistency(targetSpreadsheetId) {
    try {
      console.log('🔍 Verifying spreadsheet consistency (enhanced):', {
        target: targetSpreadsheetId,
        checkingCurrentStatus: !!window.currentStatus?.userInfo
      });
      
      // Use current status first (already loaded via unified API)
  const currentSpreadsheetId = window.currentStatus?.userInfo?.spreadsheetId;
      
      if (currentSpreadsheetId !== targetSpreadsheetId) {
        console.warn('⚠️ Spreadsheet ID mismatch detected:', {
          expected: targetSpreadsheetId,
          actual: currentSpreadsheetId
        });
        
        // 統合的な不整合修正処理
        await this._correctSpreadsheetIdInconsistency(targetSpreadsheetId, currentSpreadsheetId);
      } else {
        console.log('✅ Spreadsheet consistency verified');
      }
      
    } catch (error) {
      console.warn('⚠️ Spreadsheet consistency verification failed:', error);
    }
  },

  /**
   * Wait for sheet options to be updated with target sheet
   */
  async _waitForSheetOptionsUpdate(targetSheetName, maxWaitTime = 3000) {
  const startTime = Date.now();
  const checkInterval = 100; // Check every 100ms
    
    return new Promise(function(resolve, reject) {
  const checkSheetOptions = function() {
  const select = document.getElementById('sheet-select');
        if (!select) {
          console.warn('⚠️ Sheet select element not found during wait');
          resolve(false);
          return;
        }
        
        // Check if target sheet is in options
  const options = Array.from(select.options);
  const hasTargetSheet = options.some(function(option) { return option.value === targetSheetName; });
        
        if (hasTargetSheet) {
          console.log('✅ Target sheet found in options: ' + targetSheetName);
          resolve(true);
          return;
        }
        
        // Check timeout
  const elapsed = Date.now() - startTime;
        if (elapsed >= maxWaitTime) {
          console.warn('⚠️ Timeout waiting for sheet options update (' + elapsed + 'ms). Available: ' + options.map(function(o) { return o.value; }).join(', '));
          resolve(false); // Don't reject, allow fallback
          return;
        }
        
        // Continue checking
        setTimeout(checkSheetOptions, checkInterval);
      };
      
      // Start checking
      checkSheetOptions();
    });
  },
  
  /**
   * Generate unique history ID
   */
  generateId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  },
  
  /**
   * HTML escape utility
   */
  /**
   * Update published sheet information after restore
   */
  async _updatePublishedSheetInfo(sheetName) {
    try {
      console.log('🔄 Updating published sheet info to: ' + sheetName);
      
      // サーバーサイドで公開シート情報を更新
      if (typeof runGasWithUserId === 'function') {
  const response = await runGasWithUserId('activateSheetSimple', false, sheetName);
        if (response && response.status === 'success') {
          console.log('✅ Published sheet info updated on server: ' + sheetName);
        }
      }
      
      // クライアントサイドの状態も更新
      if (window.AdminPanel?.currentStatus) {
        window.AdminPanel.currentStatus.publishedSheetName = sheetName;
        window.AdminPanel.currentStatus.activeSheetName = sheetName;
        
        // config オブジェクトが存在しない場合は作成
        if (!window.AdminPanel.currentStatus.config) {
          window.AdminPanel.currentStatus.config = {};
        }
        window.AdminPanel.currentStatus.config.publishedSheetName = sheetName;
      }
      
      // UI表示を更新（エラーハンドリング付き） - statusオブジェクトを適切に渡す
      if (typeof updateTopicText === 'function') {
        try {
          // より適切なstatusオブジェクトを取得
  const statusForUpdate = window.currentStatus || window.AdminPanel?.currentStatus;
          if (statusForUpdate) {
            updateTopicText(statusForUpdate);
          } else {
            console.warn('⚠️ No valid status object available for updateTopicText');
          }
        } catch (error) {
          console.warn('⚠️ updateTopicText failed during published sheet info update:', error);
        }
      }
      
    } catch (error) {
      console.warn('⚠️ Failed to update published sheet info:', error);
    }
  },

  /**
   * ドラフトモードでのUI更新を適用
   */
  _applyDraftUIUpdates() {
    try {
      console.log('📝 ドラフトモードでのUI更新を適用中...');
      
      // 履歴復元の保護フラグを一時的に無効化してUI更新を実行
  const originalRestoreFlag = window._historyRestoreInProgress;
  const originalColumnSelections = window._historyColumnSelections;
      
      window._historyRestoreInProgress = false;
      window._historyColumnSelections = null;
      
      // 現在のフォーム値を読み取って設定オブジェクトを構築
  const currentConfig = this._getDraftConfiguration();
      
      // populateConfigを呼び出してUI更新
      if (typeof window._fullPopulateConfig === 'function') {
        window._fullPopulateConfig(currentConfig);
      } else if (typeof window.populateConfig === 'function') {
        window.populateConfig(currentConfig);
      }
      
      // ドラフト状態の視覚的インジケーターを表示
      this._showDraftModeIndicator();
      
      // ドラフト状態をUIボタンに反映
      this._updateDraftModeUI();
      
      // フラグを元に戻す
      window._historyRestoreInProgress = originalRestoreFlag;
      window._historyColumnSelections = originalColumnSelections;
      
      console.log('✅ ドラフトモードでのUI更新が完了しました');
      
    } catch (error) {
      console.error('❌ ドラフトモードUI更新エラー:', error);
    }
  },
  
  /**
   * 現在のドラフト設定を取得
   */
  _getDraftConfiguration() {
  const config = {};
    
    // 各フォーム要素から現在の値を取得
  const opinionHeaderEl = document.getElementById('opinionHeader');
    if (opinionHeaderEl) config.opinionHeader = opinionHeaderEl.value;
    
  const nameColumnEl = document.getElementById('name-column');
    if (nameColumnEl) config.nameColumn = nameColumnEl.value;
    
  const classColumnEl = document.getElementById('class-column');
    if (classColumnEl) config.classColumn = classColumnEl.value;
    
  const reasonHeaderEl = document.getElementById('reasonHeader');
    if (reasonHeaderEl) config.reasonHeader = reasonHeaderEl.value;
    
  const showNamesEl = document.getElementById('show-names');
    if (showNamesEl) config.showNames = showNamesEl.checked;
    
  const showCountsEl = document.getElementById('show-counts');
    if (showCountsEl) config.showCounts = showCountsEl.checked;
    
    return config;
  },
  
  /**
   * 統合されたドラフトモード状態インジケーターの表示
   */
  _showDraftModeIndicator() {
  const indicatorSection = document.getElementById('draft-mode-indicator-section');
    if (indicatorSection) {
      indicatorSection.classList.remove('hidden');
      console.log('✅ 統合ドラフトインジケーターを表示しました');
    }
    
    // ドラフト機能ヘルプも表示
  const helpSection = document.getElementById('draft-help-section');
    if (helpSection) {
      helpSection.classList.remove('hidden');
      console.log('💡 ドラフトヘルプセクションを表示しました');
    }
  },
  
  /**
   * ドラフトモード状態インジケーターの非表示
   */
  _hideDraftModeIndicator() {
  const indicatorSection = document.getElementById('draft-mode-indicator-section');
    if (indicatorSection) {
      indicatorSection.classList.add('hidden');
      console.log('✅ 統合ドラフトインジケーターを非表示にしました');
    }
    
    // ドラフト機能ヘルプも非表示
  const helpSection = document.getElementById('draft-help-section');
    if (helpSection) {
      helpSection.classList.add('hidden');
      console.log('💡 ドラフトヘルプセクションを非表示にしました');
    }
    
    // ドラフトモードUIを通常に戻す
    this._updateDraftModeUI(false);
  },
  
  /**
   * ドラフトモード状態に合わせてUIを更新
   */
  _updateDraftModeUI(isDraftMode = null) {
    if (isDraftMode === null) {
      isDraftMode = window._draftModeActive;
    }
    
  const saveButton = document.getElementById('save-publish-btn');
  const saveButtonText = document.getElementById('save-publish-text');
    
    if (saveButton && saveButtonText) {
      if (isDraftMode) {
        saveButtonText.textContent = 'ドラフトを保存して公開';
        saveButton.className = saveButton.className.replace('btn-primary', 'btn-warning');
        console.log('📝 UIをドラフトモードに変更');
      } else {
        saveButtonText.textContent = '設定を保存して公開';
        saveButton.className = saveButton.className.replace('btn-warning', 'btn-primary');
        console.log('✅ UIを通常モードに変更');
      }
    }
  },

  /**
   * スプレッドシートID不整合の統合的修正処理
   */
  async _correctSpreadsheetIdInconsistency(targetSpreadsheetId, currentSpreadsheetId) {
    try {
      console.log('🔧 統合的なスプレッドシートID修正を開始');
      
      // 1. グローバル状態の修正
      if (window.currentStatus?.userInfo) {
        console.log('🔧 Correcting currentStatus with target spreadsheet ID');
        window.currentStatus.userInfo.spreadsheetId = targetSpreadsheetId;
        
        // Also update spreadsheet URL if available
        if (window.currentStatus.userInfo.spreadsheetUrl) {
  const correctedUrl = window.currentStatus.userInfo.spreadsheetUrl.replace(
            /\/spreadsheets\/d\/[a-zA-Z0-9-_]+/,
            '/spreadsheets/d/' + targetSpreadsheetId
          );
          window.currentStatus.userInfo.spreadsheetUrl = correctedUrl;
          console.log('🔗 Spreadsheet URL also corrected');
        }
      }
      
      // 2. AdminPanel状態の修正
      if (window.AdminPanel?.currentStatus?.userInfo) {
        console.log('🔧 Correcting AdminPanel.currentStatus');
        window.AdminPanel.currentStatus.userInfo.spreadsheetId = targetSpreadsheetId;
      }
      
      // 3. UI要素の修正
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
      if (spreadsheetBtn) {
  const correctedUrl = 'https://docs.google.com/spreadsheets/d/' + targetSpreadsheetId + '/edit';
        spreadsheetBtn.href = correctedUrl;
        console.log('🔗 Spreadsheet button URL updated');
      }
      
      // 4. キャッシュクリア
      if (typeof clearAllSpreadsheetCache === 'function') {
        await clearAllSpreadsheetCache();
        console.log('🧹 キャッシュクリア完了');
      }
      
      console.log('✅ 統合的なスプレッドシートID修正が完了');
      
    } catch (error) {
      console.error('❌ スプレッドシートID修正エラー:', error);
    }
  },

  _escapeHtml(text) {
  const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
  }
};

// History manager integration
window.AdminPanel.historyManager = {
  loadSimpleHistoryTable: function() { return window.HistoryManager.renderTable(); },
  restoreFromSimpleHistory: function(item) { return window.HistoryManager._restoreHistoryItem(item); }
};

//# sourceURL=adminPanel-framework.js.html


// =============================================================================
// ADMIN PANEL CORE UTILITIES & DOM OPERATIONS
// =============================================================================

// =============================================================================
// LOGGING UTILITIES - Standardized logging with levels
// =============================================================================

// Simple logging utility with conditional output based on DEBUG mode  
// DEBUG_MODE is defined in constants.js.html

// adminLog and logging functions are defined in adminPanel-framework.js.html

// Logging functions are defined in adminPanel-framework.js.html

// =============================================================================
// ENHANCED MESSAGE SYSTEM FOR SETUP FLOW
// =============================================================================
// Message handling is now centralized in AdminPanel.ui.showMessage defined in
// adminPanel-framework.js.html. The previous inline implementation has been
// removed to avoid duplication.

// =============================================================================
// UNIFIED MANAGEMENT SYSTEM API - 統一管理システムAPI
// =============================================================================

/**
 * 統一管理システム - 全管理クラスのエントリーポイント
 */
window.unifiedManagement = {
  // キャッシュ管理 (CacheManager)
  cache: {
    get: (key, valueFn, options) => typeof cacheManager !== 'undefined' ? cacheManager.get(key, valueFn, options) : (valueFn ? valueFn() : null),
    remove: (key) => typeof cacheManager !== 'undefined' ? cacheManager.remove(key) : null,
    clearAll: () => typeof cacheManager !== 'undefined' ? cacheManager.clearAll() : null,
    clearFrontend: (options) => typeof cacheManager !== 'undefined' ? cacheManager.clearAllFrontendCaches(options) : Promise.resolve({ success: false }),
    clearSpecific: (type) => typeof cacheManager !== 'undefined' ? cacheManager.clearSpecificCache(type) : Promise.resolve({ success: false }),
    diagnose: () => typeof cacheManager !== 'undefined' ? cacheManager.diagnoseFrontendCache() : { available: false },
    getHealth: () => typeof cacheManager !== 'undefined' ? cacheManager.getHealth() : { status: 'unavailable' }
  },

  // タイミング制御 (TimingManager)
  timing: {
    delay: (ms, id) => typeof TimingManager !== 'undefined' ? TimingManager.delay(ms, id) : new Promise(resolve => setTimeout(resolve, ms)),
    sequence: (operations, intervalMs, sequenceId) => typeof TimingManager !== 'undefined' ? TimingManager.sequence(operations, intervalMs, sequenceId) : Promise.resolve([]),
    parallel: (operations, concurrency) => typeof TimingManager !== 'undefined' ? TimingManager.parallel(operations, concurrency) : Promise.all(operations.map(op => op())),
    progressSequence: (steps, onProgress, stepDelay) => typeof TimingManager !== 'undefined' ? TimingManager.progressSequence(steps, onProgress, stepDelay) : Promise.resolve([]),
    debounce: (func, key, delay) => typeof TimingManager !== 'undefined' ? TimingManager.debounce(func, key, delay) : func,
    throttle: (func, key, delay) => typeof TimingManager !== 'undefined' ? TimingManager.throttle(func, key, delay) : func,
    clearTiming: (key) => typeof TimingManager !== 'undefined' ? TimingManager.clearTiming(key) : null,
    clearAllTiming: () => typeof TimingManager !== 'undefined' ? TimingManager.clearAllTiming() : null
  },

  // フロー実行制御 (FlowExecutionManager)
  flow: {
    execute: (flowId, operation, options) => typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.executeWithLock(flowId, operation, options) : operation(),
    executeWithLoading: (flowId, operation, options) => typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.executeWithLoadingSync(flowId, operation, options) : operation(),
    cancel: (flowId) => typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.cancelFlow(flowId) : null,
    cancelAll: () => typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.cancelAllFlows() : null,
    diagnose: () => typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.diagnoseExecution() : { activeFlows: [], pendingOperations: 0 }
  },

  // UI管理 (UnifiedLoadingManager)
  ui: {
    showLoading: (message, options) => window.unifiedLoading && window.unifiedLoading.showSimple(message, options),
    showProgress: (message, step, percentage) => window.unifiedLoading && window.unifiedLoading.showAdminProgress(message, step, percentage),
    hideLoading: () => window.unifiedLoading && window.unifiedLoading.hide(),
    setLoading: (isLoading, message, step, percentage) => window.setLoading(isLoading, message, step, percentage)
  },

  // システム診断
  diagnose: () => ({
    cache: typeof cacheManager !== 'undefined' ? cacheManager.diagnoseFrontendCache() : { available: false },
    flow: typeof flowExecutionManager !== 'undefined' ? flowExecutionManager.diagnoseExecution() : { activeFlows: [], pendingOperations: 0 },
    timing: {
      activeTimers: typeof timingManager !== 'undefined' ? timingManager.activeTimers.size : 0,
      debounceTimers: typeof timingManager !== 'undefined' ? ((timingManager.debounceTimers && timingManager.debounceTimers.size) || 0) : 0,
      throttleTimers: typeof timingManager !== 'undefined' ? ((timingManager.throttleTimers && timingManager.throttleTimers.size) || 0) : 0
    },
    timestamp: Date.now()
  })
};

// レガシー互換性のためのグローバル関数
  const debounce = function(func, delay, key) {
  if (typeof TimingManager !== 'undefined') {
    return TimingManager.debounce(func, key || 'default', delay);
  } else if (window.sharedUtilities && window.sharedUtilities.debounce) {
    window.sharedUtilities.debounce.debounce(func, key || 'default', delay);
  } else {
    // フォールバック実装
    let timeouts = window._debounceTimeouts || (window._debounceTimeouts = {});
    return function(...args) {
      const timeoutKey = key || 'default';
      clearTimeout(timeouts[timeoutKey]);
      timeouts[timeoutKey] = setTimeout(() => func.apply(this, args), delay);
    };
  }
};

// Enhanced debounce system for admin panel operations
window.AdminPanel.debounce = {
  timers: new Map(),
  
  // Specialized debounce for loadStatus operations
  loadStatus: function(func, delay = 250) {
    const key = 'loadStatus';
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }
    
    const timer = setTimeout(() => {
      this.timers.delete(key);
      logDebug('🎯 Executing debounced loadStatus');
      func();
    }, delay);
    
    this.timers.set(key, timer);
    logDebug(`⏳ Debouncing loadStatus for ${delay}ms`);
  },
  
  // General purpose debounce for UI operations
  uiOperation: function(func, key, delay = 100) {
    const fullKey = `ui-${key}`;
    if (this.timers.has(fullKey)) {
      clearTimeout(this.timers.get(fullKey));
    }
    
    const timer = setTimeout(() => {
      this.timers.delete(fullKey);
      func();
    }, delay);
    
    this.timers.set(fullKey, timer);
  },
  
  // Clear specific debounce timer
  clear: function(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
  },
  
  // Clear all debounce timers
  clearAll: function() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
    logDebug('🧹 All debounce timers cleared');
  }
};

// =============================================================================
// DOM UTILITY FUNCTIONS - Use SharedUtilities
// =============================================================================

// Backward compatibility functions using SharedUtilities
const dom = window.sharedUtilities.dom;
const createSafeElement = dom.createSafeElement.bind(dom);
const getCachedElement = dom.getCachedElement.bind(dom);
const safeGetElement = getCachedElement;
const setButtonState = dom.setButtonState.bind(dom);
const setSafeTextContent = dom.setSafeTextContent.bind(dom);
const toggleClass = dom.toggleClass.bind(dom);
const addSafeEventListener = dom.addSafeEventListener.bind(dom);
const removeSafeEventListener = dom.removeSafeEventListener.bind(dom);
const clearElementCache = dom.clearElementCache.bind(dom);
const cacheElements = dom.cacheElements.bind(dom);

// =============================================================================
// EVENT HANDLER UTILITIES - Consolidated patterns
// =============================================================================

// Utility for setting up multiple event listeners efficiently
function setupMultipleListeners(elementHandlerMap) {
  Object.keys(elementHandlerMap).forEach((elementId) => {
    const element = elementId.startsWith('#') ? 
      document.querySelector(elementId) : 
      (elements[elementId] || getCachedElement(elementId));
    
    if (element) {
      const handlers = elementHandlerMap[elementId];
      if (Array.isArray(handlers)) {
        handlers.forEach((handler) => {
          addSafeEventListener(element, handler.event, handler.callback, handler.options);
        });
      } else {
        addSafeEventListener(element, handlers.event, handlers.callback, handlers.options);
      }
    }
  });
}

// Utility for setting up click handlers with confirmation
function setupConfirmationHandler(elementId, confirmTitle, confirmMessage, callback) {
  const element = elements[elementId] || getCachedElement(elementId);
  if (element) {
    addSafeEventListener(element, 'click', (e) => {
      e.preventDefault();
      showConfirmationModal(
        confirmTitle,
        confirmMessage,
        callback
      );
    });
  }
}

// Utility for setting up handlers with privacy consent
function setupPrivacyHandler(elementId, callback) {
  const element = elements[elementId] || getCachedElement(elementId);
  if (element) {
    addSafeEventListener(element, 'click', (e) => {
      e.preventDefault();
      showPrivacyModal(() => {
        hidePrivacyModal();
        callback();
      });
    });
  }
}

// Utility for delegated event handling (useful for dynamic content)
function setupDelegatedHandler(parentElement, selector, event, callback) {
  if (typeof parentElement === 'string') {
    parentElement = getCachedElement(parentElement);
  }
  
  if (parentElement) {
    addSafeEventListener(parentElement, event, (e) => {
      const target = e.target.closest(selector);
      if (target) {
        callback.call(target, e);
      }
    });
  }
}

// =============================================================================
// STATE MANAGEMENT
// =============================================================================

// マルチテナント対応: ユーザーIDは adminPanel-framework.js.html で管理

// Operation mutex system to prevent concurrent operations
window.AdminPanel.operationMutex = {
  activeOperations: new Set(),
  
  // Check if operation is already running
  isRunning: function(operationId) {
    return this.activeOperations.has(operationId);
  },
  
  // Start tracking an operation
  start: function(operationId) {
    if (this.activeOperations.has(operationId)) {
      logWarn(`⚠️ Operation ${operationId} already running`);
      return false;
    }
    this.activeOperations.add(operationId);
    logDebug(`🔒 Starting operation: ${operationId}`);
    return true;
  },
  
  // End tracking an operation
  end: function(operationId) {
    this.activeOperations.delete(operationId);
    logDebug(`🔓 Completed operation: ${operationId}`);
  },
  
  // Get all active operations
  getActive: function() {
    return Array.from(this.activeOperations);
  }
};

// User initialization is now handled in adminPanel-framework.js.html
let currentActiveSheet = '';
let webAppUrl = '';
let currentSpreadsheetUrl = '';

// Global variables from adminPanel.js.html
let currentStep = 1;
let selectedSheetId = null;
let selectedFormId = null;
let availableSheets = [];
let availableForms = [];
let currentConfig = null;

// Admin panel initialization is now handled in adminPanel-framework.js.html

// =============================================================================
// LEGACY UTILITIES (for backward compatibility)
// =============================================================================

// Safe text content setter
function safeSetText(elementId, text) {
  logDebug('safeSetText called:', { elementId, text, textType: typeof text });
  
  const element = typeof elementId === 'string' ? getCachedElement(elementId) : elementId;
  logDebug('safeSetText element found:', !!element);
  
  if (element) {
    setSafeTextContent(element, text || '');
    logDebug(`safeSetText completed for: ${elementId} with text: ${text || ''}`);
  } else {
    logWarn('safeSetText: Element not found:', elementId);
  }
}

// =============================================================================
// LAYOUT AND VIEWPORT UTILITIES
// =============================================================================

// Layout adjustment is defined in adminPanel-framework.js.html

// AdminPanel no longer overrides global setLoading
// Uses unified loading system with admin-specific configurations


// =============================================================================
// INITIALIZATION
// =============================================================================

// Initialize layout on load
// Core initialization is now handled in adminPanel-framework.js.html

// Section expansion is now handled in adminPanel-framework.js.html

// System status and user interaction management is now handled in adminPanel-framework.js.html

// Master initialization system is now handled in adminPanel-framework.js.html

//# sourceURL=adminPanel-core.js.html


// =============================================================================
// ADMIN PANEL API COMMUNICATIONS & BACKEND CALLS
// =============================================================================

// =============================================================================
// CACHE MANAGER STUB - フロントエンド用キャッシュマネージャー
// =============================================================================

/**
 * フロントエンド用キャッシュマネージャースタブ
 * バックエンドのcacheManagerが参照される場合のフォールバック
 */
window.cacheManager = window.cacheManager || {
  /**
   * フロントエンドキャッシュをクリア
   * @returns {Promise} クリア結果
   */
  clearAllFrontendCaches() {
    return new Promise((resolve) => {
      try {
        // localStorage のクリア（必要に応じて）
        const keysToPreserve = ['userId', 'adminEmail', 'debugMode'];
        const preservedData = {};
        
        keysToPreserve.forEach(key => {
          if (localStorage.getItem(key)) {
            preservedData[key] = localStorage.getItem(key);
          }
        });
        
        // 一時的にクリア
        localStorage.clear();
        
        // 保存すべきデータを復元
        Object.keys(preservedData).forEach(key => {
          localStorage.setItem(key, preservedData[key]);
        });
        
        // sessionStorageもクリア
        sessionStorage.clear();
        
        console.log('✅ Frontend caches cleared successfully');
        resolve({ success: true, message: 'Frontend caches cleared' });
      } catch (error) {
        console.warn('⚠️ Cache clear failed:', error);
        resolve({ success: false, error: error.message });
      }
    });
  },
  
  /**
   * 特定のキャッシュキーを無効化
   * @param {Array} patterns - 無効化するパターン
   */
  invalidate(patterns) {
    console.log('Cache invalidation requested for patterns:', patterns);
    // フロントエンドでは実装不要（バックエンド側で処理）
    return Promise.resolve();
  },
  
  /**
   * シートデータキャッシュを無効化
   * @param {string} spreadsheetId - スプレッドシートID
   */
  invalidateSheetData(spreadsheetId) {
    console.log('Sheet data cache invalidation requested for:', spreadsheetId);
    // フロントエンドでは実装不要（バックエンド側で処理）
    return Promise.resolve();
  }
};

// =============================================================================
// UNIFIED FLOW EXECUTION MANAGER - 統一実行制御システム
// =============================================================================

/**
 * フロー実行制御マネージャー - 重複実行・競合状態を防止
 */
class FlowExecutionManager {
  constructor() {
    this.activeFlows = new Set();
    this.pendingOperations = new Map();
    this.executionQueue = new Map();
    this.debugMode = window.DEBUG_MODE || false;
  }

  /**
   * 排他実行制御付きでフロー実行
   * @param {string} flowId - フロー識別子
   * @param {Function} operation - 実行する操作
   * @param {Object} options - 実行オプション
   * @returns {Promise} 実行結果
   */
  executeWithLock(flowId, operation, options = {}) {
    const timeout = options.timeout || SYSTEM_CONSTANTS.TIMEOUTS.DEFAULT_FLOW_TIMEOUT;
    const allowQueue = options.allowQueue || false;

    // 既に実行中の場合の処理
    if (this.activeFlows.has(flowId)) {
      if (this.pendingOperations.has(flowId)) {
        if (this.debugMode) {
          logDebug(`🔒 Flow ${flowId} already in progress, returning existing promise`);
        }
        return this.pendingOperations.get(flowId);
      }
      
      if (!allowQueue) {
        throw new Error(`Flow ${flowId} is already in progress and queueing is disabled`);
      }
      
      // キューに追加
      if (this.debugMode) {
        logDebug(`⏳ Flow ${flowId} queued for execution`);
      }
      return this.queueOperation(flowId, operation, timeout);
    }

    // 新規実行
    return this.executeOperation(flowId, operation, timeout);
  }

  /**
   * 操作を実行（改良版 - AbortController対応）
   */
  executeOperation(flowId, operation, timeout) {
  const self = this;
    self.activeFlows.add(flowId);
    
    if (self.debugMode) {
      console.log('🚀 Starting flow execution: ' + flowId);
    }

    // AbortControllerを使用した適切なタイムアウト制御
  const abortController = new AbortController();
  const timeoutId = null;
    
    try {
      // タイムアウト設定
      timeoutId = setTimeout(function() {
        console.warn('⏰ Flow ' + flowId + ' timeout after ' + timeout + 'ms - aborting operation');
        abortController.abort();
      }, timeout);

      // 操作実行（AbortSignalを渡す）
  const operationPromise = Promise.resolve(operation(abortController.signal));
      self.pendingOperations.set(flowId, operationPromise);

      return operationPromise.then(function(result) {
        // 正常完了時はタイムアウトをクリア
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        
        return result;
      }).catch(function(error) {
        // タイムアウトをクリア
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }

        // AbortErrorの場合はより詳細なエラーメッセージ
        if (error.name === 'AbortError' || abortController.signal.aborted) {
  const timeoutError = new Error('Flow ' + flowId + ' was aborted due to timeout (' + timeout + 'ms)');
          timeoutError.name = 'TimeoutError';
          timeoutError.flowId = flowId;
          timeoutError.timeout = timeout;
          console.error('❌ Flow ' + flowId + ' aborted due to timeout');
          throw timeoutError;
        }

        console.error('❌ Flow ' + flowId + ' failed:', error);
        throw error;
      }).then(function(result) {
        // リソースクリーンアップ
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        
        self.activeFlows.delete(flowId);
        self.pendingOperations.delete(flowId);
        
        // キューされた操作を実行
        self.processQueue(flowId);
        
        return result;
      });
    } catch (error) {
      // リソースクリーンアップ
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      self.activeFlows.delete(flowId);
      self.pendingOperations.delete(flowId);
      
      // キューされた操作を実行
      self.processQueue(flowId);
      
      throw error;
    }
};

  /**
   * 操作をキューに追加
   */
  queueOperation(flowId, operation, timeout) {
  const self = this;
    return new Promise(function(resolve, reject) {
      if (!self.executionQueue.has(flowId)) {
        self.executionQueue.set(flowId, []);
      }
      
      self.executionQueue.get(flowId).push({
        operation: operation,
        timeout: timeout,
        resolve: resolve,
        reject: reject
      });
    });
};

  /**
   * キューされた操作を処理
   */
  processQueue(flowId) {
    const self = this;
    const queue = self.executionQueue.get(flowId);
    if (!queue || queue.length === 0) return;

    const next = queue.shift();
    if (queue.length === 0) {
      self.executionQueue.delete(flowId);
    }

    try {
  const resultPromise = self.executeOperation(flowId, next.operation, next.timeout);
      resultPromise.then(function(result) {
        next.resolve(result);
      }).catch(function(error) {
        next.reject(error);
      });
    } catch (error) {
      next.reject(error);
    }
};

  /**
   * 指定フローの実行状態を確認
   */
  isFlowActive(flowId) {
    return this.activeFlows.has(flowId);
  }

  /**
   * 全てのアクティブフローを取得
   */
  getActiveFlows() {
    return Array.from(this.activeFlows);
  }

  /**
   * 緊急停止: 全フローをキャンセル
   */
  cancelAllFlows() {
    console.warn('🚨 Emergency stop: Cancelling all active flows');
    this.activeFlows.clear();
    this.pendingOperations.clear();
    this.executionQueue.clear();
};

/**
 * 実行状態の診断
 * @returns {Object} 診断結果
 */
  diagnoseExecution() {
    const self = this;
    return {
      activeFlows: Array.from(self.activeFlows),
      pendingOperations: self.pendingOperations.size,
      queuedOperations: Array.from(self.executionQueue.keys()).map(function(flowId) {
        return {
          flowId: flowId,
          queueLength: self.executionQueue.get(flowId).length
        };
      }),
      totalActiveFlows: self.activeFlows.size,
      timestamp: Date.now()
    };
};

  /**
   * LoadingManagerとの連携 - 統一ローディング制御
   * @param {string} flowId - フローID
   * @param {string} message - ローディングメッセージ
   * @param {boolean} isActive - アクティブ状態
   */
  updateLoadingState(flowId, message, isActive) {
    try {
      // UnifiedLoadingManagerが利用可能な場合
      if (typeof window !== 'undefined' && window.unifiedLoading) {
        if (isActive) {
          window.unifiedLoading.showSimple(message || '実行中: ' + flowId);
        } else {
          window.unifiedLoading.hide();
        }
      }
      
      // SharedUtilitiesのLoadingManagerが利用可能な場合
      if (typeof window !== 'undefined' && window.sharedUtilities && window.sharedUtilities.loading) {
        window.sharedUtilities.loading.setLoading(flowId, isActive, message);
      }

    } catch (error) {
      console.warn('⚠️ Failed to update loading state:', error);
    }
};

  /**
   * 強化されたexecuteWithLock - ローディング連携版
   * @param {string} flowId - フローID
   * @param {Function} operation - 実行する操作
   * @param {Object} options - オプション
   * @returns {Promise} 実行結果
   */
  executeWithLoadingSync(flowId, operation, options) {
    const self = this;
    options = options || {};
    const timeout = options.timeout || 30000;
    const loadingMessage = options.loadingMessage || null;
    const showLoading = options.showLoading !== undefined ? options.showLoading : true;
    const onProgress = options.onProgress || null;
    const priority = options.priority || 0;
    const retries = options.retries || 0;

    try {
      // ローディング表示開始
      if (showLoading) {
        self.updateLoadingState(flowId, loadingMessage || '処理中: ' + flowId, true);
      }

      // プログレス付きで実行
  const executionPromise = self.executeWithLock(flowId, function() {
        return new Promise(function(resolve, reject) {
          try {
            if (onProgress) {
              onProgress(0, 'starting', '実行開始');
            }
            
  const operationPromise = Promise.resolve(operation());
            operationPromise.then(function(operationResult) {
              if (onProgress) {
                onProgress(100, 'completed', '実行完了');
              }
              
              resolve(operationResult);
            }).catch(reject);
          } catch (error) {
            reject(error);
          }
        });
      }, { timeout: timeout, priority: priority, retries: retries });

      return executionPromise.catch(function(error) {
        if (onProgress) {
          onProgress(-1, 'error', 'エラー: ' + error.message);
        }
        throw error;
      }).then(function(result) {
        // ローディング表示終了
        if (showLoading) {
          setTimeout(function() {
            self.updateLoadingState(flowId, null, false);
          }, 500); // 少し遅延してからローディングを隠す
        }
        return result;
      }).catch(function(error) {
        // ローディング表示終了（エラー時も）
        if (showLoading) {
          setTimeout(function() {
            self.updateLoadingState(flowId, null, false);
          }, 500);
        }
        throw error;
      });

    } catch (error) {
      if (onProgress) {
        onProgress(-1, 'error', 'エラー: ' + error.message);
      }
      // ローディング表示終了（同期エラー時も）
      if (showLoading) {
        setTimeout(function() {
          self.updateLoadingState(flowId, null, false);
        }, 500);
      }
      throw error;
    }
  }
}

// グローバルフロー実行マネージャーのインスタンス
const flowExecutionManager = new FlowExecutionManager();

// =============================================================================
// TIMING MANAGER - 非同期処理統一化システム
// =============================================================================

/**
 * タイミング管理システム - setTimeout/setIntervalの代替
 */
function TimingManager() {
  this.activeTimers = new Map();
  this.debugMode = window.DEBUG_MODE || false;
}

/**
 * 遅延実行（setTimeoutの代替）
 * @param {number} ms - 遅延ミリ秒
 * @param {string} id - タイマーID（オプション）
 * @returns {Promise} 完了Promise
 */
TimingManager.delay = function(ms, id) {
    id = id || null;
    if (id && timingManager.activeTimers.has(id)) {
      timingManager.activeTimers.get(id).cancel();
    }

    return new Promise(function(resolve, reject) {
  const timer = setTimeout(function() {
        if (id) timingManager.activeTimers.delete(id);
        resolve();
      }, ms);

      if (id) {
        timingManager.activeTimers.set(id, {
          timer: timer,
          cancel: function() {
            clearTimeout(timer);
            timingManager.activeTimers.delete(id);
            reject(new Error('Timer ' + id + ' was cancelled'));
          }
        });
      }
    });
};

/**
 * 順次実行システム（複数のsetTimeoutの代替）
 * @param {Array} operations - 実行する操作の配列
 * @param {number} intervalMs - 各操作間の間隔
 * @param {string} sequenceId - シーケンスID（オプション）
 * @returns {Promise} 完了Promise
 */
TimingManager.sequence = function(operations, intervalMs, sequenceId) {
    intervalMs = intervalMs || 100;
    sequenceId = sequenceId || null;
  const results = [];
    
    function processNextOperation(index) {
      if (index >= operations.length) {
        return Promise.resolve(results);
      }
      
  const operation = operations[index];
      
      try {
        let operationPromise;
        if (typeof operation === 'function') {
          operationPromise = Promise.resolve(operation());
        } else {
          operationPromise = Promise.resolve(operation);
        }
        
        return operationPromise.then(function(result) {
          results.push(result);
          
          // 最後の操作でない場合は間隔を設ける
          if (index < operations.length - 1) {
  const delayId = sequenceId ? sequenceId + '_delay_' + index : null;
            return TimingManager.delay(intervalMs, delayId).then(function() {
              return processNextOperation(index + 1);
            });
          } else {
            return processNextOperation(index + 1);
          }
        }).catch(function(error) {
          console.error('Sequence operation ' + index + ' failed:', error);
          throw error;
        });
      } catch (error) {
        console.error('Sequence operation ' + index + ' failed:', error);
        return Promise.reject(error);
      }
    }
    
    return processNextOperation(0);
};

/**
 * 並列実行システム（制御された並列性）
 * @param {Array} operations - 実行する操作の配列
 * @param {number} concurrency - 同時実行数
 * @returns {Promise} 完了Promise
 */
TimingManager.parallel = function(operations, concurrency) {
    concurrency = concurrency || 3;
  const results = [];
  const executing = [];
    
    function processOperations(index) {
      if (index >= operations.length) {
        return Promise.all(results);
      }
      
  const operation = operations[index];
  const promise = Promise.resolve(operation()).then(function(result) {
  const executeIndex = executing.indexOf(promise);
        if (executeIndex !== -1) {
          executing.splice(executeIndex, 1);
        }
        return result;
      });
      
      results.push(promise);
      executing.push(promise);
      
      if (executing.length >= concurrency) {
        return Promise.race(executing).then(function() {
          return processOperations(index + 1);
        });
      } else {
        return processOperations(index + 1);
      }
    }
    
    return processOperations(0);
};

/**
 * プログレス実行システム（プログレスバー用）
 * @param {Array} steps - ステップの配列
 * @param {Function} onProgress - プログレスコールバック
 * @param {number} stepDelay - ステップ間遅延
 * @returns {Promise} 完了Promise
 */
TimingManager.progressSequence = function(steps, onProgress, stepDelay) {
    stepDelay = stepDelay || 1000;
  const results = [];
    
    function processStep(index) {
      if (index >= steps.length) {
        return Promise.resolve(results);
      }
      
  const step = steps[index];
      
      try {
        // プログレス開始通知
        if (onProgress) {
          onProgress(index, 'active', step.text || 'Step ' + (index + 1), step.detail || '実行中...');
        }
        
        // ステップ実行
        let operationPromise;
        if (typeof step.operation === 'function') {
          operationPromise = Promise.resolve(step.operation());
        } else {
          operationPromise = Promise.resolve(undefined);
        }
        
        return operationPromise.then(function(result) {
          // プログレス完了通知
          if (onProgress) {
            onProgress(index, 'completed', step.text || 'Step ' + (index + 1), step.completedText || '✅ 完了');
          }
          
          results.push(result);
          
          // 最後のステップでない場合は遅延
          if (index < steps.length - 1) {
            return TimingManager.delay(stepDelay).then(function() {
              return processStep(index + 1);
            });
          } else {
            return processStep(index + 1);
          }
        }).catch(function(error) {
          // プログレスエラー通知
          if (onProgress) {
            onProgress(index, 'error', step.text || 'Step ' + (index + 1), '❌ エラー: ' + error.message);
          }
          throw error;
        });
        
      } catch (error) {
        // プログレスエラー通知
        if (onProgress) {
          onProgress(index, 'error', step.text || 'Step ' + (index + 1), '❌ エラー: ' + error.message);
        }
        return Promise.reject(error);
      }
    }
    
    return processStep(0);
};

/**
 * タイマーをキャンセル
 * @param {string} id - タイマーID
 */
TimingManager.cancelTimer = function(id) {
    if (timingManager.activeTimers.has(id)) {
      timingManager.activeTimers.get(id).cancel();
    }
};

/**
 * 全タイマーをキャンセル
 */
TimingManager.cancelAllTimers = function() {
    timingManager.activeTimers.forEach(function(timer, id) {
      timer.cancel();
    });
    timingManager.activeTimers.clear();
};

  // =============================================================================
  // DEBOUNCE & THROTTLE INTEGRATION - SharedUtilities統合
  // =============================================================================

/**
 * Debounce関数 - 連続実行を防止
 * @param {Function} func - 実行する関数
 * @param {string} key - デバウンスキー
 * @param {number} delay - 遅延時間（ミリ秒）
 * @returns {Function} デバウンス化された関数
 */
TimingManager.debounce = function(func, key, delay) {
    delay = delay || 1000;
    if (!timingManager.debounceTimers) {
      timingManager.debounceTimers = new Map();
    }

    return function() {
  const args = Array.prototype.slice.call(arguments);
  const context = this;
      
      if (timingManager.debounceTimers.has(key)) {
        clearTimeout(timingManager.debounceTimers.get(key));
      }

  const timeoutId = setTimeout(function() {
        func.apply(context, args);
        timingManager.debounceTimers.delete(key);
      }, delay);

      timingManager.debounceTimers.set(key, timeoutId);
    };
};

/**
 * Throttle関数 - 実行頻度を制限
 * @param {Function} func - 実行する関数
 * @param {string} key - スロットルキー
 * @param {number} delay - 実行間隔（ミリ秒）
 * @returns {Function} スロットル化された関数
 */
TimingManager.throttle = function(func, key, delay) {
    delay = delay || 100;
    if (!timingManager.throttleTimers) {
      timingManager.throttleTimers = new Map();
    }
    if (!timingManager.lastExecution) {
      timingManager.lastExecution = new Map();
    }

    return function() {
  const args = Array.prototype.slice.call(arguments);
  const context = this;
  const now = Date.now();
  const lastRun = timingManager.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func.apply(context, args);
        timingManager.lastExecution.set(key, now);
      } else if (!timingManager.throttleTimers.has(key)) {
  const timeoutId = setTimeout(function() {
          func.apply(context, args);
          timingManager.lastExecution.set(key, Date.now());
          timingManager.throttleTimers.delete(key);
        }, delay - (now - lastRun));
        timingManager.throttleTimers.set(key, timeoutId);
      }
    };
};

/**
 * 特定キーのデバウンス/スロットルをクリア
 * @param {string} key - クリアするキー
 */
TimingManager.clearTiming = function(key) {
    if (timingManager.debounceTimers && timingManager.debounceTimers.has(key)) {
      clearTimeout(timingManager.debounceTimers.get(key));
      timingManager.debounceTimers.delete(key);
    }
    if (timingManager.throttleTimers && timingManager.throttleTimers.has(key)) {
      clearTimeout(timingManager.throttleTimers.get(key));
      timingManager.throttleTimers.delete(key);
    }
    if (timingManager.lastExecution) {
      timingManager.lastExecution.delete(key);
    }
};

/**
 * 全デバウンス/スロットルをクリア
 */
TimingManager.clearAllTiming = function() {
    // デバウンスタイマーをクリア
    if (timingManager.debounceTimers) {
      timingManager.debounceTimers.forEach(function(timer) {
        clearTimeout(timer);
      });
      timingManager.debounceTimers.clear();
    }
    // スロットルタイマーをクリア
    if (timingManager.throttleTimers) {
      timingManager.throttleTimers.forEach(function(timer) {
        clearTimeout(timer);
      });
      timingManager.throttleTimers.clear();
    }
    // 実行履歴をクリア
    if (timingManager.lastExecution) {
      timingManager.lastExecution.clear();
    }
};

// グローバルタイミングマネージャーのインスタンス
const timingManager = new TimingManager();

// TimingManagerをグローバルに公開
window.TimingManager = TimingManager;

// Global timing utilities
window.debounce = TimingManager.debounce;
window.throttle = TimingManager.throttle;

// =============================================================================
// UNIFIED CACHE CONTROLLER - 統一キャッシュ管理システム
// =============================================================================

/**
 * 統一キャッシュコントローラー - キャッシュ競合を防止
 */
// UnifiedCacheController機能はCacheManagerに統合されました
// cache.gsのcacheManager.clearAllFrontendCaches()を使用してください

// 統一キャッシュ制御はcache.gsのcacheManagerで管理されます

// =============================================================================
// UI UPDATE BATCHER - 統一UI更新システム
// =============================================================================

/**
 * UI更新バッチャー - UI更新の重複を防ぎ効率化
 */
class UIUpdateBatcher {
  constructor() {
    this.pendingUpdates = [];
    this.batchTimeout = null;
    this.isProcessing = false;
    this.batchDelay = 100; // バッチ処理の遅延（ms）
    this.debugMode = window.DEBUG_MODE || false;
  }

/**
 * UI更新をキューに追加
 * @param {Function} updateFn - 更新関数
 * @param {string} updateId - 更新ID（重複排除用）
 * @param {number} priority - 優先度（高いほど先に実行）
   */
  queueUpdate(updateFn, updateId, priority) {
    updateId = updateId || null;
    priority = priority || 0;
    
    // 重複排除: 同じIDの更新があれば置き換え
    if (updateId) {
  const existingIndex = this.pendingUpdates.findIndex(function(update) {
        return update.id === updateId;
      });
      if (existingIndex !== -1) {
        this.pendingUpdates[existingIndex] = { 
          fn: updateFn, 
          id: updateId, 
          priority: priority, 
          timestamp: Date.now() 
        };
        return;
      }
    }

    // 新規追加
    this.pendingUpdates.push({
      fn: updateFn,
      id: updateId || 'update_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      priority: priority,
      timestamp: Date.now()
    });

    if (this.debugMode) {
      console.log('➕ UI update queued: ' + (updateId || 'anonymous') + ', queue size: ' + this.pendingUpdates.length);
    }

    this.scheduleBatch();
};

/**
 * バッチ処理をスケジュール
 */
  scheduleBatch() {
    const self = this;
    if (self.batchTimeout || self.isProcessing) return;

    self.batchTimeout = setTimeout(() => {
      self.processBatch();
    }, self.batchDelay);
};

/**
 * バッチ処理を実行
 */
  processBatch() {
  const self = this;
    if (self.isProcessing || self.pendingUpdates.length === 0) return;

    self.isProcessing = true;
    self.batchTimeout = null;

    try {
      // 優先度順でソート（高い順）
  const sortedUpdates = self.pendingUpdates.slice().sort(function(a, b) {
        if (b.priority !== a.priority) return b.priority - a.priority;
        return a.timestamp - b.timestamp; // 同じ優先度なら古い順
      });

      self.pendingUpdates = [];

      if (self.debugMode) {
        console.log('🎯 Processing UI update batch: ' + sortedUpdates.length + ' updates');
      }

      // 順次実行（並列実行だと競合する可能性があるため）
      function processNextUpdate(index) {
        if (index >= sortedUpdates.length) {
          if (self.debugMode) {
            console.log('🎉 UI update batch completed: ' + sortedUpdates.length + ' updates processed');
          }
          
          self.isProcessing = false;
          
          // 処理中に新しい更新が追加されていたら再スケジュール
          if (self.pendingUpdates.length > 0) {
            self.scheduleBatch();
          }
          return;
        }
        
  const update = sortedUpdates[index];
        try {
  const updatePromise = Promise.resolve(update.fn());
          updatePromise.then(function() {
            // 各更新間に短い間隔を設ける
            return TimingManager.delay(10);
          }).then(function() {
            processNextUpdate(index + 1);
          }).catch(function(error) {
            console.error('❌ UI update failed: ' + update.id, error);
            TimingManager.delay(10).then(function() {
              processNextUpdate(index + 1);
            });
          });
        } catch (error) {
          console.error('❌ UI update failed: ' + update.id, error);
          TimingManager.delay(10).then(function() {
            processNextUpdate(index + 1);
          });
        }
      }
      
      processNextUpdate(0);
      
    } catch (error) {
      console.error('❌ UI update batch processing failed:', error);
      self.isProcessing = false;
      
      // 処理中に新しい更新が追加されていたら再スケジュール
      if (self.pendingUpdates.length > 0) {
        self.scheduleBatch();
      }
    }
};

/**
 * 即座にバッチ処理を実行
 */
  flushUpdates() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    
    this.processBatch();
};

/**
 * 待機中の更新をクリア
 */
  clearPendingUpdates() {
    this.pendingUpdates = [];
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    
    if (this.debugMode) {
      console.log('🧹 Pending UI updates cleared');
    }
};

/**
 * バッチャーの状態を取得
 */
  getStatus() {
    return {
      pendingUpdates: this.pendingUpdates.length,
      isProcessing: this.isProcessing,
      batchScheduled: !!this.batchTimeout
    };
  }
}

// グローバルUI更新バッチャーのインスタンス
const uiUpdateBatcher = new UIUpdateBatcher();

// =============================================================================
// BACKEND FUNCTION WRAPPERS
// =============================================================================

// マルチテナント対応: 新しいrunGasWithUserId関数 - ローディング機能付き
function runGasWithUserId(functionName, loadingMessage = '処理中...', ...args) {
  // ローディング表示が必要な場合は callWithLoading を使用
  if (loadingMessage && loadingMessage !== false) {
    // userIdが設定されていない場合は初期化を待つ
    if (!userId) {
      return userIdPromise.then(() => {
        if (!userId) {
          logError('No userId available for:', functionName);
          throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
        }
        
        // ローディング機能付きでuserIdを第一引数として追加 - Admin Panel uses overlay loading
        return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args);
      }).catch((error) => {
        logError('Error in runGasWithUserId (after userIdPromise):', error);
        throw error;
      });
    }
    
    // userIdが既に設定されている場合 - ローディング機能付き - Admin Panel uses overlay loading
    return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args).catch((error) => {
      logError('Error in runGasWithUserId (direct call with loading):', error);
      throw error;
    });
  }
  
  // ローディング不要の場合（loadingMessage = false）は従来通り
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        logError('No userId available for:', functionName);
        throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
      }
      
      // userIdを第一引数として追加
      return gasOptimizer.call(functionName, userId, ...args);
    }).catch((error) => {
      logError('userIdPromise rejected:', error);
      throw error;
    });
  }
  
  // userIdを第一引数として追加
  return gasOptimizer.call(functionName, userId, ...args);
}

// callWithCache 関数 - 読み取り専用操作用
function callWithCache(functionName, cacheKey, ttl, ...args) {
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, ...args);
  }, ttl);
}

// runGasWithUserId with cache support
function callWithCacheWithUserId(functionName, cacheKey, ttl, ...args) {
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        throw new Error('ユーザーIDが設定されていません。');
      }
      return unifiedCache.getOrSet(cacheKey, function() {
        return gasOptimizer.call(functionName, userId, ...args);
      }, ttl);
    });
  }
  
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, userId, ...args);
  }, ttl);
}

// =============================================================================
// STATUS AND DATA LOADING
// =============================================================================

// Load system status - OPTIMIZED with integrated API
// AI列判定結果とconfigJsonのキャッシュ管理
const processCache = {
  aiColumnMapping: {
    data: null,
    headersHash: null,
    timestamp: null,
    ttl: 300000 // 5分間のキャッシュ
  },
  configNormalization: {
    data: null,
    dataHash: null,
    timestamp: null,
    ttl: 60000 // 1分間のキャッシュ
  }
};

// ハッシュ生成関数（簡易版）
function generateSimpleHash(data) {
  return JSON.stringify(data).split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
}

// キャッシュ有効性チェック
function isCacheValid(cacheEntry) {
  if (!cacheEntry.data || !cacheEntry.timestamp) return false;
  return (Date.now() - cacheEntry.timestamp) < cacheEntry.ttl;
}

// グローバルに関数とキャッシュを公開（他のファイルから利用可能にする）
window.processCache = processCache;
window.generateSimpleHash = generateSimpleHash;
window.isCacheValid = isCacheValid;

// loadStatus実行管理
let loadStatusInProgress = null;
let loadStatusQueue = [];

function loadStatus(bypassCache = false) {
  const operationId = 'loadStatus';
  
  // Check operation mutex to prevent concurrent calls
  if (!bypassCache && window.AdminPanel && window.AdminPanel.operationMutex) {
    if (window.AdminPanel.operationMutex.isRunning(operationId)) {
      logDebug('🚫 loadStatus already running, returning existing promise');
      return loadStatusInProgress || Promise.resolve(currentStatus);
    }
  }
  
  // 既に実行中の場合は同じPromiseを返す（強化版）
  if (loadStatusInProgress && !bypassCache) {
    logDebug('🔄 Reusing existing loadStatus promise');
    return loadStatusInProgress;
  }

  // Start operation mutex tracking
  if (window.AdminPanel && window.AdminPanel.operationMutex) {
    window.AdminPanel.operationMutex.start(operationId);
  }

  console.group('🔄 loadStatus - 一元管理版');
  console.log('🚀 Loading system status, bypassCache:', bypassCache);

  // 新しい実行を開始（フォールバック機構付き）
  loadStatusInProgress = userIdPromise.then(() => {
    if (!userId) {
      console.error('❌ userId is not available after userIdPromise resolution in loadStatus!');
      showMessage('ユーザーIDが取得できません。ページを再読み込みしてください。', 'error');
      console.groupEnd();
      throw new Error('userId is not available');
    }
  }).catch(error => {
    console.error('❌ Error resolving userIdPromise in loadStatus:', error);
    showMessage('ユーザーIDの初期化に失敗しました。ページを再読み込みしてください。', 'error');
    
    // フォールバック: 直接認証を再試行
    console.warn('⚠️ Attempting direct authentication as fallback...');
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(response => {
          console.log('🔄 Fallback authentication response:', response);
          if (response && response.status === 'success' && response.userInfo && response.userInfo.userId) {
            userId = response.userInfo.userId;
            console.log('✅ Fallback authentication successful, userId:', userId);
            resolve(userId);
          } else {
            console.error('❌ Fallback authentication also failed:', response);
            reject(new Error('フォールバック認証も失敗しました'));
          }
        })
        .withFailureHandler(reject)
        .getCurrentUserStatus();
    });
  }).then(() => {
    if (!userId) {
      console.error('❌ userId still not available after fallback');
      throw new Error('userId is not available after fallback');
    }

    console.log('🌐 Calling getInitialData with userId:', userId, 'bypassCache:', bypassCache);

    // 履歴復元時などの強制更新用フラグ
    const forceRefresh = bypassCache && window._historyRestoreInProgress;
    const targetSheetParam = forceRefresh ? 'BYPASS_CACHE' : null;

    // runGasWithUserId を使用して getInitialData を呼び出す
    return runGasWithUserId('getInitialData', 'システム情報を読み込み中...', targetSheetParam, false)
      .then(response => {
        console.log('🚀 getInitialData response received:', {
          response: response,
          hasUserInfo: !!response?.userInfo,
          userInfoKeys: response?.userInfo ? Object.keys(response.userInfo) : [],
          adminEmail: response?.userInfo?.adminEmail,
          userId: response?.userInfo?.userId
        });
        logDebug('✅ Integrated data loaded:', response);
        
        // エラーレスポンスの検証
        if (!response || response.status === 'error') {
          const errorMsg = response ? response.message : 'サーバーから無効な応答を受信しました';
          logError('getInitialData returned error:', errorMsg);
          throw new Error(errorMsg);
        }
        
        // 必須フィールドの検証
        if (!response.userInfo) {
          logError('userInfo missing in response:', response);
          throw new Error('ユーザー情報が取得できませんでした。ページを再読み込みしてください。');
        }

        // Update UI with integrated response
        updateUIWithNewStatus(response);

        // If sheet details are included, apply them immediately
        if (response.sheetDetails && response.activeSheetName) {
          logDebug('✅ Sheet details included in integrated response, applying configuration');
          try {
            populateHeaderOptions(response.sheetDetails.allHeaders);
            logDebug('✅ Header options populated from integrated data');
            populateConfig(response.sheetDetails.guessedConfig);
            logDebug('✅ AI configuration applied from integrated data');
          } catch (configError) {
            console.error('Error applying sheet configuration from integrated data:', configError);
          }
        }

        logInfo('⚡ Performance: Single API call replaced 3-4 separate calls');
        return response; // Promiseチェーンを維持するためレスポンスを返す
      })
      .catch(error => {
        console.error('❌ Integrated API failed:', error);
        showMessage('システムステータスの読み込みに失敗しました', 'error');
        throw error; // エラーを再スロー
      })
      .finally(() => {
        console.groupEnd();
        // 実行状態をリセット
        loadStatusInProgress = null;
        
        // End operation mutex tracking
        if (window.AdminPanel && window.AdminPanel.operationMutex) {
          window.AdminPanel.operationMutex.end(operationId);
        }
      });
  }).catch(error => {
    console.error('❌ Error resolving userIdPromise in loadStatus:', error);
    showMessage('ユーザーIDの初期化に失敗しました。ページを再読み込みしてください。', 'error');
    console.groupEnd();
    // エラー時も実行状態をリセット
    loadStatusInProgress = null;
    
    // End operation mutex tracking on error
    if (window.AdminPanel && window.AdminPanel.operationMutex) {
      window.AdminPanel.operationMutex.end(operationId);
    }
    
    throw error;
  });

  return loadStatusInProgress;
}

// Load sheet configuration for selected sheet with retry mechanism
function loadConfigForSelected(sheetNameOverride = null, spreadsheetIdOverride = null, retryCount = 0, maxRetries = 3, forceLoad = false) {
  // 履歴復元中は処理をスキップ（強制読み込みフラグがある場合は除く）
  if ((window._historyRestoreInProgress || window._historyColumnSelections) && !forceLoad) {
    console.log('🛡️ loadConfigForSelected: 履歴復元中のため処理をスキップしました');
    return Promise.resolve({ success: false, message: 'Skipped during history restore' });
  }
  
  const targetSheet = sheetNameOverride || selectedSheet;
  if (!targetSheet) {
    logWarn('No sheet selected for config loading');
    return Promise.reject(new Error('No sheet selected for config loading'));
  }
  
  const targetSpreadsheetId = spreadsheetIdOverride || (currentStatus?.userInfo?.spreadsheetId);
  if (!targetSpreadsheetId) {
    logError('Missing required data for loadConfigForSelected');
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return Promise.reject(new Error('Missing required data for loadConfigForSelected'));
  }
  
  // Sanitize sheet name for API call (already sanitized from caller, but double-check)
  const sanitizedSheetName = targetSheet.replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF-]/g, '').trim();
  
  console.log('🔄 Loading config for sheet: "' + targetSheet + '" (sanitized: "' + sanitizedSheetName + '"), attempt ' + (retryCount + 1) + '/' + (maxRetries + 1));
  
  return runGasWithUserId('getSheetDetails', 'シート情報を読み込み中...', targetSpreadsheetId, sanitizedSheetName)
    .then(handleSheetDetailsSuccess)
    .catch(error => {
      console.warn('❌ loadConfigForSelected attempt ' + (retryCount + 1) + ' failed:', error);
      
      // Check if this is a sheet parsing error and we have retries left
      if (retryCount < maxRetries && (
        error.message?.includes('Unable to parse range') ||
        error.message?.includes('範囲を解析できません') ||
        error.message?.includes('Invalid range')
      )) {
        const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 5000); // Exponential backoff, max 5s
        console.log('⏳ Retrying in ' + retryDelay + 'ms...');
        
        return new Promise(resolve => setTimeout(resolve, retryDelay))
          .then(() => loadConfigForSelected(sheetNameOverride, spreadsheetIdOverride, retryCount + 1, maxRetries));
      }
      
      // If no more retries or different error, use original error handler
      return handleSheetDetailsError(error);
    });
}

// Handle successful sheet details loading
function handleSheetDetailsSuccess(details) {
  if (details && details.allHeaders) {
    populateHeaderOptions(details.allHeaders);
    
    // Show config area and hide placeholder
    const configArea = document.getElementById('config-area');
    const configPlaceholder = document.getElementById('config-placeholder');
    
    if (configArea) {
      configArea.classList.remove('hidden');
    }
    
    if (configPlaceholder) {
      configPlaceholder.classList.add('hidden');
    }
    
    if (details.guessedConfig) {
      // 履歴復元中はAI列判定をスキップ（強制読み込み時も含む）
      if (window._historyRestoreInProgress || window._historyColumnSelections || forceLoad) {
        if (forceLoad) {
          console.log('🔄 強制読み込み時: AI列判定をスキップして履歴設定を優先');
        } else {
          console.log('🛡️ 履歴復元中のため、AI列判定をスキップしました');
        }
        console.log('🔍 Skip flags:', {
          historyRestoreInProgress: window._historyRestoreInProgress,
          historyColumnSelections: !!window._historyColumnSelections,
          forceLoad: forceLoad
        });
      } else {
        // DOMの更新が完了するのを待ってからpopulateConfigを呼び出す
        setTimeout(() => {
          // 遅延実行時にも再度チェック
          if (window._historyRestoreInProgress || window._historyColumnSelections) {
            console.log('🛡️ 遅延実行時: 履歴復元中のため、AI列判定をスキップしました');
            return;
          }
          populateConfig(details.guessedConfig);
          
          // Enhanced auto-detection success message with specifics
          const detectedColumns = [];
          if (details.guessedConfig.opinionColumn) detectedColumns.push('回答列: ' + details.guessedConfig.opinionColumn);
          if (details.guessedConfig.nameColumn) detectedColumns.push('名前列: ' + details.guessedConfig.nameColumn);
          if (details.guessedConfig.classColumn) detectedColumns.push('クラス列: ' + details.guessedConfig.classColumn);
          
          const message = detectedColumns.length > 0 
            ? ('🤖 AI列判定が自動実行されました！検出された列: ' + detectedColumns.join(', ') + '。設定を確認してください。')
            : '🤖 AI列判定が自動実行されました。設定を確認してください。';
          
          showMessage(message, 'success');
        }, 0);
      }
    }
    
    // 成功時の戻り値を返す
    return {
      success: true,
      headers: details.allHeaders,
      guessedConfig: details.guessedConfig || null,
      message: 'シート設定の読み込みが完了しました'
    };
  } else {
    logWarn('No headers in sheet details:', details);
    showMessage('シートの詳細情報を取得できませんでした。', 'warning');
    
    // エラー時の戻り値を返す
    return {
      success: false,
      error: 'シートの詳細情報を取得できませんでした',
      details: details
    };
  }
}

// Handle sheet details loading error
function handleSheetDetailsError(error) {
  logError('Sheet details failed:', error);
  handleError(error, 'loadConfigForSelected', 'シート情報の読み込みに失敗しました。');
}

// =============================================================================
// AI COLUMN DETECTION
// =============================================================================

// Run AI-powered header guessing
function runHeaderGuessing() {
  if (!selectedSheet) {
    showMessage('シートを選択してください。', 'warning');
    return;
  }
  
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return;
  }
  
  // Update button state to show AI is working
  const reguessBtn = document.getElementById('reguess-headers-btn');
  if (reguessBtn) {
    const originalContent = reguessBtn.innerHTML;
    reguessBtn.disabled = true;
    reguessBtn.innerHTML = `
      <span class="relative z-10 flex items-center gap-1">
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        <span class="text-xs font-bold">AI分析中</span>
      </span>
    `;
    
    // Restore button after completion
    const restoreButton = () => {
      reguessBtn.disabled = false;
      reguessBtn.innerHTML = originalContent;
    };
    
    // Show start notification
    showMessage('🤖 高精度AI判定システムが起動しました。データを分析中...', 'info');
    
    runGasWithUserId('getSheetDetails', 'AI搭載高精度列判定システムが分析中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(function(details) {
        if (!details || !details.guessedConfig) {
          restoreButton();
          showMessage('❌ AI列判定が失敗しました。手動で列を設定してください。', 'warning');
          return;
        }
        
        const configToUse = {
          ...details.guessedConfig,
          sheetName: selectedSheet
        };
        
        setTimeout(() => {
          populateConfig(configToUse);
          restoreButton();
          
          // Enhanced completion notification with analysis details
          const detectedColumns = [];
          if (configToUse.opinionColumn) detectedColumns.push('💬 回答列: ' + configToUse.opinionColumn);
          if (configToUse.nameColumn) detectedColumns.push('👤 名前列: ' + configToUse.nameColumn);
          if (configToUse.classColumn) detectedColumns.push('🏫 クラス列: ' + configToUse.classColumn);
          if (configToUse.reasonColumn) detectedColumns.push('💭 理由列: ' + configToUse.reasonColumn);
          
          const message = detectedColumns.length > 0 
            ? ('🎉 高精度AI判定が完了しました！\n\n検出された列:\n' + detectedColumns.join('\n') + '\n\n設定を保存して公開してください。')
            : '🎉 高精度AI判定が完了しました！設定を保存して公開してください。';
          
          showMessage(message, 'success');
          
          // ✨ 重要: AI判定完了後の処理
          setTimeout(() => {
            console.log('🚀 AI判定完了 - 後処理を開始');
            
            // セットアップ状態を確認して必要な場合のみ実行
            if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
              const config = typeof currentStatus.userInfo.configJson === 'string' 
                ? JSON.parse(currentStatus.userInfo.configJson) 
                : currentStatus.userInfo.configJson;
              
              if (config.setupStatus === 'pending' || !config.formCreated) {
                console.log('🔧 セットアップ未完了状態を検出 - 処理を実行');
                completeAIDetectionProcess();
              } else {
              }
            } else {
              console.log('🔧 ステータス情報が不明 - 念のため処理を実行');
              completeAIDetectionProcess();
            }
          }, 1000);
        }, 100);
      })
      .catch(function(error) {
        restoreButton();
        console.error('AI column detection error:', error);
        
        // Enhanced error message with specific guidance
        let errorMessage = '❌ 高精度AI判定システムでエラーが発生しました。\n\n';
        if ((error && error.message && error.message.includes('permission')) || (error && error.message && error.message.includes('権限'))) {
          errorMessage += '📋 スプレッドシートへのアクセス権限を確認してください。';
        } else if ((error && error.message && error.message.includes('network')) || (error && error.message && error.message.includes('timeout'))) {
          errorMessage += '🌐 ネットワーク接続を確認して再試行してください。';
        } else {
          errorMessage += '⚙️ 手動で列を設定するか、再度お試しください。';
        }
        
        errorMessage += '\n\n💡 問題が続く場合は、管理者にお問い合わせください。';
        
        showMessage(errorMessage, 'error');
      });
  }
}

// ✨ AI判定完了後の自動セットアップ完了処理
function completeAIDetectionProcess() {
  try {
    console.log('🔧 AI判定完了 - 設定保存処理を実行中...');
    
    // 1. 設定検証
    if (!validateConfig()) {
      console.warn('⚠️ AI判定結果の設定が不完全 - 手動設定が必要');
      showMessage('AI判定結果を確認してください。設定に不備があります。', 'warning');
      return;
    }
    
    // 2. フォームURL検出・作成の実行
    
    runGasWithUserId('detectFormUrlFromSpreadsheet', 'フォーム検出中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(result => {
        console.log('📋 フォーム検出結果受信');
        
        if (result && result.success && result.formUrl) {
          
          // 3. 設定の自動保存と完了状態への更新
          const config = buildConfigObject();
          config.formUrl = result.formUrl;
          config.formCreated = true;
          config.setupStatus = 'completed';
          
          console.log('💾 AI判定完了後の設定を自動保存中...', config);
          
          // Save draft to session storage when AI prediction is completed
          const draftData = {
            questionText: config.opinionHeader || config.opinionColumn || '（問題文未設定）',
            sheetName: selectedSheet,
            config: config,
            displayMode: (function() { const el = document.getElementById('anonymous-mode'); return el && el.checked ? 'anonymous' : 'named'; })(),
            countDisplay: 'show' // Default, could be configured based on UI settings
          };
          
          saveDraftToSession(draftData);
          console.log('📝 下書きをセッションに保存しました:', draftData.questionText);
          
          return runGasWithUserId('saveSheetConfig', '設定保存中...', currentStatus.userInfo.spreadsheetId, selectedSheet, config);
        } else {
          throw new Error('フォームURLの検出に失敗しました');
        }
      })
      .then(saveResult => {
        if (saveResult && saveResult.success) {
          showMessage('🎉 AI判定が完了しました！設定を保存して公開してください。', 'success');
          
          // 4. UI状態の更新
          if (typeof loadSystemStatus === 'function') {
            loadSystemStatus();
          }
          
          // 5. ステップ表示の更新
          if (typeof navigateToStep === 'function') {
            navigateToStep(2); // ステップ2（AI列分析完了）に進む
          }

          // 6. 手動公開を促すメッセージ表示（自動公開は削除）

        } else {
          throw new Error((saveResult && saveResult.message) || '設定の保存に失敗しました');
        }
      })
      .catch(error => {
        console.error('❌ AI判定完了処理でエラー:', error);
        showMessage('⚠️ AI判定後の処理でエラーが発生しました: ' + error.message + '\n手動で「保存・公開」を実行してください。', 'warning');
      });
      
  } catch (error) {
    console.error('❌ completeAIDetectionProcess 致命的エラー:', error);
    showMessage('AI判定処理でエラーが発生しました。手動で設定を確認してください。', 'error');
  }
}

// ✨ 設定初期化統一機能
// 実行状態の管理
let initializationInProgress = false;
let lastInitializationTime = 0;
const INITIALIZATION_COOLDOWN = 30000; // 30秒のクールダウン

/**
 * 統一設定初期化機能
 * 自動診断→軽微修復→必要に応じて完全リセットの段階的アプローチ
 */
function initializeUserSettings() {
  return new Promise((resolve, reject) => {
    try {
      // 重複実行防止チェック
      const now = Date.now();
      if (initializationInProgress) {
        resolve({ 
          success: false, 
          message: '設定初期化が既に実行中です', 
          skipped: true, 
          reason: 'already_running' 
        });
        return;
      }
      
      // クールダウンチェック
      if (now - lastInitializationTime < INITIALIZATION_COOLDOWN) {
        const remainingTime = Math.ceil((INITIALIZATION_COOLDOWN - (now - lastInitializationTime)) / 1000);
        resolve({ 
          success: false, 
          message: 'あと' + remainingTime + '秒後に実行可能です', 
          skipped: true, 
          reason: 'cooldown', 
          remainingTime 
        });
        return;
      }
      
      initializationInProgress = true;
      lastInitializationTime = now;
      
      console.log('🔄 設定初期化を開始...');
      
      // フェーズ1: 自動診断
      performSystemDiagnostic()
        .then(diagnosticResult => {
          if (diagnosticResult.severity === 'none') {
            // 問題なし
            initializationInProgress = false;
            resolve({
              success: true,
              phase: 'diagnostic',
              message: '✅ 設定に問題は見つかりませんでした',
              issues: [],
              fixes: []
            });
          } else if (diagnosticResult.severity === 'minor') {
            // 軽微な問題 - 自動修復実行
            return performAutoRepair();
          } else {
            // 重大な問題 - ユーザーに選択を委ねる
            initializationInProgress = false;
            resolve({
              success: false,
              phase: 'needs_confirmation',
              message: '重大な設定問題が見つかりました。完全な初期化が必要です。',
              severity: diagnosticResult.severity,
              issues: diagnosticResult.issues,
              requiresFullReset: true
            });
          }
        })
        .then(repairResult => {
          if (repairResult) {
            initializationInProgress = false;
            resolve({
              success: true,
              phase: 'auto_repair',
              message: '🔧 ' + (repairResult.fixes?.length || 0) + '件の問題を自動修復しました',
              issues: repairResult.issues || [],
              fixes: repairResult.fixes || []
            });
          }
        })
        .catch(error => {
          initializationInProgress = false;
          reject(new Error('設定初期化エラー: ' + error.message));
        });
        
    } catch (error) {
      initializationInProgress = false;
      reject(error);
    }
  });
}

/**
 * UI付き設定初期化実行関数
 * ユーザーインタラクションとプログレス表示を含む
 */
function initializeUserSettingsWithUI() {
  const button = document.getElementById('initialize-settings-btn');
  const originalHTML = button ? button.innerHTML : '';
  
  // ボタンの状態を「処理中」に変更
  if (button) {
    button.disabled = true;
    button.innerHTML = `
      <svg class="w-3 h-3 animate-spin" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      診断中...
    `;
  }
  
  // プログレス表示
  showMessage('🔍 システム診断を開始しています...', 'info');
  
  initializeUserSettings()
    .then(result => {
      // ボタンを元の状態に戻す
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHTML;
      }
      
      if (result.success) {
        // 成功時の処理
        if (result.phase === 'diagnostic') {
          showMessage(result.message, 'success');
        } else if (result.phase === 'auto_repair') {
          showMessage(result.message, 'success');
          if (result.fixes.length > 0) {
            console.log('🔧 修復された問題:', result.fixes);
          }
        }
      } else {
        // 確認が必要な場合
        if (result.requiresFullReset) {
          const issuesList = result.issues.map(issue => '• ' + issue).join('\n');
          
          showConfirmationModal(
            '設定の完全初期化が必要です',
            '以下の問題が見つかりました:\n\n' + issuesList + '\n\n設定を完全に初期化しますか？\n（アカウントは削除されません）',
            () => {
              // ユーザーが確認した場合、完全リセットを実行
              performFullReset()
                .then(resetResult => {
                  if (resetResult.success) {
                    showMessage('✅ 設定が正常に初期化されました', 'success');
                    // ページをリロードして最新状態を反映
                    setTimeout(() => location.reload(), 1500);
                  } else {
                    showMessage('❌ 設定初期化に失敗しました', 'error');
                  }
                })
                .catch(error => {
                  console.error('Full reset failed:', error);
                  showMessage('❌ 設定初期化中にエラーが発生しました', 'error');
                });
            }
          );
        } else {
          showMessage(result.message, 'warning');
        }
      }
    })
    .catch(error => {
      // ボタンを元の状態に戻す
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHTML;
      }
      
      console.error('Settings initialization failed:', error);
      showMessage('❌ 設定初期化中にエラーが発生しました', 'error');
    });
}

/**
 * システム診断（問題の重要度を判定）
 */
function performSystemDiagnostic() {
  return new Promise((resolve) => {
    try {
      if (!currentStatus || !currentStatus.userInfo) {
        resolve({ severity: 'critical', issues: ['ユーザー情報が利用できません'] });
        return;
      }
      
      const config = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
        
      const issues = [];
      let maxSeverity = 'none';
      
      // 軽微な問題の検出
      const minorIssues = detectMinorIssues(config);
      if (minorIssues.length > 0) {
        issues.push(...minorIssues);
        maxSeverity = 'minor';
      }
      
      // 重大な問題の検出
      const criticalIssues = detectCriticalIssues(config);
      if (criticalIssues.length > 0) {
        issues.push(...criticalIssues);
        maxSeverity = 'critical';
      }
      
      resolve({
        severity: maxSeverity,
        issues: issues
      });
      
    } catch (error) {
      resolve({ 
        severity: 'critical', 
        issues: ['診断エラー: ' + error.message] 
      });
    }
  });
}

/**
 * 軽微な問題の検出
 */
function detectMinorIssues(config) {
  const issues = [];
  
  // 既存の修復ルールから軽微なものを抽出
  if (config.formUrl && config.formUrl.trim() && !config.formCreated) {
    issues.push('フォームURLが存在するが作成フラグがfalse');
  }
  
  if (config.formCreated && config.setupStatus !== 'completed') {
    issues.push('フォーム作成済みだがセットアップ状態が未完了');
  }
  
  if (config.appPublished && config.setupStatus === 'pending') {
    issues.push('公開済みだがセットアップ状態がpending');
  }
  
  if (currentStatus.sheetDetails?.guessedConfig?.opinionHeader && config.setupStatus === 'pending') {
    issues.push('AI列判定完了済みだがセットアップ状態がpending');
  }
  
  return issues;
}

/**
 * 重大な問題の検出
 */
function detectCriticalIssues(config) {
  const issues = [];
  
  // 設定が完全に破損している場合
  if (!config || typeof config !== 'object') {
    issues.push('設定データが破損しています');
  }
  
  // 必須フィールドが欠落している場合
  if (config && !config.hasOwnProperty('setupStatus')) {
    issues.push('セットアップ状態情報が欠落しています');
  }
  
  return issues;
}

/**
 * 自動修復の実行
 */
function performAutoRepair() {
  return new Promise((resolve, reject) => {
    // 既存のrepairSetupStateInconsistencies()の核心部分を使用
    repairSetupStateInconsistencies()
      .then(result => resolve(result))
      .catch(error => reject(error));
  });
}

/**
 * 完全リセットの実行（確認済み）
 */
function performFullReset() {
  return new Promise((resolve, reject) => {
    runGasWithUserId('resetConfigJson', '設定を完全初期化中...')
      .then(result => {
        if (result.success) {
          resolve({
            success: true,
            phase: 'full_reset',
            message: '✅ 設定を完全に初期化しました',
            resetAt: result.resetAt
          });
        } else {
          reject(new Error(result.message || '完全初期化に失敗しました'));
        }
      })
      .catch(error => reject(error));
  });
}

// ✨ レガシー診断・修復機能（後方互換性のため残存）
// 診断実行状態の管理
let diagnosticInProgress = false;
let lastDiagnosticTime = 0;
const DIAGNOSTIC_COOLDOWN = 30000; // 30秒のクールダウン

function repairSetupStateInconsistencies() {
  return new Promise((resolve, reject) => {
    try {
      // 重複実行防止チェック
      const now = Date.now();
      if (diagnosticInProgress) {
        resolve({ issues: [], fixes: [], skipped: true, reason: 'already_running' });
        return;
      }
      
      // クールダウンチェック
      if (now - lastDiagnosticTime < DIAGNOSTIC_COOLDOWN) {
        const remainingTime = Math.ceil((DIAGNOSTIC_COOLDOWN - (now - lastDiagnosticTime)) / 1000);
        console.log('⏳ クールダウン中です。あと' + remainingTime + '秒後に実行可能です。');
        resolve({ issues: [], fixes: [], skipped: true, reason: 'cooldown', remainingTime });
        return;
      }
      
      diagnosticInProgress = true;
      lastDiagnosticTime = now;
      console.log('🔧 セットアップ状態の診断・修復を開始...');
      
      if (!currentStatus || !currentStatus.userInfo) {
        diagnosticInProgress = false;
        reject(new Error('ユーザー情報が利用できません'));
        return;
      }
      
      const config = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
        
      const issues = [];
      const fixes = [];
      
      // 1. フォームURL vs formCreated の整合性チェック
      if (config.formUrl && config.formUrl.trim() && !config.formCreated) {
        issues.push('フォームURLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正');
      }
      
      // 2. formCreated vs setupStatus の整合性チェック
      if (config.formCreated && config.setupStatus !== 'completed') {
        issues.push('フォームが作成済みだが setupStatus != completed');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正');
      }
      
      // 3. スプレッドシートIDとactiveSheetNameの整合性チェック
      if (currentStatus.userInfo.spreadsheetId && !currentStatus.activeSheetName && selectedSheet) {
        issues.push('スプレッドシートが存在するが activeSheetName が未設定');
        // これはconfigではなくstatusの問題なので、バックエンドで修正が必要
        fixes.push('activeSheetName の更新が必要（要バックエンド処理）');
      }
      
      // 4. 公開状態の整合性チェック（publishedSheetName vs appPublished）
      if (config.publishedSheetName && !config.appPublished) {
        issues.push('公開シート名が存在するが appPublished=false');
        // これは慎重に判断する必要があるため、警告のみ
        fixes.push('注意: 公開状態の確認が必要');
      }
      
      // 5. 🔧 新ルール: appPublished=true だが setupStatus='pending' の場合（公開済み不整合）
      if (config.appPublished && config.setupStatus === 'pending') {
        issues.push('公開済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（既に公開済みのため）');
      }
      
      // 6. 🔧 新ルール: 公開URLが存在するが formCreated=false の場合
      if (currentStatus.viewUrl && currentStatus.viewUrl.trim() && !config.formCreated) {
        issues.push('公開URLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正（公開URL存在のため）');
      }
      
      // 7. 🔧 新ルール: isPublished=true だが setupStatus='pending' の場合（システム状態不整合）
      if (currentStatus.isPublished && config.setupStatus === 'pending') {
        issues.push('システムで公開済み判定だが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（公開状態確認済み）');
      }
      
      // 8. 🔧 新ルール: AI判定結果が存在するがsetupStatus='pending'の場合（AI完了後の状態更新漏れ）
      if (currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig && 
          currentStatus.sheetDetails.guessedConfig.opinionHeader && 
          config.setupStatus === 'pending') {
        issues.push('AI列判定完了済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        config.formCreated = true; // AI判定完了時はフォームも準備完了とみなす
        fixes.push('AI判定完了に基づいてセットアップ状態を完了に更新');
      }
      
      
      if (fixes.length === 0) {
        diagnosticInProgress = false;
        resolve({
          success: true,
          message: '✅ セットアップ状態に問題は見つかりませんでした',
          issues: [],
          fixes: []
        });
        return;
      }
      
      // 修正された設定を保存
      console.log('💾 修正された設定を保存中...', config);

        runGasWithUserId('syncConfigurationState', '設定修復中...', config, 'repair')
        .then(saveResult => {
          if (saveResult && saveResult.success) {
            
            // UI状態の更新
            if (typeof loadSystemStatus === 'function') {
              loadSystemStatus();
            }
            
            diagnosticInProgress = false;
            resolve({
              success: true,
              message: '🔧 ' + fixes.length + '件のセットアップ問題を修復しました',
              issues,
              fixes
            });
          } else {
            diagnosticInProgress = false;
            reject(new Error((saveResult && saveResult.message) || '設定の保存に失敗しました'));
          }
        })
        .catch(saveError => {
          diagnosticInProgress = false;
          reject(new Error('設定保存エラー: ' + saveError.message));
        });
        
    } catch (error) {
      console.error('❌ セットアップ状態修復でエラー:', error);
      diagnosticInProgress = false;
      reject(error);
    }
  });
}

// Note: runSetupRepair function has been replaced by initializeUserSettingsWithUI

// =============================================================================
// SAVE AND PUBLISH OPERATIONS
// =============================================================================

// Save configuration and publish board - 最適化版（進捗表示付き）
function saveAndPublish() {
  if (!validateConfig()) {
    showMessage('必須項目（回答データ列）が選択されていません。', 'error');
    return;
  }
  
  // 進捗表示開始 - 既存のisSaveInProgressフラグを活用
  if (isSaveInProgress) {
    showMessage('⚠️ 他の保存処理が実行中です。しばらくお待ちください。', 'warning');
    return;
  }
  
  // ドラフトモードが有効な場合は、公開前に実際の公開情報を更新
  if (window._draftModeActive) {
    console.log('📝 ドラフトモードから公開へ移行中...');
    
    // ドラフトモードを終了
    window._draftModeActive = false;
    
    // ドラフトインジケーターを非表示
    if (window.HistoryManager && typeof window.HistoryManager._hideDraftModeIndicator === 'function') {
      window.HistoryManager._hideDraftModeIndicator();
    }
    
    console.log('✅ ドラフトモードが終了しました。公開を実行します。');
  }
  
  // 進捗インジケータ表示
  showMessage('🔄 設定を保存しています...（数分かかる場合があります）', 'info');
  
  // UIからconfigオブジェクトを構築
  const config = buildConfigObject();
  
  // 自動停止設定を準備
  const autoStopSettings = {
    enabled: true,
    minutes: 360 // 6時間 = 360分（config.gsと統一）
  };
  
  // Check for privacy-sensitive settings and show warning if enabled
  const showNamesEl = document.getElementById('show-names');
  const showNames = (showNamesEl && showNamesEl.checked) || false;
  const showCountsEl = document.getElementById('show-counts');
  const showCounts = (showCountsEl && showCountsEl.checked) || false;
  
  if (showNames || showCounts) {
    // Show privacy warning modal first
    if (window.sharedModals) {
      const privacySettings = [];
      if (showNames) privacySettings.push('名前表示');
      if (showCounts) privacySettings.push('リアクション数表示');
      
      console.log('⚠️ プライバシー警告: ' + privacySettings.join('・') + 'が有効です');
      
      window.sharedModals.showPrivacyWarning(
        // onConfirm - show publish modal after privacy confirmation
        () => {
          showPublishModalAfterChecks(config, autoStopSettings);
        },
        // onCancel - user wants to review settings
        () => {
          console.log('❌ ユーザーがプライバシー設定の見直しを選択');
          showMessage('設定を見直してから再度お試しください。', 'info');
        }
      );
      return;
    }
  }
  
  // If no privacy concerns, show publish modal directly
  showPublishModalAfterChecks(config, autoStopSettings);
}

// 公開モーダル表示（プライバシーチェック後）
function showPublishModalAfterChecks(config, autoStopSettings) {
  if (window.sharedModals && typeof window.sharedModals.showPublish === 'function') {
    window.sharedModals.showPublish(
      // 公開実行時のコールバック
      () => {
        console.log('📤 公開モーダルで公開が選択されました');
        proceedWithSaveAndPublish(config);
      },
      // キャンセル時のコールバック
      () => {
        console.log('❌ 公開がキャンセルされました');
      },
      // 自動停止設定
      autoStopSettings
    );
  } else {
    // フォールバック: モーダルが利用できない場合は直接実行
    console.warn('⚠️ 公開モーダルが利用できません。直接実行します。');
    proceedWithSaveAndPublish(config);
  }
}

// Proceed with the actual save and publish operation
function proceedWithSaveAndPublish(config) {

  // Set save protection flags to prevent interference
  isSaveInProgress = true;
  freshSaveTimestamp = Date.now();
  window.freshSaveTimestamp = freshSaveTimestamp;
  
  runGasWithUserId('saveAndPublish', '設定を保存し、ボードを公開しています...', selectedSheet, config)
    .then(function(result) {
      isSaveInProgress = false;
      
      // Check if result has data (from integrated API) or legacy success status
      if (result && (result.userInfo || result.status === 'success')) {
        showMessage('✅ 設定が保存され、ボードが公開されました！', 'success');
        
        // 履歴に保存（公開時）- シンプル版
        if (typeof addToSimpleHistory === 'function') {
          const questionText = config.opinionHeader || config.opinionColumn || 'デフォルト問題文';
          const historyItem = {
            questionText: questionText,
            displayMode: document.getElementById('show-names')?.checked ? 'NAMED' : 'ANONYMOUS',
            configData: result.userInfo?.configJson ? JSON.parse(result.userInfo.configJson) : {}
          };
          addToSimpleHistory(historyItem);
        }
        
        // ボードビューアーに即座更新を通知
        try {
          // メインウィンドウにメッセージを送信（あれば）
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            }, '*');
            logInfo('ボード公開メッセージをメインウィンドウに送信');
          }
          
          // 同じドメインの他のタブにも通知
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            });
            channel.close();
            logInfo('ボード公開メッセージをBroadcastChannelで送信');
          }
        } catch (broadcastError) {
          console.warn('リアルタイム更新通知でエラー:', broadcastError);
        }
        
        // 6時間自動停止の確認モーダルを表示
        setTimeout(() => {
          // ローディングオーバーレイを確実に非表示にしてからモーダル表示
          if (window.unifiedLoadingManager) {
            window.unifiedLoadingManager.setLoading(false);
          }
          
          // 公開完了確認とURL生成後に自動停止確認モーダルを表示
          setTimeout(() => {
            // 公開状態とURL生成の確認
            if (result && (result.publishedAt || result.userInfo)) {
              const publishResult = {
                publishedAt: result.publishedAt || new Date().toISOString(),
                autoStopMinutes: result.autoStopMinutes || 360,
                boardUrl: result.boardUrl || result.viewUrl || '',
                status: 'success',
                ...result
              };
              
              console.log('📊 通常公開完了データ確認完了');
              
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(publishResult);
              } else {
                console.warn('⚠️ 自動停止確認モーダルが利用できません');
              }
            } else {
              console.warn('⚠️ 通常公開結果データが不完全のため、自動停止モーダルをスキップします:', result);
            }
          }, 800); // URL生成待ちのため少し長めに設定
        }, 2000); // 成功メッセージの後に表示
        
        // Use fresh data from save response if available
        if (result.userInfo && result._meta) {
          logInfo('Using fresh data from save response');
          updateUIWithNewStatus(result);
        } else {
          // Only force refresh if no fresh data available
          logInfo('No fresh data in response, forcing refresh');
          loadStatus(true).then(() => {
            // ステップ進行を更新
            const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
            updateStepIndicators(currentStep);
            manageSectionStates(currentStep);
          });
        }
      } else {
        logError('Save failed:', result);
        showMessage(result.message || '設定の保存に失敗しました。', 'error');
        isSaveInProgress = false;
      }
    })
    .catch(function(error) {
      logError('saveAndPublish error:', error);
      isSaveInProgress = false;
      
      // 統一キャッシュクリア（エラー後）
      cacheManager.clearAllFrontendCaches().catch(clearError => {
        console.warn('Cache clear after error failed:', clearError);
      });
      
      loadStatus(true).then(() => {
        // エラー後もステップ進行を更新
        const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
        updateStepIndicators(currentStep);
        manageSectionStates(currentStep);
      });
      handleError(error, 'saveAndPublish', '設定の保存に失敗しました。システム状態を再読み込みしました。');
    });
}

/**
 * 公開停止時の強化されたキャッシュクリア処理
 * キャッシュ関連のアクセス問題を防ぐため、あらゆるキャッシュを完全にクリア
 */
async function clearAllCachesForUnpublish() {
  console.log('🧹 公開停止時の包括的キャッシュクリア処理を開始');
  
  try {
    // 1. 既存の安定したキャッシュクリア方式
    // 統一キャッシュクリア
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      window.unifiedCache.clear();
    }
    
    // GAS最適化キャッシュクリア
    if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
      window.gasOptimizer.clearCache();
    }
    
    // SharedUtilitiesキャッシュクリア
    if (window.sharedUtilities && window.sharedUtilities.cache && typeof window.sharedUtilities.cache.clear === 'function') {
      window.sharedUtilities.cache.clear();
    }
    
    // DOM要素キャッシュクリア
    if (window.sharedUtilities && window.sharedUtilities.dom && typeof window.sharedUtilities.dom.clearElementCache === 'function') {
      window.sharedUtilities.dom.clearElementCache();
    }
    
    // 2. ローカルストレージのキャッシュクリア（StudyQuest関連のみ、履歴保護）
    try {
      const localStorageKeys = Object.keys(localStorage);
      const historyKeys = ['answerBoardHistory', 'adminPanelHistory']; // 履歴保護キー
      
      const studyQuestKeys = localStorageKeys.filter(key => 
        (key.includes('studyquest') || 
         key.includes('board') || 
         key.includes('sheet') ||
         key.includes('admin') ||
         key.includes('publication') ||
         key.includes('answer')) &&
        !historyKeys.includes(key) // 履歴キーは除外
      );
      
      studyQuestKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      console.log('✅ Cache cleared while preserving history keys:', historyKeys);
      
    } catch (e) {
      console.warn('⚠️ localStorage clear warning:', e);
    }
    
    // 3. セッションストレージのクリア
    try {
      if (window.sessionStorage) {
        const sessionKeys = Object.keys(sessionStorage);
        const studyQuestSessionKeys = sessionKeys.filter(key => 
          key.includes('studyquest') || 
          key.includes('board') || 
          key.includes('admin')
        );
        
        studyQuestSessionKeys.forEach(key => {
          sessionStorage.removeItem(key);
        });
        
      }
    } catch (e) {
      console.warn('⚠️ sessionStorage clear warning:', e);
    }
    
    // 4. BroadcastChannel通知（他のタブに公開停止を通知）
    try {
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.postMessage({
          type: 'BOARD_UNPUBLISHED',
          timestamp: Date.now(),
          userId: window.userId || 'unknown'
        });
        channel.close();
      }
    } catch (e) {
      console.warn('⚠️ BroadcastChannel notification warning:', e);
    }
    
    // 5. グローバル変数の条件付きクリア（公開停止時のみ）
    try {
      console.log('🔧 Conditional global variable clear for unpublish');
      
      // currentSpreadsheetUrlのクリア（公開停止時のみ）
      if (typeof currentSpreadsheetUrl !== 'undefined') {
        const oldUrl = currentSpreadsheetUrl;
        currentSpreadsheetUrl = '';
        console.log('✅ currentSpreadsheetUrl cleared for unpublish:', oldUrl);
      }
      
      // window.currentStatusのクリア（公開停止時のみ）
      if (window.currentStatus) {
        window.currentStatus = null;
        console.log('✅ window.currentStatus cleared for unpublish');
      }
      
      // その他のURL関連グローバル変数のクリア
      if (typeof webAppUrl !== 'undefined') {
        webAppUrl = '';
        console.log('✅ webAppUrl cleared');
      }
      
      if (typeof currentActiveSheet !== 'undefined') {
        currentActiveSheet = '';
        console.log('✅ currentActiveSheet cleared');
      }
      
    } catch (e) {
      console.warn('⚠️ Global variables clear warning:', e);
    }
    
    // 6. キャッシュ無効化のためのタイムスタンプ更新
    try {
      localStorage.setItem('lastUnpublishTime', Date.now().toString());
      localStorage.setItem('cacheInvalidationToken', Math.random().toString(36));
    } catch (e) {
      console.warn('⚠️ Cache invalidation token update warning:', e);
    }
    
    
  } catch (error) {
    console.error('❌ キャッシュクリア処理でエラー:', error);
    // エラーがあっても処理は継続
  }
}

// Unpublish board
function unpublishBoard() {
    return runGasWithUserId('unpublishBoard', 'ボードの公開を停止中...')
      .then(async function(response) {
        logDebug('公開停止レスポンス:', response);

        // 最適化された状態クリア順序：
        // 1. まずサーバー側の公開停止処理が成功したことを確認
        console.log('✅ サーバー側公開停止完了、クライアント側クリア開始');
        
        // 2. 強化されたキャッシュクリア処理（非同期で確実に実行）
        try {
          await clearAllCachesForUnpublish();
          console.log('✅ 包括的キャッシュクリア完了');
        } catch (clearError) {
          console.warn('⚠️ キャッシュクリア中にエラー:', clearError);
          // クリア失敗でも処理は継続
        }

        // 3. UI状態のリセット（カラム選択等）
        try {
          resetColumnSelections();
          console.log('✅ カラム選択リセット完了');
        } catch (resetError) {
          console.warn('⚠️ カラム選択リセット中にエラー:', resetError);
        }

        // 4. 短い遅延でDOM状態を安定化
        await new Promise(resolve => setTimeout(resolve, 100));

        // 公開停止処理が成功したことを返す
        return Promise.resolve(response);
      })
      .catch(function(error) {
        handleError(error, 'unpublishBoard', 'ボードの公開停止に失敗しました。');
        // エラーを再スローして呼び出し元でキャッチできるようにする
        return Promise.reject(error);
      });
  }

  // シンプル履歴保存関数（公開時）
  async function saveHistoryOnPublish(publishResponse, config) {
    try {
      const userInfo = publishResponse.userInfo || {};
      
      // スプレッドシート作成日を取得
      let createdDate = null;
      if (userInfo.spreadsheetId) {
        try {
          const createdDateResponse = await runGasWithUserId('getSpreadsheetCreatedDateAPI', false);
          if (createdDateResponse && createdDateResponse.status === 'success') {
            createdDate = createdDateResponse.createdDate;
          }
        } catch (error) {
          console.warn('⚠️ 作成日取得失敗:', error);
        }
      }
      
      // シンプル履歴エントリ作成
      await createSimpleHistoryEntry(publishResponse, config, userInfo, createdDate);
      
      logDebug('✅ シンプル履歴保存完了（公開時）');
    } catch (error) {
      logWarn('⚠️ 公開時の履歴保存に失敗:', error);
    }
  }
  
  /**
   * シンプル履歴エントリ作成
   * @param {Object} publishResponse - 公開API応答
   * @param {Object} config - フォーム設定
   * @param {Object} userInfo - ユーザー情報
   * @param {string} createdDate - スプレッドシート作成日
   */
  async function createSimpleHistoryEntry(publishResponse, config, userInfo, createdDate) {
    try {
      // 現在のUI状態から設定取得（showNamesベース）
      const getShowNames = () => {
        const showNamesCheckbox = document.getElementById('show-names');
        return (showNamesCheckbox && showNamesCheckbox.checked) || false;
      };
      
      const getShowCounts = () => {
        const showCountsCheckbox = document.getElementById('show-counts');
        return (showCountsCheckbox && showCountsCheckbox.checked) || false;
      };
      
      // 問題文を複数ソースから取得
      const questionText = config.opinionHeader ||
                          config.opinionColumn ||
                          userInfo.customFormInfo?.mainQuestion ||
                          'デフォルト問題文';
      
      // シンプルな履歴アイテム構造
      // 履歴保存前の詳細ログ
      console.log('📝 Creating history item with:', {
        questionText: questionText,
        selectedSheet: selectedSheet,
        activeSheetName: publishResponse.activeSheetName,
        spreadsheetId: userInfo.spreadsheetId,
        finalSheetName: publishResponse.activeSheetName || selectedSheet || ''
      });
      
      const historyItem = {
        id: generateHistoryId(),
        createdDate: createdDate,
        publishedAt: publishResponse.publishedAt || new Date().toISOString(),
        questionText: questionText,
        setupType: getSetupType(),
        
        // 復元用の最小データ（showNames/showCountsベース）
        opinionHeader: config.opinionHeader || '',
        nameHeader: config.nameHeader || '名前',
        showNames: getShowNames(),      // UI状態を直接保存
        showCounts: getShowCounts(),    // UI状態を直接保存
        
        // 復元用のシート情報
        sheetName: publishResponse.activeSheetName || selectedSheet || '',
        spreadsheetId: userInfo.spreadsheetId || ''
      };
      
      // 履歴に追加（5件制限）
      addToSimpleHistory(historyItem);
      
      console.log('✅ Simple history entry created:', historyItem.questionText);
      
    } catch (error) {
      console.error('❌ Simple history entry creation failed:', error);
    }
  }
  
  /**
   * シンプル履歴に追加（5件制限）
   * @param {Object} newItem - 新しい履歴アイテム
   */
  function addToSimpleHistory(newItem) {
    try {
      if (window.HistoryManager) {
        // Use new unified HistoryManager
        const success = window.HistoryManager.add(newItem);
        if (success) {
          console.log('✅ History saved using HistoryManager');
          // Update UI table
          window.HistoryManager.renderTable();
        } else {
          console.warn('⚠️ Failed to save history using HistoryManager');
        }
      } else {
        // Fallback to legacy method
        console.warn('⚠️ HistoryManager not available, using legacy method');
        const history = getHistoryFromStorage();
        
        // 先頭に追加
        history.unshift(newItem);
        
        // 5件に制限
        const limitedHistory = history.slice(0, 5);
        
        // 保存
        saveHistoryToStorage(limitedHistory);
        
        console.log('✅ History saved with ' + limitedHistory.length + ' items (max 5)');
        
        // テーブル更新
        if (typeof loadSimpleHistoryTable === 'function') {
          loadSimpleHistoryTable();
        }
      }
      
    } catch (error) {
      console.error('❌ Failed to add to simple history:', error);
    }
  }
  
  /**
   * セットアップタイプの取得
   * @returns {string} セットアップタイプ
   */
  function getSetupType() {
    // URLパラメータやセッション情報から判定
    if (sessionStorage.getItem('quickStartActive')) {
      return 'quickstart';
    }
    return 'custom';
  }
  
  /**
   * 履歴ID生成
   * @returns {string} 一意のID
   */
  function generateHistoryId() {
    return 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  // 古い複雑なcreateConsolidatedHistoryEntry関数は削除済み
  
  /**
   * Create history entry for QuickStart completion
   * @param {Object} quickStartResult - QuickStart completion result
   */
  function createQuickStartHistoryEntry(quickStartResult) {
    try {
      logDebug('Creating QuickStart history entry:', quickStartResult);
      
      // Extract question text from QuickStart config with better fallback
      const questionText = (quickStartResult.config && quickStartResult.config.opinionHeader) ||
                          (quickStartResult.config && quickStartResult.config.opinionColumn) ||
                          (quickStartResult.config && quickStartResult.config.reasonHeader) ||
                          (quickStartResult.config && quickStartResult.config.nameHeader) ||
                          'デフォルト問題文';
      
      console.log('📝 QuickStart question text extracted:', questionText);
      
      // Use completion time as both creation and publication time for QuickStart
      const completedAt = quickStartResult.completedAt || new Date().toISOString();
      const publishedAt = (quickStartResult.publishResult && quickStartResult.publishResult.publishedAt) || completedAt;
      
      // Create simplified QuickStart history entry
      const historyItem = {
        id: generateHistoryId(),
        createdDate: completedAt, // QuickStart creates and publishes simultaneously
        publishedAt: publishedAt,
        questionText: questionText,
        setupType: 'quickstart',
        opinionHeader: (quickStartResult.config && quickStartResult.config.opinionHeader) || '',
        nameHeader: (quickStartResult.config && quickStartResult.config.nameHeader) || '名前',
        showNames: false,   // QuickStartデフォルト: 名前表示OFF（匿名）
        showCounts: false,  // QuickStartデフォルト: リアクション数表示OFF
        sheetName: quickStartResult.sheetName || quickStartResult.publishedSheetName || '',
        spreadsheetId: quickStartResult.spreadsheetId || ''
      };
      
      addToSimpleHistory(historyItem);
      
      // Update UI - handled by addToSimpleHistory function
      // No need for additional UI update call here
      
      logDebug('QuickStart simple history entry created successfully:', {
        id: historyItem.id,
        questionText: historyItem.questionText,
        createdDate: historyItem.createdDate,
        publishedAt: historyItem.publishedAt,
        setupType: historyItem.setupType
      });
      
    } catch (error) {
      logError('Failed to create QuickStart history entry:', error);
    }
  }

// セットアップタイプを判定する補助関数
function determineSetupType(config, userInfo) {
  if (userInfo.customFormInfo) {
    return 'カスタムセットアップ';
  } else if (config.isQuickStart || config.setupType === 'quickstart') {
    return 'クイックスタート';
  } else if (config.isExternalResource) {
    return '外部リソース';
  } else {
    return 'unknown';
  }
}

// Reset column selection dropdowns to default state
function resetColumnSelections() {
  
  const columnSelects = [
    'opinion-column-select',
    'name-column-select', 
    'reason-column-select',
    'class-column-select',
    'timestamp-column-select'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.value = ''; // Reset to empty value
    }
  });
  
  // Also reset any display checkboxes
  const checkboxes = ['show-names', 'show-counts'];
  checkboxes.forEach(checkboxId => {
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      checkbox.checked = false;
    }
  });
}

// =============================================================================
// FORM MANAGEMENT
// =============================================================================

// Load saved class choices
function loadSavedClassChoices() {
    runGasWithUserId('getSavedClassChoices', 'クラス選択肢を読み込み中...')
        .then(function(result) {
            if (result.status === 'success' && result.classChoices) {
                const classChoicesTextarea = document.getElementById('class-choices');
                if (classChoicesTextarea) {
                    classChoicesTextarea.value = result.classChoices.join('\n');
                }
            }
        })
        .catch(function(error) {
            console.warn('保存されたクラス選択肢の読み込みに失敗:', error.message);
            showMessage('クラス選択肢の読み込みに失敗しました。', 'error');
        });
}

// Create form with custom configuration
/**
 * QuickStartと同じ形式のフォームタイトルを生成する。
 * @returns {string} フォームタイトル。
 */
function generateQuickstartFormTitle() {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
    timeZone: 'Asia/Tokyo'
  });
  const formatted = formatter.format(now);
  const [datePart, timePart] = formatted.split(' ');
  const [year, month, day] = datePart.split('/');
  return 'みんなの回答ボード ' + year + '年' + month + '月' + day + '日 ' + timePart;
}

function createFormWithConfig() {
  const questionTextarea = document.getElementById('custom-main-question');
  const questionTypeSelect = document.getElementById('main-question-type');
  const questionChoicesTextarea = document.getElementById('main-question-choices');
  const classChoicesTextarea = document.getElementById('class-choices');
  const includeOthersOption = document.getElementById('include-others-option').checked;
  const enableClassSelection = document.getElementById('enable-class-selection').checked;
  
  if (!questionTextarea || !questionTypeSelect) {
    showMessage('フォーム作成に必要な要素が見つかりません。', 'error');
    return;
  }
  
  const question = questionTextarea.value.trim();
  const questionType = questionTypeSelect.value; // 回答方法を取得
  const questionChoicesText = questionChoicesTextarea ? questionChoicesTextarea.value.trim() : '';
  const classChoicesText = enableClassSelection && classChoicesTextarea ? classChoicesTextarea.value.trim() : '';
  
  if (!question) {
    showMessage('問題文は必須です。', 'warning');
    return;
  }
  
  // 選択肢タイプの場合は選択肢が必要
  if ((questionType === 'choice' || questionType === 'multiple') && !questionChoicesText) {
    showMessage('選択肢タイプの場合は選択肢を入力してください。', 'warning');
    return;
  }
  
  // 選択肢を配列に変換
  const questionChoices = questionChoicesText ? 
    questionChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  // クラス選択肢を配列に変換  
  const classChoices = classChoicesText ? 
    classChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  const config = {
    mainQuestion: question,
    responseType: questionType, // 回答方法を追加
    questionChoices: questionChoices, // メイン質問の選択肢
    classChoices: classChoices,
    includeOthers: includeOthersOption,
    enableClass: enableClassSelection && classChoices.length > 0,
    formTitle: generateQuickstartFormTitle(),
  };
  
  console.log('📋 カスタムフォーム設定準備完了');
  
  hideFormConfigModal();
  
  // カスタムセットアップ用進捗表示を開始
  // Use the new unified custom setup system
  console.log('🎨 統合カスタムセットアップ開始');
  
  // userEmailは現在のユーザー情報から取得
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.adminEmail) {
    showMessage('ユーザー情報が取得できません。ページを再読み込みしてください。', 'error');
    return;
  }
  
  // Call the new unified custom setup handler - this replaces the old createCustomFormUI flow
  handleCustomSetup(config);
  
  // クラス選択肢をデータベースに保存
  saveClassChoicesToDatabase(classChoices);
}


// Save class choices to database
function saveClassChoicesToDatabase(classChoices) {
    runGasWithUserId('saveClassChoices', classChoices)
        .catch(function(error) {
            console.warn('クラス選択肢の保存に失敗:', error.message);
        });
}

// =============================================================================
// RESOURCE MANAGEMENT
// =============================================================================

// Add spreadsheet resource
function addResource() {
  const urlInput = document.getElementById('resource-url-input');
  if (!urlInput) {
    showMessage('URL入力フィールドが見つかりません。', 'error');
    return;
  }
  
  const url = urlInput.value.trim();
  if (!url) {
    showMessage('URLを入力してください。', 'warning');
    return;
  }

  // URLの種類を判定（スプレッドシートのみ対応）
  let resourceType = 'spreadsheet';
  let backendFunction = 'addSpreadsheetUrl';
  
  if (!url.includes('docs.google.com/spreadsheets/')) {
    showMessage('GoogleスプレッドシートのURLを入力してください。', 'warning');
    return;
  }
  
  const resourceTypeText = 'スプレッドシート';

  runGasWithUserId(backendFunction, resourceTypeText + 'を追加しています...', url)
    .then(function(result) {
      if (result.status === 'success') {
        showMessage(result.message, 'success');
        urlInput.value = ''; // Clear input
        
        // デバウンス制御による安全な状態更新
        if (window.AdminPanel && window.AdminPanel.debounce) {
          window.AdminPanel.debounce.loadStatus(() => loadStatus(true), 200);
        } else {
          loadStatus(true); // フォールバック
        }
      } else {
        showMessage(result.message || (resourceTypeText + 'の追加に失敗しました。'), 'error');
      }
    })
    .catch(function(error) {
      handleError(error, 'addResource', resourceTypeText + 'の追加に失敗しました。');
    });
}

// =============================================================================
// EXTERNAL LINKS AND NAVIGATION
// =============================================================================

// Copy board URL to clipboard
function copyBoardUrl(buttonElement) {
  const urlInput = document.getElementById('board-url');
  if (!urlInput) {
    console.error('board-url input element not found.');
    return;
  }

  const urlToCopy = urlInput.value;

  if (!urlToCopy) {
    showMessage('コピーするURLがありません。', 'warning');
    return;
  }

  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(urlToCopy).then(() => {
        const originalText = buttonElement.innerHTML;
        buttonElement.innerHTML = '<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>コピー完了!';
        buttonElement.disabled = true;
        setTimeout(() => {
          buttonElement.innerHTML = originalText;
          buttonElement.disabled = false;
        }, 2000);
      }).catch((error) => {
        console.error('Clipboard API failed:', error);
        // Fallback to manual copy message
        const messageElement = document.createElement('span');
        messageElement.textContent = ' (手動でコピーしてください)';
        messageElement.style.color = 'orange';
        buttonElement.parentNode.insertBefore(messageElement, buttonElement.nextSibling);
        setTimeout(() => messageElement.remove(), SYSTEM_CONSTANTS.TIMEOUTS.ERROR_DISPLAY_DURATION);
      });
    } else {
      // Fallback for browsers that don't support Clipboard API
      urlInput.select();
      urlInput.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      showMessage('URLがクリップボードにコピーされました！', 'success'); // Fallback uses showMessage
    }
  } catch (err) {
    console.error('copyBoardUrl error:', err);
    showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning'); // Fallback uses showMessage
  }
}

// Copy form URL to clipboard
function copyFormUrl() {
  const urlInput = document.getElementById('form-url-input');
  if (urlInput && urlInput.value) {
    urlInput.select();
    urlInput.setSelectionRange(0, 99999); // For mobile devices
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(urlInput.value).then(() => {
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        });
      } else {
        document.execCommand('copy');
        showMessage('フォームURLがクリップボードにコピーされました！', 'success');
      }
    } catch (err) {
      showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning');
    }
  } else {
    showMessage('コピーするフォームURLがありません。', 'warning');
  }
}

// Open database spreadsheet - 改善版（複数ソースからURL取得）
function openDatabaseSpreadsheet() {
  console.log('📊 openDatabaseSpreadsheet: URL取得を開始');
  
  // 複数ソースからスプレッドシートURLを取得
  let spreadsheetUrl = null;
  
  // 1. グローバル変数から
  if (currentSpreadsheetUrl) {
    spreadsheetUrl = currentSpreadsheetUrl;
    console.log('✅ URL from global variable:', spreadsheetUrl);
  }
  
  // 2. 現在のステータスから（フォールバック）
  if (!spreadsheetUrl && window.currentStatus && window.currentStatus.userInfo) {
    spreadsheetUrl = window.currentStatus.userInfo.spreadsheetUrl;
    console.log('📋 URL from currentStatus:', spreadsheetUrl || 'none');
  }
  
  // 3. キャッシュされたステータスから（追加フォールバック）
  if (!spreadsheetUrl && window.lastStatusCache && window.lastStatusCache.userInfo) {
    spreadsheetUrl = window.lastStatusCache.userInfo.spreadsheetUrl;
    console.log('🔄 URL from lastStatusCache:', spreadsheetUrl || 'none');
  }
  
  // 4. getActiveResourceUrls関数を使用（最終フォールバック）
  if (!spreadsheetUrl && typeof getActiveResourceUrls === 'function') {
    const status = window.currentStatus || window.lastStatusCache;
    if (status) {
      const resourceUrls = getActiveResourceUrls(status);
      spreadsheetUrl = resourceUrls.spreadsheet;
      console.log('🔍 URL from getActiveResourceUrls:', spreadsheetUrl || 'none');
    }
  }
  
  // 5. 最終手段：リアルタイム状態取得
  if (!spreadsheetUrl && typeof loadStatus === 'function') {
    console.log('🔄 Attempting real-time status fetch as last resort');
    try {
      // 同期的に状態を取得（最終手段）
      const button = event.target;
      if (button) button.disabled = true;
      
      loadStatus(true).then(status => {
        if (status && status.userInfo && status.userInfo.spreadsheetUrl) {
          console.log('✅ Got URL from real-time fetch:', status.userInfo.spreadsheetUrl);
          window.open(status.userInfo.spreadsheetUrl, '_blank');
        } else {
          console.warn('❌ Real-time fetch also failed');
          showMessage('スプレッドシートのURLが見つかりません。ページを再読み込みしてお試しください。', 'warning');
        }
        if (button) button.disabled = false;
      }).catch(error => {
        console.error('❌ Real-time status fetch failed:', error);
        showMessage('スプレッドシートのURLが見つかりません。ページを再読み込みしてお試しください。', 'warning');
        if (button) button.disabled = false;
      });
      
      return; // 非同期処理なので早期リターン
    } catch (error) {
      console.error('❌ Real-time fetch setup failed:', error);
    }
  }
  
  if (spreadsheetUrl) {
    console.log('🚀 Opening spreadsheet:', spreadsheetUrl);
    window.open(spreadsheetUrl, '_blank');
  } else {
    console.warn('❌ スプレッドシートのURL取得に失敗しました');
    showMessage('スプレッドシートのURLが見つかりません。ページを再読み込みしてお試しください。', 'warning');
  }
}

// Open form
function openForm() {
  console.log('🔗 openForm function called');
  
  // ボタンが無効化されている場合はクリックを無視
  const formBtn = document.getElementById('open-form-btn');
  if (formBtn && formBtn.disabled) {
    console.log('⚠️ Form button is disabled, ignoring click');
    showMessage('フォームを作成してからクリックしてください。', 'warning');
    return;
  }
  
  // データベースからフォームURLを取得する優先順位を設定
  let formUrl = null;
  
  // 1. configJsonから直接取得（最も確実）
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
    try {
      const configJson = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        logDebug('✅ FormURL取得: configJsonから直接取得成功');
      }
    } catch (error) {
      logWarn('⚠️ configJsonの解析でエラー:', error);
    }
  }
  
  // 2. ユーザー情報のformUrlから取得（フォールバック）
  if (!formUrl && currentStatus && currentStatus.userInfo && currentStatus.userInfo.formUrl) {
    formUrl = currentStatus.userInfo.formUrl;
    logDebug('📋 FormURL取得: userInfo.formUrlから取得');
  }
  
  // 3. カスタムフォーム情報から取得（後方互換性）
  if (!formUrl && currentStatus && currentStatus.customFormInfo && currentStatus.customFormInfo.formUrl) {
    formUrl = currentStatus.customFormInfo.formUrl;
    logDebug('📄 FormURL取得: customFormInfo.formUrlから取得');
  }
  
  if (formUrl) {
    window.open(formUrl, '_blank');
  } else {
    showMessage('フォームのURLが見つかりません。先にフォームを作成してください。', 'warning');
  }
}

/** @type {string} */
let appSetupUrl = '';

/**
 * アプリ設定ページのURLを取得して保存する。
 * キャッシュを優先して高速化。
 * @returns {void}
 */
function fetchAppSetupUrl() {
  // localStorage キャッシュを先にチェック
  const cachedUrls = localStorage.getItem('userUrls_' + userId);
  const cacheTime = localStorage.getItem('userUrls_time_' + userId);
  const CACHE_DURATION = 5 * 60 * 1000; // 5分間キャッシュ
  
  if (cachedUrls && cacheTime && (Date.now() - parseInt(cacheTime)) < CACHE_DURATION) {
    try {
      const urls = JSON.parse(cachedUrls);
      if (urls && urls.setupUrl) {
        appSetupUrl = urls.setupUrl;
        // URL cache hit - verbose logging disabled
        return;
      }
    } catch (e) {
      console.warn('キャッシュデータの解析エラー:', e);
    }
  }
  
  // キャッシュが無効な場合はサーバーから取得
  google.script.run
    .withSuccessHandler((urls) => {
      if (urls && urls.setupUrl) {
        appSetupUrl = urls.setupUrl;
        // localStorage にキャッシュを保存
        try {
          localStorage.setItem('userUrls_' + userId, JSON.stringify(urls));
          localStorage.setItem('userUrls_time_' + userId, Date.now().toString());
          console.log('✅ URLs cached to localStorage for future use');
        } catch (e) {
          console.warn('URLキャッシュ保存エラー:', e);
        }
      } else {
        console.error('アプリ設定ページURLの取得に失敗:', urls);
      }
    })
    .withFailureHandler((error) => {
      console.error('アプリ設定ページURLの取得エラー:', error);
    })
    .generateUserUrls(userId);
}

/**
 * アプリ設定管理ページを開く。
 * キャッシュを活用して高速遷移。
 * @returns {void}
 */
function openAppSetupPage() {
  const setupButton = document.querySelector('[onclick="openAppSetupPage()"]');
  const originalText = setupButton ? setupButton.textContent : '';

  if (setupButton) {
    setupButton.disabled = true;
    setupButton.style.opacity = '0.6';
    setupButton.style.pointerEvents = 'none';
    const span = setupButton.querySelector('span');
    if (span) {
      span.textContent = '移動中...';
    }
  }

  const restoreButton = () => {
    if (setupButton) {
      setupButton.disabled = false;
      setupButton.style.opacity = '';
      setupButton.style.pointerEvents = '';
      const span = setupButton.querySelector('span');
      if (span) {
        span.textContent = originalText || 'アプリ設定管理';
      }
    }
  };

  // URLが未取得の場合はキャッシュから再試行
  if (!appSetupUrl) {
    const cachedUrls = localStorage.getItem('userUrls_' + userId);
    const cacheTime = localStorage.getItem('userUrls_time_' + userId);
    const CACHE_DURATION = 5 * 60 * 1000; // 5分間キャッシュ
    
    if (cachedUrls && cacheTime && (Date.now() - parseInt(cacheTime)) < CACHE_DURATION) {
      try {
        const urls = JSON.parse(cachedUrls);
        if (urls && urls.setupUrl) {
          appSetupUrl = urls.setupUrl;
          console.log('✅ Emergency cache recovery successful');
        }
      } catch (e) {
        console.warn('緊急キャッシュ復旧失敗:', e);
      }
    }
    
    if (!appSetupUrl) {
      restoreButton();
      showMessage('アプリ設定ページのURLを取得できませんでした。ページを再読み込みしてください。', 'error');
      return;
    }
  }

  try {
    // Cache busting パラメータを追加してナビゲーションを高速化
    const urlWithCache = appSetupUrl.includes('?') 
      ? (appSetupUrl + '&t=' + Date.now()) 
      : (appSetupUrl + '?t=' + Date.now());
    window.open(urlWithCache, '_top');
  } catch (error) {
    console.error('アプリ設定ページへの遷移に失敗:', error);
    restoreButton();
    showMessage('アプリ設定ページへの移動に失敗しました。再度お試しください。', 'error');
  }
}

// フェーズ2最適化: 管理パネル初期化の並列処理
userIdPromise.then(async () => {
  // 並列実行タスク群
  const initTasks = [];
  
  // Task 1: アプリ設定URL取得
  const appSetupUrlTask = new Promise((resolve, reject) => {
    fetchAppSetupUrl();
    // fetchAppSetupUrl は即座に戻るが、実際の取得は非同期なので少し待つ
    setTimeout(() => resolve('appSetupUrl initiated'), 100);
  });
  initTasks.push(appSetupUrlTask);
  
  // Task 2: 統合キャッシュマネージャー初期化（既存システム活用）
  const cacheInitTask = new Promise((resolve) => {
    if (typeof unifiedCacheManager !== 'undefined') {
      // キャッシュクリーンアップを並列実行
      console.log('🗑️ Cache cleanup in parallel...');
      resolve('cacheManager ready');
    } else {
      resolve('cacheManager not available');
    }
  });
  initTasks.push(cacheInitTask);
  
  // Task 3: システムステータス軽量チェック（ノンブロッキング）
  const statusCheckTask = new Promise((resolve) => {
    // 軽量なステータスチェックを非同期で実行
    if (typeof window.sharedUtilities !== 'undefined' && window.sharedUtilities.gas) {
      console.log('🔍 Lightweight status check in parallel...');
      setTimeout(() => resolve('status check initiated'), 50);
    } else {
      resolve('status check not available');
    }
  });
  initTasks.push(statusCheckTask);
  
  try {
    const startTime = performance.now();
    const results = await Promise.allSettled(initTasks);
    const totalTime = performance.now() - startTime;
    
    console.log('⚡ Admin panel parallel initialization completed in ' + Math.round(totalTime) + 'ms:', {
      appSetupUrl: results[0].status,
      cacheInit: results[1].status, 
      statusCheck: results[2].status,
      totalTimeMs: Math.round(totalTime)
    });
    
    // 高速化効果の測定
    if (totalTime < 200) {
      console.log('🚀 Ultra-fast admin panel init: ' + Math.round(totalTime) + 'ms');
    }
    
  } catch (error) {
    console.warn('⚠️ Admin panel parallel init warning:', error);
    // 既存のフォールバック動作は維持
  }
});



// =============================================================================
// POLLING AND REAL-TIME UPDATES
// =============================================================================

// System status polling variables
let lastUserActivity = Date.now();
let currentPollInterval = 5 * 60 * 1000; // 開始は5分間隔
let statusPollTimer = null;

// Fresh save management to prevent interference
let freshSaveTimestamp = 0;
let isSaveInProgress = false;
const FRESH_SAVE_PROTECTION_DURATION = 30000; // 30 seconds

// Make freshSaveTimestamp globally accessible
window.freshSaveTimestamp = freshSaveTimestamp;

// =============================================================================
// CONFIG VERIFICATION MECHANISM
// =============================================================================

/**
 * 設定保存後の検証機能
 * カスタムセットアップで設定した内容が正しく保存・反映されているかを確認
 */
async function verifyConfigAfterSave(expectedSheetName, expectedConfig) {
  try {
    
    // 少し待ってからステータスを再取得
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const verificationStatus = await runGasWithUserId('getAppConfig', '設定反映を確認中...');
    
    if (verificationStatus && verificationStatus.userInfo) {
      const configJson = JSON.parse(verificationStatus.userInfo.configJson || '{}');
      const sheetKey = 'sheet_' + (expectedSheetName || '');
      const savedConfig = configJson[sheetKey];
      
      
      // 基本的な整合性チェック
      const isConsistent = (
        savedConfig &&
        savedConfig.guessedConfig &&
        expectedConfig.opinionHeader &&
        savedConfig.guessedConfig.opinionHeader === expectedConfig.opinionHeader
      );
      
      if (isConsistent) {
        return { success: true, message: '設定が正常に反映されました' };
      } else {
        console.warn('⚠️ 設定反映確認: 設定に不整合があります');
        
        // 自動修復を試行
        console.log('🔧 設定不整合を検出 - 自動修復を試行中...');
        await runGasWithUserId('saveSheetConfig', '設定を修復中...',
          currentStatus.userInfo.spreadsheetId, expectedSheetName, expectedConfig, { batchMode: true });
        
        return { success: false, message: '設定不整合を検出し、修復を試行しました', repaired: true };
      }
    }
    
    return { success: false, message: '設定確認中にエラーが発生しました' };
    
  } catch (error) {
    console.error('❌ 設定反映確認エラー:', error);
    return { success: false, message: '設定確認処理でエラーが発生しました: ' + error.message };
  }
}

/**
 * セットアップフロー完了確認（QuickStart・Custom Setup共通）
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {string} sheetName - 対象シート名
 * @returns {Object} 完了確認結果
 */
async function verifySetupFlowCompletion(flowType, sheetName) {
  try {
    console.log('🎯 ' + flowType + 'フロー完了確認開始:', sheetName);
    
    // 設定が安定するまで少し待つ
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const completionStatus = await runGasWithUserId('getAppConfig', 'フロー完了状態を確認中...');
    
    if (!completionStatus || !completionStatus.userInfo) {
      console.error('❌ フロー完了確認: ステータス取得失敗');
      return { success: false, message: 'ステータス取得に失敗しました' };
    }
    
    const configJson = JSON.parse(completionStatus.userInfo.configJson || '{}');
    const issues = [];
    
    // 必須完了状態の確認
    
    // 1. setupStatus='completed' 確認
    if (configJson.setupStatus !== 'completed') {
      issues.push('❌ setupStatus: "' + configJson.setupStatus + '" → "completed"が必要');
    }
    
    // 2. appPublished=true 確認  
    if (configJson.appPublished !== true) {
      issues.push('❌ appPublished: ' + configJson.appPublished + ' → trueが必要');
    }
    
    // 3. formCreated=true 確認
    if (configJson.formCreated !== true) {
      issues.push('❌ formCreated: ' + configJson.formCreated + ' → trueが必要');
    }
    
    // 4. 公開情報の確認と自動修正
    if (!configJson.publishedSheetName) {
      issues.push('❌ publishedSheetName未設定 → "' + sheetName + '"が必要');
    } else if (configJson.publishedSheetName !== sheetName) {
      issues.push('❌ publishedSheetName不一致: "' + configJson.publishedSheetName + '" → "' + sheetName + '"');
      
      // 自動修正機能: シート名不整合の修正を試行
      try {
        console.log('🔧 シート名不整合を自動修正します:', {
          current: configJson.publishedSheetName,
          expected: sheetName
        });
        
        // 設定を更新してシート名を同期
        configJson.publishedSheetName = sheetName;
        
        // サーバーに修正された設定を保存
        const updateResult = await runGasWithUserId('saveConfigUnified', '設定を自動修正中...', {
          configJson: JSON.stringify(configJson)
        });
        
        if (updateResult.status === 'success') {
          console.log('✅ シート名自動修正完了:', sheetName);
          // issues配列から該当のエラーを削除
          const issueIndex = issues.findIndex(issue => issue.includes('publishedSheetName不一致'));
          if (issueIndex >= 0) {
            issues.splice(issueIndex, 1);
            console.log('🎯 修正により未完了項目を解決しました');
          }
        } else {
          console.error('❌ シート名自動修正失敗:', updateResult.message);
        }
      } catch (autoFixError) {
        console.error('❌ シート名自動修正エラー:', autoFixError);
      }
    }
    
    // 4. publishedSpreadsheetIdの確認（フォールバック対応）
    if (!configJson.publishedSpreadsheetId) {
      // completionStatusからspreadsheetIdを取得してフォールバック
      if (completionStatus.userInfo && completionStatus.userInfo.spreadsheetId) {
        console.log('🔧 publishedSpreadsheetIdをuserInfo.spreadsheetIdで補完: ' + completionStatus.userInfo.spreadsheetId);
        // この値は後で同期修正で設定される
      } else {
        issues.push('❌ publishedSpreadsheetId未設定');
      }
    }
    
    // 5. シート固有設定の確認（より柔軟な判定）
    const sheetKey = 'sheet_' + (sheetName || '');
    const sheetConfig = configJson[sheetKey];
    const hasSheetConfig = !!(sheetConfig && (sheetConfig.guessedConfig || sheetConfig.opinionHeader));
    
    if (!hasSheetConfig) {
      // カスタムフローで設定が完了している場合は警告に格下げ
      if (flowType === 'custom' && configJson.setupStatus === 'completed') {
        console.warn('⚠️ シート設定が見つかりませんが、カスタムフロー完了のためスキップ: ' + sheetKey);
      } else {
        issues.push('❌ シート設定未保存: ' + sheetKey);
      }
    }
    
    if (issues.length === 0) {
      return {
        success: true,
        message: flowType + 'フローが正常に完了しました',
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!(sheetConfig && sheetConfig.guessedConfig)
        }
      };
    } else {
      console.warn('⚠️ ' + flowType + 'フロー完了確認: 未完了項目があります', issues);
      return {
        success: false,
        message: flowType + 'フローに未完了項目があります',
        issues: issues,
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!(sheetConfig && sheetConfig.guessedConfig)
        }
      };
    }
    
  } catch (error) {
    console.error('❌ ' + flowType + 'フロー完了確認エラー:', error);
    return { 
      success: false, 
      message: 'フロー完了確認でエラーが発生しました: ' + error.message 
    };
  }
}

/**
 * 設定同期メカニズム強化 - フロー完了状態との整合性を保つ
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {Object} expectedState - 期待される設定状態
 * @returns {Promise<Object>} 同期結果
 */
async function enhanceConfigSynchronization(flowType, expectedState) {
  try {
    
    // 現在のステータスを取得
    const currentStatus = await runGasWithUserId('getAppConfig', '設定同期のため最新状態を取得中...');
    
    if (!currentStatus || !currentStatus.userInfo) {
      throw new Error('設定同期: ステータス取得失敗');
    }
    
    const configJson = JSON.parse(currentStatus.userInfo.configJson || '{}');
    const synchronizationIssues = [];
    const appliedFixes = [];
    
    // 1. 必須設定状態の確認と修正
    const requiredStates = {
      setupStatus: 'completed',
      appPublished: true,
      formCreated: true,
      publishedSheetName: expectedState.sheetName,
      publishedSpreadsheetId: expectedState.spreadsheetId || currentStatus.userInfo.spreadsheetId
    };
    
    let needsSync = false;
    const updatedConfig = { ...configJson };
    
    for (const [key, expectedValue] of Object.entries(requiredStates)) {
      if (configJson[key] !== expectedValue) {
        synchronizationIssues.push(key + ': "' + configJson[key] + '" → "' + expectedValue + '"');
        updatedConfig[key] = expectedValue;
        needsSync = true;
      }
    }
    
    // 2. シート固有設定の同期確認
    if (expectedState.sheetName && expectedState.config) {
      const sheetKey = 'sheet_' + (expectedState.sheetName || '');
      const currentSheetConfig = configJson[sheetKey];
      
      
      if (!currentSheetConfig || !currentSheetConfig.guessedConfig) {
        synchronizationIssues.push('シート設定未保存: ' + sheetKey);
        updatedConfig[sheetKey] = {
          guessedConfig: expectedState.config,
          lastUpdated: new Date().toISOString(),
          flowType: flowType
        };
        needsSync = true;
        console.log('📝 ' + flowType + 'フロー: シート設定を作成 ' + sheetKey);
      }
    }
    
    // 3. 設定の同期適用（必要な場合のみ）
    if (needsSync) {
      console.log('🔧 ' + flowType + 'フロー: 設定不整合を検出 - 同期修正を実行', synchronizationIssues);
      
      // バックエンドに同期修正を依頼（パラメータ順序修正）
      const syncResult = await runGasWithUserId('syncConfigurationState', '設定同期を実行中...', 
        updatedConfig, 'repair');
      
      if (syncResult && syncResult.success) {
        appliedFixes.push(...synchronizationIssues);
        
        // 統一キャッシュクリアで最新状態を反映
        try {
          await cacheManager.clearAllFrontendCaches();
        } catch (clearError) {
          console.warn('Cache clear failed during sync:', clearError);
        }
        
        return {
          success: true,
          synchronized: true,
          appliedFixes: appliedFixes,
          message: flowType + 'フローの設定同期が完了しました'
        };
      } else {
        console.warn('⚠️ ' + flowType + 'フロー: 設定同期修正に失敗', syncResult);
        return {
          success: false,
          synchronized: false,
          issues: synchronizationIssues,
          syncResult: syncResult,
          message: '設定同期修正に失敗しました',
          details: {
            errors: (syncResult && syncResult.errors) || [],
            systemError: syncResult && syncResult.systemError,
            context: syncResult && syncResult.context
          }
        };
      }
    } else {
      return {
        success: true,
        synchronized: false,
        message: flowType + 'フローの設定は既に正しく同期されています'
      };
    }
    
  } catch (error) {
    console.error('❌ ' + flowType + 'フロー設定同期エラー:', error);
    return {
      success: false,
      synchronized: false,
      error: error.message,
      message: '設定同期処理でエラーが発生しました: ' + error.message
    };
  }
}

/**
 * 統合的な設定整合性チェック - 複数フローに対応
 * @param {Object} status - 現在のステータス
 * @returns {Object} 整合性チェック結果
 */
function performIntegratedConfigConsistencyCheck(status) {
  if (!status || !status.userInfo) {
    return { consistent: false, issues: ['ステータスデータが不正です'] };
  }
  
  try {
    const configJson = JSON.parse(status.userInfo.configJson || '{}');
    const issues = [];
    const recommendations = [];
    
    // 1. 基本的な設定整合性チェック
    const basicChecks = [
      {
        condition: configJson.setupStatus === 'completed',
        issue: 'setupStatusがcompletedではありません',
        recommendation: 'セットアップフローを完了してください'
      },
      {
        condition: configJson.formCreated === true,
        issue: 'formCreatedがtrueではありません',
        recommendation: 'フォーム作成処理を実行してください'
      },
      {
        condition: !!configJson.publishedSheetName,
        issue: 'publishedSheetNameが未設定です',
        recommendation: 'シート選択を確認してください'
      },
      {
        condition: !!configJson.publishedSpreadsheetId,
        issue: 'publishedSpreadsheetIdが未設定です',
        recommendation: 'スプレッドシート設定を確認してください'
      }
    ];
    
    basicChecks.forEach(check => {
      if (!check.condition) {
        issues.push(check.issue);
        recommendations.push(check.recommendation);
      }
    });
    
    // 2. 公開状態の整合性チェック
    if (configJson.appPublished === true) {
      if (configJson.setupStatus !== 'completed') {
        issues.push('公開状態なのにセットアップが未完了です');
        recommendations.push('セットアップを完了するか、公開を停止してください');
      }
      if (!configJson.formCreated) {
        issues.push('公開状態なのにフォームが未作成です');
        recommendations.push('フォームを作成するか、公開を停止してください');
      }
    }
    
    // 3. シート固有設定の整合性チェック
    if (configJson.publishedSheetName) {
      const sheetKey = 'sheet_' + (configJson.publishedSheetName || '');
      const sheetConfig = configJson[sheetKey];
      
      if (!sheetConfig || !sheetConfig.guessedConfig) {
        issues.push('シート固有設定が未保存です: ' + configJson.publishedSheetName);
        recommendations.push('列設定を確認・保存してください');
      }
    }
    
    const isConsistent = issues.length === 0;
    
    return {
      consistent: isConsistent,
      issues: issues,
      recommendations: recommendations,
      severity: issues.length > 3 ? 'high' : issues.length > 1 ? 'medium' : 'low',
      summary: isConsistent ? '設定は整合性が保たれています' : (issues.length + '件の整合性問題が見つかりました')
    };
    
  } catch (error) {
    console.error('設定整合性チェックエラー:', error);
    return {
      consistent: false,
      issues: ['設定解析エラーが発生しました'],
      recommendations: ['設定を再確認してください'],
      error: error.message
    };
  }
}

// Get optimal polling interval based on user activity
function getOptimalPollInterval() {
  const timeSinceActivity = Date.now() - lastUserActivity;
  
  if (timeSinceActivity < 2 * 60 * 1000) { // 2分以内
    return 30 * 1000; // 30秒間隔
  } else if (timeSinceActivity < 10 * 60 * 1000) { // 10分以内
    return 2 * 60 * 1000; // 2分間隔
  } else {
    return 10 * 60 * 1000; // 10分間隔
  }
}

// Restart status polling with new interval
function restartStatusPolling() {
  if (statusPollTimer) {
    clearInterval(statusPollTimer);
  }
  currentPollInterval = getOptimalPollInterval();
  startSystemStatusUpdate();
}

// Start system status update polling
function startSystemStatusUpdate() {
  statusPollTimer = setInterval(function() {
    // UIが非表示の時は更新しない
    if (document.hidden) return;
    
    // Skip background updates if save operation is in progress or recently completed
    if (isSaveInProgress) {
      logDebug('Skipping background update: save in progress');
      return;
    }
    
    const timeSinceFreshSave = Date.now() - freshSaveTimestamp;
    if (timeSinceFreshSave < FRESH_SAVE_PROTECTION_DURATION) {
      logDebug('Skipping background update: fresh save protection active');
      return;
    }
    
    // 現在のポーリング間隔を確認し、必要に応じて調整
    const optimalInterval = getOptimalPollInterval();
    if (Math.abs(currentPollInterval - optimalInterval) > 30000) { // 30秒以上の差
      restartStatusPolling();
      return;
    }
    
    // 統一APIを利用して軽量モードで更新（getInitialDataベース）
    runGasWithUserId('getInitialData', false, false) // 第3引数はlightweightMode
      .then(function(status) {
        // 変更があった場合のみUIを更新
        if (JSON.stringify(status) !== JSON.stringify(currentStatus)) {
          updateUIWithNewStatus(status);
        }
      })
      .catch(function(error) {
        logWarn('Background status update failed:', error);
      });
  }, currentPollInterval);
}

// =============================================================================
// CONFIG MANAGEMENT
// =============================================================================

// Reset configJson to initial values
function resetConfigJson() {
  // 危険操作の確認ダイアログ
  const confirmMessage = `⚠️ 設定リセットの確認

この操作を実行すると、以下の設定が初期値にリセットされます：
• フォーム設定（質問文、回答方法など）
• 表示設定（匿名表示、集計表示など）
• シート設定（回答連携など）

※ スプレッドシートやフォーム自体は削除されませんが、
　 設定の再構築が必要になる場合があります。

本当に設定をリセットしますか？`;

  if (!confirm(confirmMessage)) {
    return;
  }
  
  const button = document.getElementById('reset-config-btn');
  const originalHTML = button ? button.innerHTML : '';
  
  try {
    if (button) {
      // ローディング状態
      button.disabled = true;
      button.innerHTML = `
        <svg class="w-3 h-3 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        リセット中...
      `;
    }
    
    logInfo('🔄 ConfigJsonリセット開始');
    
    runGasWithUserId('resetConfigJson', '設定をリセット中...')
      .then(function(result) {
        if (result.success) {
          showMessage('✅ 設定を初期値にリセットしました。ページを再読み込みして変更を確認してください。', 'success');
          logInfo('✅ ConfigJsonリセット完了');
          
          // UIを更新するために最新データを取得
          setTimeout(() => {
            runGasWithUserId('getInitialData', 'データを更新中...')
              .then(function(updatedStatus) {
                updateUIWithNewStatus(updatedStatus);
                logInfo('🔄 リセット後のUI更新完了');
              })
              .catch(function(error) {
                logWarn('⚠️ リセット後のUI更新でエラー:', error);
                showMessage('設定はリセットされましたが、表示の更新に失敗しました。ページを再読み込みしてください。', 'warning');
              });
          }, 1000);
        } else {
          throw new Error(result.message || '設定リセットに失敗しました');
        }
      })
      .catch(function(error) {
        logError('❌ ConfigJsonリセットでエラー:', error);
        showMessage('設定リセットに失敗しました: ' + (error.message || error), 'error');
      })
      .finally(() => {
        if (button) {
          // ボタンを元の状態に戻す
          button.disabled = false;
          button.innerHTML = originalHTML;
        }
      });
      
  } catch (error) {
    logError('❌ ConfigJsonリセット実行中にエラー:', error);
    showMessage('設定リセットの実行に失敗しました', 'error');
    if (button) {
      button.disabled = false;
      button.innerHTML = originalHTML;
    }
  }
}

// =============================================================================
// QUICKSTART FUNCTIONALITY
// =============================================================================

// QuickStart progress management (Simplified 2-step)
const quickStartSteps = [
  { id: 1, text: 'フォーム・スプレッドシート作成', detail: 'フォームとスプレッドシートを自動作成中...' },
  { id: 2, text: 'ボード設定と自動公開', detail: '回答ボードの設定と自動公開を実行中...' }
];

// Custom setup progress management
// Custom Setup step definitions (7 steps for comprehensive setup) - 独立版
const customSetupSteps = [
  { id: 1, text: 'ユーザー入力の検証', detail: '入力内容を検証中...', maxTime: 12 },
  { id: 2, text: 'Googleフォームとスプレッドシートの作成', detail: 'カスタムフォームを構築中...', maxTime: 20 },
  { id: 3, text: 'AI列判定の実行', detail: 'AIが列を分析中...', maxTime: 25 },
  { id: 4, text: '設定の保存', detail: '判定結果を保存中...', maxTime: 8 },
  { id: 5, text: 'キャッシュクリア', detail: 'システムキャッシュを更新中...', maxTime: 8 },
  { id: 6, text: '完了処理', detail: 'セットアップ完了準備中...', maxTime: 5 }
];

// Show QuickStart progress bar
function showQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetProgressSteps();
  }
}

// Hide QuickStart progress bar
function hideQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset all progress steps to initial state
function resetProgressSteps() {
  quickStartSteps.forEach(step => {
    updateProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateOverallProgress(0, '初期化中...');
}

// Update individual progress step
function updateProgressStep(stepId, status, text, detail) {
  const stepElement = document.getElementById('progress-step-' + stepId);
  const dotElement = document.getElementById('progress-step-' + stepId + '-dot');
  const textElement = document.getElementById('progress-step-' + stepId + '-text');
  const detailElement = document.getElementById('progress-step-' + stepId + '-detail');
  
  if (!stepElement || !dotElement || !textElement || !detailElement) return;
  
  // Update text and detail
  textElement.textContent = text;
  detailElement.textContent = detail;
  
  // Update visual state based on status
  switch (status) {
    case 'waiting':
      dotElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      textElement.className = 'text-sm text-gray-300';
      detailElement.className = 'text-xs text-gray-500';
      break;
    case 'active':
      dotElement.className = 'w-2 h-2 rounded-full bg-emerald-400 animate-pulse';
      textElement.className = 'text-sm text-emerald-300 font-medium';
      detailElement.className = 'text-xs text-emerald-400';
      break;
    case 'completed':
      dotElement.className = 'w-2 h-2 rounded-full bg-green-400';
      textElement.className = 'text-sm text-green-300 font-medium';
      detailElement.className = 'text-xs text-green-400';
      break;
    case 'error':
      dotElement.className = 'w-2 h-2 rounded-full bg-red-400';
      textElement.className = 'text-sm text-red-300 font-medium';
      detailElement.className = 'text-xs text-red-400';
      break;
  }
}

// Update overall progress bar
function updateOverallProgress(percentage, statusMessage) {
  const progressBar = document.getElementById('progress-bar');
  const progressPercentage = document.getElementById('progress-percentage');
  const progressStatus = document.getElementById('progress-status');
  
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
  
  if (progressPercentage) {
    progressPercentage.textContent = percentage + '%';
  }
  
  if (progressStatus) {
    progressStatus.textContent = statusMessage;
  }
}

// Simulate QuickStart progress with enhanced backend synchronization
function simulateQuickStartProgress() {
  console.log('🚀 Starting simplified QuickStart progress simulation (2 steps)');
  
  // 2-Step Simplified QuickStart Progress
  updateProgressStep(1, 'active', 'フォーム・スプレッドシート作成', 'フォームとスプレッドシートを自動作成中...');
  updateOverallProgress(10, 'フォーム・スプレッドシートを作成しています...', 2.5);
  
  // 段階的に進捗を更新（2ステップ構成）
  setTimeout(() => {
    updateOverallProgress(30, 'フォーム作成中...', 2);
    
    setTimeout(() => {
      updateOverallProgress(60, 'スプレッドシート作成完了', 1.5);
      updateProgressStep(1, 'completed', 'フォーム・スプレッドシート作成', '✅ フォームとスプレッドシートが作成されました');
      updateProgressStep(2, 'active', 'ボード設定と自動公開', '回答ボードの設定と自動公開を実行中...');
      
      setTimeout(() => {
        updateOverallProgress(80, 'ボード設定適用中...', 1);
        
        setTimeout(() => {
          updateOverallProgress(95, '自動公開準備中...', 0.5);
          
          setTimeout(() => {
            // 最終完了状態は executeQuickStartProcess の成功ハンドラーで設定される
          }, 500);
        }, 800);
      }, 1000);
    }, 1500);
  }, 1000);
  
  // Optional folder creation check (non-blocking - doesn't affect main progress)
  runGasWithUserId('createUserFolder', false)
    .then(function(folderResult) {
    })
    .catch(function(error) {
      console.warn('⚠️ QuickStart folder creation check failed, but continuing:', error);
    });
}

// Simulate Custom Form progress (for custom form creation)
function simulateCustomFormProgressWithFolderCheck() {
  // Step 1: Real folder creation/check
  updateProgressStep(1, 'active', 'ユーザー専用フォルダの作成', 'フォルダ構造を準備中...');
  updateOverallProgress(5, 'フォルダを作成しています...');
  
  // Actually call the folder creation API to sync with real backend progress
  runGasWithUserId('createUserFolder', 'フォルダを確認・作成中...')
    .then(function(folderResult) {
      updateProgressStep(1, 'completed', 'ユーザー専用フォルダの作成', '✅ フォルダが作成されました');
      updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
      updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
      
      // Step 2: Custom form/spreadsheet creation
      setTimeout(() => {
        updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
        updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
        updateOverallProgress(50, 'カスタム設定を適用しています...');
        
        // Step 3: Custom configuration
        setTimeout(() => {
          updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
          updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
          updateOverallProgress(75, 'シート構造を最適化しています...');
          
          // Step 4: Sheet optimization
          setTimeout(() => {
            updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
            updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
            updateOverallProgress(90, '最終準備を実行しています...');
            
            // Step 5: Final preparation
            setTimeout(() => {
              updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
              updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
              updateOverallProgress(100, 'セットアップが完了しました！');
              
              setTimeout(() => {
                updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
              }, 500);
            }, 1000);
          }, 1500);
        }, 1000);
      }, 2000);
    })
    .catch(function(error) {
      console.warn('⚠️ Custom form folder creation failed, continuing with fallback:', error);
      updateProgressStep(1, 'error', 'ユーザー専用フォルダの作成', '⚠️ フォルダ作成でエラーが発生しましたが処理を続行します');
      showMessage('フォルダの作成に警告がありましたが、カスタムフォーム作成を続行します。', 'warning');
      
      // Continue with fallback timing even if folder creation fails
      setTimeout(() => {
        updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
        updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
        
        setTimeout(() => {
          updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
          updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
          updateOverallProgress(50, 'カスタム設定を適用しています...');
          
          setTimeout(() => {
            updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
            updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
            updateOverallProgress(75, 'シート構造を最適化しています...');
            
            setTimeout(() => {
              updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
              updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
              updateOverallProgress(90, '最終準備を実行しています...');
              
              setTimeout(() => {
                updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
                updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
                updateOverallProgress(100, 'セットアップが完了しました！');
                
                setTimeout(() => {
                  updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
                }, 500);
              }, 1000);
            }, 1500);
          }, 1000);
        }, 2000);
      }, 1000);
    });
}

// =============================================================================
// CUSTOM SETUP FUNCTIONALITY - Unified Automation
// =============================================================================

// Show Custom Setup progress bar (独立版)
function showCustomSetupProgress() {
  const progressContainer = document.getElementById('customsetup-progress'); // 独立したコンテナを使用
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetCustomSetupProgressSteps();
  }
}

// Hide Custom Setup progress bar (独立版)
function hideCustomSetupProgress() {
  const progressContainer = document.getElementById('customsetup-progress'); // 独立したコンテナを使用
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset Custom Setup progress steps (独立版)
function resetCustomSetupProgressSteps() {
  customSetupSteps.forEach(step => {
    updateCustomProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateCustomOverallProgress(0, '初期化中...', calculateTotalEstimatedTime());
}

// CustomSetup専用のプログレス更新関数
function updateCustomProgressStep(stepId, status, text, detail) {
  const stepElement = document.getElementById('custom-progress-step-' + stepId);
  const dotElement = document.getElementById('custom-progress-step-' + stepId + '-dot');
  const textElement = document.getElementById('custom-progress-step-' + stepId + '-text');
  const detailElement = document.getElementById('custom-progress-step-' + stepId + '-detail');
  const timeElement = document.getElementById('custom-progress-step-' + stepId + '-time');
  
  if (!stepElement || !dotElement || !textElement || !detailElement) return;
  
  // Update text and detail
  textElement.textContent = text;
  detailElement.textContent = detail;
  
  // Update visual state based on status
  switch (status) {
    case 'waiting':
      dotElement.className = 'w-3 h-3 rounded-full bg-gray-500 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-gray-300';
      detailElement.className = 'text-xs text-gray-500 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
    case 'active':
      dotElement.className = 'w-3 h-3 rounded-full bg-purple-400 animate-pulse transition-all duration-300';
      textElement.className = 'text-sm font-medium text-purple-300';
      detailElement.className = 'text-xs text-purple-400 mt-1';
      if (timeElement) timeElement.classList.remove('opacity-0');
      break;
    case 'completed':
      dotElement.className = 'w-3 h-3 rounded-full bg-green-400 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-green-300';
      detailElement.className = 'text-xs text-green-400 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
    case 'error':
      dotElement.className = 'w-3 h-3 rounded-full bg-red-400 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-red-300';
      detailElement.className = 'text-xs text-red-400 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
  }
}

// CustomSetup専用の全体プログレス更新関数
function updateCustomOverallProgress(percentage, statusMessage, estimatedTimeRemaining = null) {
  const progressBar = document.getElementById('custom-progress-bar');
  const progressPercentage = document.getElementById('custom-progress-percentage');
  const progressStatus = document.getElementById('custom-progress-status');
  const progressEta = document.getElementById('custom-progress-eta');
  
  if (progressBar) {
    progressBar.style.width = Math.min(percentage, 100) + '%';
  }
  
  if (progressPercentage) {
    progressPercentage.textContent = Math.round(percentage) + '%';
  }
  
  if (progressStatus) {
    progressStatus.textContent = statusMessage;
  }
  
  if (progressEta && estimatedTimeRemaining !== null) {
    const minutes = Math.ceil(estimatedTimeRemaining / 60);
    progressEta.textContent = '推定残り時間: ' + minutes + '分';
  }
}

// 推定残り時間を計算
function calculateTotalEstimatedTime() {
  return customSetupSteps.reduce((total, step) => total + (step.maxTime || SYSTEM_CONSTANTS.CUSTOM_SETUP.STEP_TIMES.CONFIG_SAVE), 0);
}

// CustomSetup専用のキャンセル処理
function setupCustomSetupCancelHandler() {
  const cancelBtn = document.getElementById('customsetup-cancel-btn');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', function() {
      if (confirm(SYSTEM_CONSTANTS.CUSTOM_SETUP.CANCEL_CONFIRMATION_MESSAGE)) {
        hideCustomSetupProgress();
        showMessage('⚠️ カスタムセットアップが中断されました', 'warning');
        // TODO: バックエンド処理の中断ロジックを実装
      }
    });
  }
}

// Simulate Custom Setup progress with real backend synchronization (独立版)
async function simulateCustomSetupProgress() {
  console.log('🎨 Starting enhanced Custom Setup progress simulation (独立版 TimingManager)');
  
  // キャンセルハンドラーをセットアップ
  setupCustomSetupCancelHandler();
  
  let currentStep = 0;
  let startTime = Date.now();
  
  for (const step of customSetupSteps) {
    currentStep++;
    
    // ステップ開始
    updateCustomProgressStep(step.id, 'active', step.text, step.detail);
    
    // プログレス計算（各ステップは全体の1/7）
    const baseProgress = ((currentStep - 1) / customSetupSteps.length) * 100;
    const nextProgress = (currentStep / customSetupSteps.length) * 100;
    
    // 段階的プログレス更新（改善版）
    const stepDuration = (step.maxTime || SYSTEM_CONSTANTS.CUSTOM_SETUP.STEP_TIMES.CONFIG_SAVE) * 1000; // 秒をミリ秒に変換
    const updateInterval = Math.min(stepDuration / 15, SYSTEM_CONSTANTS.CUSTOM_SETUP.PROGRESS_UPDATE_INTERVAL); // より頻繁な更新（15分割）
    
    let elapsed = 0;
    let lastProgressUpdate = 0;
    
    while (elapsed < stepDuration) {
      await TimingManager.delay(updateInterval);
      elapsed += updateInterval;
      
      // 現在のステップ内でのプログレス（スムーズなイージング関数を使用）
      const rawStepProgress = elapsed / stepDuration;
      const stepProgress = Math.min(rawStepProgress * rawStepProgress * (3 - 2 * rawStepProgress), 1); // スムーズステップ関数
      const currentProgress = baseProgress + (nextProgress - baseProgress) * stepProgress;
      
      // プログレスが実際に変化した時のみ更新（無駄な更新を防ぐ）
      if (Math.abs(currentProgress - lastProgressUpdate) >= 0.5) {
        // 残り時間計算（改善版）
        const totalElapsed = (Date.now() - startTime) / 1000;
        const totalEstimated = calculateTotalEstimatedTime();
        const progressRatio = currentProgress / 100;
        const estimatedTotalTime = progressRatio > 0.1 ? totalElapsed / progressRatio : totalEstimated;
        const remainingTime = Math.max(estimatedTotalTime - totalElapsed, 0);
        
        // 詳細なステップ情報を追加
        const detailWithProgress = step.detail + ' (' + Math.round(stepProgress * 100) + '%)';
        updateCustomOverallProgress(currentProgress, detailWithProgress, remainingTime);
        lastProgressUpdate = currentProgress;
      }
    }
    
    // ステップ完了
    updateCustomProgressStep(step.id, 'completed', step.text, '✅ ' + step.text + '完了');
    updateCustomOverallProgress(nextProgress, step.text + '完了');
    
    // 短い完了表示待機
    await TimingManager.delay(SYSTEM_CONSTANTS.UI.ANIMATION_DURATION);
  }
  
}

/**
 * 簡素化された状態更新関数
 * 複雑な統合処理を避け、最小限のキャッシュクリアと直接的なloadStatus呼び出し
 */
async function simpleStatusRefresh() {
  
  try {
    // 最小限のキャッシュクリア（エラー耐性）
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      window.unifiedCache.clear();
    }
    
    // デバウンス制御による安全な状態更新
    if (window.AdminPanel && window.AdminPanel.debounce) {
      return new Promise((resolve) => {
        window.AdminPanel.debounce.loadStatus(async () => {
          try {
            const status = await loadStatus(true);
            resolve(status);
          } catch (error) {
            console.warn('⚠️ デバウンスloadStatus エラー:', error);
            resolve(null);
          }
        }, 250);
      });
    } else {
      const status = await loadStatus(true);
      return status;
    }
    
  } catch (error) {
    console.warn('⚠️ 簡素化状態同期でエラー:', error);
    // エラーでもloadStatusを試行
    try {
      return await loadStatus(true);
    } catch (fallbackError) {
      console.error('❌ フォールバックloadStatusも失敗:', fallbackError);
      throw fallbackError;
    }
  }
}

/**
 * バックエンド完了ポーリング関数
 * タイムアウト発生時にバックエンド処理の完了を確認
 */
async function startBackendCompletionPolling() {
  const maxAttempts = 20; // 最大2分間（6秒×20回）
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      
      // 6秒待機
      await new Promise(resolve => setTimeout(resolve, 6000));
      
      // 状態確認
      const status = await simpleStatusRefresh();
      
      // カスタムセットアップ完了の確認
      if (status && (status.setupStep >= 3 || (status.systemStatus && status.systemStatus.setupStatus === 'completed'))) {
        
        // 成功処理
        updateProgressStep(6, 'completed', 'カスタムセットアップ完了', '🎉 バックエンドでの処理が完了しました！');
        showMessage('✅ フォームとデータの準備が完了しました！AI列判定を開始します。', 'success');
        
        // UI更新
        updateUIAfterCustomSetup(status);
        
        // プログレス非表示
        setTimeout(() => {
          hideCustomSetupProgress();
        }, 3000);
        
        return;
      }
      
      // 進行状況表示更新
      updateProgressStep(6, 'active', 'カスタムセットアップ継続中', '⏳ 処理確認中... (' + attempt + '/' + maxAttempts + ')');
      
    } catch (error) {
      console.warn('⚠️ ポーリング試行 ' + attempt + ' でエラー:', error);
    }
  }
  
  // 最大試行回数に達した場合
  console.warn('⚠️ バックエンド完了ポーリング最大試行回数に達しました');
  updateProgressStep(6, 'error', 'カスタムセットアップ状態不明', '⚠️ 処理状態を確認できませんでした');
  showMessage('⚠️ 処理状態の確認がタイムアウトしました。ページを再読み込みして状態を確認してください。', 'warning');
  
  setTimeout(() => {
    hideCustomSetupProgress();
  }, 5000);
}

/**
 * カスタムセットアップ成功後のUI更新
 */
function updateUIAfterCustomSetup(status) {
  console.log('🎨 カスタムセットアップ成功後のUI更新');
  
  try {
    // アクティブシート設定
    if (status.activeSheetName) {
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = status.activeSheetName;
        selectedSheet = status.activeSheetName;
        lastSelectedSheetName = status.activeSheetName;
      }
    }
    
    // その他のUI更新関数があれば呼び出し
    if (typeof updateSheetSelectActiveIndicator === 'function' && status.activeSheetName) {
      updateSheetSelectActiveIndicator(status.activeSheetName);
    }
    
    if (typeof updateUIForSelectedSheet === 'function') {
      updateUIForSelectedSheet();
    }
    
  } catch (error) {
    console.warn('⚠️ UI更新でエラー:', error);
  }
}

/**
 * QuickStart用バックエンド完了ポーリング関数
 * タイムアウト発生時にバックエンド処理の完了を確認
 */
async function startQuickStartPolling(quickstartBtn, quickstartText) {
  const maxAttempts = 20; // 最大2分間（6秒×20回）
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      
      // 6秒待機
      await new Promise(resolve => setTimeout(resolve, 6000));
      
      // 状態確認
      const status = await simpleStatusRefresh();
      
      // QuickStart完了の確認（フォーム作成状態やセットアップ完了を確認）
      if (status && (status.setupStep >= 3 || (status.systemStatus && status.systemStatus.setupStatus === 'completed') || status.formUrl)) {
        
        // 成功処理
        updateProgressStep(6, 'completed', 'クイックスタート完了', '🎉 バックエンドでの処理が完了しました！');
        showMessage('✅ クイックスタートが完了しました！（バックエンド処理完了）', 'success');
        
        // UI更新
        updateUIAfterQuickStart(status, quickstartBtn, quickstartText);
        
        // プログレス非表示
        setTimeout(() => {
          hideQuickStartProgress();
        }, 3000);
        
        return true; // 成功で終了
      }
      
    } catch (error) {
      console.warn('⚠️ QuickStartポーリング試行 ' + attempt + ' でエラー:', error);
    }
  }
  
  // 最大試行回数に達した場合
  console.warn('⚠️ QuickStartポーリング: 最大試行回数に達しました');
  updateProgressStep(6, 'error', 'クイックスタート確認失敗', '処理の完了を確認できませんでした');
  showMessage('⚠️ クイックスタートの完了確認に時間がかかっています。後でページを再読み込みして確認してください。', 'warning');
  
  // ボタン状態のリセット
  if (quickstartBtn && quickstartText) {
    quickstartBtn.disabled = false;
    quickstartText.textContent = 'クイックスタートを開始';
  }
  
  setTimeout(() => {
    hideQuickStartProgress();
  }, 5000);
  
  return false;
}

/**
 * QuickStart成功後のUI更新
 */
function updateUIAfterQuickStart(status, quickstartBtn, quickstartText) {
  console.log('🚀 QuickStart成功後のUI更新');
  
  try {
    // ボタン状態更新
    if (quickstartBtn && quickstartText) {
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタート完了';
    }
    
    // フォーム作成完了フラグを設定
    sessionStorage.setItem('form_just_created', 'true');
    
    // アクティブシート設定（あれば）
    if (status.activeSheetName) {
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = status.activeSheetName;
        selectedSheet = status.activeSheetName;
        lastSelectedSheetName = status.activeSheetName;
      }
    }
    
    // フォームURL表示の更新
    if (typeof updateFormUrlDisplay === 'function') {
      updateFormUrlDisplay();
    }
    
    // その他のUI更新関数があれば呼び出し
    if (typeof updateSheetSelectActiveIndicator === 'function' && status.activeSheetName) {
      updateSheetSelectActiveIndicator(status.activeSheetName);
    }
    
    if (typeof updateUIForSelectedSheet === 'function') {
      updateUIForSelectedSheet();
    }
    
    // 公開停止ボタンの状態更新
    if (typeof updateUnpublishButton === 'function') {
      updateUnpublishButton(status);
    }
    
  } catch (error) {
    console.warn('⚠️ QuickStart UI更新でエラー:', error);
  }
}

// Handle unified custom setup
async function handleCustomSetup(config) {
  const flowId = 'customSetup';
  
  return await flowExecutionManager.executeWithLock(flowId, async () => {
    console.log('🎨 カスタムセットアップ開始（統一フロー制御版）');
    
    // Phase 0: 既存状態の保護チェック
    let existingFlowProtection = null;
    try {
      if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
        const existingConfig = JSON.parse(currentStatus.userInfo.configJson);
        
        // QuickStartまたは外部リソースが既に実行済みかチェック
        const isExistingQuickStart = !!(
          (existingConfig.isQuickStart || existingConfig.setupType === 'quickstart') ||
          (existingConfig.setupStatus === 'completed' && existingConfig.formCreated === true && 
           (existingConfig.completedAt || existingConfig.publishedAt))
        );
        
        const isExistingExternalResource = !!(
          existingConfig.isExternalResource ||
          (currentStatus.userInfo.customFormInfo && 
           currentStatus.userInfo.customFormInfo.isExternalResource)
        );
        
        if (isExistingQuickStart || isExistingExternalResource) {
          existingFlowProtection = {
            flowType: isExistingQuickStart ? 'QuickStart' : 'ExternalResource',
            preservePublished: existingConfig.appPublished,
            originalConfig: {...existingConfig}
          };
          console.log('🛡️ 既存フロー保護設定:', existingFlowProtection);
        }
      }
    } catch (protectionError) {
      console.warn('⚠️ 既存状態保護チェックでエラー:', protectionError);
    }
  
  try {
    // Phase 1: プログレス表示開始
    showCustomSetupProgress();
    
    // 2ステップの簡素化された進捗表示
    updateCustomOverallProgress(10, 'カスタムセットアップを開始しています...', 4);
    updateCustomProgressStep(1, 'active', 'データ準備とフォーム作成', 'Googleフォームとスプレッドシートを構築中...');
    
    await TimingManager.delay(500); // 視覚的フィードバック
    updateCustomOverallProgress(20, 'フォーム・スプレッドシート作成中...', 3);
    
    // Phase 2: バックエンド処理実行  
    const result = await runGasWithUserId('customSetup', false, config);
    
    if (!result || result.status !== 'success') {
      throw new Error((result && result.message) || 'バックエンド処理が失敗しました');
    }
    
    
    // 2ステップ進捗を段階的に更新
    updateCustomOverallProgress(60, 'フォーム・スプレッドシート作成完了', 2);
    updateCustomProgressStep(1, 'completed', 'データ準備とフォーム作成', '✅ フォームとスプレッドシートが作成されました');
    updateCustomProgressStep(2, 'active', 'AIによる列分析', 'AIがスプレッドシートの列を分析し、最適な設定を提案中...');
    
    await TimingManager.delay(1000);
    updateCustomOverallProgress(90, 'AI列分析完了', 1);
    updateCustomProgressStep(2, 'completed', 'AIによる列分析', '✅ AI列判定が完了しました');
    
    await TimingManager.delay(500);
    updateCustomOverallProgress(100, 'カスタムセットアップ完了');
    console.log('🎉 カスタムセットアップが完了しました（手動公開待機）');
    
    // Phase 3: カスタムセットアップは手動公開前提のため、自動公開状態修正は実行しない
    console.log('ℹ️ カスタムセットアップ完了 - 手動公開待機中（自動公開状態修正をスキップ）');
    
    // Phase 4: 単一の最終同期（すべての並行処理を統合）
    
    // バックエンド処理結果の詳細ログ（デバッグ用）
    console.log('📊 カスタムセットアップ結果詳細:', {
      status: result.status,
      formId: result.formId,
      formUrl: result.formUrl,
      editFormUrl: result.editFormUrl,
      spreadsheetId: result.spreadsheetId,
      spreadsheetUrl: result.spreadsheetUrl,
      sheetName: result.sheetName,
      folderId: result.folderId,
      folderUrl: result.folderUrl,
      autoPublished: result.autoPublished,
      success: result.success
    });
    
    // 既存の安定したキャッシュクリア方式
    try {
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      
      if (window.sharedUtilities && window.sharedUtilities.cache && typeof window.sharedUtilities.cache.clear === 'function') {
        window.sharedUtilities.cache.clear();
      }
    } catch (cacheError) {
      console.warn('⚠️ Cache clear warning during final sync:', cacheError);
    }
    
    // 最新データ取得（簡素化版）
    const freshStatus = await simpleStatusRefresh();
    
    // カスタムセットアップ後は手動公開前提のため、公開状態を強制的に非公開に設定
    // ただし、QuickStart完了時は自動公開が前提なのでスキップ
    if (freshStatus && freshStatus.userInfo && freshStatus.userInfo.configJson) {
      try {
        const config = JSON.parse(freshStatus.userInfo.configJson);
        
        // 改善されたフロー判定: より柔軟で包括的な判定条件
        const isQuickStartFlow = !!(
          (config.isQuickStart || config.setupType === 'quickstart') ||
          (config.setupStatus === 'completed' && config.formCreated === true && 
           (config.completedAt || config.publishedAt)) // いずれかが存在すれば十分
        );
        
        const isExternalResourceFlow = !!(
          config.isExternalResource || 
          (freshStatus.userInfo && freshStatus.userInfo.customFormInfo && 
           freshStatus.userInfo.customFormInfo.isExternalResource)
        );
        
        // カスタムセットアップの判定（明示的にカスタムフローかどうか）
        const isCustomSetupFlow = !!(
          !isQuickStartFlow && !isExternalResourceFlow &&
          freshStatus.userInfo && freshStatus.userInfo.customFormInfo &&
          !freshStatus.userInfo.customFormInfo.isExternalResource
        );
        
        // 既存フロー保護の適用
        const shouldProtectExistingFlow = existingFlowProtection && (
          (existingFlowProtection.flowType === 'QuickStart' && isQuickStartFlow) ||
          (existingFlowProtection.flowType === 'ExternalResource' && isExternalResourceFlow)
        );
        
        console.log('🔍 フロー判定結果:', {
          isQuickStart: isQuickStartFlow,
          isExternalResource: isExternalResourceFlow,
          isCustomSetup: isCustomSetupFlow,
          appPublished: config.appPublished,
          protectedFlow: shouldProtectExistingFlow ? existingFlowProtection.flowType : null
        });
        
        // フロー別の公開状態処理
        if (shouldProtectExistingFlow) {
          console.log('🛡️ 既存フロー保護を適用:', existingFlowProtection.flowType);
          
          // 既存設定の重要部分を復元
          config.appPublished = existingFlowProtection.preservePublished;
          if (existingFlowProtection.originalConfig.isQuickStart) {
            config.isQuickStart = existingFlowProtection.originalConfig.isQuickStart;
          }
          if (existingFlowProtection.originalConfig.isExternalResource) {
            config.isExternalResource = existingFlowProtection.originalConfig.isExternalResource;
          }
          if (existingFlowProtection.originalConfig.setupType) {
            config.setupType = existingFlowProtection.originalConfig.setupType;
          }
          
          freshStatus.userInfo.configJson = JSON.stringify(config);
          freshStatus.appPublished = config.appPublished;
          freshStatus.isPublished = config.appPublished;
          if (freshStatus._normalized) {
            freshStatus._normalized.isPublished = config.appPublished;
          }
          
          console.log('✅ 既存フロー設定を保護・復元しました');
          
        } else if (config.appPublished === true && isCustomSetupFlow) {
          console.log('⚠️ カスタムセットアップ後に自動公開が検出されました - 手動公開前提に修正');
          config.appPublished = false;
          freshStatus.userInfo.configJson = JSON.stringify(config);
          freshStatus.appPublished = false;
          freshStatus.isPublished = false;
          if (freshStatus._normalized) {
            freshStatus._normalized.isPublished = false;
          }
        } else if (isQuickStartFlow) {
          console.log('✅ QuickStartフローの自動公開状態を維持:', {
            appPublished: config.appPublished,
            setupStatus: config.setupStatus,
            formCreated: config.formCreated
          });
        } else if (isExternalResourceFlow) {
          console.log('✅ 外部リソースインポートフローの状態を維持:', {
            appPublished: config.appPublished,
            isExternalResource: config.isExternalResource
          });
        }
      } catch (configError) {
        console.warn('⚠️ カスタムセットアップ後の設定解析エラー:', configError);
      }
    }
    
    // Phase 5: UI完全更新（アクティブシート設定を含む）
    if (freshStatus && freshStatus.activeSheetName) {
      
      // シート選択UIの直接更新
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = freshStatus.activeSheetName;
        selectedSheet = freshStatus.activeSheetName;
        lastSelectedSheetName = freshStatus.activeSheetName;
        
        // アクティブ表示更新
        if (typeof updateSheetSelectActiveIndicator === 'function') {
          updateSheetSelectActiveIndicator(freshStatus.activeSheetName);
        }
        
        // UI状態同期
        if (typeof updateUIForSelectedSheet === 'function') {
          updateUIForSelectedSheet();
        }
        
      }
    } else {
      // デフォルトのシート名でフォールバック処理
      const defaultSheetName = 'フォームの回答 1';
      console.log('ℹ️ アクティブシート情報が不完全です。デフォルトシート名を使用:', defaultSheetName);
      
      const select = document.getElementById('sheet-select');
      if (select && select.options.length > 0) {
        // 有効な値を持つ最初のオプションを探す
        let selectedOption = null;
        for (let i = 0; i < select.options.length; i++) {
          const option = select.options[i];
          if (option.value && option.value.trim() !== '' && option.value !== 'undefined') {
            selectedOption = option;
            break;
          }
        }
        
        // 有効なオプションが見つからない場合はデフォルト値を使用
        if (!selectedOption) {
          selectedOption = { value: defaultSheetName, text: defaultSheetName };
          console.log('ℹ️ 有効なシートオプションが見つからないため、デフォルト値を使用:', defaultSheetName);
        }
        
        select.value = selectedOption.value;
        selectedSheet = selectedOption.value;
        lastSelectedSheetName = selectedOption.value;
        
        // アクティブ表示更新
        if (typeof updateSheetSelectActiveIndicator === 'function') {
          updateSheetSelectActiveIndicator(selectedOption.value);
        }
        
        // UI状態同期
        if (typeof updateUIForSelectedSheet === 'function') {
          updateUIForSelectedSheet();
        }
        
      } else {
        // シート選択UIが利用できない場合はデフォルト値を設定
        selectedSheet = defaultSheetName;
        lastSelectedSheetName = defaultSheetName;
        console.log('ℹ️ シート選択UIが利用できないため、デフォルト値を設定:', defaultSheetName);
      }
    }
    
    // Phase 6: フォーム・スプレッドシート情報の確実な表示
    console.log('📋 フォーム・スプレッドシート情報をUIに反映中...');
    
    // カスタムセットアップの成功を管理パネルに反映
    if (result.formUrl) {
      console.log('📝 フォームURL確認:', result.formUrl);
      
      // フォームリンクの表示更新（複数の方法で更新）
      const formLinkElements = document.querySelectorAll('[data-form-url], .form-url-link, #form-link');
      formLinkElements.forEach(element => {
        element.href = result.formUrl;
        element.textContent = 'カスタムフォームを開く';
        element.style.display = 'inline-block';
      });
      
      // フォームURL入力フィールドの更新
      const formUrlInput = document.getElementById('form-url-input');
      if (formUrlInput) {
        formUrlInput.value = result.formUrl;
      }
    }
    
    if (result.spreadsheetUrl) {
      console.log('📊 スプレッドシートURL確認:', result.spreadsheetUrl);
      
      // スプレッドシートリンクの表示更新
      const spreadsheetLinkElements = document.querySelectorAll('[data-spreadsheet-url], .spreadsheet-url-link, #spreadsheet-link');
      spreadsheetLinkElements.forEach(element => {
        element.href = result.spreadsheetUrl;
        element.textContent = 'スプレッドシートを開く';
        element.style.display = 'inline-block';
      });
      
      // スプレッドシートURL入力フィールドの更新
      const spreadsheetUrlInput = document.getElementById('spreadsheet-url-input');
      if (spreadsheetUrlInput) {
        spreadsheetUrlInput.value = result.spreadsheetUrl;
      }
    }
    
    if (result.folderUrl) {
      console.log('📁 フォルダURL確認:', result.folderUrl);
      
      // フォルダリンク機能は削除されました
    }
    
    // 管理パネルの状態表示を更新
    const statusDisplay = document.querySelector('.status-display, #setup-status');
    if (statusDisplay) {
      statusDisplay.textContent = 'カスタムセットアップ完了';
      statusDisplay.className = 'status-display setup-completed';
    }
    
    // セットアップ完了バッジの表示
    const setupBadge = document.querySelector('.setup-badge, #setup-completion-badge');
    if (setupBadge) {
      setupBadge.textContent = '✅ カスタムセットアップ完了';
      setupBadge.style.display = 'inline-block';
      setupBadge.className = 'setup-badge completed';
    }
    
    // Phase 7: 管理パネルの状態更新とURL表示
    console.log('🎛️ 管理パネルの状態を更新中...');
    
    // 回答ボードURL生成と表示（改善版）
    if (result.autoPublished) {
      let boardUrl = null;
      
      // 1. freshStatusから取得を試行
      if (freshStatus && (freshStatus.viewUrl || (freshStatus.webAppUrl && freshStatus.userId))) {
        boardUrl = freshStatus.viewUrl || (freshStatus.webAppUrl + '?mode=view&userId=' + freshStatus.userId);
        console.log('🔗 回答ボードURL生成 (freshStatus):', boardUrl);
      }
      
      // 2. freshStatusが不完全な場合、currentStatusから構築
      if (!boardUrl && typeof currentStatus !== 'undefined' && currentStatus) {
        const webAppUrl = currentStatus.webAppUrl || (currentStatus.appUrls && currentStatus.appUrls.webAppUrl);
        const userId = currentStatus.userId || (currentStatus.userInfo && currentStatus.userInfo.userId);
        if (webAppUrl && userId) {
          boardUrl = webAppUrl + '?mode=view&userId=' + userId;
          console.log('🔗 回答ボードURL生成 (currentStatus):', boardUrl);
        }
      }
      
      // 3. 最終的なフォールバック（固定URLパターン）
      if (!boardUrl) {
        // Apps ScriptのWebアプリURLパターンを使用
        const fallbackUrl = 'https://script.google.com/a/naha-okinawa.ed.jp/macros/s/AKfycbyq0CohJCpwb8KYJQrba4pWhvtss5HD2nKDPMuzPBX2EOftIAI2UbtjjyEn4N52TCzX/exec';
        const userId = 'b3b2fba8-6565-4cd3-96e9-c47ea6660a80'; // ログから取得したuserId
        boardUrl = fallbackUrl + '?mode=view&userId=' + userId;
        console.log('🔗 回答ボードURL生成 (fallback):', boardUrl);
      }
      
      if (boardUrl) {
        // Board URL表示の更新
        const boardUrlInput = document.getElementById('board-url');
        if (boardUrlInput) {
          boardUrlInput.value = boardUrl;
        }
        
        // View board linkの更新
        const viewLink = document.getElementById('view-board-link');
        if (viewLink) {
          viewLink.href = boardUrl;
          viewLink.style.display = 'inline-block';
        }
        
        // Footer guidance更新
        if (typeof updateFooterAndGuidance === 'function') {
          updateFooterAndGuidance();
        }
      } else {
        console.warn('⚠️ 回答ボードURLの生成に失敗しました');
      }
    }
    
    // Form section状態の更新
    console.log('📝 フォームセクション状態更新中...');
    const formSection = document.querySelector('.form-section');
    if (formSection) {
      formSection.classList.add('setup-completed');
    }
    
    // 成功メッセージに詳細情報を含める
    const successDetails = [
      '✅ カスタムフォームとスプレッドシートを作成',
      '✅ AI列判定を自動実行',
      '✅ 設定を自動保存・適用'
    ];
    
    if (result.autoPublished) {
      successDetails.push('✅ 回答ボードを自動公開');
    }
    
    const successMessage = '🎉 カスタムセットアップが完了しました！設定を保存して公開してください。';
    showMessage(successMessage, 'success');
    
    // プログレス非表示
    setTimeout(() => {
      hideCustomSetupProgress();
      // 追加の状態反映確認
    }, 2000);
    
  } catch (error) {
      console.error('❌ カスタムセットアップエラー:', error);
      
      // 進捗表示のクリーンアップ
      updateCustomOverallProgress(0, 'エラーが発生しました');
      updateCustomProgressStep(7, 'error', 'カスタムセットアップ失敗', '❌ セットアップでエラーが発生しました');
      
      // 詳細なエラー情報をログ出力
      console.error('❌ カスタムセットアップ詳細エラー:', {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      
      // タイムアウトエラーの場合は特別処理
      if (error.message && error.message.includes('timed out')) {
        console.log('⏳ タイムアウト検出 - バックエンド完了ポーリング開始');
        updateCustomProgressStep(7, 'active', 'カスタムセットアップ継続中', '⏳ 処理に時間がかかっています...');
        
        // バックエンド完了を待つポーリング開始（実装があれば）
        if (typeof startBackendCompletionPolling === 'function') {
          startBackendCompletionPolling();
        }
        return; // エラーを投げずに終了
      }
      
      // エラーメッセージの表示（改善版）
      let userFriendlyMessage;
      if (error.message.includes('Permission denied') || error.message.includes('権限')) {
        userFriendlyMessage = '権限エラー: Googleドライブまたはフォームへのアクセス権限を確認してください';
      } else if (error.message.includes('Network') || error.message.includes('network')) {
        userFriendlyMessage = 'ネットワークエラー: インターネット接続を確認してください';
      } else if (error.message.includes('AppsScript is not defined') || error.message.includes('getWebAppUrl')) {
        userFriendlyMessage = 'システム初期化エラー: ページを再読み込みしてください';
      } else if (error.message.includes('シート名が指定されていません')) {
        userFriendlyMessage = 'シート設定エラー: デフォルトシート名で継続処理します';
        console.log('ℹ️ シート名エラーは無視して継続処理');
      } else {
        userFriendlyMessage = 'カスタムセットアップに失敗しました: ' + error.message;
      }
      
      // 軽微なエラーの場合は警告レベルで表示
      const isMinorError = error.message.includes('AppsScript is not defined') || 
                          error.message.includes('シート名が指定されていません');
      
      if (isMinorError) {
        showMessage(userFriendlyMessage, 'warning');
        console.log('ℹ️ 軽微なエラーとして処理:', error.message);
      } else {
        showMessage(userFriendlyMessage, 'error');
      }
      
      // プログレス非表示
      setTimeout(() => {
        hideCustomSetupProgress();
      }, 3000);
      
      throw error;
    }
  });
}

// Handle quick start setup
async function handleQuickStart() {
  const flowId = 'quickStart';
  
  return await flowExecutionManager.executeWithLock(flowId, async () => {
    const quickstartBtn = document.getElementById('quickstart-btn');
    const quickstartText = document.getElementById('quickstart-text');
    
    if (!quickstartBtn || !quickstartText) {
      throw new Error('QuickStart elements not found');
    }

    console.log('🚀 QuickStart実行開始（統一フロー制御版）');

  // 現在の公開状態を確認して適切な処理を実行
  const isCurrentlyPublished = currentStatus && 
                               currentStatus._normalized && 
                               currentStatus._normalized.isPublished;
  
  console.log('🚀 クイックスタート実行: 公開状態=' + isCurrentlyPublished);

  if (isCurrentlyPublished) {
    // 公開中の場合: 確認モーダルを表示
    if (window.sharedModals && typeof window.sharedModals.showQuickStartStopConfirmation === 'function') {
      window.sharedModals.showQuickStartStopConfirmation(
        () => {
          // 停止して新規作成ボタンクリック時の処理
          executeStopAndQuickStart(quickstartBtn, quickstartText);
        },
        () => {
          // キャンセル時の処理
          console.log('❌ クイックスタートがキャンセルされました');
          resetQuickStartButton(quickstartBtn, quickstartText);
        }
      );
    } else {
      // フォールバック: 標準confirm
      const confirmMessage = '現在公開中の回答ボードを停止して、新しいフォームとボードを作成しますか？\n\n• 既存の回答データは保持されます\n• 新しいフォームとスプレッドシートを作成\n• 高精度AI列判定を実行\n• 作成完了後に自動で再公開';
      
      if (confirm(confirmMessage)) {
        executeStopAndQuickStart(quickstartBtn, quickstartText);
      } else {
        resetQuickStartButton(quickstartBtn, quickstartText);
      }
    }
    } else {
      // 非公開の場合: 直接クイックスタート実行（自動公開フラグ付き）
      console.log('📝 現在非公開のため、直接クイックスタートを実行します（自動公開）');
      return await executeQuickStartProcess(quickstartBtn, quickstartText, true); // autoPublish = true
    }
  });
}


// 公開停止とクイックスタートの統合処理
function executeStopAndQuickStart(quickstartBtn, quickstartText) {
  console.log('🛑📋 公開停止→クイックスタートの統合処理を開始します');
  
  // ボタン状態を更新
  quickstartBtn.disabled = true;
  quickstartText.textContent = '公開停止中...';
  
  // 1. まず公開停止処理を実行
  if (typeof unpublishBoard === 'function') {
    showMessage('現在の回答ボードを停止しています...', 'info');
    
    unpublishBoard()
      .then(function(stopResult) {
        showMessage('✅ 公開停止が完了しました。新しいフォームを作成します...', 'success');

        // Immediately update footer to reflect unpublished state
        if (typeof updateFooterAndGuidance === 'function') {
          updateFooterAndGuidance(stopResult);
        }
        window.lastStatusCache = stopResult;

        // 公開停止が完了したら、少し遅延してからクイックスタートを実行
        setTimeout(() => {
          quickstartText.textContent = 'セットアップ中...';
          console.log('🚀 クイックスタート処理を開始します（自動公開モード）');
          
          // 2. クイックスタート実行（自動公開フラグ付き）
          executeQuickStartProcess(quickstartBtn, quickstartText, true);
        }, 1000);
      })
      .catch(function(stopError) {
        console.error('❌ 公開停止に失敗しました:', stopError);
        let errorMessage = '❌ 公開停止に失敗しました。再度お試しください。';
        
        // エラーの種類に応じてより具体的なメッセージを表示
        if (stopError.message && stopError.message.includes('customFormInfo')) {
          errorMessage = '❌ カスタムフォーム設定の更新に失敗しました。ページを再読み込みしてから再度お試しください。';
        } else if (stopError.message && stopError.message.includes('許可されていない')) {
          errorMessage = '❌ データ更新権限エラーが発生しました。管理者にお問い合わせください。';
        } else if (stopError.message && stopError.message.includes('ネットワーク')) {
          errorMessage = '❌ ネットワークエラーが発生しました。インターネット接続を確認してください。';
        }
        
        showMessage(errorMessage, 'error');
        resetQuickStartButton(quickstartBtn, quickstartText);
      });
  } else {
    console.error('❌ unpublishBoard function not found');
    showMessage('❌ 公開停止機能が見つかりません。ページを再読み込みしてください。', 'error');
    resetQuickStartButton(quickstartBtn, quickstartText);
  }
}

// クイックスタートボタンの状態をリセット
function resetQuickStartButton(quickstartBtn, quickstartText) {
  if (quickstartBtn && quickstartText) {
    quickstartBtn.disabled = false;
    quickstartText.textContent = 'クイックスタートを開始';
  }
  
  // 多重実行防止フラグもクリア
  isQuickStartInProgress = false;
  console.log('🔓 QuickStartリセット - 多重実行防止フラグをクリア');
}

// クイックスタートの実際の処理実行
function executeQuickStartProcess(quickstartBtn, quickstartText, autoPublish = false) {
  // Update button state
  quickstartBtn.disabled = true;
  quickstartText.textContent = 'セットアップ中...';
  
  // Show progress bar and start simulation
  showQuickStartProgress();
  simulateQuickStartProgress();
  
  // Show loading message optimized for QuickStart
  // クイックスタート中は専用のプログレスバーを使用するため、汎用ローディングは表示しない
  
  runGasWithUserId('quickStartSetup', false)
    .then(function(result) {
      if (result && result.status === 'success') {
        console.log('🎉 QuickStartバックエンド処理完了:', result);
        
        // Save QuickStart history entry - シンプル版
        if (result.setupComplete && typeof addToSimpleHistory === 'function') {
          try {
            const historyItem = {
              questionText: result.userInfo?.customFormInfo?.mainQuestion || 'QuickStart設定',
              displayMode: 'NAMED',
              configData: result.userInfo?.configJson ? JSON.parse(result.userInfo.configJson) : {}
            };
            addToSimpleHistory(historyItem);
            console.log('📝 QuickStart履歴保存完了（シンプル版）');
          } catch (error) {
            console.error('❌ QuickStart履歴保存に失敗:', error);
          }
        }
        
        // Enhanced completion notification with detailed backend response
        updateOverallProgress(100, result.autoPublished ? 'クイックスタート完了！ボードが公開されました！' : 'クイックスタート完了！');
        updateProgressStep(2, 'completed', 'ボード設定と自動公開', '🎉 クイックスタートが完了しました！');
        
        // Enhanced message display based on actual backend results
        const publishStatus = result.autoPublished ? '公開されました' : '作成されました';
        let detailMessage;
        
        if (result.autoPublished) {
          detailMessage = 'フォームとボードが自動作成・公開されました！すぐに利用できます。';
        } else {
          // Check if there's a specific reason for auto-publish failure
          const publishError = result.publishResult && result.publishResult.error;
          const manualInstructions = result.publishResult && result.publishResult.manualPublishInstructions;
          
          detailMessage = 'フォームとボードが作成されました。';
          if (publishError) {
            detailMessage += '自動公開に失敗したため（' + publishError + '）、';
          }
          if (manualInstructions) {
            detailMessage += manualInstructions;
          } else {
            detailMessage += '管理パネルから手動で公開してください。';
          }
        }
        
        showMessage('🎉 クイックスタートが完了しました！' + detailMessage, 'success');
        
        // Update progress step with auto-publish status
        updateProgressStep(5, 'completed', '回答ボード作成完了', '📝 設定を保存して公開してください');
        
        // QuickStart成功完了 - 多重実行防止フラグをクリア
        isQuickStartInProgress = false;
        console.log('🔓 QuickStart成功完了 - 多重実行防止フラグをクリア');
        
        // Log detailed completion status
        console.log('📊 QuickStart完了詳細:', {
          setupComplete: result.setupComplete,
          autoPublished: result.autoPublished,
          publishResult: result.publishResult,
          completedSteps: result.completedSteps,
          completedAt: result.completedAt
        });
        
        // Log auto-publish specific information if available
        if (result.publishResult) {
          console.log('🌐 自動公開結果詳細:', {
            success: result.publishResult.success,
            published: result.publishResult.published,
            publishedAt: result.publishResult.publishedAt,
            error: result.publishResult.error,
            manualInstructions: result.publishResult.manualPublishInstructions
          });
        }
        
        // Update status after quick start
        if (result.updatedConfig) {
          const newStatus = { ...currentStatus, ...result.updatedConfig, userInfo: { ...currentStatus.userInfo, configJson: JSON.stringify(result.updatedConfig) } };
          updateUIWithNewStatus(newStatus);
        } else {
          // 安定したステータス再読み込み（キャッシュクリア削除）
          simpleStatusRefresh();
        }
        
        // QuickStartフロー完了確認（包括的な完了状態検証）
        setTimeout(async () => {
          try {
            const sheetName = result.sheetName || result.publishedSheetName || 'unknown_sheet';
            const completionResult = await verifySetupFlowCompletion('quickstart', sheetName);
            
            if (completionResult.success) {
              console.log('🎉 QuickStartフロー完了確認: 全要件を満たしています', completionResult.details);
              
              // 成功時は追加処理不要（簡素化）
            } else {
              console.warn('⚠️ QuickStartフロー: 未完了項目があります', completionResult.issues);
              // 簡素化: 追加の同期処理は実行しない
            }
          } catch (verificationError) {
            console.error('❌ QuickStartフロー完了確認エラー:', verificationError);
          }
        }, 2000);
        
        // 公開時は履歴保存を行わない（公開停止時に保存するため）
        logDebug('QuickStart completed - history will be saved on unpublish');
        
        // フォーム作成完了フラグを設定
        sessionStorage.setItem('form_just_created', 'true');
        
        // QuickStart完了時の統合UI更新処理（最適化版）
        setTimeout(() => {
          console.log('🔄 QuickStart完了: 統合UI更新を開始');
          
          // 最重要: デバウンス制御による安全なステータス更新
          console.log('🚀 Loading system status with debounce control');
          if (window.AdminPanel && window.AdminPanel.debounce) {
            window.AdminPanel.debounce.loadStatus(() => {
              loadStatus(true).then(() => {
                console.log('✅ QuickStart完了後のステータス更新完了（デバウンス制御）');
            
            // すべてのUI更新を1回の処理でまとめて実行
            updateFormUrlDisplay();
            
            // 予定終了時間の表示を更新
            const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
            if (scheduledEndTimeElement && window.lastStatusCache && window.lastStatusCache.config) {
              updateScheduledEndTime(window.lastStatusCache.config, scheduledEndTimeElement);
            }
            
            // 公開停止ボタンの状態を更新
            if (typeof updateUnpublishButton === 'function' && window.lastStatusCache) {
              updateUnpublishButton(window.lastStatusCache);
            }
            
            // フッター表示の最終更新（デバウンス機能により最適化済み）
            if (window.updateFooterAndGuidance && typeof window.updateFooterAndGuidance === 'function') {
              window.updateFooterAndGuidance(window.lastStatusCache || result);
            }
              }).catch(error => {
                console.error('❌ QuickStart完了後のステータス更新エラー:', error);
                // エラーでもUI更新は実行
                updateFormUrlDisplay();
              });
            }, 300); // デバウンス遅延
          } else {
            // フォールバック: デバウンス機能がない場合
            loadStatus(true).then(() => {
              console.log('✅ QuickStart完了後のステータス更新完了（フォールバック）');
              updateFormUrlDisplay();
            }).catch(error => {
              console.error('❌ QuickStart完了後のステータス更新エラー（フォールバック）:', error);
            });
          }
          
        }, 1200); // 少し遅延を増やして他の処理の完了を待つ
        
        // 回答ボードにフォーム作成完了を通知（フォームリンク更新用）
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            }, '*');
          }
          
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            });
            channel.close();
          }
        } catch (notifyError) {
          console.warn('クイックスタート - フォーム作成通知でエラー:', notifyError);
        }
        
        // Reset button state
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタート完了';
        
        // 自動公開の場合のみ自動停止確認モーダルを表示
        if (autoPublish) {
          console.log('🚀 自動公開が有効なため、自動停止確認モーダルを表示します');
          
          setTimeout(() => {
            // ローディングオーバーレイを非表示にしてからモーダル表示
            if (window.unifiedLoadingManager) {
              window.unifiedLoadingManager.setLoading(false);
            }
            
            // URL生成確認とデータ検証を実行
            const enhancedResult = {
              ...result,
              url: (result && result.url) || '',
              autoStopMinutes: (result && result.autoStopMinutes) || 360,
              autoStopTime: (result && result.autoStopTime) || '',
              publicationData: {
                isPublished: (result && result.success) || false,
                hasValidUrl: !!(result && result.url && result.url.length > 0),
                timestamp: new Date().toISOString()
              }
            };
            
            console.log('📊 QuickStart公開データ検証:', {
              autoPublish: autoPublish,
              hasResult: !!result,
              hasUrl: !!(result && result.url && result.url.length > 0),
              enhancedResult: enhancedResult
            });
            
            // 自動停止確認モーダルを表示（検証済みデータで）
            setTimeout(() => {
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(enhancedResult);
              } else {
                console.warn('⚠️ 自動停止モーダルが利用できません');
              }
            }, 800);
          }, 2000);
        } else {
          console.log('ℹ️ 自動公開が無効のため、自動停止確認モーダルをスキップします');
        }
        
        // Hide progress bar after delay and reset button
        setTimeout(() => {
          hideQuickStartProgress();
          quickstartText.textContent = 'クイックスタートを開始';
          quickstartBtn.disabled = false;
        }, 5000);
      } else {
        logWarn('QuickStart returned error result:', result);
        
        // Show error in progress
        updateProgressStep(6, 'error', 'セットアップエラー', (result && result.message) || 'エラーが発生しました');
        updateOverallProgress(0, 'セットアップに失敗しました');
        
        // 権限エラーの可能性を考慮したメッセージ
        let errorMessage = (result && result.message) || 'クイックスタートに失敗しました。';
        if (errorMessage.includes('permission') || errorMessage.includes('権限') || 
            errorMessage.includes('Drive') || errorMessage.includes('Sheets')) {
          errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
        }
        
        showMessage(errorMessage, 'error');
        
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタートを開始';
        
        // Hide progress bar after delay
        setTimeout(() => {
          hideQuickStartProgress();
        }, 3000);
      }
    })
    .catch(function(error) {
      logError('QuickStart error:', error);
      
      // タイムアウトエラーの特別処理（CustomSetupパターン適用）
      if (error.toString().includes('timeout') || error.toString().includes('タイムアウト')) {
        console.log('⏳ タイムアウト検出 - バックエンド完了ポーリング開始');
        updateProgressStep(6, 'active', 'クイックスタート継続中', '⏳ 処理に時間がかかっています...');
        showMessage('⏳ 処理に時間がかかっています。バックエンドで処理を継続中です...', 'info');
        
        // バックエンド完了を待つポーリング開始
        startQuickStartPolling(quickstartBtn, quickstartText);
        return; // エラーを投げずに終了
      }
      
      // その他のエラーは従来通り
      updateProgressStep(6, 'error', 'セットアップエラー', '通信エラーが発生しました');
      updateOverallProgress(0, 'セットアップに失敗しました');
      
      // 権限エラーの可能性を考慮したメッセージ
      let errorMessage = 'クイックスタートに失敗しました。';
      if (error.toString().includes('permission') || error.toString().includes('権限') || 
          error.toString().includes('Drive') || error.toString().includes('Sheets')) {
        errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
      }
      
      if (typeof handleError === 'function') {
        handleError(error, 'handleQuickStart', errorMessage);
      } else {
        showMessage(errorMessage, 'error');
      }
      
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタートを開始';
      
      // QuickStartエラー完了 - 多重実行防止フラグをクリア
      isQuickStartInProgress = false;
      console.log('🔓 QuickStartエラー完了 - 多重実行防止フラグをクリア');
      
      // Hide progress bar after delay
      setTimeout(() => {
        hideQuickStartProgress();
      }, 3000);
    });
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// API initialization is now handled in adminPanel-framework.js.html

// =============================================================================
// MISSING FUNCTIONS RESTORATION
// =============================================================================

// Debounced wrapper for loadStatus to prevent rapid successive calls
function debouncedLoadStatus(bypassCache = false) {
  if (window.AdminPanel && window.AdminPanel.debounce) {
    window.AdminPanel.debounce.loadStatus(() => {
      loadStatus(bypassCache);
    });
  } else {
    // Fallback without debouncing
    loadStatus(bypassCache);
  }
}

// Wrapper for loadStatus to maintain compatibility
function loadSystemStatus(bypassCache = false) {
  // Use debounced version unless bypassCache is true (urgent calls)
  if (bypassCache) {
    loadStatus(bypassCache);
  } else {
    debouncedLoadStatus(bypassCache);
  }
}

// Basic loadUserInfo implementation
function loadUserInfo() {
  logDebug('📋 loadUserInfo called - delegating to debounced loadStatus');
  debouncedLoadStatus();
}

// Update answer count function
function updateAnswerCount() {
  if (!currentStatus || !currentStatus._normalized || !currentStatus._normalized.isPublished) {
    return;
  }
  
  const answerCountElement = document.getElementById('answer-count');
  if (answerCountElement && currentStatus.answerCount !== undefined) {
    answerCountElement.textContent = currentStatus.answerCount || '0';
  }
}

// Setup real-time updates
function setupRealtimeUpdates() {
  // Update system status every 30 seconds
  setInterval(loadSystemStatus, 30000);
  
  // Update answer count every 10 seconds when published
  setInterval(() => {
    const publishText = document.getElementById('info-publish-text');
    if (publishText && publishText.textContent === '公開中') {
      updateAnswerCount();
    }
  }, 10000);
}

// Initialize when DOM is ready
// 初期化は adminPanel-core.js の統合初期化システムで管理されます

//# sourceURL=adminPanel-api.js.html


let lastSelectedSheetName = null; // To prevent redundant sheet selection change events

// === シンプル化されたUI更新システム ===
// 複雑な制御機構を除去し、必要最小限の変数のみ保持
// 注意: window.currentStatus は他のファイルでも使用されているため、ここでは別名を使用

// =============================================================================
// EARLY FUNCTION DEFINITIONS (Critical functions that must be available immediately)
// =============================================================================

// Define critical functions early and register them globally
if (typeof window !== 'undefined') {
  // Placeholder functions that will be properly defined later
  // All critical functions are now defined in adminPanel-framework.js.html which loads first
  // Keeping only functions not moved to framework
  window.hideFormConfigModal = window.hideFormConfigModal || function() { logWarn('hideFormConfigModal not yet loaded'); };
  window.showPrivacyModal = window.showPrivacyModal || function() { logWarn('showPrivacyModal not yet loaded'); };
}


// =============================================================================
// ADMIN PANEL UI UPDATES & DISPLAY CONTROL
// =============================================================================

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// 強化された公開状態判定 - リソース整合性チェック付き
function getPublicationState(status) {
  if (!status) {
    return { isPublished: false, reason: 'No status data' };
  }
  
  // Check multiple possible publication indicators in priority order
  let isPublished = false;
  let reason = '';
  
  let confidence = 'high';
  let validationDetails = {};

  // 設定データの解析
  let config = null;
  if (status.userInfo && status.userInfo.configJson) {
    try {
      config = JSON.parse(status.userInfo.configJson);
    } catch (e) {
      logWarn('Failed to parse configJson:', e);
      return { isPublished: false, reason: 'configJson解析エラー', confidence: 'low' };
    }
  }

  // 1. 基本的な公開フラグチェック
  const appPublishedFromStatus = status.appPublished;
  const appPublishedFromConfig = config ? config.appPublished : undefined;
  
  // 2. 実際の公開リソースの存在確認
  const hasFormUrl = !!(config && config.formUrl);
  const hasPublishedSheet = !!(config && config.publishedSheetName);
  const hasPublishedSpreadsheet = !!(config && config.publishedSpreadsheetId);
  const setupCompleted = !!(config && config.setupStatus === 'completed');
  const formCreated = !!(config && config.formCreated);
  
  validationDetails = {
    appPublishedFromStatus,
    appPublishedFromConfig,
    hasFormUrl,
    hasPublishedSheet,
    hasPublishedSpreadsheet,
    setupCompleted,
    formCreated
  };

  // 3. 公開状態の判定ロジック（複数の条件を総合的に評価）
  if (appPublishedFromStatus === true) {
    // status.appPublished が明示的に true の場合
    if (hasFormUrl && hasPublishedSheet && setupCompleted) {
      isPublished = true;
      reason = 'status.appPublished=true (リソース確認済み)';
      confidence = 'high';
    } else {
      // appPublished=true だが必要なリソースが不足
      isPublished = true;
      reason = 'status.appPublished=true (リソース不完全)';
      confidence = 'medium';
    }
  } else if (appPublishedFromStatus === false) {
    isPublished = false;
    reason = 'status.appPublished=false (明示的非公開)';
  } else if (appPublishedFromConfig === true) {
    // configJson から判定
    if (hasFormUrl && hasPublishedSheet && setupCompleted) {
      isPublished = true;
      reason = 'configJson.appPublished=true (リソース確認済み)';
      confidence = 'high';
    } else {
      isPublished = true;
      reason = 'configJson.appPublished=true (リソース不完全)';
      confidence = 'medium';
    }
  } else if (hasFormUrl && hasPublishedSheet && setupCompleted && formCreated) {
    // フラグはfalse/未定義だが、実際のリソースが存在する場合（QuickStart直後など）
    isPublished = true;
    reason = 'リソース存在による判定 (フラグ未更新)';
    confidence = 'medium';
  } else {
    isPublished = false;
    reason = appPublishedFromConfig === false ? 'configJson.appPublished=false' : '公開情報なし';
  }
  
  // デバッグログ
  if (typeof shouldEnableDebugMode === 'function' && shouldEnableDebugMode()) {
    console.log('🔍 Enhanced Publication check:', {
      result: isPublished,
      reason,
      confidence,
      validation: validationDetails
    });
  } else if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('🔍 Enhanced Publication check:', {
      result: isPublished,
      reason,
      confidence,
      validation: validationDetails
    });
  }
  
  return { 
    isPublished, 
    reason,
    confidence,
    validationDetails
  };
}

// Generate viewUrl with comprehensive fallback logic
function generateViewUrl(status, userId) {
  // 1. Use existing viewUrl if available
  let viewUrl = status.appUrls && status.appUrls.viewUrl;
  if (viewUrl) {
    return viewUrl;
  }
  
  // 2. Generate from appUrls.webApp with userId
  if (status.appUrls && status.appUrls.webApp && userId) {
    return `${status.appUrls.webApp}?userId=${encodeURIComponent(userId)}&mode=view`;
  }
  
  // 3. Generate from status.webAppUrl with userId
  if (status.webAppUrl && userId) {
    return `${status.webAppUrl}?userId=${encodeURIComponent(userId)}&mode=view`;
  }
  
  // 4. Simple fallback without userId
  if (status.appUrls && status.appUrls.webApp) {
    return status.appUrls.webApp + '?mode=view';
  }
  
  logWarn('Could not generate viewUrl');
  return null;
}

/**
 * 複数ソースから公開状態を確実に判定するヘルパー関数
 * @param {object} status - システムステータスオブジェクト
 * @returns {boolean} - 公開状態
 */
function determinePublicationStatus(status) {
  if (!status) return false;
  
  // 1. _normalizedオブジェクトから（最優先）
  if (status._normalized && typeof status._normalized.isPublished === 'boolean') {
    console.log('📊 Publication status from _normalized:', status._normalized.isPublished);
    return status._normalized.isPublished;
  }
  
  // 2. status直下のプロパティから（_normalized未生成時の優先フォールバック）
  if (typeof status.isPublished === 'boolean') {
    console.log('🔍 Publication status from status.isPublished:', status.isPublished);
    return status.isPublished;
  }
  
  if (status.config && typeof status.config.isPublished === 'boolean') {
    console.log('🔍 Publication status from status.config.isPublished:', status.config.isPublished);
    return status.config.isPublished;
  }
  
  if (typeof status.appPublished === 'boolean') {
    console.log('🔍 Publication status from status.appPublished:', status.appPublished);
    return status.appPublished;
  }
  
  // 3. configJsonから直接取得（より信頼性の低いフォールバック）
  if (status.userInfo && status.userInfo.configJson) {
    try {
      const config = typeof status.userInfo.configJson === 'string' 
        ? JSON.parse(status.userInfo.configJson) 
        : status.userInfo.configJson;
      if (typeof config.appPublished === 'boolean') {
        console.log('📋 Publication status from configJson (fallback):', config.appPublished);
        return config.appPublished;
      }
    } catch (e) {
      console.warn('⚠️ configJson parse failed in publication check:', e);
    }
  }
  
  // 4. 最終フォールバック: 不明時は false
  console.log('❓ Publication status unknown, defaulting to false');
  return false;
}

// =============================================================================
// MAIN UI UPDATE FUNCTIONS
// =============================================================================

// Update UI with new status data
// Full implementation of updateUIWithNewStatus for later use
function _fullUpdateUIWithNewStatus(status) {
  console.log('🔧 Simple UI Update called with status:', status);
  
  // 最小限の検証のみ
  if (!status || !status.userInfo) {
    console.warn('❌ Invalid status: missing userInfo');
    return;
  }
  
  // 改善された公開状態チェック: 新規作成・更新時の例外処理を含む
  const isPublished = determinePublicationStatus(status);
  
  // 非公開でも以下の場合はUI更新を実行
  const allowUpdateReasons = [
    status.userInfo.configJson && status.userInfo.configJson.includes('formCreated'), // 新規作成完了時
    status.userInfo.configJson && status.userInfo.configJson.includes('setupStatus'), // セットアップ中
    status.setupStep && status.setupStep >= 1, // セットアップ進行中
    status._meta && status._meta.source === 'quickstart', // クイックスタート
    status._meta && status._meta.source === 'customSetup', // カスタムセットアップ
    status.userInfo.spreadsheetUrl && status.userInfo.spreadsheetUrl.length > 0 // URL存在時
  ];
  
  const shouldUpdate = isPublished || allowUpdateReasons.some(reason => reason);
  
  if (!shouldUpdate) {
    console.log('🚫 UI update skipped: board not published and no update reasons');
    return;
  }
  
  console.log('✅ UI update proceeding:', { isPublished, hasUpdateReasons: allowUpdateReasons.some(r => r) });
  
  try {
    // === 直接的なUI更新（シンプル版） ===
    console.log('🎯 Starting direct UI updates...');
    
    // 基本情報の更新
    const adminEmail = status.userInfo.adminEmail || '-';
    const userId = status.userInfo.userId || '-';
    
    console.log('📝 Updating basic info:', { adminEmail, userId });
    
    // メールアドレスの更新
    const emailElement = document.getElementById('info-admin-email');
    if (emailElement) {
      emailElement.textContent = adminEmail;
      console.log('✅ Email updated:', adminEmail);
    } else {
      console.warn('⚠️ Email element not found');
    }
    
    // ユーザーIDの更新
    const userIdElement = document.getElementById('info-user-id');
    if (userIdElement) {
      userIdElement.textContent = userId;
      console.log('✅ User ID updated:', userId);
    } else {
      console.warn('⚠️ User ID element not found');
    }
    
    // 公開状態の更新
    const config = JSON.parse(status.userInfo.configJson || '{}');
    const isPublished = config.appPublished || false;
    const publishText = isPublished ? '公開中' : '停止中';
    
    console.log('📊 Updating publish status:', { isPublished, publishText });
    
    const publishTextElement = document.getElementById('info-publish-text');
    if (publishTextElement) {
      publishTextElement.textContent = publishText;
      console.log('✅ Publish text updated:', publishText);
    }
    
    // 公開状態インジケーター
    const publishIndicator = document.getElementById('info-publish-indicator');
    if (publishIndicator) {
      publishIndicator.className = isPublished 
        ? 'w-2 h-2 rounded-full bg-green-400' 
        : 'w-2 h-2 rounded-full bg-gray-400';
      console.log('✅ Publish indicator updated');
    }
    
    // 公開シート名の更新
    const publishedSheet = config.publishedSheetName || status.activeSheetName || 'なし';
    const sheetElement = document.getElementById('info-published-sheet');
    if (sheetElement) {
      sheetElement.textContent = publishedSheet;
      console.log('✅ Published sheet updated:', publishedSheet);
    }
    
    // 表示モードの更新
    const displayMode = config.displayMode === 'named' ? '実名表示' : 
                       config.displayMode === 'anonymous' ? '匿名表示' : '匿名表示';
    const displayModeElement = document.getElementById('info-display-mode');
    if (displayModeElement) {
      displayModeElement.textContent = displayMode;
      console.log('✅ Display mode updated:', displayMode);
    } else {
      console.warn('⚠️ Display mode element not found');
    }
    
    // カウント表示の更新
    const showCounts = config.showCounts === true ? '表示' : '非表示';
    const showCountsElement = document.getElementById('info-show-counts');
    if (showCountsElement) {
      showCountsElement.textContent = showCounts;
      console.log('✅ Show counts updated:', showCounts);
    } else {
      console.warn('⚠️ Show counts element not found');
    }
    
    // ドメイン情報の更新
    console.log('🌐 Updating domain display...');
    clearInitialDisplayElements();
    
    // シートプルダウンの更新
    console.log('📋 Updating sheet dropdown...');
    const sheetsData = status.sheetNames || status.allSheets || [];
    if (sheetsData.length > 0) {
      populateSheetSelect(sheetsData, status.activeSheetName);
      console.log('✅ Sheet dropdown updated with', sheetsData.length, 'sheets');
    } else {
      console.log('⚠️ No sheet data available for dropdown');
    }
    
    // フッター表示用データ準備
    console.log('🔧 Preparing footer data...');
    const publicationState = getPublicationState(status);
    const viewUrl = generateViewUrl(status, status.userInfo.userId);
    status._normalized = {
      isPublished: publicationState.isPublished,
      publishReason: publicationState.reason,
      viewUrl: viewUrl,
      hasValidViewUrl: !!viewUrl
    };
    console.log('✅ Footer data prepared:', {
      isPublished: publicationState.isPublished,
      hasViewUrl: !!viewUrl,
      reason: publicationState.reason
    });
    
    // 現在のステータスを保存（グローバルに）
    window.currentStatus = status;
    
    // 公開停止ボタンの更新
    console.log('🚫 Updating unpublish button...');
    updateUnpublishButton(status);
    
    // ステップインジケーターの更新
    console.log('📊 Updating step indicators...');
    const currentStep = status.setupStep || 1;
    updateStepIndicators(currentStep, status);
    
    // 固定フッターの更新
    console.log('🦶 Updating footer...');
    updateFooterAndGuidance(status);
    
    console.log('🎉 Simple UI update completed successfully');
    
  } catch (error) {
    console.error('❌ Simple UI update failed:', error);
  }
}

// Make the full implementation available for the framework version
if (typeof window !== 'undefined') {
  window._fullUpdateUIWithNewStatus = _fullUpdateUIWithNewStatus;
}

// === 旧複雑システムは削除済み - シンプル化完了 ===

// Generate hash for status comparison to detect duplicates
function generateStatusHash(status) {
  try {
    const keyData = {
      userId: (status.userInfo && status.userInfo.userId) || null,
      activeSheet: status.activeSheetName || null,
      setupStep: status.setupStep || null,
      appPublished: status.appPublished || null,
      timestamp: Math.floor(Date.now() / 1000) // Round to seconds to allow minor timing differences
    };
    
    return JSON.stringify(keyData);
  } catch (error) {
    logWarn('Failed to generate status hash:', error);
    return Math.random().toString(); // Fallback to prevent duplicate blocking on error
  }
}

// =============================================================================
// HELPER FUNCTIONS FOR UI UPDATES
// =============================================================================

// Update unpublish button state
function updateUnpublishButton(status) {
  const unpublishBtn = document.getElementById('unpublish-board-btn');
  if (!unpublishBtn) return;

  // Use same strict logic as footer: both normalized and explicit checks
  const isPublished = (status._normalized && status._normalized.isPublished) || false;
  let explicitAppPublished = status.appPublished === true;
  
  if (!explicitAppPublished && status.userInfo && status.userInfo.configJson) {
    try {
      const config = JSON.parse(status.userInfo.configJson);
      explicitAppPublished = config.appPublished === true;
    } catch (configError) {
      console.warn('❌ Failed to parse configJson for unpublish button check:', configError);
      explicitAppPublished = false;
    }
  }
  
  const finalIsPublished = isPublished && explicitAppPublished;

  if (finalIsPublished) {
    unpublishBtn.classList.remove('hidden');
  } else {
    unpublishBtn.classList.add('hidden');
  }
}

// Update spreadsheet access button state
function updateSpreadsheetButton() {
  const btn = document.getElementById('open-spreadsheet-btn-step2');
  if (!btn) return;
  
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetUrl) {
    btn.disabled = false;
    btn.onclick = function() {
      window.open(currentStatus.userInfo.spreadsheetUrl, '_blank');
    };
    logDebug('✅ Spreadsheet button enabled with URL:', currentStatus.userInfo.spreadsheetUrl);
  } else {
    btn.disabled = true;
    btn.onclick = null;
    logDebug('⚠️ Spreadsheet button disabled - no URL available');
  }
}

// Update static UI elements
function updateStaticUI(status) {
  console.log('🔧 updateStaticUI called with status:', {
    hasStatus: !!status,
    hasUserInfo: !!status?.userInfo
  });
  
  // Update database info panel
  updateDatabaseInfo(status);
  
  // Update existing user section
  updateExistingUserSection(status);
  
  // Populate sheet selection - fix property name mismatch
  logDebug('🔍 Debug: Checking sheet data properties', {
    allSheets: status.allSheets,
    sheetNames: status.sheetNames,
    activeSheetName: status.activeSheetName
  });
  
  const sheetsData = status.sheetNames || status.allSheets || [];
  populateSheetSelect(sheetsData, status.activeSheetName);
  
  // アクティブシートの確実な反映（強化）
  if (status.activeSheetName) {
    setTimeout(() => {
      const select = document.getElementById('sheet-select');
      if (select && select.value !== status.activeSheetName) {
        console.log('🔄 Force updating active sheet selection:', status.activeSheetName);
        updateActiveSheetUI(status.activeSheetName);
      }
    }, 100);
  }
  
  // Update custom form info
  updateCustomFormInfo(status);
  
  // Check for auto-publish dialog
  checkAutoPublishDialog(status);
}

// =============================================================================
// DATABASE INFO PANEL UPDATES
// =============================================================================

function updateDatabaseInfo(status) {
  console.log('🔧 updateDatabaseInfo called with:', {
    status: !!status,
    userInfo: !!status?.userInfo,
    adminEmail: status?.userInfo?.adminEmail,
    userId: status?.userInfo?.userId,
    configJson: status?.userInfo?.configJson
  });
  
  if (!status || !status.userInfo) {
    console.warn('System info update failed: No user info available');
    return;
  }

  // スプレッドシートURLを設定（デバッグ強化版）
  console.log('🔧 Setting currentSpreadsheetUrl:', {
    fromUserInfo: status.userInfo.spreadsheetUrl || 'none',
    currentGlobal: currentSpreadsheetUrl || 'none',
    shouldUpdate: !!status.userInfo.spreadsheetUrl
  });
  
  if (status.userInfo.spreadsheetUrl) {
    currentSpreadsheetUrl = status.userInfo.spreadsheetUrl;
    console.log('✅ currentSpreadsheetUrl updated:', currentSpreadsheetUrl);
    
    // 即座に検証
    if (currentSpreadsheetUrl !== status.userInfo.spreadsheetUrl) {
      console.error('❌ URL設定に失敗:', { expected: status.userInfo.spreadsheetUrl, actual: currentSpreadsheetUrl });
    }
  } else if (status.userInfo.spreadsheetUrl === '') {
    // 明示的な空文字列の場合はクリア
    currentSpreadsheetUrl = '';
    console.log('🗑️ currentSpreadsheetUrl cleared (explicit empty string)');
  } else {
    console.log('⚠️ No spreadsheetUrl in userInfo, keeping current value:', currentSpreadsheetUrl || 'none');
  }
  
  // グローバル変数の最終確認
  setTimeout(() => {
    console.log('🔍 Final currentSpreadsheetUrl verification:', currentSpreadsheetUrl || 'still empty');
  }, 100);

  const cfg = status.config || {};

  // 基本情報の更新
  console.log('🔧 Setting basic info with safeSetText:', {
    adminEmail: status.userInfo.adminEmail,
    userId: status.userInfo.userId,
    publishedSheet: cfg.publishedSheetName || status.publishedSheetName || 'なし'
  });
  
  safeSetText('info-admin-email', status.userInfo.adminEmail);
  safeSetText('info-user-id', status.userInfo.userId);
  safeSetText('info-published-sheet', cfg.publishedSheetName || status.publishedSheetName || 'なし');
  

  // 公開状態の表示を更新
  const isPublished = cfg.isPublished !== undefined
    ? cfg.isPublished
    : status.appPublished || status.isPublished || (status.activeSheetName && (cfg.publishedSheetName || status.publishedSheetName));
  updatePublicationStatusUI(isPublished);

  // 表示モードの更新
  const displayModeFlag = cfg.showNames !== undefined ? cfg.showNames : status.showNames;
  const displayMode = displayModeFlag ? '名前表示' : '匿名表示';
  safeSetText('info-display-mode', displayMode);

  // カウント表示の更新
  const showCountsFlag = cfg.showCounts !== undefined
    ? cfg.showCounts
    : (status.showCounts !== undefined ? status.showCounts : false);
  const showCounts = showCountsFlag ? '表示' : '非表示';
  safeSetText('info-show-counts', showCounts);

  // チェックボックスの状態同期
  syncCheckboxStates(status);
}

// Update publication status UI
function updatePublicationStatusUI(isPublished) {
  const statusElement = safeGetElement('info-publish-status');
  const indicatorElement = safeGetElement('info-publish-indicator');
  const textElement = safeGetElement('info-publish-text');
  
  if (statusElement) {
    if (isPublished) {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-green-600 text-white';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-green-400';
      if (textElement) textElement.textContent = '公開中';
    } else {
      statusElement.className = 'px-2 py-1 rounded text-xs font-medium bg-gray-600 text-gray-300';
      if (indicatorElement) indicatorElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      if (textElement) textElement.textContent = '非公開';
    }
  }
}

// チェックボックスの状態を同期する関数
function syncCheckboxStates(status) {
  // Priority: Database config (configJson) > status properties > defaults
  let showNames = false;
  let showCounts = false;
  
  // 1. Prefer status.config if available
  if (status.config) {
    if (status.config.showNames !== undefined) showNames = status.config.showNames;
    if (status.config.showCounts !== undefined) showCounts = status.config.showCounts;
  } else if (status.userInfo && status.userInfo.configJson) {
    // 2. Fallback to raw configJson
    try {
      const config = JSON.parse(status.userInfo.configJson);
      if (config.showNames !== undefined) showNames = config.showNames;
      if (config.showCounts !== undefined) showCounts = config.showCounts;
    } catch (e) {
      logWarn('Failed to parse configJson, using status properties');
      if (status.showNames !== undefined) showNames = status.showNames;
      if (status.showCounts !== undefined) showCounts = status.showCounts;
    }
  } else {
    // 3. Use status properties as last resort
    if (status.showNames !== undefined) showNames = status.showNames;
    if (status.showCounts !== undefined) showCounts = status.showCounts;
  }

  // Update checkbox elements
  const showNamesCheckbox = safeGetElement('show-names');
  const showCountsCheckbox = safeGetElement('show-counts');
  
  if (showNamesCheckbox) {
    showNamesCheckbox.checked = showNames;
  }
  
  if (showCountsCheckbox) {
    showCountsCheckbox.checked = showCounts;
  }
}

// =============================================================================
// SHEET SELECTION AND CONFIGURATION
// =============================================================================

// Populate sheet selection dropdown
function populateSheetSelect(sheetNames, activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) {
    logWarn('Sheet select element not found');
    return;
  }

  logDebug('📋 Populating sheet select with data:', {
    sheetNames: sheetNames,
    activeSheetName: activeSheetName,
    dataType: typeof sheetNames,
    isArray: Array.isArray(sheetNames)
  });

  // Clear existing options
  select.innerHTML = '<option value="">-- シートを選択 --</option>';
  
  if (sheetNames && sheetNames.length > 0) {
    logDebug('✅ Adding sheets to dropdown:', sheetNames.length);
    
    sheetNames.forEach((sheet, index) => {
      const option = document.createElement('option');
      
      // Handle both object and string formats
      let sheetName;
      if (typeof sheet === 'object' && sheet.name) {
        sheetName = sheet.name;
        option.value = sheet.name;
        logDebug('📄 Sheet ' + (index + 1) + ': ' + sheet.name + ' (ID: ' + sheet.id + ')');
      } else if (typeof sheet === 'string') {
        sheetName = sheet;
        option.value = sheet;
        logDebug('📄 Sheet ' + (index + 1) + ': ' + sheet);
      } else {
        console.warn('⚠️ Unknown sheet format:', sheet);
        return;
      }
      
      // アクティブシートの表示を改善
      if (sheetName === activeSheetName) {
        option.textContent = sheetName + ' (アクティブ)';
        option.style.fontWeight = 'bold';
        option.style.color = '#10b981'; // 緑色でアクティブを表示
        option.className = 'active-sheet-option';
        logDebug('✅ Active sheet marked: ' + sheetName);
      } else {
        option.textContent = sheetName;
      }
      
      select.appendChild(option);
    });
    select.disabled = false;
    logDebug('✅ Sheet dropdown populated successfully');
  } else {
    // 初期セットアップ時は正常なのでdebugレベルに変更
    if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
      console.warn('⚠️ No sheets available:', sheetNames);
    }
    select.innerHTML = '<option value="">利用可能なシートがありません</option>';
    select.disabled = true;
  }
  
  // Set active sheet if available (強化された選択ロジック)
  if (activeSheetName) {
    // シート名の正規化を考慮した選択処理
    const normalizedActiveSheet = activeSheetName.trim();
    
    // 正確な一致を確認
    const availableOptions = Array.from(select.options);
    const matchingOption = availableOptions.find(option => option.value === normalizedActiveSheet);
    
    if (matchingOption) {
      select.value = normalizedActiveSheet;
      selectedSheet = normalizedActiveSheet;
      lastSelectedSheetName = normalizedActiveSheet;
      logDebug('✅ Active sheet set successfully:', normalizedActiveSheet);
    } else {
      // 強化されたインテリジェントフォールバック処理
      logDebug('🔍 Active sheet not found in options, attempting intelligent fallback:', {
        activeSheetName: normalizedActiveSheet,
        availableOptions: availableOptions.map(opt => opt.value)
      });
      
      let fallbackSheet = null;
      
      // 1. 完全一致を再試行（正規化後）
      const exactMatch = availableOptions.find(option => 
        _normalizeSheetName(option.value) === _normalizeSheetName(normalizedActiveSheet)
      );
      
      if (exactMatch) {
        fallbackSheet = exactMatch.value;
        console.log('✅ Found exact match after normalization:', fallbackSheet);
      } else {
        // 2. 部分一致を試行（履歴復元で役立つ）
        const partialMatch = availableOptions.find(option => 
          option.value && normalizedActiveSheet && 
          (option.value.includes(normalizedActiveSheet) || normalizedActiveSheet.includes(option.value))
        );
        
        if (partialMatch) {
          fallbackSheet = partialMatch.value;
          console.log('✅ Found partial match:', fallbackSheet);
        } else if (availableOptions.length > 1) {
          // 3. 最初の有効なオプションを選択
          fallbackSheet = availableOptions[1].value;
          console.log('✅ Using first available option:', fallbackSheet);
        }
      }
      
      if (fallbackSheet) {
        select.value = fallbackSheet;
        selectedSheet = fallbackSheet;
        lastSelectedSheetName = fallbackSheet;
        logDebug('🔄 Fallback to sheet:', fallbackSheet);
      }
    }
    
    // 選択状態を確認
    if (select.value) {
      logDebug('✅ Final sheet selection confirmed:', select.value);
    } else {
      console.error('❌ Sheet selection failed - no sheet selected');
    }
  }
  
  // Add change event listener for data preview
  select.removeEventListener('change', handleSheetSelectionChange);
  select.addEventListener('change', handleSheetSelectionChange);
  
  // Update UI for selected sheet and enable spreadsheet button
  updateUIForSelectedSheet();
  updateSpreadsheetButton();
}

// Populate header options for configuration
// Full implementation of populateHeaderOptions (framework has minimal version)
function _fullPopulateHeaderOptions(headers) {
  // Throttle function calls to prevent spam
  if (window.populateHeaderOptionsRunning) {
    return;
  }
  window.populateHeaderOptionsRunning = true;
  
  const selects = [
    'opinionHeader',      // Main required field
    'reason-column',     // Optional details field (reason column)
    'name-column', 
    'class-column'
  ];
  
  selects.forEach(selectId => {
    const select = document.getElementById(selectId);
    
    if (select) {
      // Store current value
      const currentValue = select.value;
      
      // Clear and repopulate with appropriate placeholder
      if (headers && headers.length > 0) {
        select.innerHTML = '<option value="">-- 列を選択 --</option>';
        select.disabled = false;
      } else {
        select.innerHTML = '<option value="">-- シートを選択してください --</option>';
        select.disabled = true;
      }
      
      const excludedHeaders = [
        'なるほど！',
        'いいね！',
        'もっと知りたい！',
        'ハイライト',
        'メールアドレス', // フォームで自動収集されるため、マッピング対象から除外
        'タイムスタンプ' // ユーザーの要望により除外
      ];

      const filteredHeaders = headers.filter(header => !excludedHeaders.includes(header));

      filteredHeaders.forEach(header => {
        const option = document.createElement('option');
        option.value = header;
        option.textContent = header;
        select.appendChild(option);
      });
      
      // Restore previous value if still valid
      if (currentValue && headers.includes(currentValue)) {
        select.value = currentValue;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateHeaderOptionsRunning = false;
  }, 100);
}

// Populate configuration with guessed values
// Full implementation of populateConfig (framework has minimal version)
function _fullPopulateConfig(cfg) {
  if (!cfg) return;
  
  // 履歴復元中はスキップ（ただし、ドラフトモードの場合は除く）
  if ((window._historyRestoreInProgress || window._historyColumnSelections) && !window._draftModeActive) {
    console.log('🛡️ _fullPopulateConfig: 履歴復元中のため処理をスキップしました');
    return;
  }
  
  // ドラフトモード時のログ出力
  if (window._draftModeActive) {
    console.log('📝 _fullPopulateConfig: ドラフトモードで設定を反映中');
  }
  
  // Throttle function calls to prevent spam
  if (window.populateConfigRunning) {
    return;
  }
  window.populateConfigRunning = true;
  
  const mappings = {
    // Main opinion dropdown (primary target)
    'opinionHeader': cfg.opinionHeader || cfg.opinionColumn,
    
    // Detail configuration dropdowns (secondary targets with property name fixes)
    'reason-column': cfg.reasonColumn || cfg.reasonHeader,
    'name-column': cfg.nameColumn || cfg.nameHeader,
    'class-column': cfg.classColumn || cfg.classHeader,
    'show-names': cfg.showNames,
    'show-counts': cfg.showCounts
  };
  
  Object.keys(mappings).forEach(elementId => {
    const element = document.getElementById(elementId);
    const value = mappings[elementId];
    
    if (element && value !== undefined) {
      if (element.type === 'checkbox') {
        element.checked = Boolean(value);
      } else {
        element.value = value;
      }
    }
  });
  
  // Reset throttle after a delay
  setTimeout(() => {
    window.populateConfigRunning = false;
  }, 100);
  
  updateConfigButtons();
}

// Clear configuration fields
function clearConfigFields() {
  const fieldIds = [
    'opinionHeader',      // Main required field
    'reason-column',
    'name-column',
    'class-column'
  ];
  
  fieldIds.forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.value = '';
    }
  });
  
  updateConfigButtons();
}

// Build configuration object from form
function buildConfigObject() {
  // Get values from primary elements (with fallback to secondary elements)
  const opinionHeaderEl = document.getElementById('opinionHeader');
  const reasonColumnEl = document.getElementById('reason-column');
  const nameColumnEl = document.getElementById('name-column');
  const classColumnEl = document.getElementById('class-column');
  const showNamesEl = document.getElementById('show-names');
  const showCountsEl = document.getElementById('show-counts');
  
  const opinionValue = (opinionHeaderEl ? opinionHeaderEl.value : '') || 
                      (reasonColumnEl ? reasonColumnEl.value : '') || '';
  const nameValue = nameColumnEl ? nameColumnEl.value : '';
  const classValue = classColumnEl ? classColumnEl.value : '';
  const showNames = showNamesEl ? showNamesEl.checked : false;
  const showCounts = showCountsEl ? showCountsEl.checked : false;
  
  return {
    sheetName: selectedSheet,
    // Use property names that match backend expectations (opinionHeader format)
    opinionHeader: opinionValue,
    nameHeader: nameValue,
    classHeader: classValue,
    reasonHeader: (document.getElementById('reason-column') && document.getElementById('reason-column').value) || '',
    // Column values
    opinionColumn: opinionValue,
    nameColumn: nameValue,
    classColumn: classValue,
    showNames: showNames,
    showCounts: showCounts
  };
}

// Full implementation of validateConfig (framework has minimal version)
function _fullValidateConfig() {
  // Check primary element first, then fallback to secondary element
  const opinionHeaderEl = document.getElementById('opinionHeader');
  const reasonColumnEl = document.getElementById('reason-column');
  const opinionValue = (opinionHeaderEl ? opinionHeaderEl.value : '') || 
                      (reasonColumnEl ? reasonColumnEl.value : '') || '';
  
  return opinionValue && opinionValue.trim() !== '';
}

// Full implementation of updateConfigButtons (framework has minimal version)
function _fullUpdateConfigButtons() {
  const isValid = (typeof _fullValidateConfig === 'function') ? _fullValidateConfig() : validateConfig();
  const saveBtn = document.getElementById('save-publish-btn');
  
  if (saveBtn) {
    saveBtn.disabled = !isValid;
    if (isValid) {
      saveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
      saveBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
  }
}

// Make full implementations globally available for framework fallback
window._fullValidateConfig = _fullValidateConfig;
window._fullUpdateConfigButtons = _fullUpdateConfigButtons;
window._fullUpdateFormUrlDisplay = _fullUpdateFormUrlDisplay;
window._fullPopulateHeaderOptions = _fullPopulateHeaderOptions;
window._fullPopulateConfig = _fullPopulateConfig;

// =============================================================================
// STEP INDICATORS AND GUIDANCE
// =============================================================================

// 統一されたステップ完了チェック - 公開状態優先判定対応版
function getStepCompletionFromConfig(status) {
  if (!(status && status.userInfo && status.userInfo.configJson)) {
    return { step1: false, step2: false, step3: false, isPublished: false };
  }

  try {
    const config = typeof status.userInfo.configJson === 'string' 
      ? JSON.parse(status.userInfo.configJson) 
      : status.userInfo.configJson;

    // 公開状態の優先チェック（データ不整合に関係なく公開済みなら全ステップ完了）
    const publicationState = getPublicationState(status);
    if (publicationState.isPublished) {
      return {
        step1: true,
        step2: true,
        step3: true,
        isPublished: true
      };
    }

    // 通常のステップ完了判定
    // Step 1: スプレッドシートIDの存在確認
    const step1Complete = !!(status.userInfo.spreadsheetId);
    
    // Step 2: セットアップ完了状態の確認
    const step2Complete = config.setupStatus === 'completed' && 
                          config.formCreated === true && 
                          config.formUrl && config.formUrl.trim();
    
    // Step 3: 公開状態の確認
    const step3Complete = config.appPublished === true;
    
    return {
      step1: step1Complete,
      step2: step2Complete,
      step3: step3Complete,
      isPublished: step3Complete
    };
  } catch (error) {
    console.warn('❌ configJsonの解析に失敗:', error);
    return { step1: false, step2: false, step3: false, isPublished: false };
  }
}

// Update step indicators - 最適化版（バッチDOM更新）
function updateStepIndicators(currentStep, status = null) {
  const steps = [
    document.getElementById('step-1-indicator'),
    document.getElementById('step-2-indicator'),
    document.getElementById('step-3-indicator')
  ];

  // データベース状態から実際の完了状況を取得
  const completion = getStepCompletionFromConfig(status);
  logDebug('📊 Step completion from database:', completion);

  // DOM更新をバッチ化するための設定配列を作成
  const updates = [];
  
  steps.forEach((step, index) => {
    if (!step) return;
    
    const stepNumber = index + 1;
    const circle = step.querySelector('div');
    const text = step.querySelector('span');

    // 既存のバッジを削除（最適化）
    const existingBadge = step.querySelector('.publication-badge');
    if (existingBadge) {
      existingBadge.remove();
    }

    // データベース状態に基づく完了判定
    const isStepComplete = completion['step' + stepNumber];
    
    // 更新情報を配列に追加（実際のDOM更新は後で一括実行）
    updates.push({
      circle,
      text,
      stepNumber,
      isStepComplete,
      isCurrentStep: stepNumber === currentStep
    });
  });
  
  // バッチDOM更新実行（リフローを最小化）
  requestAnimationFrame(() => {
    executeBatchStepUpdates(updates);
    // 進行状況メッセージの更新（同じアニメーションフレーム内で実行）
    updateProgressMessage(currentStep, status, completion);
  });
}

// バッチDOM更新の実行（最適化されたDOM操作）
function executeBatchStepUpdates(updates) {
  const styleConfigs = {
    completed: {
      circleClass: 'w-6 h-6 bg-green-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all',
      circleContent: '✓',
      textClasses: { remove: ['text-gray-500', 'text-cyan-400'], add: ['text-green-400', 'font-medium'] }
    },
    current: {
      circleClass: 'w-6 h-6 bg-cyan-500 text-white rounded-full flex items-center justify-center font-bold text-xs transition-all ring-2 ring-cyan-400 ring-offset-2 ring-offset-gray-900 animate-pulse',
      textClasses: { remove: ['text-gray-500', 'text-green-400'], add: ['text-cyan-400', 'font-bold'] }
    },
    pending: {
      circleClass: 'w-6 h-6 bg-gray-700 text-gray-500 rounded-full flex items-center justify-center font-bold text-xs transition-all border border-gray-600',
      textClasses: { remove: ['text-white', 'text-green-400', 'text-cyan-400', 'font-bold', 'font-medium'], add: ['text-gray-500'] }
    }
  };

  updates.forEach(({ circle, text, stepNumber, isStepComplete, isCurrentStep }) => {
    let config;
    
    if (isStepComplete) {
      config = styleConfigs.completed;
    } else if (isCurrentStep) {
      config = styleConfigs.current;
    } else {
      config = styleConfigs.pending;
    }

    // Circle要素の更新
    if (circle) {
      circle.className = config.circleClass;
      circle.innerHTML = config.circleContent || stepNumber;
    }

    // Text要素の更新（クラス操作の最適化）
    if (text && config.textClasses) {
      if (config.textClasses.remove && config.textClasses.remove.length > 0) {
        for (const className of config.textClasses.remove) {
          text.classList.remove(className);
        }
      }
      if (config.textClasses.add && config.textClasses.add.length > 0) {
        for (const className of config.textClasses.add) {
          text.classList.add(className);
        }
      }
    }
  });
}

function updateProgressMessage(currentStep, status = null, completion = null) {
  const messageElement = document.getElementById('progress-message');
  if (!messageElement) return;
  
  // completionが渡されていない場合は取得
  if (!completion) {
    completion = getStepCompletionFromConfig(status);
  }
  
  // 改善されたメッセージとガイダンス
  const messageData = getEnhancedProgressMessage(currentStep, completion, status);
  
  messageElement.textContent = messageData.message;
  messageElement.className = `text-sm ${messageData.colorClass} font-medium transition-colors duration-300`;
}

// 強化されたプログレスメッセージの生成
function getEnhancedProgressMessage(currentStep, completion, status) {
  const messageConfigs = {
    1: {
      completed: {
        message: '✅ データ準備完了：フォーム・スプレッドシートが利用可能です',
        colorClass: 'text-green-400'
      },
      inProgress: {
        message: '📋 クイックスタート（自動）またはカスタムセットアップ（既存データ）を選択',
        colorClass: 'text-cyan-400'
      }
    },
    2: {
      completed: {
        message: '✅ シート設定完了：回答データの表示準備ができました',
        colorClass: 'text-green-400'  
      },
      inProgress: {
        message: '⚙️ シートを選択して、表示する列（質問・回答など）を設定してください',
        colorClass: 'text-yellow-400'
      }
    },
    3: {
      published: {
        message: '🎉 ボード公開中：参加者が回答を投稿・閲覧できます',
        colorClass: 'text-green-400'
      },
      readyToPublish: {
        message: '🚀 公開準備完了：「ボードを公開」で参加者に共有しましょう',
        colorClass: 'text-purple-400'
      },
      needsConfiguration: {
        message: '🔧 列設定を完了してから公開してください',
        colorClass: 'text-orange-400'
      }
    }
  };
  
  // ステップごとの状態判定とメッセージ選択
  switch (currentStep) {
    case 1:
      return completion.step1 ? 
        messageConfigs[1].completed : 
        messageConfigs[1].inProgress;
        
    case 2:
      return completion.step2 ? 
        messageConfigs[2].completed : 
        messageConfigs[2].inProgress;
        
    case 3:
      if (completion.isPublished) {
        return messageConfigs[3].published;
      } else if (completion.step2) {
        return messageConfigs[3].readyToPublish;
      } else {
        return messageConfigs[3].needsConfiguration;
      }
      
    default:
      return {
        message: '🎉 セットアップ完了：StudyQuestをお楽しみください！',
        colorClass: 'text-green-400'
      };
  }
}

// デバウンス機能用のタイムアウト管理
let footerUpdateTimeout = null;

// Update footer and guidance text (with debounce)
function updateFooterAndGuidance(status) {
  // デバウンス処理：短時間の連続呼び出しを制御
  clearTimeout(footerUpdateTimeout);
  footerUpdateTimeout = setTimeout(() => {
    updateFooterAndGuidanceImmediate(status);
  }, 150); // 150ms遅延
}

// 実際のフッター更新処理
function updateFooterAndGuidanceImmediate(status) {
  console.group('🦶 updateFooterAndGuidance');
  
  // より確実なステータス確保: グローバル状態とマージ
  const effectiveStatus = status || window.currentStatus;
  if (!effectiveStatus) {
    console.warn('❌ No status available for footer update');
    console.groupEnd();
    return;
  }
  
  // 引数ステータスの詳細確認（強化版）
  console.log('🔍 Footer update with status:', {
    hasStatus: !!effectiveStatus,
    isPublished: effectiveStatus?.isPublished,
    configIsPublished: effectiveStatus?.config?.isPublished,
    appPublished: effectiveStatus?.appPublished,
    normalizedIsPublished: effectiveStatus?._normalized?.isPublished,
    configJson: effectiveStatus?.userInfo?.configJson ? 'exists' : 'missing',
    statusSource: status ? 'provided' : 'global fallback'
  });
  
  const footer = document.getElementById('admin-footer');
  const guidanceText = document.getElementById('guidance-text');
  
  if (!footer || !guidanceText) {
    console.warn('❌ Footer or guidance elements not found');
    console.groupEnd();
    return;
  }

  // 改善された公開状態判定: 統一関数使用 + フォールバック処理
  const finalIsPublished = determinePublicationStatus(effectiveStatus);
  const viewUrl = (effectiveStatus._normalized && effectiveStatus._normalized.viewUrl) || 
                  (effectiveStatus.appUrls && effectiveStatus.appUrls.viewUrl) ||
                  generateViewUrl(effectiveStatus);
  
  // 簡潔なログ出力
  console.log(`🔍 Publication check: ${finalIsPublished ? '公開中' : '非公開'}`, {
    hasViewUrl: !!viewUrl,
    source: status._normalized ? '_normalized' : 'fallback'
  });

  // Show footer if published (with strict validation)
  if (finalIsPublished) {
    footer.classList.remove('hidden');
    
    // Update board URL using our generated viewUrl (if available)
    const boardUrlInput = document.getElementById('board-url');
    const viewBoardLink = document.getElementById('view-board-link');
    
    if (boardUrlInput) {
      boardUrlInput.value = viewUrl || 'URL生成中...';
      console.log('📝 Board URL input updated:', viewUrl || 'URL generation pending');
    }
    if (viewBoardLink && viewUrl) {
      viewBoardLink.href = viewUrl;
      console.log('🔗 View board link updated:', viewUrl);
    } else if (viewBoardLink) {
      viewBoardLink.removeAttribute('href');
      console.log('🔗 View board link cleared - no URL available');
    }
    
    // Update topic text
    updateTopicText(status);
    
    guidanceText.textContent = '回答ボードは現在公開中です。';
  } else {
    footer.classList.add('hidden');
    console.log('❌ Footer hidden - board not published');
    
    // Update guidance based on setup step
    updateGuidanceForStep(status.setupStep || 1, guidanceText);
  }
  
  console.groupEnd();
  
  // 自動停止通知の表示チェック
  checkAndShowAutoStopNotification(status);
  
  adjustLayout();
}

// Update UI for selected sheet
function updateUIForSelectedSheet() {
  const hasSelection = selectedSheet && selectedSheet.trim() !== '';
  
  // Update step indicators based on server-provided setupStep
  const currentStep = currentStatus.setupStep || 1;
  updateStepIndicators(currentStep);
  
  // Enable/disable configuration section
  const configSection = document.getElementById('config-section');
  if (configSection) {
    if (hasSelection) {
      configSection.classList.remove('opacity-50', 'pointer-events-none');
      
      // 防御的ロジック: config-areaが確実に表示されるようにする
  const configArea = document.getElementById('config-area');
      if (configArea) {
        configArea.classList.remove('hidden');
        console.log('🛡️ updateUIForSelectedSheet: Config area shown defensively');
      }
    } else {
      configSection.classList.add('opacity-50', 'pointer-events-none');
    }
  }
  
  // Update guidance text
  const guidanceText = document.getElementById('guidance-text');
  if (guidanceText) {
    if (hasSelection) {
      guidanceText.textContent = 'ステップ3: 列を設定してボードを公開しましょう';
    } else {
      guidanceText.textContent = 'ステップ2: 表示したいシートを選択してください。';
    }
  }

  // Toggle placeholder visibility
  const configPlaceholder = document.getElementById('config-placeholder');
  if (configPlaceholder) {
    if (hasSelection) {
      configPlaceholder.classList.add('hidden');
    } else {
      configPlaceholder.classList.remove('hidden');
    }
  }
}

// Update topic text in footer
function updateTopicText(status) {
  const topicTextElement = document.getElementById('current-topic-text');
  const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
  
  if (!topicTextElement) return;

  let topic = '（問題文未設定）';
  
  // SAFE: 設定オブジェクトの安全な取得
  let cfg = {};
  
  // statusオブジェクトの安全性チェック
  if (!status) {
    console.warn('⚠️ updateTopicText: status is null or undefined');
    topicTextElement.textContent = topic;
    return;
  }
  
  // status.configが存在し、かつオブジェクトの場合のみ使用
  if (status.config && typeof status.config === 'object') {
    cfg = {...status.config};
  }
  
  console.log('🔍 updateTopicText: status:', status);
  
  // userInfo.configJsonからも情報を取得（安全性チェック強化）
  if (status.userInfo && status.userInfo.configJson) {
    try {
      const fullConfig = JSON.parse(status.userInfo.configJson);
      if (fullConfig && typeof fullConfig === 'object') {
        cfg = {...cfg, ...fullConfig};
        console.log('📋 updateTopicText: merged config:', cfg);
      } else {
        console.warn('⚠️ Parsed configJson is not a valid object:', fullConfig);
      }
    } catch (e) {
      console.warn('⚠️ Failed to parse userInfo.configJson:', e);
    }
  }
  
  // publishedSheetNameに基づいてsheet-specific configを取得（安全性チェック強化）
  if (status.userInfo && cfg && cfg.publishedSheetName) {
    try {
      const sheetConfigKey = `sheet_${cfg.publishedSheetName}`;
      if (cfg[sheetConfigKey] && typeof cfg[sheetConfigKey] === 'object' && cfg[sheetConfigKey].opinionHeader) {
        topic = cfg[sheetConfigKey].opinionHeader;
        console.log(`✅ Topic found from sheet config (${sheetConfigKey}):`, topic);
      } else {
        console.warn(`⚠️ No opinion header found in sheet config: ${sheetConfigKey}`, cfg[sheetConfigKey]);
      }
    } catch (e) {
      console.warn('⚠️ Error accessing sheet config:', e);
    }
  }

  // 優先順位: customFormInfo > シート固有設定 > 一般設定
  if (!topic && status.customFormInfo && status.customFormInfo.mainQuestion) {
    topic = status.customFormInfo.mainQuestion;
    console.log('✅ Topic from customFormInfo:', topic);
  } else if (!topic && cfg.opinionHeader) {
    topic = cfg.opinionHeader;
    console.log('✅ Topic from cfg.opinionHeader:', topic);
  }
  
  if (!topic) {
    const sheetName = cfg.publishedSheetName || status.publishedSheetName;
    console.log('🔍 Looking for topic in sheet config, sheetName:', sheetName);
    
    if (sheetName && sheetName !== 'フォームの回答 1') {
      if (status.userInfo && status.userInfo.configJson) {
        try {
          const fullCfg = JSON.parse(status.userInfo.configJson);
          const sheetCfg = fullCfg['sheet_' + (sheetName || '')] || {};
          console.log('📋 Sheet config found:', sheetCfg);
          
          // guessedConfig内のopinionHeaderを優先
          if (sheetCfg.guessedConfig && sheetCfg.guessedConfig.opinionHeader) {
            topic = sheetCfg.guessedConfig.opinionHeader;
            console.log('✅ Topic from guessedConfig:', topic);
          } else if (sheetCfg.opinionHeader) {
            // フォールバック: 直接のopinionHeader
            topic = sheetCfg.opinionHeader;
            console.log('✅ Topic from direct opinionHeader:', topic);
          } else {
            console.warn('⚠️ No opinion header found in sheet config, trying alternatives');
            // Try alternative headers
            const alternativeHeaders = ['reasonHeader', 'nameHeader', 'classHeader'];
            for (const header of alternativeHeaders) {
              if (sheetCfg.guessedConfig && sheetCfg.guessedConfig[header]) {
                topic = sheetCfg.guessedConfig[header];
                console.log(`✅ Topic from alternative header (${header}):`, topic);
                break;
              } else if (sheetCfg[header]) {
                topic = sheetCfg[header];
                console.log(`✅ Topic from direct alternative header (${header}):`, topic);
                break;
              }
            }
            // シート名ではなく、適切なデフォルトメッセージを表示
            topic = '（質問文が設定されていません）';
          }
        } catch (e) {
          // クイックスタート直後のフォールバック改善
          if (sheetName && fullCfg['sheet_' + (sheetName || '')] && fullCfg['sheet_' + (sheetName || '')].flowType === 'quickstart') {
            // クイックスタート用デフォルト質問文を表示
            topic = 'あなたの考えや気づいたことを教えてください';
          } else {
            topic = '（質問文が設定されていません）';
          }
        }
      } else {
        // シート名をそのまま表示せず、適切なメッセージを表示
        topic = '（質問文が設定されていません）';
      }
    }
  }

  topicTextElement.textContent = topic;
  
  // 予定終了日時の更新
  if (scheduledEndTimeElement) {
    updateScheduledEndTime(cfg, scheduledEndTimeElement);
  }
}

// 予定終了日時を更新する関数
function updateScheduledEndTime(config, element) {
  // 複数のソースから scheduledEndAt を取得を試行
  const scheduledEndAt = config.scheduledEndAt || 
                         config.scheduledEndTime ||
                         (window.lastStatusCache && window.lastStatusCache.config && window.lastStatusCache.config.scheduledEndAt) ||
                         (window.lastStatusCache && window.lastStatusCache.config && window.lastStatusCache.config.scheduledEndTime);
  
  // scheduledEndAtが設定されていない場合は、publishedAt + autoStopMinutesから計算
  let finalScheduledEndTime = scheduledEndAt;
  
  if (!finalScheduledEndTime && config.publishedAt && config.autoStopMinutes) {
    const publishedTime = new Date(config.publishedAt);
    const autoStopMs = config.autoStopMinutes * 60 * 1000;
    finalScheduledEndTime = new Date(publishedTime.getTime() + autoStopMs).toISOString();
    console.log('🕐 終了予定時刻を計算しました:', finalScheduledEndTime);
  }
  
  if (finalScheduledEndTime) {
    try {
      const endDate = new Date(finalScheduledEndTime);
      const formattedTime = endDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      // 現在時刻との比較
      const now = new Date();
      const isOverdue = endDate < now;
      const timeRemaining = endDate.getTime() - now.getTime();
      const oneHourMs = 60 * 60 * 1000; // 1時間のミリ秒
      
      if (isOverdue) {
        element.textContent = `${formattedTime} (期限切れ)`;
        element.className = 'text-xs font-medium text-red-400';
      } else if (timeRemaining <= oneHourMs) {
        // 1時間以内の場合は警告表示
        const minutesRemaining = Math.floor(timeRemaining / (60 * 1000));
        element.textContent = `${formattedTime} (残り${minutesRemaining}分)`;
        element.className = 'text-xs font-medium text-red-400 animate-pulse';
        console.log('⚠️ 期限まで1時間以内です:', minutesRemaining + '分');
      } else {
        element.textContent = formattedTime;
        element.className = 'text-xs font-medium text-orange-400';
      }
    } catch (e) {
      element.textContent = '設定エラー';
      element.className = 'text-xs font-medium text-gray-400';
    }
  } else {
    element.textContent = '未設定';
    element.className = 'text-xs font-medium text-gray-400';
  }
}

// Update guidance text for specific step
function updateGuidanceForStep(step, guidanceElement) {
  const messages = {
    1: 'ステップ1: ボードを作成または既存のリソースを追加してください。',
    2: 'ステップ2: 表示したいシートを選択してください。',
    3: 'ステップ3: 列を設定してボードを公開しましょう'
  };
  
  // 公開終了後のステップ1では、明確にセットアップ再開のメッセージを表示
  if (step === 1) {
    guidanceElement.textContent = 'セットアップを開始してください';
  } else {
    guidanceElement.textContent = messages[step] || 'セットアップを開始してください';
  }
}

// 自動停止通知の表示チェック
function checkAndShowAutoStopNotification(status) {
  const notificationElement = document.getElementById('auto-stop-notification');
  const autoStoppedTimeElement = document.getElementById('auto-stopped-time');
  
  if (!notificationElement || !autoStoppedTimeElement) return;
  
  const config = status.config || {};
  
  // 自動停止されている場合のみ通知を表示
  if (config.autoStoppedAt && config.autoStopReason === 'scheduled_timeout') {
    console.log('🔔 自動停止通知を表示します:', config.autoStoppedAt);
    
    // 停止時刻を表示
    try {
      const stoppedDate = new Date(config.autoStoppedAt);
      const formattedTime = stoppedDate.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      autoStoppedTimeElement.textContent = formattedTime;
    } catch (e) {
      autoStoppedTimeElement.textContent = '時刻不明';
    }
    
    // 通知を表示
    notificationElement.classList.remove('hidden');
    
    // 再公開ボタンのイベントリスナーを設定
    const republishBtn = document.getElementById('republish-after-auto-stop-btn');
    if (republishBtn) {
      // 既存のイベントリスナーを削除
      republishBtn.replaceWith(republishBtn.cloneNode(true));
      
      // 新しいイベントリスナーを追加
      const newRepublishBtn = document.getElementById('republish-after-auto-stop-btn');
      newRepublishBtn.addEventListener('click', function() {
        // Step 3に移動して再公開を促す
        const step3Section = document.getElementById('step3-content');
        if (step3Section) {
          step3Section.classList.remove('hidden');
          step3Section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 通知を非表示
        notificationElement.classList.add('hidden');
        
        showMessage('表示設定を確認して再公開してください', 'info');
      });
    }
  } else {
    // 自動停止されていない場合は通知を非表示
    notificationElement.classList.add('hidden');
  }
}

// =============================================================================
// SECTION TOGGLE FUNCTIONALITY
// =============================================================================

// Toggle section expansion/collapse
// toggleSection function is now defined in adminPanel-framework.js.html

// Automatically collapse completed sections
function collapseCompletedSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📁 Auto-collapsing completed step ${stepNumber}`);
  
  // Collapse the section
  section.classList.add('hidden');
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'false');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Automatically expand active section
function expandActiveSection(stepNumber) {
  const sectionId = `step${stepNumber}-content`;
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  console.log(`📂 Auto-expanding active step ${stepNumber}`);
  
  // Expand the section
  section.classList.remove('hidden');
  
  // Special handling for Step 3: ensure config-area is visible
  if (stepNumber === 3) {
    const configArea = document.getElementById('config-area');
    if (configArea && currentStatus && currentStatus.activeSheetName) {
      configArea.classList.remove('hidden');
      console.log(`📋 expandActiveSection: Config area shown for Step 3`);
    }
  }
  
  // Update toggle button state
  const toggleBtn = document.querySelector(`[onclick*="${sectionId}"]`);
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-expanded', 'true');
    const arrow = toggleBtn.querySelector('.fa-chevron-down, .fa-chevron-up');
    if (arrow) {
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }
  
  // Note: Visual indicators are now managed by manageSectionStates()
}

// Manage section states based on current step (simplified - no visual effects)
function manageSectionStates(currentStep) {
  console.log(`🔄 Managing section states for step ${currentStep}`);
  
  // ステップごとのセクション制御
  for (let i = 1; i <= 3; i++) {
    const sectionId = `step${i}-content`;
    const section = document.getElementById(sectionId);
    
    if (i === currentStep) {
      // 現在のステップ: 展開して有効化
      expandActiveSection(i);
      
      // Step 3の特別処理: config-areaの表示
      if (i === 3) {
        const configArea = document.getElementById('config-area');
        if (configArea && currentStatus && currentStatus.activeSheetName) {
          configArea.classList.remove('hidden');
          console.log(`📋 Step 3: Config area shown for sheet: ${currentStatus.activeSheetName}`);
        }
      }
      
      console.log(`🔄 Step ${i}: Active (current step)`);
    } else if (i < currentStep) {
      // 完了済みステップ: アクセス可能だが、展開は任意
      if (section) {
        section.classList.add('opacity-90'); // 完了した状態を視覚的に示す
      }
      console.log(`✅ Step ${i}: Completed (accessible)`);
    } else {
      // 未来のステップ: Step 1の場合はpending状態でも全て閲覧可能
      if (currentStep === 1) {
        // Step 1では全ステップにアクセス可能（データ確認のため）
        if (section) {
          section.classList.add('opacity-75'); // 未来のステップとして軽く表示
        }
        console.log(`⏭️ Step ${i}: Available for preview`);
      } else {
        // Step 2以降では順次開放
        if (section) {
          section.classList.add('opacity-50'); // 未来のステップとして表示
        }
        console.log(`⏭️ Step ${i}: Future step (available)`);
      }
    }
  }
}

// =============================================================================
// MODAL MANAGEMENT
// =============================================================================

// Show form configuration modal
// showFormConfigModal function is now defined in adminPanel-framework.js.html

// Hide form configuration modal
function hideFormConfigModal() {
  if (window.sharedModals) {
    window.sharedModals.hideModal('form-config-modal');
    manageFocusForModal('form-config-modal', false);
  } else {
    // Fallback for legacy support
    const modal = document.getElementById('form-config-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      manageFocusForModal('form-config-modal', false);
    }
  }
}

// Override placeholder with actual function
if (typeof window !== 'undefined') {
  window.hideFormConfigModal = hideFormConfigModal;
}

// Show privacy modal
function showPrivacyModal(onContinue) {
  const modal = document.getElementById('privacy-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('privacy-modal', true);
    
    // Set up continue handler
    const continueBtn = document.getElementById('privacy-modal-continue');
    if (continueBtn && onContinue) {
      continueBtn.onclick = onContinue;
    }
  }
}

// Override placeholder with actual function
if (typeof window !== 'undefined') {
  window.showPrivacyModal = showPrivacyModal;
}

// Hide privacy modal
// hidePrivacyModal function is now defined in adminPanel-framework.js.html

// Show digital citizenship modal
function showDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('digital-citizenship-modal', true);
  }
}

// Hide digital citizenship modal
function hideDigitalCitizenshipModal() {
  const modal = document.getElementById('digital-citizenship-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('digital-citizenship-modal', false);
  }
}

// Show confirmation modal
function showConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  console.log('🔍 showConfirmationModal: 要素検索完了');
  
  if (modal && titleElement && messageElement && confirmBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // 確認ボタンのクリックイベント
    confirmBtn.onclick = function() {
      console.log('✅ 確認ボタンがクリックされました');
      hideConfirmationModal();
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ 確認コールバック実行エラー:', error);
        }
      }
    };
    
    // キャンセルボタンのクリックイベント
    if (cancelBtn) {
      cancelBtn.onclick = function() {
        console.log('❌ キャンセルボタンがクリックされました');
        hideConfirmationModal();
      };
    }
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    manageFocusForModal('confirmation-modal', true);
    console.log('✅ 確認モーダルを表示しました');
  } else {
    console.error('❌ モーダル要素が見つかりません。フォールバックを使用します。');
    // フォールバック: ブラウザ標準の確認ダイアログ
    if (window.confirm(`${title}\n\n${message}`)) {
      if (onConfirm) {
        try {
          onConfirm();
        } catch (error) {
          console.error('❌ フォールバック確認コールバック実行エラー:', error);
        }
      }
    }
  }
}

// Hide confirmation modal
function hideConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  if (modal) {
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    manageFocusForModal('confirmation-modal', false);
  }
}

// =============================================================================
// DYNAMIC CONTENT UPDATES
// =============================================================================

// Update dynamic content when board is active
function updateDynamicContent(status) {
  // Enable buttons that require active state
  const buttons = [
    'open-spreadsheet-btn'
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = false;
      button.classList.remove('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update UI when no sheet is active
function updateUIForNoActiveSheet(status) {
  // Disable buttons that require active state
  const buttons = [
    // No form buttons to disable since we only support spreadsheets
  ];
  
  buttons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.disabled = true;
      button.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
}

// Update existing user section
function updateExistingUserSection(status) {
  // Update any user-specific UI elements
  if (status.userInfo) {
    // Update user-specific elements here if needed
  }
}

// Update custom form info
function updateCustomFormInfo(status) {
  if (status.customFormInfo) {
    // Update form-related UI elements
    const formTitle = document.getElementById('form-title-display');
    const formQuestion = document.getElementById('form-question-display');
    
    if (formTitle) {
      formTitle.textContent = status.customFormInfo.title || 'フォーム未作成';
    }
    
    if (formQuestion) {
      formQuestion.textContent = status.customFormInfo.mainQuestion || '';
    }
  }
  
  // フォームURL表示の更新（configJsonから確実に取得）
  updateFormUrlDisplay(status);
}

// フォームURL表示を確実に更新
// Full implementation of updateFormUrlDisplay (framework has minimal version)
function _fullUpdateFormUrlDisplay(status = null) {
  const formUrlInput = document.getElementById('form-url-input');
  const formUrlSection = document.getElementById('form-url-section');
  const openFormLink = document.getElementById('open-form-url-link');

  if (!formUrlInput) return;

  // 現在のstatusの最適化された取得
  const currentStatusToUse = status || currentStatus;
  if (!currentStatusToUse || !currentStatusToUse.userInfo) {
    logWarn('⚠️ updateFormUrlDisplay: status情報が不足しています');
    return;
  }

  // 新しい統一ヘルパー関数からフォームURLを取得
  const resourceUrls = getActiveResourceUrls(currentStatusToUse);
  const formUrl = resourceUrls.form;

  // UI更新の最適化
  if (formUrl) {
    updateFormUrlElements(formUrlInput, openFormLink, formUrl);
    handleFormUrlSectionVisibility(formUrlSection);
    logDebug('🔗 FormURL UI更新完了:', formUrl);
  } else {
    clearFormUrlElements(formUrlInput, formUrlSection);
    logDebug('📭 FormURL未設定のためUI非表示');
  }
}

// フォームURL要素更新の最適化
function updateFormUrlElements(input, link, url) {
  input.value = url;
  if (link) {
    link.href = url;
  }
}

// フォームURL要素クリアの最適化
function clearFormUrlElements(input, section) {
  input.value = '';
  if (section) {
    section.classList.add('hidden');
  }
}

// フォームURLセクション表示制御の最適化
function handleFormUrlSectionVisibility(section) {
  if (!section) return;
  
  const formJustCreated = sessionStorage.getItem('form_just_created');
  if (formJustCreated === 'true') {
    section.classList.remove('hidden');
    logDebug('🆕 新規フォーム作成セクション表示');
    
    // フラグクリアの最適化（タイマー処理）
    setTimeout(() => {
      sessionStorage.removeItem('form_just_created');
      logDebug('🧹 フォーム作成フラグクリア');
    }, 10000);
  } else {
    section.classList.add('hidden');
  }
}

// Check for auto-publish dialog
function checkAutoPublishDialog(status) {
  // Implementation for auto-publish dialog if needed
  if (status.needsAutoPublish) {
    // Show auto-publish confirmation
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// UI initialization is now handled in adminPanel-framework.js.html

// =============================================================================
// SHEET SELECTION FUNCTIONALITY  
// =============================================================================

// シート選択処理中フラグ（重複防止）
let sheetSelectionInProgress = false;

// Handle sheet selection change (最適化版)
async function handleSheetSelectionChange(event) {
  const newSelectedSheet = event.target.value;

  // 重複実行防止
  if (sheetSelectionInProgress) {
    console.log('📊 Sheet selection already in progress, skipping...');
    return;
  }

  // Prevent redundant calls if the selected sheet hasn't actually changed
  if (newSelectedSheet === lastSelectedSheetName) {
    console.log('📊 Sheet selection unchanged, skipping redundant processing.');
    return;
  }
  
  sheetSelectionInProgress = true;
  console.log('📊 Sheet selection changed: ' + newSelectedSheet);
  
  try {
    // Update global selected sheet variable and last selected sheet
    selectedSheet = newSelectedSheet;
    lastSelectedSheetName = newSelectedSheet;
    
    if (newSelectedSheet) {
      console.log('📋 Loading config for sheet:', newSelectedSheet);

      // 履歴復元中は特別な処理を実行
      if (window._historyRestoreInProgress || window._historyColumnSelections) {
        console.log('🔄 履歴復元中: 専用の設定読み込み処理を実行します');
        await _loadConfigForHistoryRestore(newSelectedSheet);
        updateUIForSelectedSheet();
        return;
      }

      // 基本検証
      if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
        console.error('スプレッドシート情報が見つかりません');
        return;
      }

      // シート名をサニタイズしてからAPI呼び出し
      const sanitizedSheetName = newSelectedSheet.replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF-]/g, '').trim();
      console.log(`🔄 Sanitized sheet name: "${newSelectedSheet}" → "${sanitizedSheetName}"`);

      // アクティブシートの列データを取得して列選択を更新
      const effectiveId = _resolveSpreadsheetIdForApi(currentStatus);
      loadConfigForSelected(sanitizedSheetName, effectiveId)
        .then(result => {
          console.log('✅ シート設定読み込み完了:', result);
          updateUIForSelectedSheet();
        })
        .catch(error => {
          console.error('❌ シート設定読み込み失敗:', error);
          showMessage('シートの設定読み込みに失敗しました', 'error');
          updateUIForSelectedSheet();
        })
        .finally(() => {
          // 処理フラグをリセット
          sheetSelectionInProgress = false;
        });
        
      // 即座にシートをアクティブ化
      activateSelectedSheet(newSelectedSheet);
    } else {
      // シート選択が解除された場合
      clearColumnSelections();
      updateUIForSelectedSheet();
    }
  } catch (error) {
    console.error('❌ Sheet selection error:', error);
  } finally {
    // 処理フラグをリセット（エラー時も確実に）
    sheetSelectionInProgress = false;
  }
}

// シートを即座にアクティブ化する関数
/**
 * シートを即座にアクティブ化し、UI上の選択状態も同期する
 * @param {string} sheetName - アクティブにするシート名
 */
function activateSelectedSheet(sheetName) {
  if (!sheetName || !currentStatus || !currentStatus.userInfo) {
    console.warn('⚠️ シートアクティブ化に必要な情報が不足しています');
    return;
  }

  console.log(`🎯 シートを即座にアクティブ化: ${sheetName}`);
  
  // サーバー側でアクティブシートを設定
  runGasWithUserId('setActiveSheet', 'シートをアクティブ化中...', sheetName)
    .then(response => {
      console.log('✅ シートアクティブ化完了:', response);
      
      // currentStatusを更新
      if (currentStatus.userInfo.configJson) {
        try {
          const config = JSON.parse(currentStatus.userInfo.configJson);
          config.publishedSheetName = sheetName;
          currentStatus.userInfo.configJson = JSON.stringify(config);
          currentStatus.activeSheetName = sheetName;
          
          // UI上のシート選択状態を更新
          updateActiveSheetUI(sheetName);
          
          console.log('✅ ローカル状態更新完了');
        } catch (e) {
          console.warn('⚠️ configJson更新に失敗:', e);
        }
      }
    })
    .catch(error => {
      console.error('❌ シートアクティブ化失敗:', error);
      showMessage('シートのアクティブ化に失敗しました', 'warning');
    });
}

// シートドロップダウンのアクティブ表示を更新
function updateSheetSelectActiveIndicator(activeSheetName) {
  const select = document.getElementById('sheet-select');
  if (!select) return;
  
  // 全てのオプションからアクティブ表示を削除
  Array.from(select.options).forEach(option => {
    if (option.value && option.textContent.includes(' (アクティブ)')) {
      option.textContent = option.value;
      option.style.fontWeight = 'normal';
      option.style.color = '';
      option.className = '';
    }
  });
  
  // 新しいアクティブシートに表示を追加
  const activeOption = Array.from(select.options).find(option => option.value === activeSheetName);
  if (activeOption) {
    activeOption.textContent = `${activeSheetName} (アクティブ)`;
    activeOption.style.fontWeight = 'bold';
    activeOption.style.color = '#10b981';
    activeOption.className = 'active-sheet-option';
  }
}

// 重複UI更新防止用キャッシュ
let lastUIUpdateSheet = null;
let uiUpdateCount = 0;

// 新しい関数: アクティブシートUI更新
function updateActiveSheetUI(sheetName) {
  // 重複防止: 同じシートに対する連続更新を制限
  if (lastUIUpdateSheet === sheetName && uiUpdateCount >= 2) {
    return; // 重複更新をスキップ
  }
  
  if (lastUIUpdateSheet !== sheetName) {
    uiUpdateCount = 0; // 新しいシートの場合はカウントリセット
  }
  
  console.log('🔄 updateActiveSheetUI called with:', sheetName);
  
  const select = document.getElementById('sheet-select');
  if (!select) {
    console.warn('⚠️ Sheet select element not found');
    return;
  }
  
  // シート選択を更新
  if (sheetName && select.value !== sheetName) {
    const normalizedSheetName = sheetName.trim();
    const availableOptions = Array.from(select.options);
    const matchingOption = availableOptions.find(option => option.value === normalizedSheetName);
    
    if (matchingOption) {
      select.value = normalizedSheetName;
      selectedSheet = normalizedSheetName;
      lastSelectedSheetName = normalizedSheetName;
      lastUIUpdateSheet = normalizedSheetName;
      uiUpdateCount++;
      console.log('✅ Active sheet UI updated:', normalizedSheetName);
      
      // アクティブ表示も更新
      updateSheetSelectActiveIndicator(normalizedSheetName);
      
      // UI状態も更新
      updateUIForSelectedSheet();
    } else {
      console.warn('⚠️ Sheet not found in select options:', normalizedSheetName);
    }
  }
}

// 新しい関数: シート選択の再同期
function refreshSheetSelection() {
  console.log('🔄 refreshSheetSelection called');
  
  // 現在の状態からアクティブシート情報を取得
  if (window.currentStatus && window.currentStatus.activeSheetName) {
    updateActiveSheetUI(window.currentStatus.activeSheetName);
  } else if (selectedSheet) {
    updateActiveSheetUI(selectedSheet);
  }
}

// 列選択をクリアする関数
function clearColumnSelections() {
  console.log('🧹 列選択をクリア');
  
  const columnSelects = [
    'opinion-column',
    'name-column', 
    'reason-column',
    'class-column',
    'timestamp-column'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.innerHTML = '<option value="">-- シートを選択してください --</option>';
      select.disabled = true;
    }
  });
}

// Load configuration for selected sheet - OPTIMIZED
// 効率的にAPI用のスプレッドシートIDを解決
function _resolveSpreadsheetIdForApi(status) {
  try {
    const st = status || window.currentStatus || {};
    // 最優先: userInfo.spreadsheetId（直近の切替を反映）
    if (st.userInfo && st.userInfo.spreadsheetId) return st.userInfo.spreadsheetId;
    // 次点: configJson.publishedSpreadsheetId
    if (st.configJson && st.configJson.publishedSpreadsheetId) return st.configJson.publishedSpreadsheetId;
    // フォールバック: URLから抽出
    const url = (st.userInfo && st.userInfo.spreadsheetUrl) || (st.appUrls && st.appUrls.spreadsheetUrl) || null;
    if (url) {
      const m = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9_-]+)/);
      if (m && m[1]) return m[1];
    }
  } catch (e) {
    console.warn('⚠️ _resolveSpreadsheetIdForApi failed:', e.message);
  }
  return null;
}

// 代替候補のID（userInfoとconfigJsonを入れ替え）
function _resolveAltSpreadsheetId(status, primaryId) {
  const st = status || window.currentStatus || {};
  const cand1 = st.configJson && st.configJson.publishedSpreadsheetId;
  const cand2 = st.userInfo && st.userInfo.spreadsheetId;
  if (cand1 && cand1 !== primaryId) return cand1;
  if (cand2 && cand2 !== primaryId) return cand2;
  return null;
}

function loadConfigForSelected(sheetName, spreadsheetId, retryCount = 0, maxRetries = 3) {
  console.log('📋 Loading config for: ' + sheetName);

  // 足りない場合はその場で解決
  if (!spreadsheetId) {
    spreadsheetId = _resolveSpreadsheetIdForApi(window.currentStatus);
  }

  if (!spreadsheetId || !sheetName) {
    console.error('スプレッドシート情報が不足しています。');
    return Promise.reject(new Error('スプレッドシート情報が不足しています'));
  }

  return new Promise((resolve, reject) => {

  // Check if fresh save protection is active - skip cache if so
  const timeSinceFreshSave = Date.now() - (window.freshSaveTimestamp || 0);
  const isFreshSaveActive = timeSinceFreshSave < 30000; // 30 seconds
  
    // Check if we already have sheet details from integrated API
    if (!isFreshSaveActive && currentStatus && currentStatus.sheetDetails && 
        currentStatus.activeSheetName === sheetName && currentStatus.sheetDetails.allHeaders && currentStatus.sheetDetails.allHeaders.length > 0) {
      console.log('⚡ Using cached sheet details from integrated API');
      try {
        populateHeaderOptions(currentStatus.sheetDetails.allHeaders);
        console.log('✅ Header options populated from cache');
        populateConfig(currentStatus.sheetDetails.guessedConfig);
        console.log('✅ AI configuration applied from cache');
        resolve({ source: 'cache', headers: currentStatus.sheetDetails.allHeaders, config: currentStatus.sheetDetails.guessedConfig });
        return; // Early return - no API call needed
      } catch (error) {
        console.error('Error in cached config population:', error);
        // Fall through to API call if cache fails
      }
    }

  // Force fresh API call if fresh save protection is active or cache unavailable
  if (isFreshSaveActive) {
    console.log('🔄 Fresh save protection active - forcing API call for latest data');
  } else {
    console.log('📞 Making API call for sheet details:', sheetName);
  }
  
    runGasWithUserId('getSheetDetails', 'シート情報を取得中...', spreadsheetId, sheetName)
      .then(function(details) {
        // Sheet details loaded - verbose logging disabled
        
        // If headers are empty, and we have retries left, try again after a delay
        if (details && (!details.allHeaders || details.allHeaders.length === 0) && retryCount < maxRetries) {
          console.warn(`⚠️ No headers found for ${sheetName}. Retrying in 2 seconds... (Attempt ${retryCount + 1}/${maxRetries})`);
          showMessage(`シート情報を再取得中... (${retryCount + 1}/${maxRetries})`, 'info');
          setTimeout(() => {
            loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
              .then(resolve)
              .catch(reject);
          }, 2000); // Retry after 2 seconds
          return;
        }

        try {
          // 1) ヘッダー一覧をUIへ反映
          populateHeaderOptions(details.allHeaders);
          console.log('✅ Header options populated from API');

          // 2) 履歴復元中はAI推定の上書きを避ける（列選択を再適用）
          if (window._historyRestoreInProgress) {
            console.log('🛡️ 履歴復元中: AI推定の適用をスキップし、履歴の列選択を再適用します');
            const sel = window._historyColumnSelections || {};
            const applyIf = (id, val) => {
              if (!val) return;
              const el = document.getElementById(id);
              if (el) el.value = val;
            };
            applyIf('opinionHeader', sel.opinionColumn);
            applyIf('name-column', sel.nameColumn);
            applyIf('class-column', sel.classColumn);
            applyIf('reason-column', sel.reasonColumn);
            // 一度適用したらクリア
            window._historyColumnSelections = null;
          } else {
            // 通常時はAI推定を適用
            populateConfig(details.guessedConfig);
            console.log('✅ AI configuration applied from API');
          }
          if (retryCount > 0) {
            showMessage('✅ シート情報が正常に読み込まれました！', 'success');
          }
          resolve({ source: 'api', headers: details.allHeaders, config: details.guessedConfig });
        } catch (error) {
          console.error('Error in API config population sequence:', error);
          showMessage('設定の適用中にエラーが発生しました', 'error');
          reject(error);
        }
      })
      .catch(function(error) {
        console.error('Failed to load sheet config via API:', error);
        
        // より詳細なエラーメッセージの表示
        let errorMessage = 'シート設定の読み込みに失敗しました';
        
        if (error && error.message) {
          if (error.message.includes('が見つかりません')) {
            errorMessage = `指定されたシート "${sheetName}" が見つかりません。`;
          } else if (error.message.includes('ヘッダーが見つかりません')) {
            errorMessage = `シート "${sheetName}" の1行目にヘッダーが見つかりません。`;
          } else if (error.message.includes('アクセス権限')) {
            errorMessage = 'スプレッドシートへのアクセス権限がありません。管理者にお問い合わせください。';
          } else if (error.message.includes('SheetsService')) {
            errorMessage = 'Google Sheets APIサービスでエラーが発生しました。しばらく時間をおいて再試行してください。';
          } else {
            errorMessage = `エラーの詳細: ${error.message}`;
          }
        }
        
        // フォールバック試行: spreadsheetIdを省略（サーバー側の既定スプレッドシート）
        const maybeNotFound = error && (error.message.includes('が見つかりません') || error.message.includes('Unable to parse range'));
        if (maybeNotFound && spreadsheetId && retryCount === 0) {
          // 代替のスプレッドシートIDで再試行（サーバー側フォールバックに依存しない）
          const altId = _resolveAltSpreadsheetId(window.currentStatus, spreadsheetId);
          if (altId) {
            console.warn('⚠️ Fallback: Retrying getSheetDetails with alt spreadsheetId');
            return runGasWithUserId('getSheetDetails', 'シート情報を再取得中...', altId, sheetName)
              .then(details => {
                try {
                  populateHeaderOptions(details.allHeaders);
                  console.log('✅ Header options populated from fallback API');
                  if (window._historyRestoreInProgress) {
                    const sel = window._historyColumnSelections || {};
                    const applyIf = (id, val) => {
                      if (!val) return;
                      const el = document.getElementById(id);
                      if (el) el.value = val;
                    };
                    applyIf('opinionHeader', sel.opinionColumn);
                    applyIf('name-column', sel.nameColumn);
                    applyIf('class-column', sel.classColumn);
                    applyIf('reason-column', sel.reasonColumn);
                    window._historyColumnSelections = null;
                  } else {
                    populateConfig(details.guessedConfig);
                    console.log('✅ AI configuration applied from fallback API');
                  }
                  resolve({ source: 'api-fallback', headers: details.allHeaders, config: details.guessedConfig });
                } catch (err2) {
                  console.error('Error in fallback config population sequence:', err2);
                  showMessage('設定の適用中にエラーが発生しました', 'error');
                  reject(err2);
                }
              })
              .catch(err2 => {
                console.warn('Fallback getSheetDetails also failed:', err2);
                showMessage(errorMessage, 'error');
                // After fallback failure, proceed with normal retry handling below
                // Intentionally no return here to fall through to retry logic
              });
          }
          // altIdがなければ従来のフォールバック（サーバ側既定）
          console.warn('⚠️ Fallback: Retrying getSheetDetails without spreadsheetId');
          return runGasWithUserId('getSheetDetails', 'シート情報を再取得中...', null, sheetName)
              .then(details => {
                try {
                  populateHeaderOptions(details.allHeaders);
                  console.log('✅ Header options populated from fallback API');
                if (window._historyRestoreInProgress) {
                  const sel = window._historyColumnSelections || {};
                  const applyIf = (id, val) => {
                    if (!val) return;
                    const el = document.getElementById(id);
                    if (el) el.value = val;
                  };
                  applyIf('opinionHeader', sel.opinionColumn);
                  applyIf('name-column', sel.nameColumn);
                  applyIf('class-column', sel.classColumn);
                  applyIf('reason-column', sel.reasonColumn);
                  window._historyColumnSelections = null;
                } else {
                  populateConfig(details.guessedConfig);
                  console.log('✅ AI configuration applied from fallback API');
                }
                resolve({ source: 'api-fallback', headers: details.allHeaders, config: details.guessedConfig });
              } catch (err2) {
                console.error('Error in fallback config population sequence:', err2);
                showMessage('設定の適用中にエラーが発生しました', 'error');
                reject(err2);
              }
            })
            .catch(err2 => {
              console.warn('Fallback getSheetDetails also failed:', err2);
              showMessage(errorMessage, 'error');
              // After fallback failure, proceed with normal retry handling below
              // Intentionally no return here to fall through to retry logic
            });
        }

        showMessage(errorMessage, 'error');
        
        // エラー時のリトライオプションを提供
        if (retryCount < maxRetries) {
          setTimeout(() => {
            const retryButton = document.createElement('button');
            retryButton.textContent = '再試行';
            retryButton.className = 'ml-2 px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600';
            retryButton.onclick = () => {
              retryButton.remove();
              loadConfigForSelected(sheetName, spreadsheetId, retryCount + 1, maxRetries)
                .then(resolve)
                .catch(reject);
            };
            
            const messageElement = document.querySelector('.message');
            if (messageElement) {
              messageElement.appendChild(retryButton);
            }
          }, 1000);
        } else {
          reject(error);
        }
      });
  }); // Promise終了
}


// =============================================================================
// SETUP STATUS HANDLING FUNCTIONS
// =============================================================================

/**
 * userInfoからsetupStatusを安全に取得
 * @param {Object} userInfo - ユーザー情報オブジェクト
 * @returns {string} setupStatus ('pending', 'completed', 'error')
 */
function getSetupStatusFromUserInfo(userInfo) {
  try {
    if (!userInfo || !userInfo.configJson) {
      return 'pending'; // ユーザー情報がない場合はセットアップ未完了とみなす
    }

    const config = typeof userInfo.configJson === 'string'
      ? JSON.parse(userInfo.configJson)
      : userInfo.configJson;

    // setupStatusが明示的に設定されている場合はそれを使用
    if (config.setupStatus) {
      console.log('🔧 configJson setupStatus:', config.setupStatus);
      return config.setupStatus;
    }
    
    // setupStatusがない場合、他のフィールドから推測（循環参照回避）
    // Note: この推測ロジックは循環参照を避けるため、formUrlベースに変更
    if (config.formCreated === true && config.formUrl && config.formUrl.trim()) {
      return 'completed';
    }
    
    return 'pending';
    
  } catch (error) {
    console.warn('getSetupStatusFromUserInfo JSON解析エラー:', error.message);
    return 'pending'; // エラー時はセットアップ未完了とみなす
  }
}


/**
 * 初期表示要素をクリアして適切なドメイン表示に切り替え
 */
function clearInitialDisplayElements() {
  // 初期表示を非表示にして、適切なドメイン表示に切り替え
  const initialContainer = document.getElementById('header-domain-initial');
  if (initialContainer) {
    initialContainer.style.display = 'none';
    console.log('✅ 初期ドメイン表示を非表示');
  }
  
  // 適切なドメイン情報を表示
  showAppropriateHeaderStatus();
  
  // 既存のセットアップガイドのみ削除
  const existingGuides = [
    document.getElementById('setup-pending-guide'),
    document.querySelector('.setup-guide')
  ];
  
  existingGuides.forEach(guide => {
    if (guide) {
      guide.remove();
      console.log('✅ 既存セットアップガイドを削除');
    }
  });
}

/**
 * ヘッダーに適切なステータス表示を設定
 */
function showAppropriateHeaderStatus() {
  // ドメイン一致表示（仮）を表示
  const domainMatch = document.getElementById('header-domain-match');
  const domainMismatch = document.getElementById('header-domain-mismatch');
  
  if (domainMatch && domainMismatch) {
    // 現在はドメイン一致として表示（実際のドメインチェックは別途実装）
    domainMatch.style.display = 'block';
    domainMismatch.style.display = 'none';
    
    // ドメイン名を適切に設定
    const domainText = document.getElementById('header-domain-match-text');
    if (domainText) {
      domainText.textContent = 'naha-okinawa.ed.jp'; // cspell:disable-line
    }
    
    console.log('✅ ドメイン一致表示を有効化');
  }
}

/**
 * セットアップ状況に応じてボタン状態を更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateButtonStatesForSetup(status) {
  // より穏やかなUI制御（セットアップ無効化ではなく、適切なガイダンス）

  // 最低限無効化すべき公開関連ボタンのみ
  const criticalPublishButtons = [
    'save-publish-btn',
    'unpublish-board-btn'
  ];
  
  criticalPublishButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      // データが不足している場合のみ無効化
      const hasSpreadsheet = status.userInfo && status.userInfo.spreadsheetId;
      const hasActiveSheet = status.activeSheetName;
      
      if (!hasSpreadsheet || !hasActiveSheet) {
        button.disabled = true;
        button.classList.add('opacity-75');
        button.title = '先にデータソースとシートを設定してください';
      } else {
        button.disabled = false;
        button.classList.remove('opacity-75');
        button.title = '';
      }
    }
  });
  
  console.log('✅ ボタン状態を適切に更新しました');
}


/**
 * 基本的な静的UI要素のみ更新
 * @param {Object} status - ステータスオブジェクト
 */
function updateBasicStaticUI(status) {
  // ユーザー情報など最低限の情報のみ更新
  if (status.userInfo) {
    // 既存のupdateDatabaseInfo関数を使用して重複を避ける
    updateDatabaseInfo(status);
  }
}

// Update system status display
/**
 * 現在アクティブなすべてのリソースURLを取得し、統一されたオブジェクトとして返す。
 * @param {object} status - 最新のシステムステータスオブジェクト
 * @returns {object} - 各リソースのURLを格納したオブジェクト
 */
function getActiveResourceUrls(status) {
  const urls = {
    spreadsheet: null,
    folder: null,
    form: null,
    editForm: null
  };

  if (!status || !status.userInfo) {
    return urls; // ユーザー情報がなければ空のURLを返す
  }

  // 1. スプレッドシートURLの取得（複数ソースから確保）
  urls.spreadsheet = status.userInfo.spreadsheetUrl || 
                     status.appUrls?.spreadsheetUrl ||
                     (typeof currentSpreadsheetUrl !== 'undefined' ? currentSpreadsheetUrl : null);
  
  console.log('📊 Spreadsheet URL determination:', {
    fromUserInfo: status.userInfo.spreadsheetUrl || 'none',
    fromAppUrls: status.appUrls?.spreadsheetUrl || 'none', 
    fromGlobal: (typeof currentSpreadsheetUrl !== 'undefined' ? currentSpreadsheetUrl : 'none'),
    final: urls.spreadsheet
  });

  // 2. configJsonの解析 (一度だけ実行)
  let config = {};
  if (status.userInfo.configJson) {
    try {
      config = typeof status.userInfo.configJson === 'string' 
        ? JSON.parse(status.userInfo.configJson) 
        : status.userInfo.configJson;
    } catch (e) {
      console.warn("configJsonの解析に失敗しました", e);
    }
  }

  // 3. フォルダURLの取得 (configJsonから、またはfolderId から構築)
  urls.folder = config.folderUrl || null;
  
  // フォルダURLが設定されていない場合、folderIdから構築を試行
  if (!urls.folder && config.folderId) {
    const safeFolderId = String(config.folderId || '');
    urls.folder = 'https://drive.google.com/drive/folders/' + safeFolderId;
    console.log('📁 Folder URL constructed from folderId:', urls.folder);
  }

  // 4. フォームURLの取得 (configJsonから、公開シートを優先)
  const publishedSheetName = config.publishedSheetName;
  if (publishedSheetName) {
    const sheetConfig = config['sheet_' + String(publishedSheetName || '')];
    if (sheetConfig) {
      urls.form = sheetConfig.formUrl || urls.form;
      urls.editForm = sheetConfig.editFormUrl || urls.editForm;
    }
  }
  
  // フォールバック: 複数ソースからフォームURL取得
  if (!urls.form) {
    urls.form = config.formUrl || 
                status.userInfo.formUrl ||
                status.appUrls?.formUrl ||
                null;
  }
  
  if (!urls.editForm) {
    urls.editForm = config.editFormUrl || 
                    status.userInfo.editFormUrl ||
                    status.appUrls?.editFormUrl ||
                    (urls.form ? urls.form.replace('/viewform', '/edit') : null);
  }
  
  console.log('📋 Form URL determination:', {
    form: urls.form || 'none',
    editForm: urls.editForm || 'none',
    fromConfig: !!config.formUrl,
    fromUserInfo: !!status.userInfo.formUrl,
    fromAppUrls: !!status.appUrls?.formUrl
  });

  return urls;
}

/**
 * シート名の正規化処理
 */
function _normalizeSheetName(sheetName) {
  if (!sheetName) return '';
  
  return sheetName
    .trim()
    .replace(/\s+/g, ' ')  // 複数の空白を1つに
    .replace(/[\u3000]/g, ' ')  // 全角空白を半角に
    .toLowerCase();
}

/**
 * 履歴復元時専用の設定読み込み処理
 */
async function _loadConfigForHistoryRestore(sheetName) {
  try {
    console.log('📝 履歴復元用設定読み込み開始:', sheetName);
    
    // 履歴復元フラグを一時的に無効化して設定読み込み
    const originalRestoreFlag = window._historyRestoreInProgress;
    const originalColumnSelections = window._historyColumnSelections;
    
    window._historyRestoreInProgress = false;
    window._historyColumnSelections = null;
    
    // 設定読み込み実行（強制読み込みフラグ付き）
    const result = await loadConfigForSelected(sheetName, null, 0, 3, true);
    
    // フラグを元に戻す
    window._historyRestoreInProgress = originalRestoreFlag;
    window._historyColumnSelections = originalColumnSelections;
    
    console.log('✅ 履歴復元用設定読み込み完了:', result);
    
    // 履歴データの列設定を再適用
    if (window._historyColumnSelections) {
      console.log('🔄 履歴の列設定を再適用中...');
      _applyHistoryColumnSettings(window._historyColumnSelections);
    }
    
  } catch (error) {
    console.error('❌ 履歴復元用設定読み込みエラー:', error);
  }
}

/**
 * 履歴の列設定をDOMに再適用
 */
function _applyHistoryColumnSettings(columnSelections) {
  try {
    // DOM要素への値設定
    if (columnSelections.opinionHeader) {
      const opinionEl = document.getElementById('opinionHeader');
      if (opinionEl) {
        opinionEl.value = columnSelections.opinionHeader;
        console.log('✅ Opinion header reapplied:', columnSelections.opinionHeader);
      }
    }
    
    if (columnSelections.nameColumn) {
      const nameEl = document.getElementById('name-column');
      if (nameEl) {
        nameEl.value = columnSelections.nameColumn;
        console.log('✅ Name column reapplied:', columnSelections.nameColumn);
      }
    }
    
    if (columnSelections.classColumn) {
      const classEl = document.getElementById('class-column');
      if (classEl) {
        classEl.value = columnSelections.classColumn;
        console.log('✅ Class column reapplied:', columnSelections.classColumn);
      }
    }
    
    if (columnSelections.reasonHeader) {
      const reasonEl = document.getElementById('reasonHeader');
      if (reasonEl) {
        reasonEl.value = columnSelections.reasonHeader;
        console.log('✅ Reason header reapplied:', columnSelections.reasonHeader);
      }
    }
    
  } catch (error) {
    console.error('❌ 履歴列設定再適用エラー:', error);
  }
}

function updateSystemStatusDisplay(status) {
  if (!status) return;

  // すべてのリソースURLを一括取得
  const resourceUrls = getActiveResourceUrls(status);

  // Update publish status
  const publishIndicator = document.getElementById('info-publish-indicator');
  const publishText = document.getElementById('info-publish-text');

  if (status.isPublished) {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-green-400';
    publishText.textContent = '公開中';
  } else {
    publishIndicator.className = 'w-2 h-2 rounded-full bg-gray-400';
    publishText.textContent = '非公開';
  }

  // Update other status fields
  document.getElementById('info-published-sheet').textContent = status.sheetName || '-';
  document.getElementById('info-display-mode').textContent = status.displayMode || '-';
  document.getElementById('info-show-counts').textContent = status.showCounts ? '表示' : '非表示';

  // Enable resource buttons if URLs are available
  const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
  if (spreadsheetBtn) {
    spreadsheetBtn.disabled = !resourceUrls.spreadsheet;
    if (resourceUrls.spreadsheet) {
      spreadsheetBtn.onclick = () => window.open(resourceUrls.spreadsheet, '_blank');
      spreadsheetBtn.title = 'スプレッドシートを開く';
    } else {
      spreadsheetBtn.title = 'スプレッドシートURLが未設定です';
    }
  }

  // フォームボタンの有効化
  const formBtn = document.getElementById('open-form-btn');
  if (formBtn) {
    formBtn.disabled = false;
    formBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    if (resourceUrls.form) {
      formBtn.onclick = () => window.open(resourceUrls.form, '_blank');
      formBtn.title = 'フォームを開く';
    } else {
      formBtn.onclick = () => showMessage('フォームURLが未設定です。フォームを作成してください。', 'warning');
      formBtn.title = 'フォームURLが未設定です。フォームを作成してください。';
    }
  }

  // Handle generic resource button in Step 1 (any resource)
  const resourceBtn = document.getElementById('add-resource-btn');
  if (resourceBtn) {
    const anyResourceUrl = resourceUrls.spreadsheet || resourceUrls.folder || resourceUrls.form || resourceUrls.editForm;
    resourceBtn.disabled = false;
    if (anyResourceUrl) {
      resourceBtn.onclick = () => window.open(anyResourceUrl, '_blank');
      resourceBtn.title = 'リソースを開く';
    } else {
      resourceBtn.onclick = () => showMessage('リソースURLが未設定です', 'warning');
      resourceBtn.title = 'リソースURLが未設定です';
    }
  }

  // Handle new resource buttons
  console.log('resourceUrls:', resourceUrls); // Gemini Debug
  updateNewResourceButtons(resourceUrls);
}

// Navigate to specific step
// navigateToStep function is now defined in adminPanel-framework.js.html


// セットアップ状況をグローバルステータスから取得




// Validate configuration
function validateConfiguration() {
  if (!currentConfig || !currentConfig.columnMappings) return false;
  
  const mappings = currentConfig.columnMappings;
  const hasContent = Object.values(mappings).includes('content');
  const hasAuthor = Object.values(mappings).includes('author');
  
  return hasContent && hasAuthor;
}


// =============================================================================
// HISTORY MANAGEMENT FUNCTIONS
// =============================================================================

// 履歴管理の定数
// HISTORY_STORAGE_KEY and MAX_HISTORY_ITEMS are defined in adminPanel-simple-history.js.html

/**
 * 回答ボードの履歴を保存
 * @param {Object} historyItem - 保存する履歴アイテム
 */
function saveToHistory(historyItem) {
  try {
    if (!historyItem || !historyItem.questionText) {
      logWarn('Invalid history item, skipping save');
      return;
    }

    const history = getHistoryFromStorage();
    
    // AI列判定結果を含む拡張された履歴アイテムを作成
    const newItem = {
      id: generateHistoryId(),
      timestamp: new Date().toISOString(),
      publishedAt: historyItem.publishedAt || new Date().toISOString(),
      publishedEndAt: historyItem.publishedEndAt || null,
      // 新しいフィールド: 終了関連
      endTime: historyItem.endTime || null, // 実際の終了日時（終了時に記録）
      scheduledEndTime: historyItem.scheduledEndTime || null, // 予定終了日時
      questionText: historyItem.questionText,
      sheetName: historyItem.sheetName || '',
      answerCount: historyItem.answerCount || 0,
      reactionCount: historyItem.reactionCount || 0,
      config: historyItem.config || {},
      formUrl: historyItem.formUrl || '',
      spreadsheetUrl: historyItem.spreadsheetUrl || '',
      setupType: historyItem.setupType || 'unknown', // クイックスタート、カスタムセットアップ、外部リソースを識別
      isActive: historyItem.isActive || false, // 現在公開中かどうか
      displayMode: historyItem.displayMode || 'named',
      countDisplay: historyItem.countDisplay || 'show',
      status: historyItem.status || 'published',
      
      // AI列判定結果の保存（復元時に必要）
      sheetDetails: {
        allHeaders: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.allHeaders) || [],
        guessedConfig: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig) || {},
        existingConfig: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.existingConfig) || {}
      },
      
      // 復元に必要な追加情報
      activeSheetName: (currentStatus && currentStatus.activeSheetName) || historyItem.sheetName,
      spreadsheetId: (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetId) || '',
      
      // 保存時点での設定完了状態
      configurationComplete: !!(currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig && currentStatus.sheetDetails.guessedConfig.opinionHeader),
      
      // Simple format for quick display
      format: (() => {
        const cfg = historyItem.config || (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig) || {};
        if (cfg.multipleChoice || cfg.allowMultipleAnswers || (cfg.formElements && cfg.formElements.some(e => e.type === 'checkbox'))) return 'multi';
        if (cfg.singleChoice || cfg.choices || cfg.options || (cfg.formElements && cfg.formElements.some(e => e.type === 'radio' || e.type === 'select'))) return 'select';
        return 'text';
      })()
    };
    
    history.unshift(newItem);
    
    // 最大数を超えた場合は過去のものを削除
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }
    
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    logDebug('Enhanced history saved:', newItem);
    
    // サーバーサイドに同期（非同期、エラーハンドリング付き）
    syncHistoryToServer(newItem).then(result => {
      if (result.status === 'error') {
        logWarn('Server sync failed after retries:', result.message);
        // サーバー同期失敗をユーザーに通知（オプション）
        if (typeof showMessage === 'function' && result.retryCount > 2) {
          showMessage('⚠️ サーバーへの同期に失敗しましたが、ローカルには保存されました', 'warning');
        }
      } else {
        logDebug('Server sync completed successfully');
      }
    }).catch(error => {
      logError('Unexpected error in server sync:', error);
    });
    
    // UI を更新
    if (window.AdminPanel?.historyManager?.loadSimpleHistoryTable) {
      window.AdminPanel.historyManager.loadSimpleHistoryTable();
    } else {
      console.warn('⚠️ History manager not available for UI update');
    }
    
  } catch (error) {
    logWarn('Failed to save history:', error);
  }
}

/**
 * 履歴をサーバーサイドに同期
 * @param {Object} historyItem - 同期する履歴アイテム
 */
async function syncHistoryToServer(historyItem, retryCount = 0) {
  const MAX_RETRIES = 1; // 2→1に削減でパフォーマンス向上
  
  try {
    if (!historyItem || !historyItem.id) {
      logWarn('Invalid history item for server sync:', historyItem);
      return { status: 'error', message: 'Invalid history item' };
    }
    
    logDebug('Syncing history to server (attempt ' + (retryCount + 1) + '):', historyItem.questionText);
    
    // 軽量タイムアウトでサーバー同期を実行  
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Server sync timeout')), 15000); // 30s→15sに短縮
    });
    
    // 送信ペイロードを軽量化（サーバ側でさらにサニタイズ）
    const compact = {
      id: historyItem.id,
      questionText: (historyItem.questionText || '').slice(0, 140),
      sheetName: historyItem.sheetName || '',
      publishedAt: historyItem.publishedAt || new Date().toISOString(),
      endTime: historyItem.endTime || null,
      scheduledEndTime: historyItem.scheduledEndTime || null,
      isActive: !!historyItem.isActive,
      // 表示モードはテキストで簡素化
      displayMode: historyItem.displayMode || (historyItem.config && historyItem.config.displayMode) || 'named',
      status: historyItem.status || 'published',
      spreadsheetId: (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetId) || '',
      answerCount: historyItem.answerCount || 0,
      reactionCount: historyItem.reactionCount || 0,
      setupType: historyItem.setupType || 'custom',
      // 簡易フォーマット（テキスト/選択/複数）
      format: (function deriveFormat() {
        const cfg = historyItem.config || (historyItem.sheetDetails && historyItem.sheetDetails.guessedConfig) || {};
        if (cfg.multipleChoice || cfg.allowMultipleAnswers || (cfg.formElements && cfg.formElements.some(e => e.type === 'checkbox'))) return 'multi';
        if (cfg.singleChoice || cfg.choices || cfg.options || (cfg.formElements && cfg.formElements.some(e => e.type === 'radio' || e.type === 'select'))) return 'select';
        return 'text';
      })()
    };
    const syncPromise = runGasWithUserId('saveHistoryToSheetAPI', false, compact);
    const response = await Promise.race([syncPromise, timeoutPromise]);
    
    if (response && response.status === 'success') {
      logDebug('History synced to server successfully');
      return { status: 'success', message: 'Server sync completed' };
    } else {
      const errorMsg = (response && response.message) || 'Unknown server error';
      logWarn('Server history sync failed:', errorMsg);
      
      // リトライロジック
      if (retryCount < MAX_RETRIES) {
        logDebug('Retrying server sync in 2 seconds...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        return await syncHistoryToServer(historyItem, retryCount + 1);
      }
      
      return { status: 'error', message: errorMsg, retryCount: retryCount + 1 };
    }
  } catch (error) {
    const errorMsg = error.message || 'Server sync failed';
    logWarn('Failed to sync history to server:', errorMsg);
    
    // リトライロジック
    if (retryCount < MAX_RETRIES && !errorMsg.includes('timeout')) {
      logDebug('Retrying server sync due to error in 2 seconds...');
      await new Promise(resolve => setTimeout(resolve, 2000));
      return await syncHistoryToServer(historyItem, retryCount + 1);
    }
    
    return { status: 'error', message: errorMsg, retryCount: retryCount + 1 };
  }
}

/**
 * 履歴を localStorage から取得
 * @returns {Array} 履歴配列
 */
function getHistoryFromStorage() {
  try {
    const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
    return historyJson ? JSON.parse(historyJson) : [];
  } catch (error) {
    logWarn('Failed to parse history from storage:', error);
    return [];
  }
}

/**
 * 履歴を localStorage に保存
 * @param {Array} historyArray 保存する履歴配列
 */
function saveHistoryToStorage(historyArray) {
  try {
    const safe = Array.isArray(historyArray) ? historyArray : [];
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(safe));
  } catch (error) {
    logWarn('Failed to save history to storage:', error);
  }
}

/**
 * サーバーサイドとローカルストレージの履歴を統合
 * @returns {Promise<Array>} 統合された履歴配列
 */
async function getMergedHistory() {
  try {
    // ローカルストレージから取得（検証付き）
    let localHistory = [];
    try {
      localHistory = getHistoryFromStorage();
      if (!Array.isArray(localHistory)) {
        logWarn('Local history is not an array, resetting to empty');
        localHistory = [];
      }
    } catch (localError) {
      logWarn('Failed to load local history:', localError);
      localHistory = [];
    }
    
    // サーバーサイドから取得（タイムアウト付き）
    let serverHistory = [];
    try {
      logDebug('Loading server history...');
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Server history timeout')), 8000); // 15s→8sに短縮
      });
      
      const historyPromise = runGasWithUserId('getHistoryFromServerAPI', false);
      const response = await Promise.race([historyPromise, timeoutPromise]);
      
      if (response && response.status === 'success') {
        if (Array.isArray(response.historyArray)) {
          serverHistory = response.historyArray.filter(item => item && item.id); // 軽量検証
          if (serverHistory.length > 0) logDebug('Server history loaded:', serverHistory.length, 'items');
        } else {
          logWarn('Server response historyArray is not an array');
        }
      } else {
        logWarn('Server history response failed:', (response && response.message) || 'Unknown error');
      }
    } catch (serverError) {
      if (serverError.message.includes('timeout')) {
        logWarn('Server history request timed out, using local only');
      } else {
        logWarn('Failed to load server history:', serverError.message);
      }
    }
    
    // 改善された統合処理：formId基準で重複排除し、詳細情報を保持
    const mergedMap = new Map(); // formId -> merged item
    const idMap = new Map(); // id -> merged item (for final deduplication)
    let totalItems = 0;
    
    // Helper function to merge two history items
    const mergeHistoryItems = (existing, newItem, source) => {
      if (!existing) return {...newItem, source};
      
      // Prefer server data for basic info, but preserve local sheetDetails
      const merged = {...newItem, source};
      
      // Preserve detailed local information if available
      if (existing.sheetDetails && (!merged.sheetDetails || Object.keys(existing.sheetDetails).length > Object.keys(merged.sheetDetails || {}).length)) {
        merged.sheetDetails = existing.sheetDetails;
        logDebug('Preserved local sheetDetails for formId:', newItem.formId);
      }
      
      // Preserve format information if available
      if (existing.format && !merged.format) {
        merged.format = existing.format;
      }
      
      return merged;
    };
    
    // First pass: collect all items by formId
    [...localHistory, ...serverHistory].forEach((item, index) => {
      if (!item || !item.id) return;
      
      const isLocal = index < localHistory.length;
      const source = isLocal ? 'local' : 'server';
      
      // Use formId for primary deduplication, fallback to id
      const key = item.formId || item.id;
      const existing = mergedMap.get(key);
      
      if (existing) {
        // Merge with existing item
        const merged = mergeHistoryItems(existing, item, source);
        mergedMap.set(key, merged);
        logDebug(`Merged duplicate formId: ${key} (${source})`);
      } else {
        // New item
        mergedMap.set(key, {...item, source});
      }
      totalItems++;
    });
    
    // Second pass: final deduplication by ID (in case formId wasn't unique enough)
    mergedMap.forEach((item) => {
      if (idMap.has(item.id)) {
        const existing = idMap.get(item.id);
        const merged = mergeHistoryItems(existing, item, item.source);
        idMap.set(item.id, merged);
        logDebug(`Final deduplication for ID: ${item.id}`);
      } else {
        idMap.set(item.id, item);
      }
    });
    
    // 軽量ソート（最終的にidMapからソート）
    const mergedArray = Array.from(idMap.values()).sort((a, b) => {
      const aTime = new Date(a.timestamp || a.publishedAt || a.createdAt || 0).getTime();
      const bTime = new Date(b.timestamp || b.publishedAt || b.createdAt || 0).getTime();
      return bTime - aTime; // 降順
    });
    
    if (mergedArray.length > 0) {
      logDebug(`History merged: ${mergedArray.length} items (${localHistory.length} local, ${serverHistory.length} server)`);
    }
    
    return mergedArray;
  } catch (error) {
    logError('Critical error in getMergedHistory:', error);
    // フォールバック：ローカルのみ（さらに安全に）
    try {
      const fallbackHistory = getHistoryFromStorage();
      logDebug('Using fallback local history:', fallbackHistory.length, 'items');
      return Array.isArray(fallbackHistory) ? fallbackHistory : [];
    } catch (fallbackError) {
      logError('Even fallback failed:', fallbackError);
      return [];
    }
  }
}

/**
 * 履歴用のユニークIDを生成
 * @returns {string} ユニークID
 */
function generateHistoryId() {
  return `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Draft session storage management functions
 */

// Draft session storage key
const DRAFT_SESSION_KEY = 'answerboard_draft_state'; // cspell:disable-line

/**
 * Save draft state to session storage
 * @param {Object} draftData - Draft form data
 */
function saveDraftToSession(draftData) {
  try {
    if (!draftData || !draftData.questionText) {
      logWarn('Invalid draft data, skipping session save');
      return;
    }

    // Create unique form identifier
    const formId = `${(currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetId) || 'unknown'}_${draftData.sheetName || selectedSheet || 'unknown'}`;
    
    const draftState = {
      formId,
      createdAt: new Date().toISOString(),
      questionText: draftData.questionText,
      sheetName: draftData.sheetName || selectedSheet,
      config: draftData.config || {},
      displayMode: draftData.displayMode || 'named', // named or anonymous
      countDisplay: draftData.countDisplay || 'show', // show or hide
      
      // AI column prediction results for recovery
      sheetDetails: {
        allHeaders: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.allHeaders) || [],
        guessedConfig: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig) || {},
        existingConfig: (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.existingConfig) || {}
      },
      
      // Form configuration state
      spreadsheetId: (currentStatus && currentStatus.userInfo && currentStatus.userInfo.spreadsheetId) || '',
      configurationComplete: !!(currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig && currentStatus.sheetDetails.guessedConfig.opinionHeader),
      
      // Timestamp for draft management
      lastUpdated: new Date().toISOString()
    };
    
    sessionStorage.setItem(DRAFT_SESSION_KEY, JSON.stringify(draftState));
    logDebug('Draft saved to session storage:', draftState.questionText);
    
  } catch (error) {
    logWarn('Failed to save draft to session:', error);
  }
}

/**
 * Get draft state from session storage
 * @returns {Object|null} Draft state or null if not found
 */
function getDraftFromSession() {
  try {
    const draftJson = sessionStorage.getItem(DRAFT_SESSION_KEY);
    if (!draftJson) return null;
    
    const draftState = JSON.parse(draftJson);
    logDebug('Draft loaded from session storage:', draftState.questionText);
    return draftState;
    
  } catch (error) {
    logWarn('Failed to load draft from session:', error);
    return null;
  }
}

/**
 * Clear draft from session storage
 */
function clearDraftFromSession() {
  try {
    sessionStorage.removeItem(DRAFT_SESSION_KEY);
    logDebug('Draft cleared from session storage');
  } catch (error) {
    logWarn('Failed to clear draft from session:', error);
  }
}

/**
 * Check if draft exists in session storage
 * @returns {boolean} True if draft exists
 */
function hasDraftInSession() {
  try {
    return !!sessionStorage.getItem(DRAFT_SESSION_KEY);
  } catch (error) {
    logWarn('Failed to check draft in session:', error);
    return false;
  }
}

/**
 * Recover draft state from session storage on page load
 * @returns {Promise<boolean>} True if draft was recovered successfully
 */
async function recoverDraftFromSession() {
  try {
    const draftState = getDraftFromSession();
    if (!draftState) {
      logDebug('No draft found in session storage');
      return false;
    }
    
    logDebug('Attempting to recover draft from session:', draftState.questionText);
    
    // Show recovery notification
    showMessage('下書きを読み込んでいます...', 'info');
    
    // Restore basic form state
    if (draftState.sheetName) {
      selectedSheet = draftState.sheetName;
      const sheetSelect = document.getElementById('sheet-select');
      if (sheetSelect) {
        sheetSelect.value = draftState.sheetName;
      }
    }
    
    // Restore spreadsheet ID if available
    if (draftState.spreadsheetId && currentStatus && currentStatus.userInfo) {
      currentStatus.userInfo.spreadsheetId = draftState.spreadsheetId;
    }
    
    // Restore sheet details and AI prediction results
    if (draftState.sheetDetails && currentStatus) {
      if (!currentStatus.sheetDetails) {
        currentStatus.sheetDetails = {};
      }
      
      currentStatus.sheetDetails.allHeaders = draftState.sheetDetails.allHeaders || [];
      currentStatus.sheetDetails.guessedConfig = draftState.sheetDetails.guessedConfig || {};
      currentStatus.sheetDetails.existingConfig = draftState.sheetDetails.existingConfig || {};
    }
    
    // Restore question text
    const questionInput = document.getElementById('question-input');
    if (questionInput && draftState.questionText) {
      questionInput.value = draftState.questionText;
    }
    
    // Restore display mode settings
    const anonymousCheckbox = document.getElementById('anonymous-mode');
    if (anonymousCheckbox) {
      anonymousCheckbox.checked = draftState.displayMode === 'anonymous';
    }
    
    // Update UI to reflect recovered state
    if (draftState.configurationComplete) {
      // Show that AI column prediction is completed
      const currentStep = document.querySelector('[data-step="4"]');
      if (currentStep) {
        updateStepProgress(4, currentStatus);
      }
    }
    
    // Update any config panels if they exist
    if (draftState.config && Object.keys(draftState.config).length > 0) {
      updateConfigPanelUI(draftState.config);
    }
    
    // Show success message
    const ageMinutes = Math.floor((new Date() - new Date(draftState.createdAt)) / (1000 * 60));
    const ageText = ageMinutes < 1 ? '直前' : `${ageMinutes}分前`;
    showMessage(`下書きを読み込みました（${ageText}に作成）`, 'success');
    
    logDebug('Draft recovered successfully from session storage');
    return true;
    
  } catch (error) {
    logError('Failed to recover draft from session:', error);
    showMessage('下書きの読み込みに失敗しました', 'error');
    return false;
  }
}

/**
 * Update config panel UI with recovered settings
 * @param {Object} config - Configuration object
 */
function updateConfigPanelUI(config) {
  try {
    // Update opinion header if available
    if (config.opinionHeader) {
      const opinionSelect = document.getElementById('opinion-header-select');
      if (opinionSelect) {
        opinionSelect.value = config.opinionHeader;
      }
    }
    
    // Update name header if available
    if (config.nameHeader) {
      const nameSelect = document.getElementById('name-header-select');
      if (nameSelect) {
        nameSelect.value = config.nameHeader;
      }
    }
    
    // Update reaction settings if available
    if (config.allowReactions !== undefined) {
      const reactionCheckbox = document.getElementById('allow-reactions');
      if (reactionCheckbox) {
        reactionCheckbox.checked = !!config.allowReactions;
      }
    }
    
    logDebug('Config panel UI updated with recovered settings');
    
  } catch (error) {
    logWarn('Failed to update config panel UI:', error);
  }
}

// 旧来のカード形式の履歴表示は削除 - 簡単なテーブル形式のみ使用

/**
 * 簡単な履歴テーブルを表示（新実装）
 */


/**
 * Enhanced history restoration preview modal
 * @param {Object} item - History item to preview
 */
function showHistoryRestorationPreview(item) {
  try {
    console.log('🔍 Showing history restoration preview:', item);
    
    // Extract preview information
    const question = item.questionText || item.sheetName || 'この履歴';
    const truncated = question.length > 50 ? (question.substring(0, 50) + '...') : question;
    const published = item.publishedAt ? new Date(item.publishedAt).toLocaleString('ja-JP') : '未設定';
    const status = item.isActive ? '公開中' : '終了';
    const statusIcon = item.isActive ? '🌐' : '⏹️';
    
    // Get configuration preview
    const configPreview = getConfigurationPreview(item);
    const headerPreview = getHeaderPreview(item);
    
    // Build detailed message
    const detailsHtml = `
      <div class="space-y-4">
        <div class="bg-gray-800/50 rounded-lg p-3">
          <h4 class="text-sm font-semibold text-cyan-400 mb-2">📋 復元される設定内容</h4>
          <div class="text-xs text-gray-300 space-y-1">
            <div><span class="text-gray-400">質問:</span> ${truncated}</div>
            <div><span class="text-gray-400">公開日時:</span> ${published}</div>
            <div><span class="text-gray-400">状態:</span> ${statusIcon} ${status}</div>
          </div>
        </div>
        
        ${configPreview ? `
        <div class="bg-blue-900/20 rounded-lg p-3">
          <h4 class="text-sm font-semibold text-blue-400 mb-2">⚙️ 列設定</h4>
          <div class="text-xs text-gray-300">${configPreview}</div>
        </div>
        ` : ''}
        
        ${headerPreview ? `
        <div class="bg-green-900/20 rounded-lg p-3">
          <h4 class="text-sm font-semibold text-green-400 mb-2">📊 利用可能ヘッダー</h4>
          <div class="text-xs text-gray-300">${headerPreview}</div>
        </div>
        ` : ''}
        
        <div class="bg-yellow-900/20 border border-yellow-600/30 rounded-lg p-3">
          <p class="text-xs text-yellow-200">
            ⚠️ この操作により、現在の未保存の設定は上書きされます。
          </p>
        </div>
      </div>
    `;
    
    // Show enhanced confirmation modal
    if (typeof window.showConfirmationModal === 'function') {
      // Create a custom modal for detailed preview
      showDetailedHistoryModal(truncated, detailsHtml, () => {
        console.log('✅ User confirmed history restoration');
        selectHistoryItem(item.id);
      });
    } else {
      // Fallback to basic confirmation
      const basicMessage = `「${truncated}」の設定を復元します。\n\n公開日時: ${published}\n状態: ${status}\n\n現在の未保存の設定は上書きされます。`;
      if (confirm(basicMessage)) {
        selectHistoryItem(item.id);
      }
    }
    
  } catch (error) {
    console.error('❌ History preview failed:', error);
    // Fallback to direct restoration
    selectHistoryItem(item.id);
  }
}

/**
 * Get configuration preview text
 * @param {Object} item - History item
 * @returns {string} Configuration preview HTML
 */
function getConfigurationPreview(item) {
  try {
    const config = item.configSnapshot || item.config || {};
    const settings = [];
    
    if (config.opinionHeader) settings.push(`意見欄: ${config.opinionHeader}`);
    if (config.nameHeader) settings.push(`名前欄: ${config.nameHeader}`);
    if (config.classHeader) settings.push(`クラス欄: ${config.classHeader}`);
    if (config.reasonHeader) settings.push(`理由欄: ${config.reasonHeader}`);
    
    // Display settings
    if (config.showNames !== undefined) settings.push(`名前表示: ${config.showNames ? 'ON' : 'OFF'}`);
    if (config.showCounts !== undefined) settings.push(`カウント表示: ${config.showCounts ? 'ON' : 'OFF'}`);
    
    return settings.length > 0 ? settings.join('<br>') : '設定情報なし';
  } catch (error) {
    console.warn('Config preview failed:', error);
    return '設定プレビューエラー';
  }
}

/**
 * Get header preview text
 * @param {Object} item - History item
 * @returns {string} Header preview HTML
 */
function getHeaderPreview(item) {
  try {
    const headers = item.headerSnapshot?.allHeaders || item.sheetDetails?.allHeaders || [];
    if (headers.length === 0) return null;
    
    const displayHeaders = headers.slice(0, 5).join(', ');
    const remaining = headers.length > 5 ? ` (+${headers.length - 5}個)` : '';
    
    return `${displayHeaders}${remaining}`;
  } catch (error) {
    console.warn('Header preview failed:', error);
    return null;
  }
}

/**
 * Show detailed history restoration modal
 * @param {string} title - Modal title
 * @param {string} contentHtml - HTML content
 * @param {Function} onConfirm - Confirmation callback
 */
function showDetailedHistoryModal(title, contentHtml, onConfirm) {
  // Use existing confirmation modal but with enhanced content
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  if (modal && titleElement && messageElement && confirmBtn && cancelBtn) {
    titleElement.textContent = '履歴設定の復元';
    messageElement.innerHTML = contentHtml;
    confirmBtn.textContent = '復元する';
    
    // Set up event handlers
    const handleConfirm = () => {
      modal.classList.add('hidden');
      onConfirm();
      cleanup();
    };
    
    const handleCancel = () => {
      modal.classList.add('hidden');
      cleanup();
    };
    
    const cleanup = () => {
      confirmBtn.removeEventListener('click', handleConfirm);
      cancelBtn.removeEventListener('click', handleCancel);
    };
    
    confirmBtn.addEventListener('click', handleConfirm);
    cancelBtn.addEventListener('click', handleCancel);
    
    // Show modal
    modal.classList.remove('hidden');
  } else {
    console.warn('⚠️ Modal elements not found, using fallback');
    if (confirm(`履歴設定「${title}」を復元しますか？`)) {
      onConfirm();
    }
  }
}

/**
 * シンプル履歴アイテム正規化 - 新しい簡素な形式に統一
 * @param {Object} rawItem - 生の履歴アイテム
 * @returns {Object} 正規化された履歴アイテム
 */
function normalizeHistoryItem(rawItem) {
  try {
    console.log('🔄 Normalizing history item to simple format:', rawItem);
    
    // シンプルな新形式構造に変換
    const normalizedItem = {
      id: rawItem.id,
      createdDate: rawItem.createdDate || null, // 後で追加予定
      publishedAt: rawItem.publishedAt || rawItem.timestamp,
      questionText: rawItem.questionText || 
                   rawItem.config?.opinionHeader ||
                   rawItem.configSnapshot?.opinionHeader ||
                   'デフォルト質問',
      setupType: rawItem.setupType || 'unknown',
      
      // 最小限の復元データ
      opinionHeader: rawItem.config?.opinionHeader || 
                    rawItem.configSnapshot?.opinionHeader || 
                    rawItem.questionText || '',
      nameHeader: rawItem.config?.nameHeader || 
                 rawItem.configSnapshot?.nameHeader || 
                 '名前',
      displayMode: normalizeDisplayMode(rawItem.displayMode || 
                                      rawItem.config?.displayMode ||
                                      rawItem.configSnapshot?.displayMode),
      
      // 復元用データ
      sheetName: rawItem.sheetName || '',
      spreadsheetId: rawItem.spreadsheetId || ''
    };
    
    console.log('✅ Item normalized to simple format:', normalizedItem);
    return normalizedItem;
    
  } catch (error) {
    console.error('❌ Simple history normalization failed:', error);
    // フォールバック: 最小限の構造を返す
    return {
      id: rawItem.id || generateHistoryId(),
      createdDate: null,
      publishedAt: rawItem.publishedAt || rawItem.timestamp || new Date().toISOString(),
      questionText: rawItem.questionText || '不明',
      setupType: rawItem.setupType || 'unknown',
      opinionHeader: '',
      nameHeader: '名前',
      displayMode: 'named',
      sheetName: rawItem.sheetName || '',
      spreadsheetId: rawItem.spreadsheetId || ''
    };
  }
}

/**
 * シンプル履歴バリデーション
 * @param {Object} item - 正規化済み履歴アイテム
 * @returns {boolean} 有効かどうか
 */
function validateSimpleHistoryItem(item) {
  return item && item.id && item.publishedAt;
}

/**
 * シンプル履歴選択処理
 * @param {string} historyId - 履歴ID
 */
async function selectHistoryItem(historyId) {
  try {
    // 履歴を検索
    const mergedHistory = await getMergedHistory();
    const rawItem = mergedHistory.find(h => h.id === historyId);
    
    if (!rawItem) {
      showMessage('履歴アイテムが見つかりませんでした', 'error');
      return;
    }
    
    // シンプル正規化
    const item = normalizeHistoryItem(rawItem);
    console.log('📝 Simple normalized history item:', item);
    
    // 基本バリデーション
    if (!validateSimpleHistoryItem(item)) {
      showMessage('履歴データが不正です', 'error');
      return;
    }
    
    // シンプルな復元確認モーダル表示
    showHistoryRestorationPreview(
      '履歴復元の確認',
      item,
      // 確認後の復元実行
      async () => {
        console.log('✅ User confirmed simple history restoration');
        if (window.AdminPanel?.historyManager?.restoreFromSimpleHistory) {
          await window.AdminPanel.historyManager.restoreFromSimpleHistory(item);
        } else {
          console.error('❌ History manager not available for restoration');
          showMessage('履歴復元機能が利用できません', 'error');
        }
      },
      // キャンセル時の処理
      () => {
        console.log('❌ History restoration cancelled');
      }
    );
    
  } catch (error) {
    console.error('❌ Simple history selection failed:', error);
    showMessage('履歴選択に失敗しました', 'error');
  }
}

/**
 * シンプル履歴からの復元実行
 * @param {Object} item - 正規化済み履歴アイテム
 */

/**
 * HTMLエスケープ関数
 * @param {string} text - エスケープするテキスト
 * @returns {string} エスケープされたテキスト
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// 旧来の複雑な履歴管理関数群は削除 - selectHistoryItem()による自動フローのみ使用

// =============================================================================
// CONFIG JSON 正規化・修復システム
// =============================================================================

/**
 * configJsonの整合性を確保し、矛盾した状態を修復する
 * @param {Object} config - 修復対象のconfig
 * @param {Object} userInfo - ユーザー情報
 * @return {Object} 正規化されたconfig
 */
function normalizeConfigJson(config, userInfo) {
  if (!config || typeof config !== 'object') {
    console.warn('⚠️ normalizeConfigJson: 無効なconfigオブジェクト');
    return config;
  }
  
  // キャッシュチェック（同じデータの重複処理を防止）
  if (window.processCache && window.generateSimpleHash && window.isCacheValid) {
    const configHash = window.generateSimpleHash(config);
    const cacheEntry = window.processCache.configNormalization;
    
    if (window.isCacheValid(cacheEntry) && cacheEntry.dataHash === configHash) {
      console.log('🚀 configJson正規化: キャッシュから結果を取得');
      return cacheEntry.data;
    }
  }
  
  // 本番環境では詳細ログを削減
  if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('🔧 configJson正規化開始:', {
      setupStatus: config.setupStatus,
      setupStep: config.setupStep,
      appPublished: config.appPublished,
      publishedSheetName: config.publishedSheetName
    });
  }
  
  // Step 1: publishedSheetName修復
  config = fixPublishedSheetName(config);
  
  // Step 2: setupStep再計算（統一関数使用）
  // Note: setupStepは計算プロパティとして常に動的に算出され、configJsonには保存されません
  
  // Step 3: グローバル列設定同期
  config = syncGlobalColumnSettings(config);
  
  // Step 4: 必須フィールドの補完
  config = ensureRequiredFields(config);
  
  // Step 5: 冗長フィールドの削除
  config = removeRedundantFields(config);
  
  // 本番環境では詳細ログを削減
  if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
    console.log('✅ configJson正規化完了:', {
      setupStatus: config.setupStatus,
      appPublished: config.appPublished,
      publishedSheetName: config.publishedSheetName
    });
  }
  
  // キャッシュ更新
  if (window.processCache && window.generateSimpleHash) {
    const configHash = window.generateSimpleHash(config);
    const cacheEntry = window.processCache.configNormalization;
    cacheEntry.data = config;
    cacheEntry.dataHash = configHash;
    cacheEntry.timestamp = Date.now();
  }
  
  return config;
}

/**
 * 冗長フィールドの削除（データ整合性向上）
 * @param {Object} config - 対象config
 * @return {Object} クリーンアップされたconfig
 */
function removeRedundantFields(config) {
  const cleanConfig = Object.assign({}, config);
  
  // setupStepは計算プロパティのため、保存済みの値を削除
  delete cleanConfig.setupStep;
  
  console.log('🧹 冗長フィールド削除: setupStep');
  
  return cleanConfig;
}

/**
 * ConfigJsonの整合性検証機能（フロントエンド専用）
 * @param {Object} config - 検証対象のconfig
 * @param {Object} userInfo - ユーザー情報
 */
function validateConfigJsonIntegrity(config, userInfo) {
  if (!config || !userInfo) {
    console.warn('⚠️ 整合性検証: 無効なパラメータ');
    return;
  }
  
  const setupStatus = config.setupStatus || 'pending';
  const formCreated = !!config.formCreated;
  const appPublished = !!config.appPublished;
  const hasFormUrl = !!(config.formUrl && config.formUrl.trim());
  const hasPublishedSheet = !!(config.publishedSheetName && config.publishedSheetName.trim());
  const hasSpreadsheet = !!(userInfo.spreadsheetId && userInfo.spreadsheetId.trim());
  
  console.group('🔍 ConfigJson整合性検証');
  
  // 基本状態の表示
  console.log('📊 現在の状態:', {
    setupStatus,
    formCreated,
    appPublished,
    hasFormUrl,
    hasPublishedSheet,
    hasSpreadsheet
  });
  
  // 重要な不整合を検出
  const issues = [];
  
  if (setupStatus === 'completed' && !formCreated) {
    issues.push('❌ setupStatus=completedなのにformCreated=false');
  }
  
  if (formCreated && !hasFormUrl) {
    issues.push('❌ formCreated=trueなのにformUrlが未設定');
  }
  
  if (appPublished && !hasPublishedSheet) {
    issues.push('❌ appPublished=trueなのにpublishedSheetNameが未設定');
  }
  
  if (!hasSpreadsheet && (setupStatus === 'completed' || formCreated || appPublished)) {
    issues.push('❌ データソース未設定なのに高度な設定が有効');
  }
  
  // setupStepが保存されている場合の警告
  if (config.setupStep !== undefined) {
    issues.push('⚠️ setupStepがconfigJsonに保存されています（冗長）');
  }
  
  // 結果表示
  if (issues.length === 0) {
    console.log('✅ 整合性検証完了: 問題なし');
  } else {
    console.warn('⚠️ 整合性問題検出:', issues);
  }
  
  console.groupEnd();
}

/**
 * publishedSheetName修復関数
 * @param {Object} config - 修復対象のconfig
 * @return {Object} 修復されたconfig
 */
function fixPublishedSheetName(config) {
  // publishedSheetNameが'フォームの回答 1'のようなデフォルト名の場合も修復対象
  const isDefaultSheetName = config.publishedSheetName === 'フォームの回答 1' || 
                            config.publishedSheetName && config.publishedSheetName.startsWith('フォームの回答');
                            
  if ((!config.publishedSheetName || 
       config.publishedSheetName.trim() === '' || 
       isDefaultSheetName) && 
      config.publishedSpreadsheetId) {
    
    // AI列判定結果から質問文を取得を試行
    if (currentStatus && currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig && currentStatus.sheetDetails.guessedConfig.opinionHeader) {
      const questionText = currentStatus.sheetDetails.guessedConfig.opinionHeader;
      config.publishedSheetName = questionText;
      
      if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
        console.log('🔧 publishedSheetName修復 (AI列判定結果使用):', {
          元の名前: config.publishedSheetName,
          新しい名前: questionText
        });
      }
      return config;
    }
    
    // AI列判定結果が無い場合は従来のsheet_キー検索
    const sheetKeys = Object.keys(config).filter(key => key.startsWith('sheet_'));
    
    if (sheetKeys.length > 0) {
      // 最初に見つかったシート名を使用
      const detectedSheetName = sheetKeys[0].replace('sheet_', '');
      config.publishedSheetName = detectedSheetName;
      
      if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) {
        console.log('🔧 publishedSheetName修復 (シートキー使用):', {
          検出されたシート名: detectedSheetName,
          利用可能なシート設定: sheetKeys
        });
      }
    }
  }
  
  return config;
}





/**
 * グローバル列設定を最新のシート設定と同期
 * @param {Object} config - 同期対象のconfig
 * @return {Object} 同期されたconfig
 */
function syncGlobalColumnSettings(config) {
  if (!config.publishedSheetName) {
    return config; // シート名が不明な場合はスキップ
  }
  
  const sheetConfigKey = 'sheet_' + String(config.publishedSheetName || '');
  const sheetConfig = config[sheetConfigKey];
  
  if (sheetConfig && typeof sheetConfig === 'object') {
    // シート固有設定をグローバル設定に同期
    config.opinionHeader = sheetConfig.opinionHeader || config.opinionHeader || '';
    config.nameHeader = sheetConfig.nameHeader || config.nameHeader || '';
    config.reasonHeader = sheetConfig.reasonHeader || config.reasonHeader || '';
    config.classHeader = sheetConfig.classHeader || config.classHeader || '';
    config.timestampHeader = sheetConfig.timestampHeader || config.timestampHeader || '';
    
    // フォームURL同期 - シート固有のformUrlをグローバル設定に同期
    if (sheetConfig.formUrl) {
      config.formUrl = sheetConfig.formUrl;
      console.log('🔗 フォームURL同期:', {
        sheetName: config.publishedSheetName,
        formUrl: config.formUrl
      });
    }
    
    console.log('🔧 グローバル列設定同期完了:', {
      sheetName: config.publishedSheetName,
      mainQuestion: config.opinionHeader,
      nameColumn: config.nameHeader
    });
  }
  
  return config;
}

/**
 * 必須フィールドの補完
 * @param {Object} config - 補完対象のconfig
 * @return {Object} 補完されたconfig
 */
function ensureRequiredFields(config) {
  console.log('🔧 ensureRequiredFields called with:', typeof config);
  
  // Ensure config is a valid object
  if (!config || typeof config !== 'object') {
    config = {};
  }
  
  // 個別設定（最も安全な方法）
  if (config.showNames === undefined) config.showNames = false;
  if (config.showCounts === undefined) config.showCounts = false;
  if (config.highlightMode === undefined) config.highlightMode = false;
  if (config.displayMode === undefined) config.displayMode = 'named';
  if (config.countDisplay === undefined) config.countDisplay = 'show';
  if (config.autoStopEnabled === undefined) config.autoStopEnabled = true;
  if (config.autoStopMinutes === undefined) config.autoStopMinutes = 360;
  
  console.log('✅ ensureRequiredFields completed');
  return config;
}


/**
 * 公開済み状態用configJson修復関数
 * @param {Object} config - 修復対象のconfig
 * @return {Object} 修復されたconfig
 */
function fixConfigForPublishedState(config) {
  const fixedConfig = Object.assign({}, config);
  
  // 公開済み状態の必須フィールドを修復
  if (fixedConfig.setupStatus !== 'completed') {
    console.log('🔧 setupStatus fixed from pending to completed');
    fixedConfig.setupStatus = 'completed';
  }
  
  if (!fixedConfig.formCreated) {
    console.log('🔧 formCreated status fixed from false to true');
    fixedConfig.formCreated = true;
  }
  
  if (!fixedConfig.appPublished) {
    console.log('🔧 appPublished status fixed from false to true');
    fixedConfig.appPublished = true;
  }
  
  // Form URL temporary setting (if actual form URL is unknown)
  if (!fixedConfig.formUrl || fixedConfig.formUrl.trim() === '') {
    console.log('🔧 formUrl temporary setting for published state maintenance');
    fixedConfig.formUrl = 'https://docs.google.com/temp-form-url'; // Temporary license URL
  }
  
  return fixedConfig;
}


// 簡単な履歴テーブル初期化は initializeAdminPanel で実行されるように変更
// DOMContentLoaded は削除 - framework.js.htmlで統一管理

// Draft recovery utility function
function recoverDraftIfAvailable() {
  // Check for and recover draft from session storage
  if (typeof hasDraftInSession === 'function' && hasDraftInSession()) {
    if (typeof recoverDraftFromSession === 'function') {
      recoverDraftFromSession().catch(error => {
        console.warn('⚠️ Draft recovery failed:', error);
      });
    }
  }
}

// 日時フォーマット関数
function formatDateTime(date) {
  try {
    const options = {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Asia/Tokyo'
    };
    // Google Apps Script compatible date formatting
    return date.toLocaleDateString('ja-JP', options).replace(/\//g, '-');
  } catch (error) {
    console.warn('⚠️ Date formatting failed:', error);
    return date.toISOString().split('T')[0] + ' ' + date.toISOString().split('T')[1].substring(0, 5);
  }
}

// リソースボタンを更新する関数 (フォルダ機能は削除済み)
function updateNewResourceButtons(resourceUrls) {
  // ドライブフォルダ機能は削除されました
  console.log('📊 Resource URLs updated:', resourceUrls);
}

// 初期化は adminPanel-core.js の統合初期化システムで管理されます

// Explicitly register full implementations when this file loads
if (window.AdminPanel && window.AdminPanel.functionRegistry) {
  console.log('🔧 Registering full implementations from adminPanel-ui.js.html');
  const fullImplFunctions = [
    'updateUIWithNewStatus', 'populateHeaderOptions', 'populateConfig', 
    'updateFormUrlDisplay', 'validateConfig', 'updateConfigButtons'
  ];
  
  fullImplFunctions.forEach(funcName => {
    window.AdminPanel.functionRegistry.registerFullImplementation(funcName);
  });
  
  // Immediately check for full implementations after registration
  setTimeout(() => {
    const foundCount = window.AdminPanel.functionRegistry.checkForFullImplementations();
    console.log(`✅ Full implementation registration complete: ${foundCount}/6 functions available`);
  }, 50);
} else {
  console.warn('⚠️ AdminPanel.functionRegistry not available for full implementation registration');
}

//# sourceURL=adminPanel-ui.js.html


// =============================================================================
// ADMIN PANEL EVENT LISTENERS & UI INTERACTIONS
// =============================================================================

// DOM Elements Cache
let elements = {};

// Event handler state tracking to prevent duplicate attachments
const eventHandlersAttached = {
  setupEventListeners: false,
  formConfigModal: false,
  resourceHandlers: false,
  accountManagement: false,
  externalLinks: false,
  modalHandlers: false,
  realtimeValidation: false
};

// 履歴管理用定数 - adminPanel-ui.js.htmlで定義済みのため、ここでは参照のみ
// const HISTORY_STORAGE_KEY = 'answerBoardHistory'; // 重複宣言を回避

// =============================================================================
// MAIN EVENT LISTENERS SETUP
// =============================================================================

function setupEventListeners() {
  // Prevent duplicate event handler attachment
  if (eventHandlersAttached.setupEventListeners) {
    logWarn('AdminPanel: Event handlers already attached, skipping duplicate setup');
    return;
  }
  
  eventHandlersAttached.setupEventListeners = true;
  
  // Cache frequently used elements (with safety check)
  if (typeof getCachedElement === 'function') {
    elements = {
      'sheet-select': getCachedElement('sheet-select'),
      'save-publish-btn': getCachedElement('save-publish-btn'),
      'unpublish-board-btn': getCachedElement('unpublish-board-btn'),
      'delete-account-btn': getCachedElement('delete-account-btn'),
      'open-spreadsheet-btn': getCachedElement('open-spreadsheet-btn'),
      'open-form-btn': getCachedElement('open-form-btn'),
      'clear-history-btn': getCachedElement('clear-history-btn')
    };
  } else {
    console.warn('getCachedElement not available, using fallback');
    elements = {
      'sheet-select': document.getElementById('sheet-select'),
      'save-publish-btn': document.getElementById('save-publish-btn'),
      'unpublish-board-btn': document.getElementById('unpublish-board-btn'),
      'delete-account-btn': document.getElementById('delete-account-btn'),
      'open-spreadsheet-btn': document.getElementById('open-spreadsheet-btn'),
      'open-form-btn': document.getElementById('open-form-btn'),
      'clear-history-btn': document.getElementById('clear-history-btn')
    };
  }
  
  
  // AI column detection button
  const reguessBtn = document.getElementById('reguess-headers-btn');
  if (reguessBtn) {
    reguessBtn.addEventListener('click', runHeaderGuessing);
  }
  
  // Save and publish button
  if (elements['save-publish-btn']) {
    elements['save-publish-btn'].addEventListener('click', () => {
      if (!selectedSheet) {
        showMessage('まずシートを選択してください。', 'warning');
        return;
      }
      saveAndPublish();
    });
  }
  
  // Unpublish button
  if (elements['unpublish-board-btn']) {
    elements['unpublish-board-btn'].addEventListener('click', () => {
      showStopConfirmationModal(
        '公開停止の確認',
        '回答ボードの公開を停止しますか？',
        () => {
          unpublishBoard()
            .then((unpublishResult) => {
              logInfo('公開停止完了:', unpublishResult);
              
              // unpublishBoard()内で既にキャッシュクリア処理が実行されているため、
              // ここでは重複処理を避けて、状態同期に集中
              logInfo('公開停止後の状態同期を開始（キャッシュクリア済み）');
              
              // 改善された非同期処理完了待機
              return new Promise(async (resolve) => {
                try {
                  // Step 1: DOM状態の安定化待機（短縮）
                  await new Promise(r => setTimeout(r, 300));
                  
                  // Step 2: 状態再読み込み（強制リフレッシュ）
                  await loadStatus(true);
                  logInfo('公開停止後の状態更新完了');
                  
                  // Step 3: 最終的なUI状態確認
                  await new Promise(r => setTimeout(r, 100));
                  
                  resolve(unpublishResult);
                } catch (error) {
                  logWarn('状態同期エラー:', error);
                  resolve(unpublishResult); // エラーでも続行
                }
              });
            })
            .then(function() {
              logInfo('公開停止後の完全リセットUI更新開始');
              
              // ステップ1に戻すためのUI更新
              if (typeof updateStepIndicators === 'function') {
                console.log('🎯 updateStepIndicators実行中: ステップ1に完全リセット');
                updateStepIndicators(1, null);
              } else {
                console.warn('⚠️ updateStepIndicators関数が見つかりません');
              }
              
              if (typeof updateGuidanceForStep === 'function') {
                const guidanceText = document.getElementById('guidance-text');
                if (guidanceText) {
                  console.log('🎯 updateGuidanceForStep実行中: ステップ1ガイダンス');
                  updateGuidanceForStep(1, guidanceText);
                } else {
                  console.warn('⚠️ guidance-text要素が見つかりません');
                }
              } else {
                console.warn('⚠️ updateGuidanceForStep関数が見つかりません');
              }
              
              // フォーム関連要素の初期化
              try {
                console.log('🧹 フォーム関連UI要素を初期状態にリセット');
                
                // シート選択ドロップダウンをクリア
                const sheetSelect = document.getElementById('sheet-select');
                if (sheetSelect) {
                  sheetSelect.innerHTML = '<option value="">シートを選択してください</option>';
                  sheetSelect.selectedIndex = 0;
                  console.log('✅ シート選択ドロップダウンをリセット');
                }
                
                // 列設定フォームをクリア
                const columnSelects = ['opinion-column', 'name-column', 'reason-column', 'class-column'];
                columnSelects.forEach(selectId => {
                  const selectElement = document.getElementById(selectId);
                  if (selectElement) {
                    selectElement.innerHTML = '<option value="">選択してください</option>';
                    selectElement.selectedIndex = 0;
                  }
                });
                console.log('✅ 列設定フォームをリセット');
                
                // チェックボックスの初期化
                const checkboxes = ['show-names', 'show-counts'];
                checkboxes.forEach(checkboxId => {
                  const checkbox = document.getElementById(checkboxId);
                  if (checkbox) {
                    checkbox.checked = false;
                  }
                });
                console.log('✅ 表示設定チェックボックスをリセット');
                
              } catch (resetError) {
                console.warn('⚠️ UI要素リセット中にエラー:', resetError);
              }
              
              console.log('✅ 公開停止後の完全リセットUI更新完了');
              showMessage('回答ボードは非公開になり、設定は初期状態にリセットされました。', 'success');
            })
            .catch(function(error) {
              console.error('❌ 公開停止に失敗しました:', error);
              let errorMessage = '❌ 公開停止に失敗しました。再度お試しください。';
              
              // エラーの種類に応じてより具体的なメッセージを表示
              if (error.message && error.message.includes('customFormInfo')) {
                errorMessage = '❌ カスタムフォーム設定の更新に失敗しました。ページを再読み込みしてから再度お試しください。';
              } else if (error.message && error.message.includes('許可されていない')) {
                errorMessage = '❌ データ更新権限エラーが発生しました。管理者にお問い合わせください。';
              } else if (error.message && error.message.includes('ネットワーク')) {
                errorMessage = '❌ ネットワークエラーが発生しました。インターネット接続を確認してください。';
              }
              
              showMessage(errorMessage, 'error');
            });
        }
      );
    });
  }
  
  // Clear history button - 直接取得で確実に処理
  const clearHistoryBtn = document.getElementById('clear-history-btn');
  if (clearHistoryBtn) {
    clearHistoryBtn.addEventListener('click', () => {
      console.log('🗑️ 履歴クリアボタンがクリックされました');
      
        if (typeof showConfirmationModal === 'function') {
          showHistoryClearConfirmationModal(
            '履歴削除の確認',
            'すべての履歴を削除しますか？この操作は取り消せません。',
            async function() {
              
              try {
                // ローディング表示
                showMessage('🔄 履歴をクリアしています...', 'info');
                
                // シンプル履歴システムを使用
                if (typeof clearSimpleHistory === 'function') {
                  clearSimpleHistory();
                  showMessage('✅ 履歴をクリアしました', 'success');
                } else {
                  // フォールバック: 直接localStorage操作
                  localStorage.removeItem(HISTORY_STORAGE_KEY || 'answerBoardHistory');
                  if (typeof updateHistoryTable === 'function') {
                    updateHistoryTable();
                  }
                  showMessage('✅ 履歴をクリアしました', 'success');
                }
                
              } catch (error) {
                console.error('❌ 履歴クリアに失敗:', error);
                showMessage('❌ 履歴クリア中にエラーが発生しました: ' + error.message, 'error');
              }
            }
          );
        } else {
          console.error('❌ showConfirmationModal関数が見つかりません');
          // フォールバック: 直接確認
          if (confirm('すべての履歴を削除しますか？この操作は取り消せません。')) {
            (async () => {
              try {
                // ローディング表示
                showMessage('🔄 履歴をクリアしています...', 'info');
                
                // シンプル履歴システムを使用（フォールバック）
                if (typeof clearSimpleHistory === 'function') {
                  clearSimpleHistory();
                  showMessage('✅ 履歴をクリアしました', 'success');
                } else {
                  // フォールバック: 直接localStorage操作
                  localStorage.removeItem(HISTORY_STORAGE_KEY || 'answerBoardHistory');
                  if (typeof updateHistoryTable === 'function') {
                    updateHistoryTable();
                  }
                  showMessage('✅ 履歴をクリアしました', 'success');
                }
                
              } catch (error) {
                console.error('❌ 履歴クリアに失敗:', error);
                showMessage('❌ 履歴クリア中にエラーが発生しました: ' + error.message, 'error');
              }
            })();
          }
        }
    });
  } else {
    console.error('❌ clear-history-btnが見つかりません');
  }
  
  // クイックスタートボタンのイベントリスナー
  const quickstartBtn = document.getElementById('quickstart-btn');
  if (quickstartBtn) {
    quickstartBtn.addEventListener('click', function() {
      if (typeof handleQuickStart === 'function') {
        handleQuickStart();
      } else {
        console.error('handleQuickStart function not found');
        showMessage('クイックスタート機能を読み込み中です。少し待ってから再度お試しください。', 'warning');
      }
    });
  }

  // Create board button
  const createBoardBtn = document.getElementById('create-board-btn');
  if (createBoardBtn) {
    createBoardBtn.addEventListener('click', function() {
      // 公開状態をチェックしてカスタムセットアップ選択モーダルを表示
      if (currentStatus && currentStatus._normalized && currentStatus._normalized.isPublished) {
        // 公開中の場合、選択モーダルを表示
        window.sharedModals.showCustomSetupSelection(
          (selectedOption) => {
            if (selectedOption === 'stop') {
              // 停止して作成を選択
              proceedWithCustomFormCreation(true);
            } else if (selectedOption === 'continue') {
              // 継続しながら作成を選択
              proceedWithCustomFormCreation(false);
            }
          },
          () => {
            console.log('❌ カスタムセットアップがキャンセルされました');
          }
        );
      } else {
        // 公開していない場合、直接フォーム作成モーダルを表示
        proceedWithCustomFormCreation(false);
      }
    });
  }

  // カスタムフォーム作成を進行
  function proceedWithCustomFormCreation(shouldStop) {
    if (shouldStop) {
      
      // 実際に公開停止処理を実行
      if (typeof unpublishBoard === 'function') {
        console.log('🛑 公開停止処理を開始します...');
        
        // 公開停止の確認ダイアログを表示
        showStopConfirmationModal(
          '公開停止の確認',
          '現在公開中のボードを停止してから、カスタムフォームを作成します。よろしいですか？',
          function() {
            // 確認後、実際に停止処理を実行
            executeStopAndCreateForm();
          },
          function() {
            console.log('❌ 公開停止がキャンセルされました');
          }
        );
      } else {
        console.error('unpublishBoard function not found');
        showMessage('公開停止機能を読み込み中です。少し待ってから再度お試しください。', 'warning');
      }
    } else {
      
      // カスタムセットアップ時は全セクション展開フラグを設定
      try {
        localStorage.setItem('expandAllSections', 'true');
      } catch (e) {
        console.warn('⚠️ localStorage設定に失敗:', e);
      }
      
      // 継続の場合は直接フォーム作成モーダルを表示
      showFormConfigModalSafely();
    }
  }

  // 公開停止→フォーム作成の実行
  function executeStopAndCreateForm() {

    // unpublishBoard関数を呼び出し
    unpublishBoard()
      .then(function(response) {
        // Use debounced loadStatus to prevent rapid successive calls
        if (window.AdminPanel && window.AdminPanel.debounce) {
          window.AdminPanel.debounce.loadStatus(() => loadStatus(true), 300);
          return Promise.resolve(response);
        } else {
          return loadStatus(true).then(() => response);
        }
      })
      .then(function(response) {
        // 公開停止が確実に完了した旨を表示
        showMessage('✅ 公開停止が完了しました。カスタムフォームを作成できます。', 'success');

        // 全セクション展開フラグを設定（公開停止後の管理パネル表示改善）
        try {
          localStorage.setItem('expandAllSections', 'true');
          console.log('📂 公開停止後の全セクション展開フラグを設定しました');
        } catch (e) {
          console.warn('⚠️ localStorage設定に失敗:', e);
        }

        // 少し遅延してからフォーム作成モーダルを表示
        setTimeout(function() {
          console.log('🎨 フォーム作成モーダルを表示します');
          showFormConfigModalSafely();
        }, 1500); // 1.5秒後に表示（UIフィードバック時間を確保）
      })
      .catch(function(error) {
        console.error('❌ 公開停止に失敗しました:', error);
        let errorMessage = '❌ 公開停止に失敗しました。再度お試しください。';
        
        // エラーの種類に応じてより具体的なメッセージを表示
        if (error.message && error.message.includes('customFormInfo')) {
          errorMessage = '❌ カスタムフォーム設定の更新に失敗しました。ページを再読み込みしてから再度お試しください。';
        } else if (error.message && error.message.includes('許可されていない')) {
          errorMessage = '❌ データ更新権限エラーが発生しました。管理者にお問い合わせください。';
        } else if (error.message && error.message.includes('ネットワーク')) {
          errorMessage = '❌ ネットワークエラーが発生しました。インターネット接続を確認してください。';
        }
        
        showMessage(errorMessage, 'error');
      });
  }

  // 安全なフォーム作成モーダル表示
  function showFormConfigModalSafely() {
    if (typeof showFormConfigModal === 'function') {
      showFormConfigModal();
    } else {
      console.error('showFormConfigModal function not found');
      showMessage('フォーム作成機能を読み込み中です。少し待ってから再度お試しください。', 'warning');
    }
  }

  // Create additional form button
  const createAdditionalFormBtn = document.getElementById('create-additional-form-btn');
  if (createAdditionalFormBtn) {
    createAdditionalFormBtn.addEventListener('click', function() {
      if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
        showMessage('スプレッドシートの情報が見つかりません。', 'error');
        return;
      }
      showFormConfigModal();
    });
  }
  
  // Form configuration modal handlers
  setupFormConfigModalHandlers();
  
  // Resource management
  setupResourceHandlers();
  
  // Account management
  setupAccountManagementHandlers();
  
  // External links
  setupExternalLinkHandlers();
  
  // Modal handlers
  setupModalHandlers();
  
  // Real-time validation
  setupRealtimeValidation();
  
}

// =============================================================================
// FORM CONFIGURATION MODAL HANDLERS
// =============================================================================

function setupFormConfigModalHandlers() {
  if (eventHandlersAttached.formConfigModal) {
    logDebug('Form config modal handlers already attached');
    return;
  }
  eventHandlersAttached.formConfigModal = true;
  
  const formConfigClose = document.getElementById('form-config-close');
  const formConfigCancel = document.getElementById('form-config-cancel');
  const formConfigCreate = document.getElementById('form-config-create');
  
  if (formConfigClose) {
    formConfigClose.addEventListener('click', function() {
      if (typeof hideFormConfigModal === 'function') {
        hideFormConfigModal();
      } else {
        console.warn('hideFormConfigModal not available');
      }
    });
  }
  
  if (formConfigCancel) {
    formConfigCancel.addEventListener('click', function() {
      if (typeof hideFormConfigModal === 'function') {
        hideFormConfigModal();
      } else {
        console.warn('hideFormConfigModal not available');
      }
    });
  }
  
  if (formConfigCreate) {
    formConfigCreate.addEventListener('click', createFormWithConfig);
  }
}

// =============================================================================
// RESOURCE MANAGEMENT HANDLERS
// =============================================================================

function setupResourceHandlers() {
  if (eventHandlersAttached.resourceHandlers) {
    logDebug('Resource handlers already attached');
    return;
  }
  eventHandlersAttached.resourceHandlers = true;
  
  const addResourceBtn = document.getElementById('add-resource-btn');
  const resourceUrlInput = document.getElementById('resource-url-input');
  const initializeSettingsBtn = document.getElementById('initialize-settings-btn');
  
  if (addResourceBtn) {
    addResourceBtn.addEventListener('click', addResource);
  }
  
  if (resourceUrlInput) {
    resourceUrlInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        addResource();
      }
    });
  }
  
  if (initializeSettingsBtn) {
    initializeSettingsBtn.addEventListener('click', initializeUserSettingsWithUI);
  }
}

// =============================================================================
// ACCOUNT MANAGEMENT HANDLERS
// =============================================================================

function setupAccountManagementHandlers() {
  if (eventHandlersAttached.accountManagement) {
    logDebug('Account management handlers already attached');
    return;
  }
  eventHandlersAttached.accountManagement = true;
  
  // Delete account handler - 防御的実装
  const deleteBtn = elements['delete-account-btn'] || getCachedElement('delete-account-btn');
  if (deleteBtn) {
    // 重複登録防止のためフラグで管理
    if (!deleteBtn._deleteListenerAttached) {
      deleteBtn.addEventListener('click', handleDeleteRequest);
      deleteBtn._deleteListenerAttached = true;
      if (window.DEBUG_MODE || window.location.hostname === 'localhost') {
        console.log('Delete account button event listener attached successfully');
      }
    }
  } else {
    console.warn('Delete account button not found');
  }
  
  // Switch account handlers
  const switchAccountBtns = document.querySelectorAll('[onclick*="switchToAnotherAccount"]');
  switchAccountBtns.forEach((btn) => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      switchToAnotherAccount();
    });
  });
}

// =============================================================================
// EXTERNAL LINK HANDLERS
// =============================================================================

function setupExternalLinkHandlers() {
  if (eventHandlersAttached.externalLinks) {
    logDebug('External link handlers already attached');
    return;
  }
  eventHandlersAttached.externalLinks = true;
  
  // Open spreadsheet
  if (elements['open-spreadsheet-btn']) {
    elements['open-spreadsheet-btn'].addEventListener('click', openDatabaseSpreadsheet);
  }
  
  // Open form
  if (elements['open-form-btn']) {
    elements['open-form-btn'].addEventListener('click', openForm);
  }
  
  // Digital citizenship
  const digitalCitizenshipBtn = document.getElementById('digital-citizenship-btn');
  if (digitalCitizenshipBtn) {
    digitalCitizenshipBtn.addEventListener('click', showDigitalCitizenshipModal);
  }
  
  // Copy board URL
  const copyUrlBtn = document.getElementById('copy-url-btn');
  if (copyUrlBtn) {
    copyUrlBtn.addEventListener('click', copyBoardUrl);
  }
  
  // Copy form URL
  const copyFormUrlBtn = document.getElementById('copy-form-url-btn');
  if (copyFormUrlBtn) {
    copyFormUrlBtn.addEventListener('click', copyFormUrl);
  }
}

// =============================================================================
// MODAL HANDLERS
// =============================================================================

function setupModalHandlers() {
  if (eventHandlersAttached.modalHandlers) {
    logDebug('Modal handlers already attached');
    return;
  }
  eventHandlersAttached.modalHandlers = true;
  
  // Privacy modal
  const privacyClose = document.getElementById('privacy-modal-close');
  const privacyCancel = document.getElementById('privacy-modal-cancel');
  
  if (privacyClose) {
    privacyClose.addEventListener('click', hidePrivacyModal);
  }
  
  if (privacyCancel) {
    privacyCancel.addEventListener('click', hidePrivacyModal);
  }
  
  // Digital citizenship modal
  const dcClose = document.getElementById('digital-citizenship-close');
  if (dcClose) {
    dcClose.addEventListener('click', hideDigitalCitizenshipModal);
  }
  
  // Confirmation modal
  const confirmClose = document.getElementById('confirmation-modal-close');
  const confirmCancel = document.getElementById('confirmation-modal-cancel');
  
  if (confirmClose) {
    confirmClose.addEventListener('click', hideConfirmationModal);
  }
  
  if (confirmCancel) {
    confirmCancel.addEventListener('click', hideConfirmationModal);
  }
  
  // Close modals on backdrop click
  setupBackdropClickHandlers();
}

// =============================================================================
// BACKDROP CLICK HANDLERS
// =============================================================================

function setupBackdropClickHandlers() {
  const modals = [
    'form-config-modal',
    'privacy-modal',
    'digital-citizenship-modal',
    'confirmation-modal'
  ];
  
  modals.forEach((modalId) => {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          // Close modal when clicking backdrop
          switch(modalId) {
            case 'form-config-modal':
              if (typeof hideFormConfigModal === 'function') {
                hideFormConfigModal();
              }
              break;
            case 'privacy-modal':
              hidePrivacyModal();
              break;
            case 'digital-citizenship-modal':
              hideDigitalCitizenshipModal();
              break;
            case 'confirmation-modal':
              hideConfirmationModal();
              break;
          }
        }
      });
    }
  });
}

// =============================================================================
// REAL-TIME VALIDATION
// =============================================================================

function setupRealtimeValidation() {
  if (eventHandlersAttached.realtimeValidation) {
    logDebug('Realtime validation handlers already attached');
    return;
  }
  eventHandlersAttached.realtimeValidation = true;
  
  // Opinion column validation
  const opinionSelect = document.getElementById('opinion-column');
  if (opinionSelect) {
    opinionSelect.addEventListener('change', updateConfigButtons);
  }
  
  // Show names checkbox
  const showNamesCheckbox = document.getElementById('show-names');
  if (showNamesCheckbox) {
    showNamesCheckbox.addEventListener('change', updateConfigButtons);
  }
  
  // Show counts checkbox
  const showCountsCheckbox = document.getElementById('show-counts');
  if (showCountsCheckbox) {
    showCountsCheckbox.addEventListener('change', updateConfigButtons);
  }
  
  // Name column validation
  const nameSelect = document.getElementById('name-column');
  if (nameSelect) {
    nameSelect.addEventListener('change', function() {
  const showNamesCheckbox = document.getElementById('show-names');
      if (showNamesCheckbox && this.value) {
        showNamesCheckbox.disabled = false;
      } else if (showNamesCheckbox) {
        showNamesCheckbox.disabled = true;
        showNamesCheckbox.checked = false;
      }
      updateConfigButtons();
    });
  }
}

// =============================================================================
// SPECIFIC EVENT HANDLERS
// =============================================================================

// Handle delete account request
function handleDeleteRequest() {
  window.sharedModals.showConfirmation(
    'アカウント削除の確認',
    '本当にこのアカウントを削除しますか？この操作は元に戻せず、すべてのデータが失われます。',
    function() {
      runGasWithUserId('deleteCurrentUserAccount', 'アカウントを完全に削除しています...')
        .then(function(response) {
          showMessage(response.message || 'アカウントが削除されました。ログイン画面に移動します。', 'success');
          
          // 完全なキャッシュクリア実行
          try {
            if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
              window.unifiedCache.clear();
            }
            if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
              window.gasOptimizer.clearCache();
            }
            if (window.localStorage) {
              // 履歴キーを保護する選択的クリア
              const historyKeys = ['answerBoardHistory', 'adminPanelHistory'];
              const allKeys = Object.keys(localStorage);
              
              allKeys.forEach(key => {
                if (!historyKeys.includes(key)) {
                  try {
                    localStorage.removeItem(key);
                  } catch (e) {
                    console.warn('⚠️ Failed to remove localStorage key:', key);
                  }
                }
              });
              
            }
            if (window.sessionStorage) {
              window.sessionStorage.clear();
            }
          } catch (clearError) {
            console.warn('キャッシュクリアエラー:', clearError);
          }
          
          // 強制的なログイン画面リダイレクト
          setTimeout(function() {
            // サーバーサイドのセッションをクリアしてログイン画面にリダイレクト
            runGasWithUserId('resetUserAuthentication')
              .then(function(loginUrl) {
                console.log('ログイン画面にリダイレクト:', loginUrl);
                window.location.href = loginUrl || window.location.origin + window.location.pathname;
              })
              .catch(function(error) {
                console.warn('リダイレクトエラー:', error);
                // フォールバック: ページを強制リロードしてログイン状態をリセット
                window.location.href = window.location.origin + window.location.pathname;
              });
          }, 1500);
        })
        .catch(function(error) {
          handleError(error, 'deleteAccount', 'アカウントの削除に失敗しました。');
        });
    }
  );
}

/**
 * Show history clear confirmation modal with appropriate button text
 * @param {string} title - Modal title
 * @param {string} message - Modal message
 * @param {Function} onConfirm - Confirmation callback
 */
function showHistoryClearConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  if (modal && titleElement && messageElement && confirmBtn && cancelBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    confirmBtn.textContent = '削除する';
    cancelBtn.textContent = 'キャンセル';
    
    // Set up event handlers
    const handleConfirm = () => {
      modal.classList.add('hidden');
      onConfirm();
      cleanup();
    };
    
    const handleCancel = () => {
      modal.classList.add('hidden');
      cleanup();
    };
    
    const cleanup = () => {
      confirmBtn.removeEventListener('click', handleConfirm);
      cancelBtn.removeEventListener('click', handleCancel);
    };
    
    confirmBtn.addEventListener('click', handleConfirm);
    cancelBtn.addEventListener('click', handleCancel);
    
    // Show modal
    modal.classList.remove('hidden');
  } else {
    console.warn('⚠️ Modal elements not found, using fallback');
    if (confirm(`${title}\n\n${message}`)) {
      onConfirm();
    }
  }
}

/**
 * Show stop/unpublish confirmation modal with appropriate button text
 * @param {string} title - Modal title
 * @param {string} message - Modal message
 * @param {Function} onConfirm - Confirmation callback
 */
function showStopConfirmationModal(title, message, onConfirm) {
  const modal = document.getElementById('confirmation-modal');
  const titleElement = document.getElementById('modal-title');
  const messageElement = document.getElementById('modal-message');
  const confirmBtn = document.getElementById('modal-confirm-btn');
  const cancelBtn = document.getElementById('modal-cancel-btn');
  
  if (modal && titleElement && messageElement && confirmBtn && cancelBtn) {
    titleElement.textContent = title;
    messageElement.textContent = message;
    confirmBtn.textContent = '停止する';
    cancelBtn.textContent = 'キャンセル';
    
    // Set up event handlers
    const handleConfirm = () => {
      modal.classList.add('hidden');
      onConfirm();
      cleanup();
    };
    
    const handleCancel = () => {
      modal.classList.add('hidden');
      cleanup();
    };
    
    const cleanup = () => {
      confirmBtn.removeEventListener('click', handleConfirm);
      cancelBtn.removeEventListener('click', handleCancel);
    };
    
    confirmBtn.addEventListener('click', handleConfirm);
    cancelBtn.addEventListener('click', handleCancel);
    
    // Show modal
    modal.classList.remove('hidden');
  } else {
    console.warn('⚠️ Modal elements not found, using fallback');
    if (confirm(`${title}\n\n${message}`)) {
      onConfirm();
    }
  }
}

// Switch to another account
function switchToAnotherAccount() {
  showConfirmationModal(
    'アカウント切り替え',
    '別のアカウントでログインしますか？現在のセッションがクリアされます。',
    function() {
      sharedUtilities.gas.callWithLoading('resetUserAuthentication', 'セッションをクリアしています...', 'overlay')
        .then(function(result) {
          console.log('Session cleanup result:', result);
          window.location.href = 'https://accounts.google.com/logout';
        })
        .catch(function(error) {
          console.error('Session cleanup failed:', error);
          alert('セッションクリアに失敗しました。手動でGoogleアカウントからログアウトしてください。');
          window.location.href = 'https://accounts.google.com/logout';
        });
    }
  );
}

// updateUIForSelectedSheet function moved to adminPanel-ui.js.html to resolve loading order issues

// =============================================================================
// KEYBOARD SHORTCUTS
// =============================================================================

// Setup keyboard shortcuts
document.addEventListener('keydown', function(e) {
  // Ctrl/Cmd + S for save and publish
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    if (selectedSheet && elements['save-publish-btn'] && !elements['save-publish-btn'].disabled) {
      saveAndPublish();
    }
  }
  
  // Escape to close modals
  if (e.key === 'Escape') {
  const openModals = document.querySelectorAll('.modal:not(.hidden)');
    if (openModals.length > 0) {
  const lastModal = openModals[openModals.length - 1];
  const modalId = lastModal.id;
      
      switch(modalId) {
        case 'form-config-modal':
          if (typeof hideFormConfigModal === 'function') {
            hideFormConfigModal();
          }
          break;
        case 'privacy-modal':
          hidePrivacyModal();
          break;
        case 'digital-citizenship-modal':
          hideDigitalCitizenshipModal();
          break;
        case 'confirmation-modal':
          hideConfirmationModal();
          break;
      }
    }
  }
});


// =============================================================================
// ACCESSIBILITY ENHANCEMENTS
// =============================================================================

// Focus management for modals
function manageFocusForModal(modalId, show) {
  const modal = document.getElementById(modalId);
  if (!modal) return;
  
  if (show) {
    // Store currently focused element
    modal.setAttribute('data-previous-focus', (document.activeElement && document.activeElement.id) || '');
    
    // Focus first interactive element in modal
  const firstFocusable = modal.querySelector('button, input, textarea, select, [tabindex]:not([tabindex="-1"])');
    if (firstFocusable) {
      firstFocusable.focus();
    }
  } else {
    // Restore focus to previous element
  const previousFocusId = modal.getAttribute('data-previous-focus');
    if (previousFocusId) {
  const previousElement = document.getElementById(previousFocusId);
      if (previousElement) {
        previousElement.focus();
      }
    }
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Event listener initialization is now handled in adminPanel-framework.js.html

//# sourceURL=adminPanel-events.js.html


// =============================================================================
// CONSOLIDATED ADMIN PANEL CORE FUNCTIONALITY
// =============================================================================
// This file consolidates adminPanel.js.html and adminPanel-core.js.html
// to reduce redundancy and improve maintainability

// =============================================================================
// UNIFIED MANAGEMENT SYSTEM API - 統一管理システムAPI
// =============================================================================

/**
 * 統一管理システム - 全管理クラスのエントリーポイント
 */
window.unifiedManagement = {
  // キャッシュ管理 (CacheManager)
  cache: {
    get(key, valueFn, options) {
      return typeof cacheManager !== 'undefined' ? cacheManager.get(key, valueFn, options) : (valueFn ? valueFn() : null);
    },
    remove(key) {
      return typeof cacheManager !== 'undefined' ? cacheManager.remove(key) : null;
    },
    clearAll() {
      return typeof cacheManager !== 'undefined' ? cacheManager.clearAll() : null;
    },
    clearFrontend(options) {
      return typeof cacheManager !== 'undefined' ? cacheManager.clearAllFrontendCaches(options) : Promise.resolve({ success: false });
    },
    clearSpecific(type) {
      return typeof cacheManager !== 'undefined' ? cacheManager.clearSpecificCache(type) : Promise.resolve({ success: false });
    },
    diagnose() {
      return typeof cacheManager !== 'undefined' ? cacheManager.diagnoseFrontendCache() : { available: false };
    },
    getHealth() {
      return typeof cacheManager !== 'undefined' ? cacheManager.getHealth() : { status: 'unavailable' };
    }
  },

  // タイミング制御 (TimingManager)  
  timing: {
    delay(ms, id) {
      return typeof TimingManager !== 'undefined' ? TimingManager.delay(ms, id) : new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    },
    sequence(operations, intervalMs, sequenceId) {
      return typeof TimingManager !== 'undefined' ? TimingManager.sequence(operations, intervalMs, sequenceId) : Promise.resolve([]);
    },
    parallel(operations, concurrency) {
      return typeof TimingManager !== 'undefined' ? TimingManager.parallel(operations, concurrency) : Promise.all(operations.map((op) => op()));
    },
    debounce(func, key, delay) {
      return typeof TimingManager !== 'undefined' ? TimingManager.debounce(func, key, delay) : func;
    },
    throttle(func, key, delay) {
      return typeof TimingManager !== 'undefined' ? TimingManager.throttle(func, key, delay) : func;
    }
  },

  // ローディング制御
  loading: {
    show(options) {
      if (typeof UnifiedLoadingManager !== 'undefined') {
        return UnifiedLoadingManager.showLoading(options);
      }
      return { success: false };
    },
    hide(options) {
      if (typeof UnifiedLoadingManager !== 'undefined') {
        return UnifiedLoadingManager.hideLoading(options);
      }
      return { success: false };
    },
    update(progress, message) {
      if (typeof UnifiedLoadingManager !== 'undefined') {
        return UnifiedLoadingManager.updateProgress(progress, message);
      }
      return { success: false };
    }
  }
};

// =============================================================================
// STEP VALIDATION AND MANAGEMENT
// =============================================================================

/**
 * セットアップ状況をグローバルステータスから取得
 */
const getSetupStatusFromGlobalStatus = () => {
  try {
    if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
      const config = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
      return config.setupStatus || 'pending';
    }
    return 'pending';
  } catch (error) {
    logWarn('getSetupStatusFromGlobalStatus エラー:', error);
    return 'pending';
  }
}

/**
 * 現在のステップを検証し、UI状態を更新
 */
function validateCurrentStep() {
  const savePublishBtn = document.getElementById('save-publish-btn');
  if (!savePublishBtn) return;
  
  // セットアップ状況を確認
  const setupStatus = getSetupStatusFromGlobalStatus();
  
  const isValid = false;
  
  // currentStepがグローバルに定義されていることを確認
  if (typeof currentStep === 'undefined') {
    console.warn('currentStep is not defined, defaulting to 1');
    currentStep = 1;
  }
  
  switch (currentStep) {
    case 1:
      isValid = (typeof selectedSheetId !== 'undefined' && selectedSheetId) || 
                (typeof selectedFormId !== 'undefined' && selectedFormId);
      break;
    case 2:
      // Step 2 validation: check for both config validation AND setup completion
  const configValid = (typeof currentConfig !== 'undefined' && currentConfig) && 
                       (typeof validateConfiguration === 'function' ? validateConfiguration() : true);
  const step2Complete = typeof checkStep2Completion === 'function' ? checkStep2Completion() : false;
      isValid = configValid || step2Complete;
      logDebug('Step 2 validation: configValid=' + configValid + ', step2Complete=' + step2Complete + ', isValid=' + isValid);
      break;
    case 3:
      isValid = true;
      break;
    default:
      isValid = false;
  }
  
  savePublishBtn.disabled = !isValid;
}

/**
 * Step 2の完了状態をチェック
 */
function checkStep2Completion() {
  try {
    // 基本的な設定項目の存在チェック
  const hasValidConfig = currentConfig && 
                        typeof currentConfig === 'object' && 
                        Object.keys(currentConfig).length > 0;
    
    // UI要素の状態チェック  
  const hasFormSelection = document.querySelector('input[name="form-option"]:checked');
  const hasSheetSelection = document.getElementById('sheet-select') && 
                           document.getElementById('sheet-select').value;
    
    return hasValidConfig || hasFormSelection || hasSheetSelection;
  } catch (error) {
    logWarn('checkStep2Completion エラー:', error);
    return false;
  }
}

/**
 * 設定の妥当性を検証
 */
function validateConfiguration() {
  try {
    if (!currentConfig || typeof currentConfig !== 'object') {
      return false;
    }
    
    // 基本的な必須項目のチェック
  const requiredFields = ['timestampHeader', 'opinionHeader'];
    for (let i = 0; i < requiredFields.length; i++) {
  const field = requiredFields[i];
      if (!currentConfig[field]) {
        logDebug('Missing required field: ' + field);
        return false;
      }
    }
    
    return true;
  } catch (error) {
    logWarn('validateConfiguration エラー:', error);
    return false;
  }
}

// =============================================================================
// UI HELPER FUNCTIONS
// =============================================================================

// safeGetElement function already defined at line 3023

/**
 * 安全なイベントリスナー登録
 */
function safeAddEventListener(element, event, handler) {
  if (!element) return false;
  
  try {
    element.addEventListener(event, handler);
    return true;
  } catch (error) {
    console.warn('イベントリスナーの登録に失敗:', event, error);
    return false;
  }
}

/**
 * 要素の表示/非表示を安全に切り替え
 */
function safeToggleVisibility(selector, isVisible) {
  const element = safeGetElement(selector);
  if (!element) return false;
  
  try {
    if (isVisible) {
      element.style.display = '';
      element.classList.remove('hidden');
    } else {
      element.style.display = 'none';
      element.classList.add('hidden');
    }
    return true;
  } catch (error) {
    console.warn('要素の表示切り替えに失敗:', selector, error);
    return false;
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * 統合コア機能の初期化
 */
function initializeAdminCore() {
  console.log('🔧 Admin Core initializing...');
  
  try {
    // 基本的なUI状態の初期化
    if (typeof validateCurrentStep === 'function') {
      validateCurrentStep();
    }
    
    // グローバルエラーハンドリングの設定
    window.addEventListener('error', function(event) {
      if (event.error && event.error.message) {
        logError('Global error caught:', event.error.message);
      }
    });
    
    // Promiseエラーハンドリング
    window.addEventListener('unhandledrejection', function(event) {
      logError('Unhandled promise rejection:', event.reason);
      event.preventDefault(); // ブラウザのデフォルトエラー表示を防ぐ
    });
    
    console.log('✅ Admin Core initialized successfully');
    return true;
  } catch (error) {
    console.error('❌ Admin Core initialization failed:', error);
    return false;
  }
}

// DOM準備完了後に初期化実行
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAdminCore);
} else {
  initializeAdminCore();
}

// =============================================================================
// LEGACY COMPATIBILITY
// =============================================================================

// 既存コードとの互換性のため、主要な関数をグローバルスコープに配置
window.validateCurrentStep = validateCurrentStep;
window.getSetupStatusFromGlobalStatus = getSetupStatusFromGlobalStatus;
window.checkStep2Completion = checkStep2Completion;
window.validateConfiguration = validateConfiguration;
window.safeGetElement = safeGetElement;
window.safeAddEventListener = safeAddEventListener;
window.safeToggleVisibility = safeToggleVisibility;


/**
 * 簡易履歴管理システム
 * ローカルストレージのみを使用するシンプルなアプローチ
 */

// 履歴管理定数
const HISTORY_STORAGE_KEY = 'answerBoardHistory';
const MAX_HISTORY_ITEMS = 5;

/**
 * ローカルストレージから履歴を取得
 * @returns {Array} 履歴配列
 */
function getSimpleHistory() {
  try {
    const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
    return historyJson ? JSON.parse(historyJson) : [];
  } catch (error) {
    logWarn('履歴データの読み込みに失敗:', error);
    return [];
  }
}

/**
 * 履歴をローカルストレージに保存
 * @param {Array} historyArray 履歴配列
 */
function saveSimpleHistory(historyArray) {
  try {
    const safeHistory = Array.isArray(historyArray) ? historyArray : [];
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(safeHistory));
    logDebug('履歴を保存しました:', safeHistory.length, '件');
  } catch (error) {
    logWarn('履歴の保存に失敗:', error);
  }
}

/**
 * 新しい履歴項目を追加
 * @param {Object} historyItem 履歴アイテム
 */
function addToSimpleHistory(historyItem) {
  try {
    if (!historyItem || !historyItem.questionText) {
      logWarn('無効な履歴アイテムです');
      return;
    }

    const history = getSimpleHistory();
    const newItem = {
      id: 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      questionText: historyItem.questionText,
      publishedAt: new Date().toISOString(),
      displayMode: historyItem.displayMode || 'NAMED',
      configData: historyItem.configData || {} // configJsonとして保存される実際の設定データ
    };

    // 先頭に追加
    history.unshift(newItem);

    // 最大件数を超えた場合は削除
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }

    saveSimpleHistory(history);
    updateHistoryTable();
    
    logDebug('履歴に追加しました:', newItem);
  } catch (error) {
    logError(error, 'addToSimpleHistory', ERROR_SEVERITY.MEDIUM, ERROR_CATEGORIES.USER_INPUT);
  }
}

/**
 * 履歴をクリア
 */
function clearSimpleHistory() {
  try {
    localStorage.removeItem(HISTORY_STORAGE_KEY);
    updateHistoryTable();
    logDebug('履歴をクリアしました');
  } catch (error) {
    logWarn('履歴のクリアに失敗:', error);
  }
}

/**
 * 履歴から復元する（シンプル版）
 * @param {string} historyId 履歴ID
 */
async function restoreFromSimpleHistory(historyId) {
  try {
    const history = getSimpleHistory();
    const selectedItem = history.find(item => item.id === historyId);
    
    if (!selectedItem) {
      showMessage('選択された履歴が見つかりません', 'error');
      return;
    }

    // 確認ダイアログ
    const confirmed = confirm('「' + selectedItem.questionText + '」の設定を復元しますか？\n\n現在の設定は上書きされます。');
    if (!confirmed) return;

    // 設定データを直接データベースに保存
    const userId = getUserId();
    if (!userId) {
      showMessage('ユーザーIDが取得できません', 'error');
      return;
    }

    // configDataをconfigJsonとして保存
    const result = await runGasWithUserId('updateUserConfig', selectedItem.configData);
    
    if (result && result.success) {
      showMessage('履歴から設定を復元しました', 'success');
      
      // キャッシュをクリアして再読み込み
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      
      // 管理画面を再読み込み
      setTimeout(() => {
        location.reload();
      }, 1000);
      
    } else {
      showMessage('設定の復元に失敗しました', 'error');
    }
    
  } catch (error) {
    logError(error, 'restoreFromSimpleHistory', ERROR_SEVERITY.HIGH, ERROR_CATEGORIES.USER_INPUT);
    showMessage('履歴の復元中にエラーが発生しました', 'error');
  }
}

/**
 * 履歴テーブルを更新
 */
function updateHistoryTable() {
  try {
    const historyTableBody = document.getElementById('history-table-body');
    if (!historyTableBody) return;

    const history = getSimpleHistory();
    
    if (history.length === 0) {
      historyTableBody.innerHTML = '<tr><td colspan="3" class="text-gray-500 text-center py-4">履歴がありません</td></tr>';
      return;
    }

    historyTableBody.innerHTML = history.map(item => {
      const publishedDate = new Date(item.publishedAt).toLocaleDateString('ja-JP', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      return `
        <tr class="hover:bg-gray-50">
          <td class="py-2 px-3 text-sm">${escapeHtml(item.questionText)}</td>
          <td class="py-2 px-3 text-xs text-gray-500">${publishedDate}</td>
          <td class="py-2 px-3 text-right">
            <button onclick="restoreFromSimpleHistory('${item.id}')" 
                    class="text-blue-600 hover:text-blue-800 text-xs px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
              復元
            </button>
          </td>
        </tr>
      `;
    }).join('');
    
  } catch (error) {
    logWarn('履歴テーブルの更新に失敗:', error);
  }
}

// HTMLエスケープはSharedUtilities.htmlで定義されています

// 初期化時に履歴テーブルを更新
// History table update moved to main DOMContentLoaded handler

// =============================================================================
// 互換性レイヤー - 複雑な履歴システムとの互換性を維持
// =============================================================================

// 互換性関数: loadSimpleHistoryTable
if (typeof loadSimpleHistoryTable === 'undefined') {
  window.loadSimpleHistoryTable = function() {
    if (typeof updateHistoryTable === 'function') {
      updateHistoryTable();
    } else {
      console.warn('⚠️ updateHistoryTable関数が利用できません');
    }
  };
}

// 互換性関数: getHistoryFromStorage（レガシー）
if (typeof getHistoryFromStorage === 'undefined') {
  window.getHistoryFromStorage = function() {
    return getSimpleHistory();
  };
}

// 互換性関数: saveHistoryToStorage（レガシー）
if (typeof saveHistoryToStorage === 'undefined') {
  window.saveHistoryToStorage = function(historyArray) {
    saveSimpleHistory(historyArray);
  };
}

// 互換性関数: saveToHistory（レガシー）
if (typeof saveToHistory === 'undefined') {
  window.saveToHistory = function(historyItem) {
    addToSimpleHistory(historyItem);
  };
}

// HistoryManager の互換レイヤー
if (!window.HistoryManager) {
  window.HistoryManager = {
    renderTable: function() {
      if (typeof updateHistoryTable === 'function') {
        updateHistoryTable();
      }
      return true;
    },
    addToHistory: function(item) {
      if (typeof addToSimpleHistory === 'function') {
        addToSimpleHistory(item);
      }
    },
    _initialized: true
  };
}

console.log('✅ 履歴システム（互換性レイヤー含む）初期化完了');


/**
 * @fileoverview Admin Panel Simple History Compatibility Layer
 * 互換性レイヤーファイル - 将来の履歴機能拡張用
 * 
 * このファイルは AdminPanel.html から参照されていますが、
 * 現在は空の実装として機能しています。
 * 将来的に履歴機能の互換性レイヤーが必要になった場合に
 * ここに実装を追加できます。
 */

(function() {
  'use strict';
  
  // 履歴システムの互換性チェック
  if (typeof window.HistoryManager === 'undefined') {
    console.log('HistoryManager not found, compatibility layer ready for future implementation');
  } else {
    console.log('HistoryManager detected, compatibility layer active');
    
    // 将来の互換性実装用のフック
    try {
      if (window.HistoryManager && window.HistoryManager.prototype && 
          typeof window.HistoryManager.prototype.init === 'function') {
        const originalInit = window.HistoryManager.prototype.init;
        window.HistoryManager.prototype.init = function() {
          console.log('HistoryManager init intercepted by compatibility layer');
          return originalInit.apply(this, arguments);
        };
      } else {
        console.log('HistoryManager.prototype.init not available, skipping hook');
      }
    } catch (error) {
      console.warn('Error setting up HistoryManager compatibility hook:', error.message);
    }
  }
  
  // グローバル互換性フラグ
  window.HISTORY_COMPAT_LAYER_LOADED = true;
  
})();
</script>


// =============================================================================
// ADMIN PANEL HTML INTEGRATION - Extracted JavaScript Sections
// =============================================================================

// Section 1: Initialization and Utility Functions
// Simple initialization system for GAS environment
window.onerror = function(message, source, lineno, colno, error) { 
  // Suppress specific syntax errors that don't affect functionality
  if (message && message.includes('Unexpected end of input')) {
    return true; // Suppress this specific error
  }
  return true; // Suppress all errors for stability
};
window.onunhandledrejection = function() { return true; };

// Debug mode setting
const __DEBUG_MODE_RAW__ = '<?= escapeJavaScript(shouldEnableDebugMode()) ?>';
window.DEBUG_MODE = (__DEBUG_MODE_RAW__ === 'true' || __DEBUG_MODE_RAW__ === true);

// Minimal log suppression for production
if (!window.DEBUG_MODE) {
  const originalLog = console.log;
  console.log = function(...args) {
    const msg = args.join(' ');
    if (msg.match(/[✅🔧🛡️🔍🎉📞🔐🚀🔄]/)) return; // Suppress emoji logs
    if (msg.includes('loaded successfully') || msg.includes('initialized')) return;
    originalLog.apply(console, args);
  };
}

// =============================================================================
// UTILITY FUNCTIONS - Core UI Interactions
// =============================================================================
// Duplicate toggleSection function removed - using class method instead

function copyBoardUrl(button) {
  const urlInput = document.getElementById('board-url');
  if (!urlInput || !urlInput.value) {
    logError('Board URL not found or empty');
    return;
  }
  
  urlInput.select();
  urlInput.setSelectionRange(0, 99999); // For mobile
  
  try {
    document.execCommand('copy');
    // Visual feedback
    const originalText = button.innerHTML;
    button.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
    setTimeout(() => {
      button.innerHTML = originalText;
    }, 1500);
    logInfo('✅ URL copied to clipboard');
  } catch (err) {
    logError('Failed to copy URL:', err);
  }
}

function showSecurityInfo() {
  if (window.sharedModals && window.sharedModals.showSecurityModal) {
    window.sharedModals.showSecurityModal();
  } else {
    logInfo('セキュリティ情報: naha-okinawa.ed.jp ドメイン専用システム');
  }
}

function showGoogleIntegrationInfo() {
  if (window.sharedModals && window.sharedModals.showGoogleIntegrationModal) {
    window.sharedModals.showGoogleIntegrationModal();
  } else {
    logInfo('Google連携: スプレッドシートとフォームの自動作成・管理');
  }
}

window.adminPanel = window.adminPanel || {};
window.adminPanel.logoutAndRedirect = function() {
  if (confirm('ログイン画面に戻りますか？')) {
    const webAppUrl = getWebAppUrl?.() || ScriptApp?.getService()?.getUrl() || window.location.origin;
    window.location.href = webAppUrl + '?mode=login';
  }
};

// Legacy function stubs for compatibility
window.openAppSetupPage = window.openAppSetupPage || function() { 
  logInfo('アプリセットアップ機能は準備中です');
};
window.runHeaderGuessing = function() {
  logInfo('🤖 AI列判定を実行中...');
  AdminPanel_callGAS('autoMapHeaders', window.AdminPanel.currentUserId, window.AdminPanel.currentSpreadsheetId, document.getElementById('sheet-select').value)
    .then(response => {
      if (response && response.success) {
        logInfo('✅ AI判定完了: 列設定を更新しました');
        populateColumnSelects(response.headers);
      } else {
        logError('AI判定に失敗しました:', response?.message);
      }
    })
    .catch(error => logError('AI判定エラー:', error));
};
window.addResource = function() { 
  logInfo('リソース追加機能は準備中です');
};
window.initializeUserSettingsWithUI = window.initializeUserSettingsWithUI || function() { 
  console.warn('initializeUserSettingsWithUI function not yet loaded'); 
};

// Section 2: System Admin and Core Functions
const __IS_SYSTEM_ADMIN_RAW__ = '<?= escapeJavaScript(typeof isDeployUser !== "undefined" ? isDeployUser : "false") ?>';
const __IS_SYSTEM_ADMIN__ = __IS_SYSTEM_ADMIN_RAW__ === 'true' || __IS_SYSTEM_ADMIN_RAW__ === true;
window.isSystemAdmin = __IS_SYSTEM_ADMIN__;

// AdminPanel namespace already initialized at the top of file - removing duplicate

// Section 3: Modal Initialization
// 管理者モーダルの初期化
// Modal initialization and app setup moved to main initialization

</script>
