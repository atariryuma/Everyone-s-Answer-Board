<script>
/**
 * StudyQuest Memory Manager
 * GASæœ€é©åŒ–æ¸ˆã¿ - ãƒ¡ãƒ¢ãƒªç®¡ç†ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã€ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†
 */

/**
 * ãƒ¡ãƒ¢ãƒªç®¡ç†ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
 */
class MemoryManager {
  constructor(coreState) {
    this.coreState = coreState;
    
    // ãƒ¡ãƒ¢ãƒªç›£è¦–è¨­å®š
    this.memorySettings = {
      checkInterval: 30000, // 30ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
      warningThreshold: 0.8, // 80%ã§è­¦å‘Š
      criticalThreshold: 0.9, // 90%ã§å¼·åˆ¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      maxHeapSize: STUDY_QUEST_CONSTANTS.GAS_MAX_MEMORY_MB * 1024 * 1024
    };
    
    // ãƒªã‚½ãƒ¼ã‚¹è¿½è·¡
    this.trackedResources = {
      eventListeners: new Map(),
      domElements: new WeakMap(),
      timers: new Set(),
      intervals: new Set(),
      observers: new Set(),
      caches: new Set()
    };
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æˆ¦ç•¥
    this.cleanupStrategies = new Map();
    this.setupCleanupStrategies();
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
    this.memoryMetrics = {
      initialHeapSize: 0,
      currentHeapSize: 0,
      peakHeapSize: 0,
      cleanupCount: 0,
      lastCleanupTime: 0
    };
    
    this.startMemoryMonitoring();
    this.setupPageUnloadCleanup();
  }

  /**
   * ãƒ¡ãƒ¢ãƒªç›£è¦–ã®é–‹å§‹
   */
  startMemoryMonitoring() {
    if (performance.memory) {
      this.memoryMetrics.initialHeapSize = performance.memory.usedJSHeapSize;
      
      const monitoringInterval = setInterval(() => {
        this.performMemoryCheck();
      }, this.memorySettings.checkInterval);
      
      this.trackInterval(monitoringInterval);
      
      console.log('ğŸ§  Memory monitoring started');
    } else {
      console.warn('âš ï¸ Performance.memory not available, memory monitoring disabled');
    }
  }

  /**
   * ãƒ¡ãƒ¢ãƒªãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
   */
  performMemoryCheck() {
    if (!performance.memory) return;
    
    const currentHeap = performance.memory.usedJSHeapSize;
    const totalHeap = performance.memory.totalJSHeapSize;
    const heapLimit = performance.memory.jsHeapSizeLimit;
    
    this.memoryMetrics.currentHeapSize = currentHeap;
    this.memoryMetrics.peakHeapSize = Math.max(this.memoryMetrics.peakHeapSize, currentHeap);
    
    const heapUsageRatio = currentHeap / heapLimit;
    
    console.log(`ğŸ§  Memory check: ${Math.round(currentHeap / 1024 / 1024)}MB / ${Math.round(heapLimit / 1024 / 1024)}MB (${(heapUsageRatio * 100).toFixed(1)}%)`);
    
    // è­¦å‘Šãƒ¬ãƒ™ãƒ«ã®ãƒã‚§ãƒƒã‚¯
    if (heapUsageRatio > this.memorySettings.criticalThreshold) {
      console.warn('ğŸš¨ Critical memory usage detected, forcing cleanup');
      this.forceCleanup();
    } else if (heapUsageRatio > this.memorySettings.warningThreshold) {
      console.warn('âš ï¸ High memory usage detected, performing optimization');
      this.performOptimization();
    }
    
    // CoreçŠ¶æ…‹ã«å ±å‘Š
    this.coreState.updatePerformanceMetrics({
      memoryMetrics: {
        currentMB: Math.round(currentHeap / 1024 / 1024),
        peakMB: Math.round(this.memoryMetrics.peakHeapSize / 1024 / 1024),
        usageRatio: heapUsageRatio,
        cleanupCount: this.memoryMetrics.cleanupCount
      }
    });
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¿½è·¡
   */
  trackEventListener(element, eventType, handler, options = {}) {
    const listenerId = this.generateListenerId(element, eventType);
    
    this.trackedResources.eventListeners.set(listenerId, {
      element,
      eventType,
      handler,
      options,
      addedAt: Date.now()
    });
    
    element.addEventListener(eventType, handler, options);
    
    console.log(`ğŸ“ Event listener tracked: ${listenerId}`);
    
    return listenerId;
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
   */
  removeEventListener(listenerId) {
    const listener = this.trackedResources.eventListeners.get(listenerId);
    
    if (listener) {
      listener.element.removeEventListener(listener.eventType, listener.handler, listener.options);
      this.trackedResources.eventListeners.delete(listenerId);
      
      console.log(`ğŸ—‘ï¸ Event listener removed: ${listenerId}`);
      return true;
    }
    
    return false;
  }

  /**
   * å…¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanupEventListeners() {
    let removedCount = 0;
    
    for (const [listenerId, listener] of this.trackedResources.eventListeners.entries()) {
      try {
        listener.element.removeEventListener(listener.eventType, listener.handler, listener.options);
        removedCount++;
      } catch (error) {
        console.warn(`âš ï¸ Failed to remove event listener ${listenerId}:`, error);
      }
    }
    
    this.trackedResources.eventListeners.clear();
    
    console.log(`ğŸ§¹ Cleaned up ${removedCount} event listeners`);
    return removedCount;
  }

  /**
   * ã‚¿ã‚¤ãƒãƒ¼ã®è¿½è·¡
   */
  trackTimeout(timeoutId) {
    this.trackedResources.timers.add(timeoutId);
    return timeoutId;
  }

  trackInterval(intervalId) {
    this.trackedResources.intervals.add(intervalId);
    return intervalId;
  }

  /**
   * ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanupTimers() {
    let clearedCount = 0;
    
    // Timeouts
    for (const timeoutId of this.trackedResources.timers) {
      clearTimeout(timeoutId);
      clearedCount++;
    }
    this.trackedResources.timers.clear();
    
    // Intervals
    for (const intervalId of this.trackedResources.intervals) {
      clearInterval(intervalId);
      clearedCount++;
    }
    this.trackedResources.intervals.clear();
    
    console.log(`ğŸ§¹ Cleaned up ${clearedCount} timers`);
    return clearedCount;
  }

  /**
   * ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã®è¿½è·¡
   */
  trackObserver(observer, name = 'unknown') {
    this.trackedResources.observers.add({ observer, name });
    return observer;
  }

  /**
   * ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanupObservers() {
    let disconnectedCount = 0;
    
    for (const { observer, name } of this.trackedResources.observers) {
      try {
        if (typeof observer.disconnect === 'function') {
          observer.disconnect();
          disconnectedCount++;
        }
      } catch (error) {
        console.warn(`âš ï¸ Failed to disconnect observer ${name}:`, error);
      }
    }
    
    this.trackedResources.observers.clear();
    
    console.log(`ğŸ§¹ Cleaned up ${disconnectedCount} observers`);
    return disconnectedCount;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è¿½è·¡
   */
  trackCache(cache, name = 'unknown') {
    this.trackedResources.caches.add({ cache, name });
    return cache;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanupCaches() {
    let clearedCount = 0;
    
    for (const { cache, name } of this.trackedResources.caches) {
      try {
        if (typeof cache.clear === 'function') {
          cache.clear();
          clearedCount++;
        } else if (cache instanceof Map) {
          cache.clear();
          clearedCount++;
        } else if (cache instanceof Set) {
          cache.clear();
          clearedCount++;
        }
      } catch (error) {
        console.warn(`âš ï¸ Failed to clear cache ${name}:`, error);
      }
    }
    
    console.log(`ğŸ§¹ Cleaned up ${clearedCount} caches`);
    return clearedCount;
  }

  /**
   * DOMè¦ç´ ã®å¼±å‚ç…§è¿½è·¡
   */
  trackDOMElement(element, metadata = {}) {
    this.trackedResources.domElements.set(element, {
      ...metadata,
      trackedAt: Date.now()
    });
  }

  /**
   * å¼·åˆ¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  forceCleanup() {
    console.log('ğŸš¨ Performing force cleanup...');
    
    const startTime = Date.now();
    const cleanupResults = {};
    
    // å„ç¨®ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    cleanupResults.eventListeners = this.cleanupEventListeners();
    cleanupResults.timers = this.cleanupTimers();
    cleanupResults.observers = this.cleanupObservers();
    cleanupResults.caches = this.cleanupCaches();
    
    // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å¼·åˆ¶å®Ÿè¡Œï¼ˆå¯èƒ½ãªå ´åˆï¼‰
    if (window.gc) {
      window.gc();
      cleanupResults.forcedGC = true;
    }
    
    // çµ±è¨ˆæ›´æ–°
    this.memoryMetrics.cleanupCount++;
    this.memoryMetrics.lastCleanupTime = Date.now();
    
    const duration = Date.now() - startTime;
    
    console.log(`âœ… Force cleanup completed in ${duration}ms:`, cleanupResults);
    
    return cleanupResults;
  }

  /**
   * æœ€é©åŒ–å‡¦ç†
   */
  performOptimization() {
    console.log('âš¡ Performing memory optimization...');
    
    // æ®µéšçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    const strategies = [
      'cleanupExpiredCaches',
      'cleanupOrphanedListeners',
      'compactDataStructures',
      'clearTemporaryReferences'
    ];
    
    for (const strategy of strategies) {
      if (this.cleanupStrategies.has(strategy)) {
        try {
          this.cleanupStrategies.get(strategy)();
        } catch (error) {
          console.warn(`âš ï¸ Optimization strategy ${strategy} failed:`, error);
        }
      }
    }
    
    console.log('âœ… Memory optimization completed');
  }

  /**
   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æˆ¦ç•¥ã®è¨­å®š
   */
  setupCleanupStrategies() {
    // æœŸé™åˆ‡ã‚Œã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.cleanupStrategies.set('cleanupExpiredCaches', () => {
      for (const { cache, name } of this.trackedResources.caches) {
        if (typeof cache.cleanup === 'function') {
          cache.cleanup();
        }
      }
    });
    
    // å­¤ç«‹ã—ãŸã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.cleanupStrategies.set('cleanupOrphanedListeners', () => {
      const toRemove = [];
      
      for (const [listenerId, listener] of this.trackedResources.eventListeners.entries()) {
        // DOMè¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯å‰Šé™¤
        if (!document.contains(listener.element)) {
          toRemove.push(listenerId);
        }
      }
      
      toRemove.forEach(id => this.removeEventListener(id));
    });
    
    // ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æœ€é©åŒ–
    this.cleanupStrategies.set('compactDataStructures', () => {
      // é…åˆ—ã®æœ€é©åŒ–ï¼ˆæœªä½¿ç”¨é ˜åŸŸã®å‰Šæ¸›ï¼‰
      if (this.coreState.state.currentAnswers && Array.isArray(this.coreState.state.currentAnswers)) {
        // é…åˆ—ã®åœ§ç¸®ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯çŠ¶æ³ã«å¿œã˜ã¦ï¼‰
        const compacted = this.coreState.state.currentAnswers.slice();
        this.coreState.updateState({ currentAnswers: compacted });
      }
    });
    
    // ä¸€æ™‚çš„ãªå‚ç…§ã®ã‚¯ãƒªã‚¢
    this.cleanupStrategies.set('clearTemporaryReferences', () => {
      // ä¸€æ™‚çš„ãªDOMå‚ç…§ã‚’ã‚¯ãƒªã‚¢
      const tempElements = document.querySelectorAll('[data-temp]');
      tempElements.forEach(el => el.remove());
    });
  }

  /**
   * ãƒšãƒ¼ã‚¸ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—è¨­å®š
   */
  setupPageUnloadCleanup() {
    const cleanup = () => {
      console.log('ğŸ”„ Page unload cleanup initiated');
      this.forceCleanup();
    };
    
    // è¤‡æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾å¿œ
    const unloadEvents = ['beforeunload', 'unload', 'pagehide'];
    unloadEvents.forEach(eventType => {
      this.trackEventListener(window, eventType, cleanup, { passive: true });
    });
    
    // Visibility API ã‚’ä½¿ç”¨ã—ãŸéè¡¨ç¤ºæ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.trackEventListener(document, 'visibilitychange', () => {
      if (document.hidden) {
        this.performOptimization();
      }
    }, { passive: true });
  }

  /**
   * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
   */
  generateListenerId(element, eventType) {
    const elementId = element.id || element.tagName || 'unknown';
    const timestamp = Date.now();
    return `${elementId}-${eventType}-${timestamp}`;
  }

  /**
   * ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å–å¾—
   */
  getMemoryUsage() {
    if (!performance.memory) {
      return { available: false };
    }
    
    return {
      available: true,
      used: performance.memory.usedJSHeapSize,
      total: performance.memory.totalJSHeapSize,
      limit: performance.memory.jsHeapSizeLimit,
      usedMB: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
      totalMB: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
      limitMB: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024),
      usageRatio: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit
    };
  }

  /**
   * ãƒªã‚½ãƒ¼ã‚¹çµ±è¨ˆã®å–å¾—
   */
  getResourceStats() {
    return {
      eventListeners: this.trackedResources.eventListeners.size,
      timers: this.trackedResources.timers.size,
      intervals: this.trackedResources.intervals.size,
      observers: this.trackedResources.observers.size,
      caches: this.trackedResources.caches.size,
      memoryMetrics: this.memoryMetrics
    };
  }

  /**
   * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®å–å¾—
   */
  getDebugInfo() {
    return {
      memory: this.getMemoryUsage(),
      resources: this.getResourceStats(),
      cleanupStrategies: Array.from(this.cleanupStrategies.keys()),
      trackedListeners: Array.from(this.trackedResources.eventListeners.keys()),
      lastCleanup: new Date(this.memoryMetrics.lastCleanupTime).toISOString()
    };
  }

  /**
   * å®Œå…¨ãªãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  destroy() {
    console.log('ğŸ§¹ Memory manager destroying...');
    
    const finalCleanup = this.forceCleanup();
    
    // è‡ªèº«ã®ç›£è¦–ã‚¿ã‚¤ãƒãƒ¼ã‚‚ã‚¯ãƒªã‚¢
    this.cleanupTimers();
    
    // å…¨ã¦ã®è¿½è·¡ã‚’ã‚¯ãƒªã‚¢
    this.trackedResources.eventListeners.clear();
    this.trackedResources.timers.clear();
    this.trackedResources.intervals.clear();
    this.trackedResources.observers.clear();
    this.trackedResources.caches.clear();
    
    console.log('âœ… Memory manager destroyed, final cleanup:', finalCleanup);
    
    return finalCleanup;
  }
}

/**
 * è‡ªå‹•ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
 */
class AutoMemoryManager extends MemoryManager {
  constructor(coreState) {
    super(coreState);
    
    // è‡ªå‹•ç®¡ç†è¨­å®š
    this.autoSettings = {
      enabled: true,
      aggressiveMode: false,
      adaptiveThresholds: true,
      backgroundOptimization: true
    };
    
    this.setupAutoManagement();
  }

  /**
   * è‡ªå‹•ç®¡ç†ã®è¨­å®š
   */
  setupAutoManagement() {
    if (!this.autoSettings.enabled) return;
    
    // ã‚¢ã‚¤ãƒ‰ãƒ«æ™‚é–“ã§ã®æœ€é©åŒ–
    if ('requestIdleCallback' in window && this.autoSettings.backgroundOptimization) {
      const idleOptimization = (deadline) => {
        if (deadline.timeRemaining() > 10) { // 10msä»¥ä¸Šã®ä½™è£•ãŒã‚ã‚‹å ´åˆ
          this.performOptimization();
        }
        
        // æ¬¡ã®ã‚¢ã‚¤ãƒ‰ãƒ«æ™‚é–“ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        if (this.autoSettings.enabled) {
          requestIdleCallback(idleOptimization, { timeout: 60000 }); // æœ€å¤§60ç§’å¾…æ©Ÿ
        }
      };
      
      requestIdleCallback(idleOptimization);
    }
    
    // é©å¿œçš„ã—ãã„å€¤ã®èª¿æ•´
    if (this.autoSettings.adaptiveThresholds) {
      this.setupAdaptiveThresholds();
    }
  }

  /**
   * é©å¿œçš„ã—ãã„å€¤ã®è¨­å®š
   */
  setupAdaptiveThresholds() {
    const adjustThresholds = () => {
      const memoryUsage = this.getMemoryUsage();
      
      if (memoryUsage.available && memoryUsage.usageRatio > 0.7) {
        // é«˜ãƒ¡ãƒ¢ãƒªä½¿ç”¨æ™‚ã¯ã‚ˆã‚Šç©æ¥µçš„ã«
        this.memorySettings.warningThreshold = 0.7;
        this.memorySettings.criticalThreshold = 0.8;
        this.autoSettings.aggressiveMode = true;
      } else {
        // é€šå¸¸æ™‚ã¯æ¨™æº–è¨­å®š
        this.memorySettings.warningThreshold = 0.8;
        this.memorySettings.criticalThreshold = 0.9;
        this.autoSettings.aggressiveMode = false;
      }
    };
    
    // å®šæœŸçš„ãªèª¿æ•´
    const adjustmentInterval = setInterval(adjustThresholds, 60000); // 1åˆ†ã”ã¨
    this.trackInterval(adjustmentInterval);
  }

  /**
   * ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–ãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  performOptimization() {
    if (this.autoSettings.aggressiveMode) {
      // ã‚ˆã‚Šç©æ¥µçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      super.performOptimization();
      
      // è¿½åŠ ã®æœ€é©åŒ–å‡¦ç†
      this.performAggressiveOptimization();
    } else {
      super.performOptimization();
    }
  }

  /**
   * ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–æœ€é©åŒ–
   */
  performAggressiveOptimization() {
    console.log('âš¡ Performing aggressive optimization...');
    
    // ã‚ˆã‚Šé »ç¹ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    for (const { cache } of this.trackedResources.caches) {
      if (typeof cache.cleanup === 'function') {
        cache.cleanup();
      }
    }
    
    // DOMè¦ç´ ã®ç©æ¥µçš„ãªè§£æ”¾
    const unusedElements = document.querySelectorAll('[data-unused], .hidden, [style*="display: none"]');
    let removedCount = 0;
    
    unusedElements.forEach(el => {
      if (el.dataset.keepAlive !== 'true') {
        el.remove();
        removedCount++;
      }
    });
    
    if (removedCount > 0) {
      console.log(`ğŸ—‘ï¸ Aggressively removed ${removedCount} unused DOM elements`);
    }
  }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
window.MemoryManager = MemoryManager;
window.AutoMemoryManager = AutoMemoryManager;

</script>