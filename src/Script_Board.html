<script>
const DEBUG_MODE = true;
function debugLog() {
  if (DEBUG_MODE && console && console.log) {
    try {
      // 引数を安全に処理
      const args = Array.from(arguments).map(arg => {
        if (typeof arg === 'object' && arg !== null) {
          return safeDebugStringify(arg);
        }
        return arg;
      });
      console.log.apply(console, args);
    } catch (error) {
      console.warn('debugLog error:', error.message);
    }
  }
}

function safeDebugStringify(obj, maxDepth = 2, currentDepth = 0) {
  if (currentDepth > maxDepth) return '[Max Depth Reached]';
  
  try {
    if (obj === null || obj === undefined) return obj;
    if (typeof obj !== 'object') return obj;
    
    // DOM要素の安全な表示
    if (obj instanceof HTMLElement) {
      return `[${obj.tagName}${obj.id ? '#' + obj.id : ''}${obj.className ? '.' + obj.className.split(' ').slice(0, 2).join('.') : ''}]`;
    }
    
    // 配列の安全な表示
    if (Array.isArray(obj)) {
      if (obj.length > 5) {
        return `[Array(${obj.length}): first 3 items + ${obj.length - 3} more]`;
      }
      return obj.map(item => safeDebugStringify(item, maxDepth, currentDepth + 1));
    }
    
    // オブジェクトの安全な表示
    const result = {};
    let count = 0;
    for (const key in obj) {
      if (count >= 8) {
        result['...'] = `[${Object.keys(obj).length - 8} more properties]`;
        break;
      }
      result[key] = safeDebugStringify(obj[key], maxDepth, currentDepth + 1);
      count++;
    }
    return result;
  } catch (error) {
    return '[Stringify Error: ' + error.message + ']';
  }
}
const __SHOW_COUNTS__ = '<?= typeof showCounts !== "undefined" ? showCounts : false ?>';
const __DISPLAY_MODE__ = '<?= typeof displayMode !== "undefined" ? displayMode : "anonymous" ?>';
const __SHEET_NAME__ = '<?= typeof sheetName !== "undefined" ? sheetName : "" ?>';
const __MAPPING__ = '<?= typeof mapping !== "undefined" ? JSON.stringify(mapping) : "{}" ?>';
const __USER_ID__ = '<?= typeof userId !== "undefined" ? userId : "" ?>';
const __SPREADSHEET_ID__ = '<?= typeof spreadsheetId !== "undefined" ? spreadsheetId : "" ?>';
const __OWNER_NAME__ = '<?= typeof ownerName !== "undefined" ? ownerName : "" ?>';
const __OPINION_HEADER__ = '<?= typeof opinionHeader !== "undefined" ? opinionHeader : "お題" ?>';
const __SHOW_ADMIN_FEATURES__ = '<?= typeof showAdminFeatures !== "undefined" ? showAdminFeatures : false ?>';
const __SHOW_HIGHLIGHT_TOGGLE__ = '<?= typeof showHighlightToggle !== "undefined" ? showHighlightToggle : false ?>';
const __SHOW_SCORE_SORT__ = '<?= typeof showScoreSort !== "undefined" ? showScoreSort : false ?>';
const __IS_STUDENT_MODE__ = '<?= typeof isStudentMode !== "undefined" ? isStudentMode : true ?>';
const __IS_ADMIN_USER__ = '<?= typeof isAdminUser !== "undefined" ? isAdminUser : false ?>';
window.showCounts = __SHOW_COUNTS__.startsWith('<') ? false : __SHOW_COUNTS__ === 'true';
window.displayMode = __DISPLAY_MODE__.startsWith('<') ? 'anonymous' : __DISPLAY_MODE__;
window.showAdminFeatures = __SHOW_ADMIN_FEATURES__.startsWith('<') ? false : __SHOW_ADMIN_FEATURES__ === 'true';
window.showHighlightToggle = __SHOW_HIGHLIGHT_TOGGLE__.startsWith('<') ? false : __SHOW_HIGHLIGHT_TOGGLE__ === 'true';
window.showScoreSort = __SHOW_SCORE_SORT__.startsWith('<') ? false : __SHOW_SCORE_SORT__ === 'true';
window.isStudentMode = __IS_STUDENT_MODE__.startsWith('<') ? true : __IS_STUDENT_MODE__ === 'true';
window.isAdminUser = __IS_ADMIN_USER__.startsWith('<') ? false : __IS_ADMIN_USER__ === 'true';
const SHEET_NAME = __SHEET_NAME__.startsWith('<') ? 'テストシート' : __SHEET_NAME__;
const USER_ID = __USER_ID__.startsWith('<') ? '' : __USER_ID__;
const OWNER_NAME = __OWNER_NAME__.startsWith('<') ? '' : __OWNER_NAME__;
let MAPPING;
try {
  if (typeof __MAPPING__ === 'string' && !__MAPPING__.startsWith('<')) {
    MAPPING = JSON.parse(__MAPPING__);
  } else {
    MAPPING = {};
  }
} catch (e) {
  console.warn('Failed to parse MAPPING:', e);
  MAPPING = {};
}
</script>

<script>
// Optimize initial render
const RENDER_BATCH_SIZE = 10;
const VIEWPORT_BUFFER = 200; // Viewport buffer for virtual scrolling
const PERFORMANCE_BUDGET = 16; // Maximum ms per frame
const CHUNK_SIZE = 5; // DOM operations per chunk
const IDLE_TIMEOUT = 5000; // Idle timeout for cleanup
const ICONS = {
  'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
  'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
  'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
  'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
  'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
  'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
  'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star-solid': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
  'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
};

class UnifiedCache {
  constructor() {
    this.data = new Map();
    this.timestamps = new Map();
  }
  
  set(key, value, ttl = 300000) { // 5分のデフォルトTTL
    this.data.set(key, value);
    this.timestamps.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (!this.data.has(key)) return undefined;
    
    const expiry = this.timestamps.get(key);
    if (expiry && Date.now() > expiry) {
      this.delete(key);
      return undefined;
    }
    
    return this.data.get(key);
  }
  
  has(key) {
    return this.get(key) !== undefined;
  }
  
  delete(key) {
    this.data.delete(key);
    this.timestamps.delete(key);
  }
  
  clear() {
    this.data.clear();
    this.timestamps.clear();
  }
  
  cleanup() {
    const now = Date.now();
    for (const [key, expiry] of this.timestamps.entries()) {
      if (now > expiry) {
        this.delete(key);
      }
    }
  }
  
  get size() {
    return this.data.size;
  }
}

class StudyQuestApp {
  constructor() {
    this.cache = new UnifiedCache();
    this.weakCache = new WeakMap(); // For DOM element caching
    this.performanceMetrics = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;
    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      newContentBanner: document.getElementById('newContentBanner'),
      newContentText: document.getElementById('newContentText'),
      refreshContentBtn: document.getElementById('refreshContentBtn'),
      dismissBannerBtn: document.getElementById('dismissBannerBtn'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter'),
      loadingOverlay: document.getElementById('loading-overlay')
    };
    this.state = {
      currentAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      isStudentMode: window.isStudentMode,
      isAdminUser: window.isAdminUser,
      showCounts: window.showCounts,
      showAdminFeatures: window.showAdminFeatures,
      showHighlightToggle: window.isAdminUser, // 管理者なら常に表示
      showScoreSort: window.showScoreSort,
      displayMode: window.displayMode,
      sheetName: SHEET_NAME,
      hasNewContent: false,
      newContentCount: 0,
      lastSeenCount: 0,
      pollingFailureCount: 0
    };
    
    debugLog('初期状態設定:', {
      isAdminUser: this.state.isAdminUser,
      windowIsAdminUser: window.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle
    });
    
    // デバッグ機能の動作確認テスト
    debugLog('🛠️ デバッグ機能が有効化されました');
    this.serverShowCounts = window.showCounts;
    this.serverDisplayMode = window.displayMode;
    this.pollingInterval = null;
    this.handlers = {};
    this.adminModeVerified = false; // 管理モード切り替え時の権限確認フラグ
    this.reactionDebounce = new Map(); // リアクションのデバウンス処理用
    this.highlightDebounce = new Map(); // ハイライトのデバウンス処理用
    this.pendingReactions = new Set(); // 処理中のリアクション
    
    // イベントリスナー重複登録防止フラグ
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];
    this.gas = {
      getPublishedSheetData: (sheetName, classFilter, sort) => this.runGas('getPublishedSheetData', sheetName, classFilter, sort),
      getAvailableSheets: () => this.runGas('getAvailableSheets'),
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('addReaction', rowIndex, reaction, sheetName),
      removeReaction: (rowIndex, reaction, sheetName) => this.runGas('removeReaction', rowIndex, reaction, sheetName),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('toggleHighlight', rowIndex, sheetName),
      checkHighlightPermission: () => this.runGas('checkHighlightPermission'),
      endPublication: () => this.runGas('endPublication')
    };
    this.iconMapping = {
      'lightbulb': 'lightbulb-outline',
      'hand-thumb-up': 'hand-thumb-up-outline',
      'magnifying-glass-plus': 'magnifying-glass-plus-outline',
      'star': 'star-outline'
    };
    this.init();
  }

  runGas(functionName, ...args) {
    return new Promise((resolve, reject) => {
      try {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          [functionName](...args);
      } catch (error) {
        reject(error);
      }
    });
  }

  async init() {
    try {
      this.initializeIcons();
      await this.showLoading();
      
      // Critical event listeners first
      this.setupCriticalEventListeners();
      
      // Load and render initial content
      await this.loadAndRenderAnswers();
      
      // Setup non-critical features after initial load
      this.setupNonCriticalEventListeners();
      
      // Setup UI controls and features
      this.setupUIControls();
      
      // Initialize polling for new content
      this.startContentPolling();
      
      await this.hideLoading();
      
      // Show info modal on first visit
      this.showFirstTimeInfo();
      
      debugLog('StudyQuestApp の初期化が完了しました');
    } catch (error) {
      console.error('初期化エラー:', error);
      await this.hideLoading();
      this.showErrorMessage('アプリケーションの初期化に失敗しました: ' + error.message);
    }
  }

  initializeIcons() {
    // Initialize all icons in the DOM
    Object.entries(ICONS).forEach(([iconName, svgContent]) => {
      const elements = document.querySelectorAll(`[data-icon="${iconName}"]`);
      elements.forEach(element => {
        element.innerHTML = svgContent;
      });
    });

    // Specific icon initialization
    if (this.elements.iconClose) this.elements.iconClose.innerHTML = ICONS['x'];
    if (this.elements.iconGrid) this.elements.iconGrid.innerHTML = ICONS['grid-2x2'];
    
    // Initialize modal info icons
    if (this.elements.infoIconLike) this.elements.infoIconLike.innerHTML = ICONS['hand-thumb-up-outline'];
    if (this.elements.infoIconUnderstand) this.elements.infoIconUnderstand.innerHTML = ICONS['lightbulb-outline'];
    if (this.elements.infoIconCurious) this.elements.infoIconCurious.innerHTML = ICONS['magnifying-glass-plus-outline'];
    if (this.elements.infoIconHighlight) this.elements.infoIconHighlight.innerHTML = ICONS['star-outline'];
  }

  async showLoading(message = '読み込み中...') {
    if (this.elements.loadingOverlay) {
      this.elements.loadingOverlay.querySelector('p').textContent = message;
      this.elements.loadingOverlay.classList.remove('hidden');
    }
  }

  async hideLoading() {
    if (this.elements.loadingOverlay) {
      this.elements.loadingOverlay.classList.add('hidden');
    }
  }

  setupCriticalEventListeners() {
    if (this.eventDelegationSetup) return;
    this.eventDelegationSetup = true;

    // Event delegation for answer cards and reactions
    if (this.elements.answersContainer) {
      this.elements.answersContainer.addEventListener('click', this.handleAnswerClick.bind(this));
    }

    // Modal close handlers
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.closeAnswerModal.bind(this));
    }

    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', (e) => {
        if (e.target === this.elements.answerModalContainer) {
          this.closeAnswerModal();
        }
      });
    }

    // Info modal handlers
    if (this.elements.infoModalConfirmBtn) {
      this.elements.infoModalConfirmBtn.addEventListener('click', this.closeInfoModal.bind(this));
    }

    // ESC key handler
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (!this.elements.answerModalContainer.classList.contains('hidden')) {
          this.closeAnswerModal();
        } else if (!this.elements.infoModalContainer.classList.contains('hidden')) {
          this.closeInfoModal();
        }
      }
    });
  }

  setupNonCriticalEventListeners() {
    if (this.nonCriticalListenersSetup) return;
    this.nonCriticalListenersSetup = true;

    // Size slider
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handleSizeChange.bind(this));
      this.elements.sizeSlider.addEventListener('change', this.handleSizeChange.bind(this));
    }

    // Filter and sort controls
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handleFilterChange.bind(this));
    }

    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handleSortChange.bind(this));
    }

    // Admin controls
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.addEventListener('click', this.toggleAdminMode.bind(this));
    }

    if (this.elements.endPublicationBtn) {
      this.elements.endPublicationBtn.addEventListener('click', this.handleEndPublication.bind(this));
    }

    // New content banner
    if (this.elements.refreshContentBtn) {
      this.elements.refreshContentBtn.addEventListener('click', this.handleRefreshContent.bind(this));
    }

    if (this.elements.dismissBannerBtn) {
      this.elements.dismissBannerBtn.addEventListener('click', this.hideNewContentBanner.bind(this));
    }
  }

  setupUIControls() {
    // Initialize size slider
    this.updateGridColumns();

    // Setup admin features visibility
    this.updateAdminVisibility();

    // Update header with sheet name and settings
    this.updateHeader();
  }

  updateAdminVisibility() {
    const isAdmin = this.state.isAdminUser;
    const showAdminFeatures = this.state.showAdminFeatures;

    debugLog('Admin visibility update:', { isAdmin, showAdminFeatures });

    // Admin toggle button
    if (this.elements.adminToggleBtn) {
      if (isAdmin) {
        this.elements.adminToggleBtn.classList.remove('hidden');
        this.elements.adminToggleBtn.removeAttribute('hidden');
      } else {
        this.elements.adminToggleBtn.classList.add('hidden');
        this.elements.adminToggleBtn.setAttribute('hidden', 'true');
      }
    }

    // End publication button
    if (this.elements.endPublicationBtn) {
      if (isAdmin && showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', 'true');
      }
    }

    // Score sorting option
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.classList.remove('hidden');
      } else {
        this.elements.scoreOption.classList.add('hidden');
      }
    }
  }

  updateHeader() {
    // Update sheet name
    if (this.elements.sheetNameText) {
      this.elements.sheetNameText.textContent = this.state.sheetName || 'シート名読み込み中...';
    }

    // Update heading with topic
    if (this.elements.headingLabel) {
      const opinionHeader = typeof __OPINION_HEADER__ !== 'undefined' && !__OPINION_HEADER__.startsWith('<') 
        ? __OPINION_HEADER__ 
        : 'お題';
      this.elements.headingLabel.textContent = opinionHeader;
    }
  }

  async loadAndRenderAnswers() {
    if (this.state.isLoading) return;
    
    this.state.isLoading = true;
    
    try {
      const classFilter = this.elements.classFilter?.value || '';
      const sortOrder = this.elements.sortOrder?.value || 'newest';
      
      debugLog('Loading answers with filters:', { classFilter, sortOrder, sheetName: this.state.sheetName });
      
      const data = await this.gas.getPublishedSheetData(this.state.sheetName, classFilter, sortOrder);
      
      if (data && data.success) {
        this.state.currentAnswers = data.answers || [];
        
        // Update answer count
        this.updateAnswerCount(this.state.currentAnswers.length);
        
        // Update class filter options
        this.updateClassFilter(data.classes || []);
        
        // Render answers
        this.renderAnswers(this.state.currentAnswers);
        
        debugLog('Answers loaded successfully:', this.state.currentAnswers.length);
      } else {
        throw new Error(data?.message || 'データの取得に失敗しました');
      }
    } catch (error) {
      console.error('Error loading answers:', error);
      this.showErrorMessage('回答の読み込みに失敗しました: ' + error.message);
    } finally {
      this.state.isLoading = false;
    }
  }

  renderAnswers(answers) {
    if (!this.elements.answersContainer) return;

    const container = this.elements.answersContainer;
    container.innerHTML = '';

    if (!answers || answers.length === 0) {
      container.innerHTML = `
        <div class="col-span-full text-center py-12 text-gray-400">
          <p class="text-lg mb-2">📝</p>
          <p>まだ回答がありません</p>
        </div>
      `;
      return;
    }

    const fragment = document.createDocumentFragment();

    answers.forEach((answer, index) => {
      const card = this.createAnswerCard(answer, index);
      fragment.appendChild(card);
    });

    container.appendChild(fragment);
  }

  createAnswerCard(answer, index) {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel p-4 rounded-xl border-2 border-gray-600 transition-all hover:border-gray-500 cursor-pointer';
    card.dataset.rowIndex = answer.rowIndex || index;
    card.dataset.answerIndex = index;

    // Apply reaction styling
    const reactionClasses = this.getReactionStyling(answer);
    if (reactionClasses.borderClass) {
      card.classList.add(reactionClasses.borderClass);
    }
    if (reactionClasses.backgroundClass) {
      card.classList.add(reactionClasses.backgroundClass);
    }

    // Apply highlight styling
    if (answer.isHighlighted) {
      card.classList.add('highlighted');
    }

    const displayName = this.getDisplayName(answer);
    const answerPreview = this.escapeHtml(answer.answer || '');
    
    card.innerHTML = `
      ${answer.isHighlighted ? '<div class="highlight-badge" aria-label="ハイライト表示">⭐</div>' : ''}
      
      <div class="answer-preview text-gray-200 mb-3 leading-relaxed">
        ${answerPreview}
      </div>
      
      <div class="flex items-center justify-between">
        <div class="text-sm text-gray-400">
          ${displayName}
        </div>
        
        <div class="flex items-center gap-2">
          ${this.createReactionButtons(answer)}
          ${this.createHighlightButton(answer)}
        </div>
      </div>
    `;

    return card;
  }

  getDisplayName(answer) {
    if (this.state.displayMode === 'named' && answer.name) {
      return this.escapeHtml(answer.name);
    }
    return '匿名';
  }

  createReactionButtons(answer) {
    if (!this.state.showCounts) return '';

    return this.reactionTypes.map(reaction => {
      const count = answer[`${reaction.key.toLowerCase()}Count`] || 0;
      const isActive = answer[`user${reaction.key}`] || false;
      const icon = isActive ? 
        ICONS[`${this.iconMapping[reaction.icon]?.replace('-outline', '-solid') || reaction.icon}`] :
        ICONS[this.iconMapping[reaction.icon] || reaction.icon];

      return `
        <button class="reaction-btn ${isActive ? 'reacted' : ''} p-1 rounded transition-all" 
                data-reaction="${reaction.key}" 
                data-row-index="${answer.rowIndex}"
                aria-label="${reaction.key}リアクション ${count}件"
                title="${reaction.key}: ${count}件">
          <div class="flex items-center gap-1">
            <span class="w-4 h-4">${icon}</span>
            <span class="text-xs">${count}</span>
          </div>
        </button>
      `;
    }).join('');
  }

  createHighlightButton(answer) {
    if (!this.state.showHighlightToggle) return '';

    const isHighlighted = answer.isHighlighted;
    const icon = isHighlighted ? ICONS['star-solid'] : ICONS['star-outline'];

    return `
      <button class="highlight-btn ${isHighlighted ? 'liked' : ''} p-1 transition-all" 
              data-row-index="${answer.rowIndex}"
              aria-label="${isHighlighted ? 'ハイライト解除' : 'ハイライト設定'}"
              title="${isHighlighted ? 'ハイライト解除' : 'ハイライト設定'}">
        <span class="w-4 h-4">${icon}</span>
      </button>
    `;
  }

  getReactionStyling(answer) {
    const reactions = [];
    
    if ((answer.likeCount || 0) > 0) reactions.push('like');
    if ((answer.understandCount || 0) > 0) reactions.push('understand');
    if ((answer.curiousCount || 0) > 0) reactions.push('curious');

    const totalReactions = (answer.likeCount || 0) + (answer.understandCount || 0) + (answer.curiousCount || 0);
    
    let borderClass = '';
    let backgroundClass = '';

    if (reactions.length > 0) {
      backgroundClass = `reaction-bg-${reactions.join('-')}`;
      
      if (totalReactions >= 3) {
        borderClass = 'reaction-border-3';
      } else if (totalReactions >= 2) {
        borderClass = 'reaction-border-2';
      } else {
        borderClass = 'reaction-border-1';
      }
    }

    return { borderClass, backgroundClass };
  }

  handleAnswerClick(e) {
    const card = e.target.closest('.answer-card');
    if (!card) return;

    // Handle reaction button clicks
    const reactionBtn = e.target.closest('.reaction-btn');
    if (reactionBtn) {
      e.stopPropagation();
      this.handleReactionClick(reactionBtn);
      return;
    }

    // Handle highlight button clicks
    const highlightBtn = e.target.closest('.highlight-btn');
    if (highlightBtn) {
      e.stopPropagation();
      this.handleHighlightClick(highlightBtn);
      return;
    }

    // Handle card click (open modal)
    this.openAnswerModal(card);
  }

  async handleReactionClick(button) {
    const reaction = button.dataset.reaction;
    const rowIndex = button.dataset.rowIndex;
    
    if (!reaction || !rowIndex) return;

    const reactionKey = `${rowIndex}-${reaction}`;
    
    // Debounce check
    if (this.reactionDebounce.has(reactionKey)) return;
    this.reactionDebounce.set(reactionKey, true);
    
    // Pending check
    if (this.pendingReactions.has(reactionKey)) return;
    this.pendingReactions.add(reactionKey);

    try {
      button.classList.add('loading');
      
      const isCurrentlyReacted = button.classList.contains('reacted');
      const result = isCurrentlyReacted 
        ? await this.gas.removeReaction(rowIndex, reaction, this.state.sheetName)
        : await this.gas.addReaction(rowIndex, reaction, this.state.sheetName);

      if (result && result.success) {
        this.updateReactionUI(button, result.newCount, !isCurrentlyReacted);
        this.updateModalReactions(rowIndex, reaction, result.newCount, !isCurrentlyReacted);
      } else {
        throw new Error(result?.message || 'リアクションの更新に失敗しました');
      }
    } catch (error) {
      console.error('Reaction error:', error);
      this.showErrorMessage('リアクションの更新に失敗しました');
    } finally {
      button.classList.remove('loading');
      this.pendingReactions.delete(reactionKey);
      
      setTimeout(() => {
        this.reactionDebounce.delete(reactionKey);
      }, 1000);
    }
  }

  updateReactionUI(button, newCount, isReacted) {
    const countSpan = button.querySelector('.text-xs');
    if (countSpan) {
      countSpan.textContent = newCount;
    }

    if (isReacted) {
      button.classList.add('reacted');
    } else {
      button.classList.remove('reacted');
    }

    // Update icon
    const iconSpan = button.querySelector('.w-4');
    if (iconSpan) {
      const reaction = button.dataset.reaction;
      const reactionType = this.reactionTypes.find(r => r.key === reaction);
      if (reactionType) {
        const iconKey = isReacted ? 
          `${this.iconMapping[reactionType.icon]?.replace('-outline', '-solid') || reactionType.icon}` :
          this.iconMapping[reactionType.icon] || reactionType.icon;
        iconSpan.innerHTML = ICONS[iconKey] || '';
      }
    }
  }

  async handleHighlightClick(button) {
    const rowIndex = button.dataset.rowIndex;
    
    if (!rowIndex) return;

    const highlightKey = `highlight-${rowIndex}`;
    
    // Debounce check
    if (this.highlightDebounce.has(highlightKey)) return;
    this.highlightDebounce.set(highlightKey, true);

    try {
      button.classList.add('loading');
      
      const result = await this.gas.toggleHighlight(rowIndex, this.state.sheetName);

      if (result && result.success) {
        this.updateHighlightUI(button, result.isHighlighted);
        this.updateCardHighlight(rowIndex, result.isHighlighted);
      } else {
        throw new Error(result?.message || 'ハイライトの更新に失敗しました');
      }
    } catch (error) {
      console.error('Highlight error:', error);
      this.showErrorMessage('ハイライトの更新に失敗しました');
    } finally {
      button.classList.remove('loading');
      
      setTimeout(() => {
        this.highlightDebounce.delete(highlightKey);
      }, 1000);
    }
  }

  updateHighlightUI(button, isHighlighted) {
    const iconSpan = button.querySelector('.w-4');
    if (iconSpan) {
      iconSpan.innerHTML = isHighlighted ? ICONS['star-solid'] : ICONS['star-outline'];
    }

    if (isHighlighted) {
      button.classList.add('liked');
    } else {
      button.classList.remove('liked');
    }
  }

  updateCardHighlight(rowIndex, isHighlighted) {
    const card = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (!card) return;

    if (isHighlighted) {
      card.classList.add('highlighted');
      
      // Add highlight badge if not exists
      if (!card.querySelector('.highlight-badge')) {
        const badge = document.createElement('div');
        badge.className = 'highlight-badge';
        badge.setAttribute('aria-label', 'ハイライト表示');
        badge.textContent = '⭐';
        card.prepend(badge);
      }
    } else {
      card.classList.remove('highlighted');
      
      // Remove highlight badge
      const badge = card.querySelector('.highlight-badge');
      if (badge) {
        badge.remove();
      }
    }
  }

  openAnswerModal(card) {
    if (this.modalOperationPending) return;
    this.modalOperationPending = true;

    try {
      const answerIndex = parseInt(card.dataset.answerIndex);
      const answer = this.state.currentAnswers[answerIndex];
      
      if (!answer) return;

      this.state.lastFocusedElement = document.activeElement;

      // Update modal content
      if (this.elements.modalAnswer) {
        this.elements.modalAnswer.innerHTML = this.escapeHtml(answer.answer || '');
      }

      if (this.elements.modalStudentName) {
        this.elements.modalStudentName.textContent = this.getDisplayName(answer);
      }

      // Update modal reactions
      this.updateModalReactionDisplay(answer);

      // Apply styling to modal card
      this.updateModalCardStyling(answer);

      // Show modal
      this.elements.answerModalContainer.classList.remove('hidden');
      this.elements.answerModalCard.classList.add('modal-fade', 'modal-scale');
      
      // Focus management
      setTimeout(() => {
        this.elements.answerModalCloseBtn?.focus();
      }, 100);

    } finally {
      setTimeout(() => {
        this.modalOperationPending = false;
      }, 300);
    }
  }

  updateModalReactionDisplay(answer) {
    if (!this.elements.modalReactionContainer) return;

    if (!this.state.showCounts) {
      this.elements.modalReactionContainer.innerHTML = '';
      return;
    }

    const reactions = this.reactionTypes.map(reaction => {
      const count = answer[`${reaction.key.toLowerCase()}Count`] || 0;
      const isActive = answer[`user${reaction.key}`] || false;
      const icon = isActive ? 
        ICONS[`${this.iconMapping[reaction.icon]?.replace('-outline', '-solid') || reaction.icon}`] :
        ICONS[this.iconMapping[reaction.icon] || reaction.icon];

      return `
        <div class="flex items-center gap-1 px-2 py-1 rounded ${isActive ? 'bg-cyan-500/20 text-cyan-300' : 'text-gray-400'}">
          <span class="w-4 h-4">${icon}</span>
          <span class="text-sm">${count}</span>
        </div>
      `;
    }).join('');

    this.elements.modalReactionContainer.innerHTML = reactions;
  }

  updateModalCardStyling(answer) {
    if (!this.elements.answerModalCard) return;

    // Reset classes
    this.elements.answerModalCard.className = 'glass-panel rounded-xl p-6 flex flex-col shadow-2xl border-2 border-cyan-400/80 w-full max-w-5xl h-auto max-h-[85vh] relative';

    // Apply reaction styling
    const reactionClasses = this.getReactionStyling(answer);
    if (reactionClasses.borderClass) {
      this.elements.answerModalCard.classList.add(reactionClasses.borderClass);
    }
    if (reactionClasses.backgroundClass) {
      this.elements.answerModalCard.classList.add(reactionClasses.backgroundClass);
    }

    // Apply highlight styling
    if (answer.isHighlighted) {
      this.elements.answerModalCard.classList.add('highlighted');
    }
  }

  updateModalReactions(rowIndex, reaction, newCount, isReacted) {
    // This would update the modal if it's open for the same answer
    const modalCard = this.elements.answerModalCard;
    if (!modalCard || this.elements.answerModalContainer.classList.contains('hidden')) return;

    // Find the corresponding answer and update modal display
    const answer = this.state.currentAnswers.find(a => a.rowIndex == rowIndex);
    if (answer) {
      answer[`${reaction.toLowerCase()}Count`] = newCount;
      answer[`user${reaction}`] = isReacted;
      this.updateModalReactionDisplay(answer);
      this.updateModalCardStyling(answer);
    }
  }

  closeAnswerModal() {
    if (!this.elements.answerModalContainer) return;

    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalCard.classList.remove('modal-fade', 'modal-scale');

    // Restore focus
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
      this.state.lastFocusedElement = null;
    }
  }

  showFirstTimeInfo() {
    if (localStorage.getItem('studyquest-info-shown') === 'true') return;

    if (this.elements.infoModalContainer) {
      this.elements.infoModalContainer.classList.remove('hidden');
      this.elements.infoModalCard.classList.add('modal-fade', 'modal-scale');
    }
  }

  closeInfoModal() {
    if (!this.elements.infoModalContainer) return;

    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalCard.classList.remove('modal-fade', 'modal-scale');
    
    localStorage.setItem('studyquest-info-shown', 'true');
  }

  handleSizeChange() {
    this.updateGridColumns();
  }

  updateGridColumns() {
    const slider = this.elements.sizeSlider;
    const valueDisplay = this.elements.sliderValue;
    const container = this.elements.answersContainer;

    if (!slider || !valueDisplay || !container) return;

    const cols = parseInt(slider.value);
    valueDisplay.textContent = cols;

    // Update grid classes
    container.className = container.className.replace(/grid-cols-\d+/g, '');
    container.classList.add(`grid-cols-1`);
    
    if (cols >= 2) container.classList.add(`sm:grid-cols-2`);
    if (cols >= 3) container.classList.add(`md:grid-cols-3`);
    if (cols >= 4) container.classList.add(`lg:grid-cols-4`);
    if (cols >= 5) container.classList.add(`xl:grid-cols-5`);
    if (cols >= 6) container.classList.add(`2xl:grid-cols-6`);
  }

  async handleFilterChange() {
    await this.loadAndRenderAnswers();
  }

  async handleSortChange() {
    await this.loadAndRenderAnswers();
  }

  updateAnswerCount(count) {
    if (this.elements.answerCount) {
      const countText = this.elements.answerCount.querySelector('#answerCountText');
      if (countText) {
        countText.textContent = `${count}件`;
      }
    }
  }

  updateClassFilter(classes) {
    if (!this.elements.classFilter || !classes || classes.length === 0) return;

    const currentValue = this.elements.classFilter.value;
    this.elements.classFilter.innerHTML = '<option value="">すべて</option>';

    classes.forEach(className => {
      const option = document.createElement('option');
      option.value = className;
      option.textContent = className;
      if (className === currentValue) {
        option.selected = true;
      }
      this.elements.classFilter.appendChild(option);
    });

    if (classes.length > 1) {
      this.elements.classFilter.classList.remove('hidden');
    }
  }

  toggleAdminMode() {
    this.state.showAdminFeatures = !this.state.showAdminFeatures;
    this.updateAdminVisibility();
    debugLog('Admin mode toggled:', this.state.showAdminFeatures);
  }

  async handleEndPublication() {
    if (!confirm('公開を終了しますか？この操作は取り消せません。')) return;

    try {
      await this.showLoading('公開を終了しています...');
      
      const result = await this.gas.endPublication();
      
      if (result && result.success) {
        alert('公開を終了しました。');
        window.location.reload();
      } else {
        throw new Error(result?.message || '公開終了に失敗しました');
      }
    } catch (error) {
      console.error('End publication error:', error);
      this.showErrorMessage('公開終了に失敗しました: ' + error.message);
    } finally {
      await this.hideLoading();
    }
  }

  startContentPolling() {
    if (this.pollingInterval) return;

    this.pollingInterval = setInterval(async () => {
      try {
        await this.checkForNewContent();
      } catch (error) {
        console.error('Polling error:', error);
        this.state.pollingFailureCount++;
        
        if (this.state.pollingFailureCount >= 3) {
          this.stopContentPolling();
          debugLog('Polling stopped due to repeated failures');
        }
      }
    }, 30000); // Check every 30 seconds
  }

  stopContentPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
  }

  async checkForNewContent() {
    try {
      const classFilter = this.elements.classFilter?.value || '';
      const sortOrder = this.elements.sortOrder?.value || 'newest';
      
      const data = await this.gas.getPublishedSheetData(this.state.sheetName, classFilter, sortOrder);
      
      if (data && data.success) {
        const newCount = data.answers?.length || 0;
        const currentCount = this.state.currentAnswers.length;
        
        if (newCount > currentCount) {
          this.state.hasNewContent = true;
          this.state.newContentCount = newCount - currentCount;
          this.showNewContentBanner();
        }
      }
    } catch (error) {
      console.error('Check new content error:', error);
      throw error;
    }
  }

  showNewContentBanner() {
    if (!this.elements.newContentBanner) return;

    const text = this.elements.newContentText;
    if (text) {
      text.textContent = `${this.state.newContentCount}件の新しい意見が投稿されました`;
    }

    this.elements.newContentBanner.classList.remove('hidden');
  }

  hideNewContentBanner() {
    if (this.elements.newContentBanner) {
      this.elements.newContentBanner.classList.add('hidden');
    }
    this.state.hasNewContent = false;
    this.state.newContentCount = 0;
  }

  async handleRefreshContent() {
    this.hideNewContentBanner();
    await this.loadAndRenderAnswers();
  }

  showErrorMessage(message) {
    const container = this.elements.answersContainer;
    if (container) {
      container.innerHTML = `
        <div class="col-span-full text-center py-12 text-red-400">
          <p class="text-lg mb-2">⚠️</p>
          <p>${this.escapeHtml(message)}</p>
        </div>
      `;
    }
  }

  escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  destroy() {
    this.stopContentPolling();
    
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    
    this.cache.clear();
    this.weakCache = new WeakMap();
  }
}

// Utility functions for domain and form link loading
async function loadDomainInfo() {
  try {
    debugLog('Loading domain info...');
    
    const result = await new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)
        .getDeployUserDomainInfo();
    });
    
    debugLog('Domain info result:', result);
    
    const domainInitial = document.getElementById('header-domain-initial');
    const domainMatch = document.getElementById('header-domain-match');
    const domainMismatch = document.getElementById('header-domain-mismatch');
    const domainMatchText = document.getElementById('header-domain-match-text');
    const domainMismatchText = document.getElementById('header-domain-mismatch-text');
    
    if (domainInitial) domainInitial.classList.add('hidden');
    
    if (result && result.isDomainMatch) {
      if (domainMatch) domainMatch.classList.remove('hidden');
      if (domainMatchText) {
        domainMatchText.textContent = result.deployDomain || '学校ドメイン';
      }
    } else {
      if (domainMismatch) domainMismatch.classList.remove('hidden');
      if (domainMismatchText) {
        domainMismatchText.textContent = result?.currentDomain || '外部アクセス';
      }
    }
  } catch (error) {
    console.error('Failed to load domain info:', error);
    const domainInitial = document.getElementById('header-domain-initial');
    if (domainInitial) domainInitial.classList.add('hidden');
  }
}

async function loadFormLink() {
  try {
    debugLog('Loading form link...');
    
    const result = await new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)
        .getWebAppUrl();
    });
    
    debugLog('Form link result:', result);
    
    if (result && result.success && result.url) {
      const formLinkBtn = document.getElementById('form-link-btn');
      if (formLinkBtn) {
        formLinkBtn.href = result.url;
        formLinkBtn.classList.remove('hidden');
      }
    }
  } catch (error) {
    console.error('Failed to load form link:', error);
  }
}

// Initialize the application
try {
  debugLog('Creating StudyQuestApp instance...');
  window.studyQuestApp = new StudyQuestApp();
  
  // Debug function for getting card information
  window.getAnswerCardInfo = function(cardSelector) {
    try {
      const card = document.querySelector(cardSelector || '.answer-card');
      if (!card) {
        console.log('No answer card found with selector:', cardSelector);
        return { success: false, error: 'Card not found' };
      }
      
      const cardInfo = {
        element: card,
        classes: Array.from(card.classList),
        dataset: { ...card.dataset },
        rowIndex: card.dataset.rowIndex,
        boundingRect: card.getBoundingClientRect(),
        computedStyle: {
          display: getComputedStyle(card).display,
          visibility: getComputedStyle(card).visibility,
          opacity: getComputedStyle(card).opacity
        },
        textContent: card.textContent?.trim() || '',
        innerHTML: card.innerHTML
      };
      
      console.log('Answer card info:', cardInfo);
      return { success: true, cardInfo };
    } catch (error) {
      console.error('Error getting card info:', error);
      return { success: false, error: `Error getting card info: ${error.message}` };
    }
  };
  
  // ドメイン情報とフォームリンクを取得
  loadDomainInfo();
  loadFormLink();
  
  window.addEventListener('beforeunload', () => {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
  });
} catch (error) {
  console.error('Error creating StudyQuestApp instance:', error);
  const container = document.getElementById('answers');
  if (container) {
    const msg = StudyQuestApp.prototype.escapeHtml(error.message || '');
    container.innerHTML = '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + msg + '</div>';
  }
}
</script>