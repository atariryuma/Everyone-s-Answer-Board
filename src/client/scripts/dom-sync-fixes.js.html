<script>
// DOM操作競合問題の修正提案

// 1. DOM操作ロック機構の追加
class DOMOperationLock {
  constructor() {
    this.locks = new Map();
    this.queues = new Map();
  }

  async acquire(elementId) {
    if (this.locks.get(elementId)) {
      // 既にロックされている場合は待機
      return new Promise((resolve) => {
        if (!this.queues.has(elementId)) {
          this.queues.set(elementId, []);
        }
        this.queues.get(elementId).push(resolve);
      });
    }
    
    this.locks.set(elementId, true);
    return Promise.resolve();
  }

  release(elementId) {
    this.locks.delete(elementId);
    const queue = this.queues.get(elementId);
    if (queue && queue.length > 0) {
      const nextResolve = queue.shift();
      this.locks.set(elementId, true);
      nextResolve();
    }
  }
}

// 2. 安全なDOM操作ヘルパー
class SafeDOMOperations {
  constructor() {
    this.lock = new DOMOperationLock();
    this.pendingOperations = new Set();
  }

  async safeUpdateElement(elementSelector, updateFn, lockKey = elementSelector) {
    const operationId = `${lockKey}-${Date.now()}`;
    
    if (this.pendingOperations.has(lockKey)) {
      console.warn(`DOM operation already pending for ${lockKey}`);
      return false;
    }

    this.pendingOperations.add(lockKey);
    
    try {
      await this.lock.acquire(lockKey);
      
      const element = document.querySelector(elementSelector);
      if (!element || !document.contains(element)) {
        console.warn(`Element not found or not in DOM: ${elementSelector}`);
        return false;
      }
      
      // DOM操作を実行
      const result = updateFn(element);
      
      // 操作後に要素がまだ存在するかチェック
      if (!document.contains(element)) {
        console.warn(`Element was removed during operation: ${elementSelector}`);
        return false;
      }
      
      return result;
    } finally {
      this.lock.release(lockKey);
      this.pendingOperations.delete(lockKey);
    }
  }

  // バッチDOM操作
  async batchDOMOperations(operations) {
    const results = [];
    
    for (const operation of operations) {
      const result = await this.safeUpdateElement(
        operation.selector,
        operation.updateFn,
        operation.lockKey || operation.selector
      );
      results.push(result);
    }
    
    return results;
  }
}

// 3. 修正されたhandleReactionメソッド
async function handleReaction_FIXED(rowIndex, reaction) {
  const numericRowIndex = parseInt(rowIndex, 10);
  const reactionKey = `${numericRowIndex}-${reaction}`;
  const lockKey = `reaction-${numericRowIndex}`;

  // 連続クリック防止
  if (this.pendingReactions.has(reactionKey)) {
    return;
  }

  this.pendingReactions.add(reactionKey);

  try {
    // DOM操作をロックして安全に実行
    await this.safeDOMOps.safeUpdateElement(
      `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`,
      (btn) => {
        btn.classList.add('loading');
        btn.disabled = true;
      },
      lockKey
    );

    // サーバー通信
    const res = await this.gas.addReaction(numericRowIndex, reaction, this.state.sheetName);

    if (res && res.status === 'ok' && res.reactions) {
      const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
      if (item) {
        item.reactions = res.reactions;
        
        // 安全な非同期UI更新
        await this.safeApplyUpdates([item]);
      }
    }
  } catch (error) {
    console.error('Failed to add reaction:', error);
  } finally {
    // ローディング状態を解除
    await this.safeDOMOps.safeUpdateElement(
      `[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`,
      (btn) => {
        btn.classList.remove('loading');
        btn.disabled = false;
      },
      lockKey
    );
    
    this.pendingReactions.delete(reactionKey);
  }
}

// 4. 修正されたapplyUpdatesメソッド
async function safeApplyUpdates(items) {
  const operations = [];
  
  for (const item of items) {
    // カード要素の更新操作を準備
    operations.push({
      selector: `.answer-card[data-row-index="${item.rowIndex}"]`,
      lockKey: `card-${item.rowIndex}`,
      updateFn: (card) => {
        // ハイライト状態の更新
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        
        // ハイライトボタンの更新
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('liked', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
          }
        }
        
        return true;
      }
    });
    
    // リアクションボタンの更新操作を準備
    this.reactionTypes.forEach(rt => {
      if (item.reactions && item.reactions[rt.key]) {
        operations.push({
          selector: `[data-row-index="${item.rowIndex}"][data-reaction="${rt.key}"]`,
          lockKey: `reaction-${item.rowIndex}-${rt.key}`,
          updateFn: (btn) => {
            this.updateReactionButtonUI(item.rowIndex, rt.key, 
              item.reactions[rt.key].count, item.reactions[rt.key].reacted);
            return true;
          }
        });
      }
    });
  }
  
  // バッチでDOM操作を実行
  await this.safeDOMOps.batchDOMOperations(operations);
}

// 5. 修正されたrenderBoardメソッド（部分）
async function renderBoard_FIXED(isLayoutChange = false, oldRows = []) {
  // 既存の前処理...
  
  // DOM更新をロックして実行
  const containerLockKey = 'answers-container';
  
  await this.safeDOMOps.safeUpdateElement('#answers', (container) => {
    // スケルトンの削除
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    
    if (newRows.length === 0) {
      if (!container.querySelector('.no-answers')) {
        container.innerHTML = '';
        const p = document.createElement('p');
        p.className = 'text-center text-gray-500 col-span-full mt-8 no-answers';
        p.textContent = 'このクラスの回答はありません。';
        container.appendChild(p);
      }
    } else {
      // 既存カードのマップ作成
      const existingMap = new Map();
      container.querySelectorAll('.answer-card').forEach(card => {
        existingMap.set(card.dataset.rowIndex, card);
      });
      
      // 不要なカードの削除
      existingMap.forEach((card, id) => {
        if (!newRows.some(r => String(r.rowIndex) === id)) {
          card.remove();
          existingMap.delete(id);
        }
      });
      
      // フラグメントを使用した効率的な更新
      const fragment = document.createDocumentFragment();
      
      newRows.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        
        if (!card) {
          card = this.createAnswerCard(row);
          card.classList.add('new-card');
        } else {
          this.updateExistingCard(card, row, oldData, changedItems);
        }
        
        fragment.appendChild(card);
      });
      
      container.appendChild(fragment);
    }
    
    return true;
  }, containerLockKey);
}

// 6. 初期化時のセットアップ
function initializeDOMSafety() {
  // StudyQuestAppクラスにDOM安全性ツールを追加
  this.safeDOMOps = new SafeDOMOperations();
  
  // 既存のメソッドを安全版に置き換え
  this.handleReaction = handleReaction_FIXED.bind(this);
  this.safeApplyUpdates = safeApplyUpdates.bind(this);
  this.renderBoard = renderBoard_FIXED.bind(this);
}
</script>