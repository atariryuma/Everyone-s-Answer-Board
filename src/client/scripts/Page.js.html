<script>
const DEBUG_MODE = true;
function debugLog() {
  if (DEBUG_MODE && console && console.log) {
    try {
      // 引数を安全に処理
      const args = Array.from(arguments).map(arg => {
        if (typeof arg === 'object' && arg !== null) {
          return safeDebugStringify(arg);
        }
        return arg;
      });
      console.log.apply(console, args);
    } catch (error) {
      console.warn('debugLog error:', error.message);
    }
  }
}

function safeDebugStringify(obj, maxDepth = 2, currentDepth = 0) {
  if (currentDepth > maxDepth) return '[Max Depth Reached]';
  
  try {
    if (obj === null || obj === undefined) return obj;
    if (typeof obj !== 'object') return obj;
    
    // DOM要素の安全な表示
    if (obj instanceof HTMLElement) {
      return `[${obj.tagName}${obj.id ? '#' + obj.id : ''}${obj.className ? '.' + obj.className.split(' ').slice(0, 2).join('.') : ''}]`;
    }
    
    // 配列の安全な表示
    if (Array.isArray(obj)) {
      if (obj.length > 5) {
        return `[Array(${obj.length}): first 3 items + ${obj.length - 3} more]`;
      }
      return obj.map(item => safeDebugStringify(item, maxDepth, currentDepth + 1));
    }
    
    // オブジェクトの安全な表示
    const result = {};
    let count = 0;
    for (const key in obj) {
      if (count >= 8) {
        result['...'] = `[${Object.keys(obj).length - 8} more properties]`;
        break;
      }
      result[key] = safeDebugStringify(obj[key], maxDepth, currentDepth + 1);
      count++;
    }
    return result;
  } catch (error) {
    return '[Stringify Error: ' + error.message + ']';
  }
}
const __SHOW_COUNTS__ = '<?= typeof showCounts !== "undefined" ? showCounts : false ?>';
const __DISPLAY_MODE__ = '<?= typeof displayMode !== "undefined" ? displayMode : "anonymous" ?>';
const __SHEET_NAME__ = '<?= typeof sheetName !== "undefined" ? sheetName : "" ?>';
const __MAPPING__ = '<?= typeof mapping !== "undefined" ? JSON.stringify(mapping) : "{}" ?>';
const __USER_ID__ = '<?= typeof userId !== "undefined" ? userId : "" ?>';
const __SPREADSHEET_ID__ = '<?= typeof spreadsheetId !== "undefined" ? spreadsheetId : "" ?>';
const __OWNER_NAME__ = '<?= typeof ownerName !== "undefined" ? ownerName : "" ?>';
const __OPINION_HEADER__ = '<?= typeof opinionHeader !== "undefined" ? opinionHeader : "お題" ?>';
const __SHOW_ADMIN_FEATURES__ = '<?= typeof showAdminFeatures !== "undefined" ? showAdminFeatures : false ?>';
const __SHOW_HIGHLIGHT_TOGGLE__ = '<?= typeof showHighlightToggle !== "undefined" ? showHighlightToggle : false ?>';
const __SHOW_SCORE_SORT__ = '<?= typeof showScoreSort !== "undefined" ? showScoreSort : false ?>';
const __IS_STUDENT_MODE__ = '<?= typeof isStudentMode !== "undefined" ? isStudentMode : true ?>';
const __IS_ADMIN_USER__ = '<?= typeof isAdminUser !== "undefined" ? isAdminUser : false ?>';
window.showCounts = __SHOW_COUNTS__.startsWith('<') ? false : (__SHOW_COUNTS__ === 'true');
window.displayMode = __DISPLAY_MODE__.startsWith('<') ? 'anonymous' : __DISPLAY_MODE__;
window.showAdminFeatures = __SHOW_ADMIN_FEATURES__.startsWith('<') ? false : (__SHOW_ADMIN_FEATURES__ === 'true');
window.showHighlightToggle = __SHOW_HIGHLIGHT_TOGGLE__.startsWith('<') ? false : (__SHOW_HIGHLIGHT_TOGGLE__ === 'true');
window.showScoreSort = __SHOW_SCORE_SORT__.startsWith('<') ? false : (__SHOW_SCORE_SORT__ === 'true');
window.isStudentMode = __IS_STUDENT_MODE__.startsWith('<') ? true : __IS_STUDENT_MODE__ === 'true';
window.isAdminUser = __IS_ADMIN_USER__.startsWith('<') ? false : __IS_ADMIN_USER__ === 'true';
const SHEET_NAME = __SHEET_NAME__.startsWith('<') ? 'テストシート' : __SHEET_NAME__;
const USER_ID = __USER_ID__.startsWith('<') ? '' : __USER_ID__;
const OWNER_NAME = __OWNER_NAME__.startsWith('<') ? '' : __OWNER_NAME__;
let MAPPING;
try {
  if (typeof __MAPPING__ === 'string' && !__MAPPING__.startsWith('<')) {
    MAPPING = JSON.parse(__MAPPING__);
  } else {
    MAPPING = {};
  }
} catch (e) {
  console.warn('Failed to parse MAPPING:', e);
  MAPPING = {};
}
</script>
<script>
// Optimize initial render
const RENDER_BATCH_SIZE = 10;
const VIEWPORT_BUFFER = 200; // Viewport buffer for virtual scrolling
const PERFORMANCE_BUDGET = 16; // Maximum ms per frame
const CHUNK_SIZE = 5; // DOM operations per chunk
const IDLE_TIMEOUT = 5000; // Idle timeout for cleanup
const ICONS = {
  'lightbulb-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6zM9 16.5h6v4H9v-4zm0 1h6zm0 1h6zM10.5 11l.5 2h2l.5-2m-3 1h3"/></svg>',
  'lightbulb-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2V.5M5.25 6.75L4.2 5.7M18.75 6.75l1.05-1.05" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4a6 6 0 00-6 6c0 2.25 1 4.2 2.5 5.34V16.5h7v-1.16A6.002 6.002 0 0018 10a6 6 0 00-6-6z M10.5 11.25 L11 13 L13 13 L13.5 11.25 H 10.5 Z"/><path d="M9 16.5h6v1H9z M9 18h6v1H9z M9 19.5h6v1H9z"/></svg>',
  'hand-thumb-up-outline': '<svg fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.338 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>',
  'hand-thumb-up-solid': '<svg fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z M6.5 10v12h1V10h-1z"/></svg>',
  'magnifying-glass-plus-outline': '<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"/></svg>',
  'magnifying-glass-plus-solid': '<svg viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15z M9.75 7.5v2.25H7.5v1.5h2.25V13.5h1.5v-2.25H13.5v-1.5h-2.25V7.5h-1.5z" fill="currentColor"/><path d="M10.5 18a7.5 7.5 0 100-15 7.5 7.5 0 000 15zM16.5 16.5l4.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  'x': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
  'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star-solid': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'star': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 8.5 22 9.3 17 14 18.2 21 12 17.8 5.8 21 7 14 2 9.3 9 8.5 12 2"/></svg>',
  'grid-2x2': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></svg>',
  'users': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>'
};

class UnifiedCache {
  constructor() {
    this.data = new Map();
    this.timestamps = new Map();
  }
  
  set(key, value, ttl = 300000) { // 5分のデフォルトTTL
    this.data.set(key, value);
    this.timestamps.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (!this.data.has(key)) return undefined;
    
    const expiry = this.timestamps.get(key);
    if (expiry && Date.now() > expiry) {
      this.delete(key);
      return undefined;
    }
    
    return this.data.get(key);
  }
  
  has(key) {
    return this.get(key) !== undefined;
  }
  
  delete(key) {
    this.data.delete(key);
    this.timestamps.delete(key);
  }
  
  clear() {
    this.data.clear();
    this.timestamps.clear();
  }
  
  cleanup() {
    const now = Date.now();
    for (const [key, expiry] of this.timestamps.entries()) {
      if (now > expiry) {
        this.delete(key);
      }
    }
  }
  
  get size() {
    return this.data.size;
  }
}

class StudyQuestApp {
  constructor() {
    this.cache = new UnifiedCache();
    this.weakCache = new WeakMap(); // For DOM element caching
    this.performanceMetrics = { frameTime: 0, domOperations: 0 };
    this.visibilityObserver = null;
    this.resizeObserver = null;
    this.deferredUpdates = new Set();
    this.animationFrameId = null;
    this.idleCallbackId = null;
    this.domFragmentPool = [];
    this.isLowPerformanceMode = true;
    this.elements = {
      body: document.body,
      mainContainer: document.getElementById('main-container'),
      answersContainer: document.getElementById('answers'),
      sizeSlider: document.getElementById('sizeSlider'),
      sliderValue: document.getElementById('sliderValue'),
      headingLabel: document.getElementById('headingLabel'),
      sheetNameText: document.getElementById('sheetNameText'),
      endPublicationBtn: document.getElementById('endPublicationBtn'),
      adminToggleBtn: document.getElementById('adminToggleBtn'),
      answerCount: document.getElementById('answerCount'),
      answerModalContainer: document.getElementById('answerModalContainer'),
      answerModalCloseBtn: document.getElementById('answerModalCloseBtn'),
      answerModalCard: document.getElementById('answerModalCard'),
      modalAnswer: document.getElementById('modalAnswer'),
      modalStudentName: document.getElementById('modalStudentName'),
      modalReactionContainer: document.getElementById('modalReactions'),
      modalFooter: document.getElementById('modalFooter'),
      infoModalContainer: document.getElementById('infoModalContainer'),
      infoModalCard: document.getElementById('infoModalCard'),
      infoModalConfirmBtn: document.getElementById('infoModalConfirmBtn'),
      infoIconLike: document.getElementById('infoIconLike'),
      infoIconUnderstand: document.getElementById('infoIconUnderstand'),
      infoIconCurious: document.getElementById('infoIconCurious'),
      infoIconHighlight: document.getElementById('infoIconHighlight'),
      newContentBanner: document.getElementById('newContentBanner'),
      newContentText: document.getElementById('newContentText'),
      refreshContentBtn: document.getElementById('refreshContentBtn'),
      dismissBannerBtn: document.getElementById('dismissBannerBtn'),
      iconClose: document.getElementById('iconClose'),
      iconGrid: document.getElementById('iconGrid'),
      classFilter: document.getElementById('classFilter'),
      sortOrder: document.getElementById('sortOrder'),
      scoreOption: document.getElementById('scoreOption'),
      footer: document.getElementById('controlsFooter'),
      loadingOverlay: document.getElementById('loading-overlay')
    };
    this.state = {
      currentAnswers: [],
      isLoading: false,
      lastFocusedElement: null,
      isStudentMode: window.isStudentMode,
      isAdminUser: window.isAdminUser,
      showCounts: window.showCounts,
      showAdminFeatures: window.showAdminFeatures,
      showHighlightToggle: window.isAdminUser, // 管理者なら常に表示
      showScoreSort: window.showScoreSort,
      displayMode: window.displayMode,
      sheetName: SHEET_NAME,
      hasNewContent: false,
      newContentCount: 0,
      lastSeenCount: 0,
      pollingFailureCount: 0
    };
    
    debugLog('初期状態設定:', {
      isAdminUser: this.state.isAdminUser,
      windowIsAdminUser: window.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle
    });
    
    // デバッグ機能の動作確認テスト
    debugLog('🛠️ デバッグ機能が有効化されました');
    this.serverShowCounts = window.showCounts;
    this.serverDisplayMode = window.displayMode;
    this.pollingInterval = null;
    this.handlers = {};
    this.adminModeVerified = false; // 管理モード切り替え時の権限確認フラグ
    this.reactionDebounce = new Map(); // リアクションのデバウンス処理用
    this.highlightDebounce = new Map(); // ハイライトのデバウンス処理用
    this.pendingReactions = new Set(); // 処理中のリアクション
    
    // イベントリスナー重複登録防止フラグ
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    this.reactionTypes = [
      { key: 'LIKE', icon: 'hand-thumb-up' },
      { key: 'UNDERSTAND', icon: 'lightbulb' },
      { key: 'CURIOUS', icon: 'magnifying-glass-plus' }
    ];
    this.gas = {
      getPublishedSheetData: (sheetName, classFilter, sort) => this.runGas('getPublishedSheetData', sheetName, classFilter, sort),
      getAvailableSheets: () => this.runGas('getAvailableSheets'),
      addReaction: (rowIndex, reaction, sheetName) => this.runGas('addReaction', rowIndex, reaction, sheetName),
      toggleHighlight: (rowIndex, sheetName) => this.runGas('toggleHighlight', rowIndex, sheetName),
      checkAdmin: () => this.runGas('checkAdmin')
    };
    const savedCols = localStorage.getItem('boardColumns');
    if (savedCols && this.elements.sizeSlider && this.elements.sliderValue) {
      this.elements.sizeSlider.value = savedCols;
      this.elements.sliderValue.textContent = savedCols;
    }
    this.init();
  }
  init() {
      // Critical path only - non-blocking
      this.setupCriticalElements();
      this.showMinimalSkeleton();
      
      // Apply default low performance tweaks
      this.optimizeForLowPerformance();
      
      // Immediate async loading for data
      this.loadDataImmediate();
      
      // Defer all non-critical operations
      requestIdleCallback(() => {
        this.setupNonCriticalEventListeners();
        this.renderIcons();
        this.adjustLayout();
        this.updateSortOptions();
        this.setupObservers();
        // Initial admin state setup - 管理者であっても最初は閲覧モードで起動、切り替えボタンのみ表示
        if (window.isAdminUser) {
          this.state.isAdminUser = true;
          if (this.elements.adminToggleBtn) {
            this.elements.adminToggleBtn.classList.remove('hidden');
            this.elements.adminToggleBtn.removeAttribute('hidden');
            this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
          }
        }
        // Check if modal should be shown
        const introSeen = localStorage.getItem('introSeen');
        
        // Show modal if never seen before
        if (!introSeen) {
          setTimeout(() => this.showInfoModal(), 500);
        }
      }, { timeout: 50 });

      // AdminPanelからのメッセージをリッスン
      window.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'REFRESH_BOARD_DATA') {
          debugLog('REFRESH_BOARD_DATAメッセージを受信しました。ボードを再読み込みします。');
          this.loadSheetData(true);
        }
      });
    }
  setupCriticalElements() {
    if (this.elements.headingLabel) {
      const opinionHeader = __OPINION_HEADER__.startsWith('<')
        ? 'お題を読み込み中...'
        : this.escapeHtml(__OPINION_HEADER__);
      this.elements.headingLabel.textContent = opinionHeader;
    }

    // Only setup absolutely critical event listeners
    this.setupEventDelegation();
    this.handlers.onAnswerModalCloseClick = () => this.hideAnswerModal();
    if (this.elements.answerModalCloseBtn) {
      this.elements.answerModalCloseBtn.addEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    // Size slider for immediate response with throttling
    const debouncedRender = this.debounce(() => this.renderBoard(true), 200);
    this.handlers.onSizeSliderInput = this.throttle((e) => {
      localStorage.setItem('boardColumns', e.target.value);
      debouncedRender();
    }, 100); // Throttle to 100ms
    
    if (this.elements.sizeSlider) {
      this.elements.sizeSlider.addEventListener('input', this.handlers.onSizeSliderInput, { passive: true });
    }
  }
  
  setupNonCriticalEventListeners() {
    // 重複登録防止
    if (this.nonCriticalListenersSetup) {
      debugLog('非クリティカルイベントリスナーは既に設定済み');
      return;
    }
    
    // Modal handlers
    this.handlers.onAnswerModalContainerClick = (e) => {
      if (e.target === e.currentTarget) {
        this.hideAnswerModal();
      }
    };
    if (this.elements.answerModalContainer) {
      this.elements.answerModalContainer.addEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn) {
      this.handlers.onInfoModalConfirmClick = () => this.hideInfoModal();
      this.elements.infoModalConfirmBtn.addEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    this.handlers.onModalReactionClick = (e) => {
      const btn = e.target.closest('.reaction-btn');
      const highlightBtn = e.target.closest('.highlight-btn');
      
      if (highlightBtn) {
        const id = highlightBtn.dataset.rowIndex;
        if (id) {
          this.handleHighlight(id);
        }
      } else if (btn) {
        const id = btn.dataset.rowIndex;
        const reaction = btn.dataset.reaction;
        if (id && reaction) {
          this.handleReaction(id, reaction);
        }
      }
    };
    if (this.elements.modalReactionContainer) {
      this.elements.modalReactionContainer.addEventListener('click', this.handlers.onModalReactionClick);
    }
    this.handlers.onClassFilterChange = () => {
      this.dismissNewContentBanner(); // フィルター変更時は既存の通知を消去
      this.loadSheetData(true).then(() => {
        this.state.lastSeenCount = this.state.currentAnswers.length; // 新しいベースラインを設定
      });
    };
    this.handlers.onSortOrderChange = () => {
      this.dismissNewContentBanner(); // ソート変更時は既存の通知を消去
      this.loadSheetData(true).then(() => {
        this.state.lastSeenCount = this.state.currentAnswers.length; // 新しいベースラインを設定
      });
    };
    if (this.elements.classFilter) {
      this.elements.classFilter.addEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder) {
      this.elements.sortOrder.addEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.endPublicationBtn) {
      this.handlers.onEndPublicationClick = () => this.endPublication();
      this.elements.endPublicationBtn.addEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.adminToggleBtn) {
      this.handlers.onAdminToggleClick = () => this.toggleAdminMode();
      this.elements.adminToggleBtn.addEventListener('click', this.handlers.onAdminToggleClick);
    }
    
    // 新着通知バナーのイベントハンドラー
    if (this.elements.refreshContentBtn) {
      this.handlers.onRefreshContentClick = () => this.refreshContent();
      this.elements.refreshContentBtn.addEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn) {
      this.handlers.onDismissBannerClick = () => this.dismissNewContentBanner();
      this.elements.dismissBannerBtn.addEventListener('click', this.handlers.onDismissBannerClick);
    }
    this.handlers.onDocumentKeydown = (e) => {
      if (e.key === 'Escape') {
        this.hideAnswerModal();
      }
    };
    document.addEventListener('keydown', this.handlers.onDocumentKeydown);
    this.handlers.onWindowResize = this.debounce(() => this.adjustLayout(), 100);
    window.addEventListener('resize', this.handlers.onWindowResize, { passive: true });
    this.handlers.onVisibilityChange = () => {
      if (document.hidden) {
        this.stopPolling();
        // Cleanup when page is hidden
        this.throttledUpdate('hidden-cleanup', () => this.cleanup(), 1000);
      } else {
        this.startPolling();
      }
    };
    document.addEventListener('visibilitychange', this.handlers.onVisibilityChange, { passive: true });
    
    this.nonCriticalListenersSetup = true;
    debugLog('非クリティカルイベントリスナー設定完了');
  }
  /**
 * イベント委譲の設定（安定版の堅牢なロジックを採用）
 * これにより、クリックイベントが他のイベントと競合しなくなります。
 */
setupEventDelegation() {
    // 重複登録防止
    if (this.eventDelegationSetup) {
        debugLog('イベント委譲は既に設定済み');
        return;
    }
    
    this.handlers.onAnswersContainerClick = (e) => {
            target: e.target,
            targetClass: e.target.className,
            targetTag: e.target.tagName,
            currentTarget: e.currentTarget,
            eventType: e.type,
            timestamp: new Date().toISOString()
        });

        const answerCard = e.target.closest('.answer-card');
            answerCard: answerCard,
            cardClass: answerCard?.className,
            cardRowIndex: answerCard?.dataset?.rowIndex,
            isHidden: answerCard?.classList?.contains('hidden-card')
        });

        if (!answerCard || answerCard.classList.contains('hidden-card')) {
            return;
        }

        const rowIndex = answerCard.dataset.rowIndex;
        if (!rowIndex) {
            return;
        }

            rowIndex: rowIndex,
            cardElement: answerCard
        });

        // リアクションボタンのクリックを処理
        const reactionBtn = e.target.closest('.reaction-btn');
        if (reactionBtn) {
                button: reactionBtn,
                reaction: reactionBtn.dataset.reaction,
                disabled: reactionBtn.disabled,
                rowIndex: rowIndex
            });
            e.stopPropagation(); // ★重要: イベントの伝播を止め、カード本体のクリックと分離
            if (!reactionBtn.disabled) {
                this.handleReaction(rowIndex, reactionBtn.dataset.reaction);
            } else {
            }
            return;
        }

        // ハイライトボタンのクリックを処理
        const highlightBtn = e.target.closest('.highlight-btn');
        if (highlightBtn) {
                button: highlightBtn,
                disabled: highlightBtn.disabled,
                rowIndex: rowIndex
            });
            e.stopPropagation(); // ★重要: 同様にイベントの伝播を停止
            if (!highlightBtn.disabled) {
                this.handleHighlight(rowIndex);
            } else {
            }
            return;
        }

        // 上記以外の場合は、カード本体のクリックとしてモーダルを表示
        this.showAnswerModal(rowIndex);
    };

    if (this.elements.answersContainer) {
        // 既存のリスナーをクリアしてから追加
        this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
        this.elements.answersContainer.addEventListener('click', this.handlers.onAnswersContainerClick);
        this.eventDelegationSetup = true;
    } else {
        return Promise.resolve(cached);
      }
    }
    
    debugLog('GAS API呼び出し:', { 
      funcName, 
      argsCount: Array.isArray(args) ? args.length : 'not-array',
      argsPreview: Array.isArray(args) && args.length > 0 ? args.slice(0, 2) : args,
      userId: USER_ID, 
      isStateChanging 
    });
    
    return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        const userId = USER_ID || '';
        debugLog('Google Apps Script環境検出済み、実際にAPI呼び出し実行中...');
        google.script.run
          .withSuccessHandler((result) => {
            debugLog('GAS APIレスポンス受信:', { 
              funcName, 
              argsCount: Array.isArray(args) ? args.length : 'not-array',
              resultType: typeof result,
              resultSize: Array.isArray(result) ? result.length : typeof result === 'object' ? Object.keys(result || {}).length : 'primitive',
              success: true 
            });
            if (!isStateChanging) {
              this.cache.set(cacheKey, result, 1000); // 1秒キャッシュ
            }
            resolve(result);
          })
          .withFailureHandler((error) => {
            console.error('GAS APIエラー受信:', { funcName, args, error, success: false });
            reject(error);
          })
          .withUserObject({ userId: userId })
          [funcName](...args);
      } else {
        console.warn('Google Apps Script environment not detected.');
        this.getMockData(funcName, ...args).then((result) => {
          debugLog('モックデータ取得:', { funcName, result });
          if (!isStateChanging) {
            this.cache.set(cacheKey, result, 1000); // 1秒キャッシュ
          }
          resolve(result);
        }).catch(reject);
      }
    });
  }
  async verifyAdminAsync() {
    // Use server-provided flag first (fast)
    if (window.isAdminUser) {
      this.state.isAdminUser = true;
      this.state.showHighlightToggle = true; // 管理者なら常に表示
      debugLog('管理者権限確認済み、ハイライトトグル有効化:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle
      });
      this.updateAdminButtonUI();
      this.updateEndPublicationButtonUI();
      return;
    }
    
    // Fallback API call (slower)
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (isAdmin) {
        window.isAdminUser = true;
        this.state.isAdminUser = true;
        this.state.showHighlightToggle = true; // 管理者なら常に表示
        debugLog('API管理者権限確認済み、ハイライトトグル有効化:', {
          isAdminUser: this.state.isAdminUser,
          showHighlightToggle: this.state.showHighlightToggle
        });
        this.updateAdminButtonUI();
        this.updateEndPublicationButtonUI();
      }
    } catch (e) {
      console.error('Admin check failed', e);
    }
  }
  
  // 管理者UI更新の共通メソッド
  updateAdminButtonUI() {
    if (this.elements.adminToggleBtn) {
      this.elements.adminToggleBtn.classList.remove('hidden');
      this.elements.adminToggleBtn.removeAttribute('hidden');
      this.elements.adminToggleBtn.textContent = this.state.showAdminFeatures ? '閲覧モード' : '管理モード';
    }
  }
  
  updateEndPublicationButtonUI() {
    if (this.elements.endPublicationBtn) {
      if (this.state.showAdminFeatures) {
        this.elements.endPublicationBtn.classList.remove('hidden');
        this.elements.endPublicationBtn.removeAttribute('hidden');
      } else {
        this.elements.endPublicationBtn.classList.add('hidden');
        this.elements.endPublicationBtn.setAttribute('hidden', '');
      }
    }
  }
  
  // サーバー管理者権限確認の共通メソッド
  async checkServerAdminPermission() {
    try {
      const isAdmin = await this.gas.checkAdmin();
      if (!isAdmin) {
        throw new Error('サーバー側で管理者権限が確認できませんでした');
      }
      return true;
    } catch (error) {
      console.error('管理者権限確認エラー:', error);
      throw error;
    }
  }
  
  // 新着コンテンツチェック（表示は更新しない）
  async checkForNewContent() {
    try {
      const selectedClass = this.elements.classFilter ? this.elements.classFilter.value : 'すべて';
      const sortOrder = this.elements.sortOrder.value;
      const data = await     this.gas.getPublishedSheetData(selectedClass, sortOrder);
      
      // 成功した場合は失敗カウントをリセット
      this.state.pollingFailureCount = 0;
      
      const newCount = data.data ? data.data.length : 0;
      if (newCount > this.state.lastSeenCount && this.state.lastSeenCount > 0) {
        const newItems = newCount - this.state.lastSeenCount;
        this.showNewContentBanner(newItems);
        debugLog('新着コンテンツ検出:', { 
          newItems, 
          newCount, 
          lastSeenCount: this.state?.lastSeenCount || 0 
        });
      }
    } catch (error) {
      this.state.pollingFailureCount++;
      console.warn('新着チェックに失敗:', error, 'failureCount:', this.state.pollingFailureCount);
      
      // 連続で失敗が続く場合はポーリング間隔を延ばす
      if (this.state.pollingFailureCount >= 3) {
        debugLog('連続失敗によりポーリング間隔を延長');
        this.stopPolling();
        setTimeout(() => {
          this.startPolling();
        }, 5000); // 5秒後に再開
        this.state.pollingFailureCount = 0;
      }
    }
  }
  
  // 新着通知バナーを表示
  showNewContentBanner(newItems) {
    if (!this.elements.newContentBanner) return;
    
    // 既に表示されている場合は内容のみ更新
    if (!this.elements.newContentBanner.classList.contains('hidden')) {
      this.state.newContentCount += newItems;
      const totalItems = this.state.newContentCount;
      const message = totalItems === 1 ? '新しい意見が投稿されました' : `${totalItems}件の新しい意見が投稿されました`;
      this.elements.newContentText.textContent = message;
      return;
    }
    
    this.state.hasNewContent = true;
    this.state.newContentCount = newItems;
    
    const message = newItems === 1 ? '新しい意見が投稿されました' : `${newItems}件の新しい意見が投稿されました`;
    this.elements.newContentText.textContent = message;
    
    this.elements.newContentBanner.classList.remove('hidden');
    
    // 自動的に3秒後にアニメーション効果を追加
    setTimeout(() => {
      if (!this.elements.newContentBanner.classList.contains('hidden')) {
        this.elements.newContentBanner.style.animation = 'bounce 1s ease-in-out';
      }
    }, 3000);
  }
  
  // 新着バナーを閉じる
  dismissNewContentBanner() {
    if (!this.elements.newContentBanner) return;
    
    this.elements.newContentBanner.classList.add('hidden');
    this.elements.newContentBanner.style.animation = '';
    this.state.hasNewContent = false;
    this.state.newContentCount = 0;
  }
  
  // コンテンツを更新（手動）
  async refreshContent() {
    this.dismissNewContentBanner();
    
    try {
      await this.loadSheetData(true, false);
      this.state.lastSeenCount = this.state.currentAnswers.length;
      
      // 軽い成功フィードバック
      if (this.elements.refreshContentBtn) {
        const originalText = this.elements.refreshContentBtn.textContent;
        this.elements.refreshContentBtn.textContent = '更新完了！';
        this.elements.refreshContentBtn.style.background = 'rgba(16, 185, 129, 0.3)';
        setTimeout(() => {
          this.elements.refreshContentBtn.textContent = originalText;
          this.elements.refreshContentBtn.style.background = '';
        }, 2000);
      }
    } catch (error) {
      console.error('コンテンツ更新に失敗:', error);
      
      // エラーフィードバック
      if (this.elements.refreshContentBtn) {
        const originalText = this.elements.refreshContentBtn.textContent;
        this.elements.refreshContentBtn.textContent = '更新失敗';
        this.elements.refreshContentBtn.style.background = 'rgba(239, 68, 68, 0.3)';
        setTimeout(() => {
          this.elements.refreshContentBtn.textContent = originalText;
          this.elements.refreshContentBtn.style.background = '';
        }, 2000);
      }
    }
  }
  
  getMockData(funcName, ...args) {
    return new Promise((resolve) => {
      setTimeout(() => {
        if (funcName === 'getPublishedSheetData') {
          const currentDisplayMode = window.displayMode || this.state.displayMode;
          const studentName1 = currentDisplayMode === 'named' ? '田中太郎' : '';
          const studentName2 = currentDisplayMode === 'named' ? '佐藤花子' : '';
          resolve({
            header: 'テスト問題',
            sheetName: 'テストシート',
            data: [
              {
                rowIndex: 1,
                name: studentName1,
                class: '3年A組',
                opinion: 'これは素晴らしいアイデアだと思います。',
                reason: '理由は簡潔で分かりやすく、実現可能性が高いからです。',
                reactions: {
                  UNDERSTAND: { count: 5, reacted: false },
                  LIKE: { count: 2, reacted: false },
                  CURIOUS: { count: 1, reacted: false }
                },
                highlight: false
              },
              {
                rowIndex: 2,
                name: studentName2,
                class: '3年B組',
                opinion: '少し改善の余地があると考えます。',
                reason: 'より多くの人の意見を聞く必要があると思います。',
                reactions: {
                  UNDERSTAND: { count: 3, reacted: true },
                  LIKE: { count: 0, reacted: false },
                  CURIOUS: { count: 0, reacted: false }
                },
                highlight: true
              }
            ]
          });
        } else if (funcName === 'addReaction') {
          resolve({
            status: 'ok',
            reactions: {
              UNDERSTAND: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              LIKE: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 },
              CURIOUS: { count: Math.floor(Math.random() * 5), reacted: Math.random() < 0.5 }
            }
          });
        } else if (funcName === 'toggleHighlight') {
          const currentHighlight = args[2] === undefined ? false : !args[2];
          resolve({
            status: 'ok',
            highlight: currentHighlight
          });
        } else if (funcName === 'checkAdmin') {
          resolve(true);
        }
      }, 300);
    });
  }
  startPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    
    const pollInterval = this.isLowPerformanceMode ? 30000 : 15000;
    // 新着チェックのみ実行、自動更新はしない
    this.pollingInterval = setInterval(() => this.checkForNewContent(), pollInterval);
    
    // Start automatic cleanup for memory management
    this.cleanupInterval = setInterval(() => {
      this.cache.cleanup();
    }, 5 * 60 * 1000); // Cleanup every 5 minutes
  }
  stopPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
  destroy() {
    this.stopPolling();
    this.cleanup();
    if (this.elements.sizeSlider && this.handlers.onSizeSliderInput) {
      this.elements.sizeSlider.removeEventListener('input', this.handlers.onSizeSliderInput);
    }
    if (this.elements.answerModalCloseBtn && this.handlers.onAnswerModalCloseClick) {
      this.elements.answerModalCloseBtn.removeEventListener('click', this.handlers.onAnswerModalCloseClick);
    }
    if (this.elements.answerModalContainer && this.handlers.onAnswerModalContainerClick) {
      this.elements.answerModalContainer.removeEventListener('click', this.handlers.onAnswerModalContainerClick);
    }
    if (this.elements.infoModalConfirmBtn && this.handlers.onInfoModalConfirmClick) {
      this.elements.infoModalConfirmBtn.removeEventListener('click', this.handlers.onInfoModalConfirmClick);
    }
    if (this.elements.modalReactionContainer && this.handlers.onModalReactionClick) {
      this.elements.modalReactionContainer.removeEventListener('click', this.handlers.onModalReactionClick);
    }
    if (this.elements.classFilter && this.handlers.onClassFilterChange) {
      this.elements.classFilter.removeEventListener('change', this.handlers.onClassFilterChange);
    }
    if (this.elements.sortOrder && this.handlers.onSortOrderChange) {
      this.elements.sortOrder.removeEventListener('change', this.handlers.onSortOrderChange);
    }
    if (this.elements.adminToggleBtn && this.handlers.onAdminToggleClick) {
      this.elements.adminToggleBtn.removeEventListener('click', this.handlers.onAdminToggleClick);
    }
    if (this.handlers.onDocumentKeydown) {
      document.removeEventListener('keydown', this.handlers.onDocumentKeydown);
    }
    if (this.handlers.onWindowResize) {
      window.removeEventListener('resize', this.handlers.onWindowResize);
    }
    if (this.handlers.onVisibilityChange) {
      document.removeEventListener('visibilitychange', this.handlers.onVisibilityChange);
    }
    if (this.elements.answersContainer && this.handlers.onAnswersContainerClick) {
      this.elements.answersContainer.removeEventListener('click', this.handlers.onAnswersContainerClick);
    }
    if (this.handlers.onDocumentClick) {
      document.removeEventListener('click', this.handlers.onDocumentClick);
    }
    // Cleanup observers
    if (this.visibilityObserver) {
      this.visibilityObserver.disconnect();
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    // Cancel any pending callbacks
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.idleCallbackId) {
      cancelIdleCallback(this.idleCallbackId);
    }
    // 漏れていたイベントリスナーの削除
    if (this.elements.refreshContentBtn && this.handlers.onRefreshContentClick) {
      this.elements.refreshContentBtn.removeEventListener('click', this.handlers.onRefreshContentClick);
    }
    if (this.elements.dismissBannerBtn && this.handlers.onDismissBannerClick) {
      this.elements.dismissBannerBtn.removeEventListener('click', this.handlers.onDismissBannerClick);
    }
    if (this.elements.endPublicationBtn && this.handlers.onEndPublicationClick) {
      this.elements.endPublicationBtn.removeEventListener('click', this.handlers.onEndPublicationClick);
    }
    if (this.elements.sheetSelector && this.handlers.onSheetSelectorChange) {
      this.elements.sheetSelector.removeEventListener('change', this.handlers.onSheetSelectorChange);
    }
    
    // イベントリスナー設定フラグのリセット
    this.eventDelegationSetup = false;
    this.nonCriticalListenersSetup = false;
    this.modalOperationPending = false;
    
    // Clear caches
    this.cache.clear();
    this.deferredUpdates.clear();
    this.domFragmentPool.length = 0;
    
    debugLog('アプリケーションのクリーンアップ完了');
  }
  async loadDataImmediate() {
    try {
      // Verify admin first to ensure proper initialization
      await this.verifyAdminAsync();
      
      // Start loading immediately without waiting
      this.loadSheetData(false, true).then(() => {
        this.startPolling();
      }).catch(error => {
        console.error('Error in loadSheetData:', error);
        this.hideLoadingOverlay();
        this.displayEmptyState();
      });
      
      // Load sheets in background
      this.loadAvailableSheets();
    } catch (error) {
      console.error('Error in loadDataImmediate:', error);
      this.hideLoadingOverlay();
      this.displayEmptyState();
    }
  }
  
  showMinimalSkeleton() {
    // Show only 3 skeletons for immediate visual feedback
    const count = 3;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      frag.appendChild(this.createSkeletonCard());
    }
    this.elements.answersContainer.appendChild(frag);
  }

  displayEmptyState() {
    const container = this.elements.answersContainer;
    if (!container) return;
    
    container.innerHTML = `
      <div class="text-center py-16 px-6 col-span-full">
        <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
        <h3 class="mt-2 text-lg font-medium text-white">まだ回答がありません</h3>
        <p class="mt-1 text-sm text-gray-400">最初の回答者になりましょう！</p>
      </div>
    `;
  }

  // Add these two methods
  showLoadingOverlay() {
    if (this.elements.loadingOverlay) {
      this.elements.loadingOverlay.classList.remove('hidden');
    }
  }

  hideLoadingOverlay() {
    if (this.elements.loadingOverlay) {
      this.elements.loadingOverlay.classList.add('hidden');
    }
  }

  async loadSheetData(showLoading = true, isInitialLoad = false, requestedSheetName = null) {
    if (this.state.isLoading && showLoading) return;
    this.state.isLoading = true;
    this.showLoadingOverlay(); // Add this line

    const selectedClass = isInitialLoad ? 'すべて' : (this.elements.classFilter ? this.elements.classFilter.value : 'すべて');
    const oldAnswers = [...this.state.currentAnswers];
    
    // Show immediate visual feedback
    if (isInitialLoad) {
      this.elements.headingLabel.innerHTML = '<svg class="w-6 h-6 animate-spin inline-block" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" fill="currentColor"></path></svg>';
    }
    
    // Optimized loading state - don't clear if initial load
    if (showLoading && !isInitialLoad) {
      const count = Math.min(parseInt(this.elements.sizeSlider.value, 10) * 2, 8); // Cap at 8
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        frag.appendChild(this.createSkeletonCard());
      }
      const container = this.elements.answersContainer;
      container.className = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      container.innerHTML = '';
      container.appendChild(frag);
    }
    try {
      const sortOrder = this.elements.sortOrder.value;
      const classFilter = isInitialLoad ? 'すべて' : (this.elements.classFilter ? this.elements.classFilter.value : 'すべて');
      
      // Add timeout to prevent infinite loading
      const timeoutId = setTimeout(() => {
        console.error('Sheet data loading timed out');
        this.hideLoadingOverlay();
        this.displayEmptyState();
      }, 10000); // 10 second timeout

      google.script.run
        .withSuccessHandler(result => {
          clearTimeout(timeoutId);
          this.state.isLoading = false;
          this.hideLoadingOverlay();
          
          if (!result || !result.data || result.data.length === 0) {
            this.displayEmptyState();
            if (isInitialLoad) {
              this.state.lastSeenCount = 0;
            }
            return;
          }

          this.state.currentAnswers = result.data;
          
          if (isInitialLoad) {
            this.state.lastSeenCount = result.data.length;
          }

          // Update heading with the actual question text from server
          if (result.header && this.elements.headingLabel) {
            this.elements.headingLabel.textContent = result.header;
          }

          this.renderBoard(false);
        })
        .withFailureHandler(error => {
          clearTimeout(timeoutId);
          console.error('Error loading sheet data:', error);
          this.state.isLoading = false;
          this.hideLoadingOverlay();
          this.displayEmptyState();
        })
        .getPublishedSheetData(classFilter, sortOrder);
      
      
      // Post-processing after successful data load
      this.adjustLayout();
      
      if (!this.state.isAdminUser) {
        this.state.showAdminFeatures = false;
        this.state.showHighlightToggle = false;
      } else {
        this.state.showHighlightToggle = true;
        debugLog('loadSheetData管理者設定更新:', {
          isAdminUser: this.state.isAdminUser,
          showAdminFeatures: this.state.showAdminFeatures,
          showHighlightToggle: this.state.showHighlightToggle
        });
        this.cache.clear();
        debugLog('管理者ハイライト設定によりキャッシュクリア実行');
      }
      
      if (isInitialLoad) {
        this.elements.answersContainer.classList.add('render-optimized');
      }
    } catch (error) {
      console.error('Error loading sheet data:', error);
      const errorMessage = this.escapeHtml(error.message || 'Unknown error');
      this.elements.answersContainer.querySelectorAll('.skeleton').forEach(el => el.remove());
      this.elements.answersContainer.innerHTML = '<div class="text-center text-red-400 col-span-full mt-8 p-4 bg-red-900/20 rounded-lg">' + '<p class="font-bold">データの読み込みに失敗しました。</p>' + '<p class="text-sm mt-2">' + errorMessage + '</p>' + '<button id="retryLoadBtn" class="mt-4 game-btn bg-cyan-600 text-white px-4 py-2 rounded-lg font-bold border-cyan-800 hover:bg-cyan-500 text-sm">再試行</button>' + '</div>';
    } finally {
      // Loading state is now managed in success/failure handlers
    }
  }
  async loadAvailableSheets() {
    try {
      const sheetsData = await this.gas.getAvailableSheets();
      this.populateSheetSelector(sheetsData);
    } catch (error) {
      console.error('Failed to load available sheets:', error);
      if (this.elements.sheetSelector) {
        this.elements.sheetSelector.innerHTML = '<option value="">エラー: シート読み込み失敗</option>';
      }
    }
  }
  populateSheetSelector(sheets) {
    const selector = this.elements.sheetSelector;
    
    if (!selector) return;

    if (!sheets || sheets.length === 0) {
      selector.innerHTML = '<option value="">利用可能なシートがありません</option>';
      selector.disabled = true;
      return;
    }
    
    // シート選択肢を構築
    if (!Array.isArray(sheets)) {
      console.error('Invalid sheets data:', sheets);
      selector.innerHTML = '<option>シートデータが無効です</option>';
      selector.disabled = true;
      return;
    }
    
    const options = sheets.map(sheet => {
      const selected = sheet.name === this.state.sheetName ? 'selected' : ''; // Use sheet.name for comparison
      const activeLabel = sheet.name === this.state.sheetName ? ' (現在のアクティブシート)' : '';
      return `<option value="${this.escapeHtml(sheet.name)}" ${selected}>${this.escapeHtml(sheet.name)}${activeLabel}</option>`;
    }).join('');
    
    selector.innerHTML = options;
    selector.disabled = false;
    
    // 現在のアクティブシートを記録
    // this.state.currentActiveSheet is already set by loadSheetData
  }
  async switchSheet() {
    const selectedSheet = this.elements.sheetSelector.value;
    if (!selectedSheet || selectedSheet === this.state.currentActiveSheet) {
      return;
    }
    
    try {
      // 新しいシートのデータを読み込み
      await this.loadSheetData(true, false, selectedSheet);
      this.state.currentActiveSheet = selectedSheet;
      
      // UIを更新
      this.updateSheetSelectorLabels();
    } catch (error) {
      console.error('Failed to switch sheet:', error);
      // エラー時は元のシートに戻す
      this.elements.sheetSelector.value = this.state.currentActiveSheet || '';
    }
  }
  updateSheetSelectorLabels() {
    const selector = this.elements.sheetSelector;
    const options = Array.from(selector.options);
    
    options.forEach(option => {
      const sheetName = option.value;
      const isActive = sheetName === this.state.currentActiveSheet;
      const cleanName = sheetName.replace(/ \(現在のアクティブシート\)$/, '');
      
      if (isActive) {
        option.textContent = `${cleanName} (現在のアクティブシート)`;
      } else {
        option.textContent = cleanName;
      }
    });
  }
  populateClassFilter(rows) {
    const classFilter = this.elements.classFilter;
    // Ensure rows is an array before mapping
    const uniqueClasses = ['すべて', ...new Set(Array.isArray(rows) ? rows.map(r => r.class).filter(Boolean) : [])];
    classFilter.innerHTML = uniqueClasses.map(c => '<option value="' + this.escapeHtml(c) + '">' + this.escapeHtml(c) + '</option>').join('');
    classFilter.value = 'すべて';
    classFilter.classList.remove('hidden');
  }
  applyReactionStyles(element, data) {
    if (!element || !data) return;
    
    // 既存のリアクション関連クラスをクリア
    const reactionClasses = [
      'reaction-bg-like', 'reaction-bg-understand', 'reaction-bg-curious',
      'reaction-bg-like-understand', 'reaction-bg-like-curious', 'reaction-bg-understand-curious',
      'reaction-bg-like-understand-curious', 'reaction-border-1', 'reaction-border-2', 'reaction-border-3',
      'highlighted'
    ];
    reactionClasses.forEach(cls => element.classList.remove(cls));
    
    // ハイライト状態を適用（リアクション装飾より優先）
    if (data.highlight) {
      element.classList.add('highlighted');
      debugLog('ハイライト装飾適用:', { rowIndex: data.rowIndex, element: element.tagName, highlight: data.highlight });
      // ハイライト時はリアクション装飾をスキップ
      return;
    } else {
      debugLog('ハイライト装飾なし:', { rowIndex: data.rowIndex, element: element.tagName, highlight: data.highlight });
    }
    
    // アクティブなリアクションを特定
    const active = this.reactionTypes.filter(rt => 
      data.reactions && data.reactions[rt.key] && data.reactions[rt.key].count > 0
    ).map(rt => rt.key);
    
    // 背景色クラスを適用
    if (active.length === 1) {
      if (active[0] === 'LIKE') element.classList.add('reaction-bg-like');
      else if (active[0] === 'UNDERSTAND') element.classList.add('reaction-bg-understand');
      else if (active[0] === 'CURIOUS') element.classList.add('reaction-bg-curious');
    } else if (active.length === 2) {
      const sorted = active.sort();
      if (sorted[0] === 'CURIOUS' && sorted[1] === 'LIKE') element.classList.add('reaction-bg-like-curious');
      else if (sorted[0] === 'LIKE' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-like-understand');
      else if (sorted[0] === 'CURIOUS' && sorted[1] === 'UNDERSTAND') element.classList.add('reaction-bg-understand-curious');
    } else if (active.length === 3) {
      element.classList.add('reaction-bg-like-understand-curious');
    }
    
    // ボーダー幅を適用
    const totalReactions = this.reactionTypes.reduce((sum, rt) => sum + (data.reactions?.[rt.key]?.count || 0), 0);
    if (totalReactions >= 10) {
      element.classList.add('reaction-border-3');
    } else if (totalReactions >= 5) {
      element.classList.add('reaction-border-2');
    } else if (totalReactions > 0) {
      element.classList.add('reaction-border-1');
    }
  }
  renderBoard(isLayoutChange = false, oldRows = []) {
    // 管理者の場合はハイライトトグルを確実に有効化
    if (this.state.isAdminUser && !this.state.showHighlightToggle) {
      this.state.showHighlightToggle = true;
      debugLog('renderBoard中にハイライトトグル強制有効化:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle
      });
      // ハイライトトグル設定が変更されたのでキャッシュをクリア
      this.cache.clear();
      debugLog('renderBoard: ハイライト設定変更によりキャッシュクリア実行');
    }
    
    const container = this.elements.answersContainer;
    container.querySelectorAll('.skeleton').forEach(el => el.remove());
    const newRows = this.state.currentAnswers;
    
    // Batch DOM updates using performance-aware batching
    const updates = [];
    if (this.elements.sliderValue && this.elements.sizeSlider && 
        this.elements.sliderValue.textContent !== this.elements.sizeSlider.value) {
      updates.push(() => this.elements.sliderValue.textContent = this.elements.sizeSlider.value);
    }
    if (this.elements.sizeSlider) {
      const newClassName = 'grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-' + this.elements.sizeSlider.value;
      if (container.className !== newClassName) {
        updates.push(() => container.className = newClassName);
      }
    }
    if (this.elements.answerCount) {
      const userIcon = this.getIcon('users', 'w-4 h-4 inline-block -mt-1');
      const countHtml = userIcon + '<span>' + newRows.length + '件</span>';
      if (this.elements.answerCount.innerHTML !== countHtml) {
        updates.push(() => this.elements.answerCount.innerHTML = countHtml);
      }
    }
    
    // Apply updates using performance-aware batching
    this.batchDOMUpdates(updates);
    
    if (newRows.length === 0) {
      if (!container.querySelector('.no-answers')) {
        container.innerHTML = '';
        const p = document.createElement('p');
        p.className = 'text-center text-gray-500 col-span-full mt-8 no-answers';
        p.textContent = 'このクラスの回答はありません。';
        container.appendChild(p);
      }
    } else {
      const existingMap = new Map();
      container.querySelectorAll('.answer-card').forEach(card => {
        existingMap.set(card.dataset.rowIndex, card);
      });
      existingMap.forEach((card, id) => {
        if (!newRows.some(r => String(r.rowIndex) === id)) {
          card.remove();
          existingMap.delete(id);
        }
      });
      const changedItems = [];
      let prevNode = null;
      // Enhanced batch processing with virtual scrolling for large datasets
      if (newRows.length > RENDER_BATCH_SIZE) {
        this.renderWithVirtualScrolling(newRows, oldRows, container, existingMap, changedItems);
      } else {
        // Process small datasets normally
        const fragment = this.getReusableFragment();
        
        newRows.forEach((row) => {
          const rowId = String(row.rowIndex);
          let card = existingMap.get(rowId);
          const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);
          
          if (!card) {
            card = this.createAnswerCard(row);
            card.classList.add('new-card');
            
            // Add to visibility observer
            if (this.visibilityObserver) {
              this.visibilityObserver.observe(card);
            }
            
            changedItems.push(row);
          } else {
            this.updateExistingCard(card, row, oldData, changedItems);
          }
          
          if (prevNode) {
            fragment.appendChild(card);
          } else {
            fragment.insertBefore(card, fragment.firstChild);
          }
          prevNode = card;
        });
        
        // Append fragment to container
        if (fragment.children.length > 0) {
          container.appendChild(fragment);
        }
        
        // Recycle fragment
        this.recycleFragment(fragment);
      }
      // Defer updates for better performance
      if (changedItems.length) {
        this.deferredRender(() => this.applyUpdates(changedItems));
      }
    }
  }
  
  renderWithVirtualScrolling(newRows, oldRows, container, existingMap, changedItems) {
    const batchSize = this.isLowPerformanceMode ? CHUNK_SIZE : RENDER_BATCH_SIZE;
    let currentIndex = 0;
    let prevNode = null;
    
    const processBatch = () => {
      const startTime = performance.now();
      const endIndex = Math.min(currentIndex + batchSize, newRows.length);
      const batch = newRows.slice(currentIndex, endIndex);
      
      // Use document fragment for efficient DOM manipulation
      const fragment = this.getReusableFragment();
      
      batch.forEach((row) => {
        const rowId = String(row.rowIndex);
        let card = existingMap.get(rowId);
        const oldData = oldRows.find(r => r.rowIndex === row.rowIndex);
        
        if (!card) {
          card = this.createAnswerCard(row);
          card.classList.add('new-card');
          
          // Add to visibility observer for virtual scrolling
          if (this.visibilityObserver) {
            this.visibilityObserver.observe(card);
          }
          
          changedItems.push(row);
        } else {
          this.updateExistingCard(card, row, oldData, changedItems);
        }
        
        if (prevNode) {
          fragment.appendChild(card);
        } else {
          fragment.insertBefore(card, fragment.firstChild);
        }
        prevNode = card;
      });
      
      // Append fragment to container
      if (fragment.children.length > 0) {
        container.appendChild(fragment);
      }
      
      // Recycle fragment
      this.recycleFragment(fragment);
      
      currentIndex = endIndex;
      
      // Continue processing if there are more items
      if (currentIndex < newRows.length) {
        const elapsed = performance.now() - startTime;
        
        if (elapsed < PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
          // Continue synchronously if we have time budget
          processBatch();
        } else {
          // Defer to next frame/idle callback
          this.deferredRender(processBatch);
        }
      }
    };
    
    processBatch();
  }
  
  updateExistingCard(card, row, oldData, changedItems) {
    if (oldData) {
      let hasChanges = false;
      
      if (oldData.opinion !== row.opinion) {
        const t = card.querySelector('.opinion-text');
        if (t) {
          t.textContent = row.opinion;
          hasChanges = true;
        }
      }
      
      if (oldData.reason !== row.reason) {
        const p = card.querySelector('.answer-preview p');
        if (p) {
          p.textContent = row.reason;
          hasChanges = true;
        }
      }
      
      if (oldData.name !== row.name) {
        const n = card.querySelector('.font-bold');
        if (n) {
          n.textContent = row.name;
          hasChanges = true;
        }
      }
      
      if (JSON.stringify(oldData.reactions) !== JSON.stringify(row.reactions) || 
          oldData.highlight !== row.highlight) {
        hasChanges = true;
      }
      
      if (hasChanges) {
        changedItems.push(row);
      }
    }
  }
  createAnswerCard(data) {
    // Check cache first for unchanged data
    const cacheKey = JSON.stringify({
      rowIndex: data.rowIndex,
      opinion: data.opinion,
      reason: data.reason,
      name: data.name,
      reactions: data.reactions,
      highlight: data.highlight,
      showCounts: this.state.showCounts,
      displayMode: this.state.displayMode,
      showHighlightToggle: this.state.showHighlightToggle
    });
    
    debugLog('createAnswerCard キャッシュチェック:', {
      rowIndex: data.rowIndex,
      cacheKey: cacheKey.substring(0, 100) + '...',
      showHighlightToggle: this.state.showHighlightToggle,
      hasCachedCard: !!this.cache.get(`render-${cacheKey}`)
    });
    
    const cachedCard = this.cache.get(`render-${cacheKey}`);
    if (cachedCard) {
      const clonedCard = cachedCard.cloneNode(true);
      // Ensure cloned card has proper data-row-index
      clonedCard.dataset.rowIndex = data.rowIndex;
      
      // Ensure all child elements with data-row-index are updated
      const elementsWithRowIndex = clonedCard.querySelectorAll('[data-row-index]');
      elementsWithRowIndex.forEach(element => {
        element.dataset.rowIndex = data.rowIndex;
      });
      
      debugLog('キャッシュされたカードを使用:', { 
        rowIndex: data.rowIndex,
        cachedCardDataset: cachedCard.dataset,
        clonedCardDataset: clonedCard.dataset,
        hasAnswerCardClass: clonedCard.className.includes('answer-card'),
        updatedChildElements: elementsWithRowIndex.length
      });
      return clonedCard;
    }
    
    const card = document.createElement('div');
    const highlightClass = data.highlight ? ' highlighted' : '';
    card.className = 'relative answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 cursor-pointer' + highlightClass;
    card.dataset.rowIndex = data.rowIndex;
    card.setAttribute('role', 'article');
    card.setAttribute('tabindex', '0');
    card.setAttribute('aria-label', '回答カード: ' + (data.opinion || '').substring(0, 50) + (data.opinion && data.opinion.length > 50 ? '...' : ''));
    
    debugLog('Created answer card with rowIndex:', {
      rowIndex: data.rowIndex,
      rowIndexType: typeof data.rowIndex,
      datasetRowIndex: card.dataset.rowIndex,
      cardClassName: card.className,
      hasAnswerCardClass: card.className.includes('answer-card')
    });
    let highlightBtnHtml = '';
    debugLog('createCard ハイライトボタン条件チェック:', {
      rowIndex: data.rowIndex,
      showHighlightToggle: this.state.showHighlightToggle,
      isAdminUser: this.state.isAdminUser,
      condition: this.state.showHighlightToggle
    });
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
      debugLog('カードハイライトボタン作成:', { 
        rowIndex: data.rowIndex, 
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        isAdminUser: this.state.isAdminUser,
        windowIsAdminUser: window.isAdminUser,
        showAdminFeatures: this.state.showAdminFeatures,
        highlight: data.highlight
      });
    } else {
      debugLog('カードハイライトボタンをスキップ:', { 
        rowIndex: data.rowIndex, 
        showHighlightToggle: this.state.showHighlightToggle,
        windowShowHighlightToggle: window.showHighlightToggle,
        isAdminUser: this.state.isAdminUser,
        windowIsAdminUser: window.isAdminUser,
        showAdminFeatures: this.state.showAdminFeatures
      });
    }
    const showName = this.state.displayMode === 'named';
    let displayName = '';
    
    if (showName) {
      // 名前が利用可能な場合はそれを使用、なければemailから生成
      if (data.name) {
        displayName = data.name;
      } else if (data.email) {
        displayName = data.email.split('@')[0];
      }
      
    }
    
    const nameHtml = showName && displayName ? '<div><span class="font-bold text-sm text-gray-200">' + this.escapeHtml(displayName) + '</span></div>' : '';
    const containerClass = nameHtml ? 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-between items-center' : 'text-xs text-gray-400 pt-3 border-t-2 border-cyan-400/80 border-dashed flex justify-end items-center';
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions ? data.reactions[rt.key] : { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-lg text-gray-200" aria-hidden="true">' + (info.count || 0) + '</span>' : '';
      const reactionNames = { 'LIKE': 'いいね！', 'UNDERSTAND': 'なるほど！', 'CURIOUS': 'もっと知りたい！' };
      const reactionName = reactionNames[rt.key] || rt.key;
      const ariaLabel = `${reactionName}${info.reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${info.count || 0}件)` : ''}`;
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1 ' + colorClass + ' ' + cls + '" data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + ariaLabel + '" aria-pressed="' + info.reacted + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    card.innerHTML = '<div class="relative flex-grow mb-3 answer-preview">' + '<h3 class="opinion-text text-cyan-200 whitespace-pre-wrap break-words text-xl md:text-2xl font-semibold leading-tight">' + this.escapeHtml(data.opinion || '') + '</h3>' + '<p class="text-gray-100 whitespace-pre-wrap break-words mt-4">' + this.escapeHtml(data.reason || '') + '</p>' + '</div>' + '<div class="' + containerClass + '">' + nameHtml + '<div class="flex items-center gap-1" role="group" aria-label="回答への反応">' + reactionButtonsHtml + highlightBtnHtml + '</div>' + '</div>';
    if (data.highlight) {
      const badge = document.createElement('span');
      badge.className = 'highlight-badge';
      badge.innerHTML = this.getIcon('star', '', true);
      card.appendChild(badge);
    }
    
    // 統一されたリアクションスタイルを適用
    this.applyReactionStyles(card, data);
    
    // Cache the card for reuse (limit cache size)
    if (this.cache.size > 100) {
      this.cache.cleanup();
    }
    this.cache.set(`render-${cacheKey}`, card.cloneNode(true));
    
    return card;
  }
  createSkeletonCard() {
    const card = document.createElement('div');
    card.className = 'answer-card glass-panel rounded-xl p-4 flex flex-col justify-between shadow-lg border-2 border-cyan-400/80 skeleton';
    // Simplified skeleton for faster rendering
    card.innerHTML = '<div class="h-20 w-full rounded bg-gray-500/30 mb-4"></div><div class="h-6 w-full rounded bg-gray-500/20"></div>';
    return card;
  }
  /**
 * リアクション処理（連続クリック防止機能＋安定化されたUI更新）
 */
/**
 * リアクション処理（連続クリック防止機能＋安定化されたUI更新）
 */
async handleReaction(rowIndex, reaction) {
    console.log('🎯 [REACTION DEBUG] handleReaction called:', {
        rowIndex: rowIndex,
        reaction: reaction,
        timestamp: new Date().toISOString()
    });

    const numericRowIndex = parseInt(rowIndex, 10);
    const reactionKey = `${numericRowIndex}-${reaction}`;

    console.log('🔧 [REACTION DEBUG] Processing reaction:', {
        numericRowIndex: numericRowIndex,
        reactionKey: reactionKey,
        pendingReactions: Array.from(this.pendingReactions)
    });

    // ★連続クリック防止機能（問題版から継承）
    if (this.pendingReactions.has(reactionKey)) {
        console.log('🚫 [REACTION DEBUG] Reaction already pending, skipping:', reactionKey);
        return; // すでに処理中なら何もしない
    }

    console.log('✅ [REACTION DEBUG] Adding reaction to pending:', reactionKey);
    this.pendingReactions.add(reactionKey);

    const btns = document.querySelectorAll(`[data-row-index="${rowIndex}"][data-reaction="${reaction}"]`);
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);

    if (!item) {
        this.pendingReactions.delete(reactionKey);
        return;
    }

    // ★修正ポイント①：UI更新をボタンのローディング表示のみに限定
    // これにより、クリックイベントを妨害するカード全体のDOM変更を防ぐ
    btns.forEach(btn => {
        btn.classList.add('loading');
        btn.disabled = true;
    });

    try {
        // ★修正ポイント②：先にサーバーと通信する
        const res = await this.gas.addReaction(numericRowIndex, reaction, this.state.sheetName);

        // レスポンスの安全な処理
        debugLog('addReactionレスポンス:', { res, type: typeof res });
        
        if (res && res.status === 'ok') {
            // ★修正ポイント③：サーバーからの応答成功後に、UIを完全に更新する
            if (res.reactions && typeof res.reactions === 'object') {
                item.reactions = res.reactions;
            } else {
                debugLog('警告: reactionsプロパティが期待された形式ではありません');
                // フォールバック: 既存のreactionsを保持し、カウントのみ更新
                if (!item.reactions) {
                    item.reactions = {};
                }
                if (!item.reactions[reaction]) {
                    item.reactions[reaction] = { count: 0, reacted: false };
                }
                item.reactions[reaction].count = (item.reactions[reaction].count || 0) + 1;
                item.reactions[reaction].reacted = true;
            }
            requestAnimationFrame(() => this.applyUpdates([item])); // 次の描画フレームで安全にUIを更新

            // モーダルが開いていればそちらも更新
            if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
                if (modalRowIndex == rowIndex) {
                    this.updateModalContent(item);
                }
            }
        } else {
            const errorMsg = res?.message || 'リアクションの処理に失敗しました';
            debugLog('リアクションAPIエラー:', { 
                res, 
                errorMsg,
                responseType: typeof res,
                hasValues: res?.values !== undefined,
                responseKeys: res ? Object.keys(res) : []
            });
            
            // ユーザーフレンドリーなエラーメッセージ
            if (errorMsg.includes('Cannot read properties of undefined')) {
                throw new Error('データの読み込みに失敗しました。ページを更新してもう一度お試しください。');
            } else {
                throw new Error(errorMsg);
            }
        }
    } catch (error) {
        console.error('Failed to add reaction:', error);
        debugLog('リアクションエラー詳細:', {
            error: error.message,
            stack: error.stack,
            reaction,
            rowIndex,
            item: item ? { rowIndex: item.rowIndex, hasReactions: !!item.reactions } : null
        });
        this.showErrorFeedback(btns[0], 'リアクションに失敗しました');
        // エラー時は何もしない（UIは元の状態のまま）
    } finally {
        // ★修正ポイント④：最後にボタンのローディング状態を解除
        btns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
        this.pendingReactions.delete(reactionKey);
    }
}
  
  showErrorFeedback(btn, message) {
    if (!btn) return;
    
    // 元のクラスを保存
    const originalClasses = btn.className;
    
    // エラー表示
    btn.classList.add('bg-red-500');
    btn.title = message;
    
    // 2秒後に元に戻す
    setTimeout(() => {
      btn.className = originalClasses;
      btn.title = '';
    }, 2000);
  }
  async handleHighlight(rowIndex) {
    console.log('⭐ [HIGHLIGHT DEBUG] handleHighlight called:', {
        rowIndex: rowIndex,
        timestamp: new Date().toISOString()
    });

    debugLog('handleHighlight開始:', { 
      rowIndex, 
      isAdminUser: this.state.isAdminUser, 
      showHighlightToggle: this.state.showHighlightToggle,
      windowIsAdminUser: window.isAdminUser,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures,
      windowShowHighlightToggle: window.showHighlightToggle
    });

    console.log('🔐 [HIGHLIGHT DEBUG] Admin permissions check:', {
        isAdminUser: this.state.isAdminUser,
        showHighlightToggle: this.state.showHighlightToggle,
        showAdminFeatures: this.state.showAdminFeatures
    });
    
    // バックエンド側で管理者権限をチェックするので、フロントエンド側のチェックは不要
    
    const numericRowIndex = parseInt(rowIndex, 10);
    const highlightKey = `${numericRowIndex}-highlight`;
    
    // Enhanced debounce for highlight operations
    if (this.highlightDebounce.has(highlightKey)) {
      debugLog('デバウンス中、処理をスキップ');
      clearTimeout(this.highlightDebounce.get(highlightKey));
      return; // Ignore rapid highlight clicks
    }
    
    // Rate limiting for highlights
    const now = Date.now();
    const lastHighlightTime = this.lastReactionTimes?.get(highlightKey) || 0;
    if (now - lastHighlightTime < 500) { // Minimum 500ms between highlights
      debugLog('レート制限中、処理をスキップ');
      return;
    }
    
    // 既に処理中の場合は無視
    if (this.pendingReactions.has(highlightKey)) {
      debugLog('既に処理中、処理をスキップ');
      return;
    }
    
    this.pendingReactions.add(highlightKey);
    if (!this.lastReactionTimes) this.lastReactionTimes = new Map();
    this.lastReactionTimes.set(highlightKey, now);
    
    const btns = document.querySelectorAll('.highlight-btn[data-row-index="' + numericRowIndex + '"]');
    const item = this.state.currentAnswers.find(i => i.rowIndex == numericRowIndex);
    
    debugLog('ハイライト処理:', { numericRowIndex, btnsFound: btns.length, itemFound: !!item });
    
    if (!item) {
      debugLog('対象データが見つからない');
      this.pendingReactions.delete(highlightKey);
      return;
    }
    
    // ★修正ポイント①：UI更新をボタンのローディング表示のみに限定
    btns.forEach(btn => {
        btn.classList.add('loading');
        btn.disabled = true;
    });
    
    try {
        // ★修正ポイント②：先にサーバーと通信する
        const res = await this.gas.toggleHighlight(numericRowIndex, this.state.sheetName);

        if (res && res.status === 'ok') {
            // ★修正ポイント③：サーバーからの応答成功後に、UIを完全に更新する
            item.highlight = res.highlight;
            requestAnimationFrame(() => this.applyUpdates([item])); // 次の描画フレームで安全にUIを更新

            // モーダルが開いていればそちらも更新
            if (!this.elements.answerModalContainer.classList.contains('hidden')) {
                const modalRowIndex = this.elements.modalReactionContainer.querySelector('[data-row-index]')?.dataset.rowIndex;
                if (modalRowIndex == rowIndex) {
                    this.updateModalContent(item);
                }
            }
        } else {
            throw new Error(res?.message || 'ハイライトの処理に失敗しました');
        }
    } catch (error) {
        console.error('Failed to toggle highlight:', error);
        this.showErrorFeedback(btns[0], 'ハイライトに失敗しました');
    } finally {
        // ★修正ポイント④：最後にボタンのローディング状態を解除
        btns.forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
        this.pendingReactions.delete(highlightKey);
    }
  }
  
  async toggleAdminMode() {
    // ボタンを一時的に無効化して重複クリックを防ぐ
    const btn = this.elements.adminToggleBtn;
    if (btn) {
      btn.disabled = true;
    }
    
    try {
      const enable = !this.state.showAdminFeatures;
      
      // 管理者権限チェック
      if (enable) {
        if (!this.state.isAdminUser) {
          console.warn('管理者権限がありません。');
          return;
        }
        
        // 最初の管理モード切り替え時のみサーバー側で再確認（オプション）
        if (!this.adminModeVerified) {
          try {
            const ok = await this.gas.checkAdmin();
            if (!ok) {
              console.warn('サーバー側の権限確認に失敗しました。');
              // ローカルの権限情報を信頼して継続
            }
            this.adminModeVerified = true;
          } catch (e) {
            console.warn('権限確認API呼び出しに失敗しました', e);
            // エラーが発生してもローカルの権限情報を信頼して継続
          }
        }
      }
      
      // グローバル設定を更新
      window.showAdminFeatures = enable;
      window.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
      window.showScoreSort = enable;
      
      debugLog('toggleAdminMode状態更新:', {
        enable,
        isAdminUser: this.state.isAdminUser,
        showAdminFeatures: window.showAdminFeatures,
        showHighlightToggle: window.showHighlightToggle
      });
      if (enable) {
        window.showCounts = true;
        window.displayMode = 'named';
        window.isStudentMode = false;
      } else {
        window.showCounts = this.serverShowCounts;
        window.displayMode = this.serverDisplayMode;
        window.isStudentMode = true;
      }
      this.updateConfigFromGlobals();
      
      // キャッシュをクリアして新しい設定で再描画
      this.cache.clear();
      
      // 管理モード切り替え時は既存のカードを全て削除して強制再生成
      this.elements.answersContainer.innerHTML = '';
      
      // UI状態を更新
      this.updateSortOptions();
      // 管理モード切り替え時は設定変更のため再描画が必要
      this.loadSheetData(true, false);
    } finally {
      // ボタンを再度有効化
      if (btn) {
        btn.disabled = false;
      }
    }
  }
  async endPublication() {
    if (!confirm('公開を終了しますか？生徒は回答ボードにアクセスできなくなります。')) {
      return;
    }
    
    try {
      await this.runGas('clearActiveSheet');
      alert('公開を終了しました。管理画面に移動します。');
      this.endAdminMode();
    } catch (error) {
      console.error('公開終了に失敗しました:', error);
      alert('公開終了に失敗しました: ' + (error.message || error));
    }
  }
  endAdminMode() {
    google.script.run
      .withSuccessHandler(function(adminUrl) {
        const url = new URL(adminUrl);
        url.searchParams.set('mode', 'admin');
        window.location.href = url.toString();
      })
      .getWebAppUrl();
  }
  updateReactionButtonUI(rowIndex, reaction, count, reacted) {
    document.querySelectorAll('[data-row-index="' + rowIndex + '"][data-reaction="' + reaction + '"]').forEach(btn => {
      const countEl = btn.querySelector('.reaction-count');
      if (countEl && this.state.showCounts) {
        countEl.textContent = count;
      }
      const rt = this.reactionTypes.find(r => r.key === reaction);
      const svgEl = btn.querySelector('svg');
      if (svgEl && rt) {
        svgEl.outerHTML = this.getIcon(rt.icon, 'w-5 h-5', reacted);
      }
      const colorClass = reaction === 'LIKE' ? 'text-red-500' : reaction === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      btn.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
      btn.classList.add(colorClass);
      btn.classList.toggle('liked', reacted);
      btn.setAttribute('aria-pressed', reacted.toString());
      const reactionNames = { 'LIKE': 'いいね！', 'UNDERSTAND': 'なるほど！', 'CURIOUS': 'もっと知りたい！' };
      const reactionName = reactionNames[reaction] || reaction;
      const ariaLabel = `${reactionName}${reacted ? 'を取り消す' : 'する'}${this.state.showCounts ? ` (現在${count}件)` : ''}`;
      btn.setAttribute('aria-label', ariaLabel);
    });
  }
  applyUpdates(items) {
    items.forEach(item => {
      this.reactionTypes.forEach(rt => {
        if (item.reactions && item.reactions[rt.key]) {
          this.updateReactionButtonUI(item.rowIndex, rt.key, item.reactions[rt.key].count, item.reactions[rt.key].reacted);
        }
      });
      const card = document.querySelector('.answer-card[data-row-index="' + item.rowIndex + '"]');
      if (card) {
        card.classList.toggle('highlighted', item.highlight);
        this.applyReactionStyles(card, item);
        const highlightBtn = card.querySelector('.highlight-btn');
        if (highlightBtn) {
          highlightBtn.classList.toggle('liked', item.highlight);
          highlightBtn.setAttribute('aria-pressed', String(item.highlight));
          const label = item.highlight ? 'ハイライトを解除する' : 'ハイライトする';
          highlightBtn.setAttribute('aria-label', label);
          const svgEl = highlightBtn.querySelector('svg');
          if (svgEl) {
            svgEl.outerHTML = this.getIcon('star', 'w-5 h-5', item.highlight);
          }
        }
        let badge = card.querySelector('.highlight-badge');
        if (item.highlight && !badge) {
          badge = document.createElement('span');
          badge.className = 'highlight-badge';
          badge.innerHTML = this.getIcon('star', '', true);
          card.appendChild(badge);
        } else if (!item.highlight && badge) {
          badge.remove();
        }
      }
    });
  }
  showAnswerModal(rowIndex) {
    console.log('📱 [MODAL DEBUG] showAnswerModal called:', {
        rowIndex: rowIndex,
        rowIndexType: typeof rowIndex,
        timestamp: new Date().toISOString()
    });

    debugLog('showAnswerModal called:', {
      rowIndex: rowIndex,
      rowIndexType: typeof rowIndex,
      currentAnswersLength: this.state.currentAnswers?.length,
      filteredDataLength: this.state.filteredData?.length
    });

    console.log('🔍 [MODAL DEBUG] Data search context:', {
        currentAnswersLength: this.state.currentAnswers?.length,
        filteredDataLength: this.state.filteredData?.length,
        searchingFor: rowIndex
    });
    
    // 最新データを取得（filteredDataとcurrentAnswersの両方から）
    let data = this.state.currentAnswers.find(r => r.rowIndex == rowIndex);
    debugLog('Data search in currentAnswers:', {
      found: !!data,
      searchRowIndex: rowIndex,
      availableRowIndexes: this.state.currentAnswers?.map(r => r.rowIndex) || []
    });
    
    if (!data && this.state.filteredData) {
      data = this.state.filteredData.find(r => r.rowIndex == rowIndex);
      debugLog('Data search in filteredData:', {
        found: !!data,
        searchRowIndex: rowIndex,
        availableRowIndexes: this.state.filteredData?.map(r => r.rowIndex) || []
      });
    }
    
    if (!data) {
      debugLog('ERROR: No data found for rowIndex:', {
        rowIndex: rowIndex,
        currentAnswers: this.state.currentAnswers,
        filteredData: this.state.filteredData
      });
      return;
    }
    
    debugLog('Data found for modal:', {
      rowIndex: rowIndex,
      data: data,
      opinion: data.opinion?.substring(0, 50) + '...',
      reason: data.reason?.substring(0, 50) + '...'
    });
    this.state.lastFocusedElement = document.activeElement;
    this.elements.modalAnswer.innerHTML = '<p class="text-cyan-200 whitespace-pre-wrap break-words text-3xl md:text-4xl font-bold leading-tight">' + this.escapeHtml(data.opinion || '') + '</p>' + '<p class="text-gray-200 whitespace-pre-wrap break-words text-2xl md:text-3xl mt-6">' + this.escapeHtml(data.reason || '') + '</p>';
    const showName = this.state.displayMode === 'named';
    let modalDisplayName = '';
    
    if (showName) {
      // 名前が利用可能な場合はそれを使用、なければemailから生成
      if (data.name) {
        modalDisplayName = data.name;
      } else if (data.email) {
        modalDisplayName = data.email.split('@')[0];
      }
    }
    
    this.elements.modalStudentName.textContent = modalDisplayName;
    const footerBase = 'text-xs text-gray-400 pt-4 border-t-2 border-dashed border-cyan-400/80 flex';
    this.elements.modalFooter.className = footerBase + (showName ? ' justify-between items-center' : ' justify-end items-center');
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを追加
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // リアクションに基づくカード色の適用
    debugLog('モーダルにリアクション装飾適用:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions,
      element: this.elements.answerModalCard.className
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
    debugLog('モーダル装飾適用後:', {
      className: this.elements.answerModalCard.className
    });
    
    this.elements.answerModalContainer.classList.remove('hidden');
    this.elements.answerModalContainer.classList.add('modal-fade');
    this.elements.answerModalCard.classList.add('modal-scale');
    
    this.elements.answerModalCloseBtn.focus();
  }
  updateModalContent(data) {
    if (!data) return;
    
    // リアクションボタンを更新
    const reactionButtonsHtml = this.reactionTypes.map(rt => {
      const info = data.reactions?.[rt.key] || { count: 0, reacted: false };
      const cls = info.reacted ? 'liked' : '';
      const colorClass = rt.key === 'LIKE' ? 'text-red-500' : rt.key === 'UNDERSTAND' ? 'text-yellow-500' : 'text-green-500';
      const countSpan = this.state.showCounts ? '<span class="reaction-count font-bold text-2xl text-gray-200">' + info.count + '</span>' : '';
      return '<button type="button" class="reaction-btn like-btn flex items-center gap-1.5 ' + colorClass + ' ' + cls + '" ' + 'data-row-index="' + data.rowIndex + '" data-reaction="' + rt.key + '" aria-label="' + rt.key + '">' + this.getIcon(rt.icon, 'w-5 h-5', info.reacted) + countSpan + '</button>';
    }).join('');
    
    // ハイライトボタンを更新
    let highlightBtnHtml = '';
    if (this.state.showHighlightToggle) {
      const cls = data.highlight ? 'liked' : '';
      const highlightAriaLabel = data.highlight ? 'ハイライトを解除する' : 'ハイライトする';
      highlightBtnHtml = '<button type="button" class="highlight-btn like-btn text-purple-600 ' + cls + '" aria-label="' + highlightAriaLabel + '" aria-pressed="' + data.highlight + '" data-row-index="' + data.rowIndex + '">' + this.getIcon('star', 'w-5 h-5', data.highlight) + '</button>';
    }
    
    this.elements.modalReactionContainer.innerHTML = reactionButtonsHtml + highlightBtnHtml;
    
    // モーダルカードのスタイルを更新
    debugLog('updateModalContent装飾適用:', {
      rowIndex: data.rowIndex,
      highlight: data.highlight,
      reactions: data.reactions
    });
    this.applyReactionStyles(this.elements.answerModalCard, data);
  }
  hideAnswerModal() {
    this.elements.answerModalContainer.classList.add('hidden');
    this.elements.answerModalContainer.classList.remove('modal-fade');
    this.elements.answerModalCard.classList.remove('modal-scale');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  showInfoModal() {
    this.state.lastFocusedElement = document.activeElement;
    this.elements.infoModalContainer.classList.remove('hidden');
    this.elements.infoModalContainer.classList.add('modal-fade');
    this.elements.infoModalCard.classList.add('modal-scale');
    
    // Ensure modal starts from the top
    this.elements.infoModalCard.scrollTop = 0;
    
    // Focus on the modal container first, then the button
    setTimeout(() => {
      this.elements.infoModalConfirmBtn.focus();
    }, 100);
  }
  hideInfoModal() {
    this.elements.infoModalContainer.classList.add('hidden');
    this.elements.infoModalContainer.classList.remove('modal-fade');
    this.elements.infoModalCard.classList.remove('modal-scale');
    
    localStorage.setItem('introSeen', '1');
    if (this.state.lastFocusedElement) {
      this.state.lastFocusedElement.focus();
    }
  }
  getIcon(name, classes = '', solid = false) {
    // Cache icons to avoid repeated string concatenation
    const cacheKey = `icon-${name}-${classes}-${solid}`;
    const cachedIcon = this.cache.get(cacheKey);
    if (cachedIcon) {
      return cachedIcon;
    }
    
    let key = name;
    if (ICONS[name + '-outline'] || ICONS[name + '-solid']) {
      key = solid ? name + '-solid' : name + '-outline';
    }
    const icon = ICONS[key];
    if (!icon) {
      console.warn('Icon not found:', key);
      const fallback = '<span aria-hidden="true" class="' + classes + '">⭐</span>';
      this.cache.set(cacheKey, fallback);
      return fallback;
    }
    const result = '<span aria-hidden="true" class="' + classes + '">' + icon + '</span>';
    this.cache.set(cacheKey, result);
    return result;
  }
  renderIcons() {
    if (this.elements.infoIconLike) {
      this.elements.infoIconLike.innerHTML = this.getIcon('hand-thumb-up');
    }
    if (this.elements.infoIconUnderstand) {
      this.elements.infoIconUnderstand.innerHTML = this.getIcon('lightbulb');
    }
    if (this.elements.infoIconCurious) {
      this.elements.infoIconCurious.innerHTML = this.getIcon('magnifying-glass-plus');
    }
    if (this.elements.infoIconHighlight) {
      this.elements.infoIconHighlight.innerHTML = this.getIcon('star');
    }
    if (this.elements.iconClose) {
      this.elements.iconClose.innerHTML = this.getIcon('x');
    }
    if (this.elements.iconGrid) {
      this.elements.iconGrid.innerHTML = this.getIcon('grid-2x2');
    }
  }
  debounce(func, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }
  
  throttle(func, delay) {
    let timeoutId;
    let lastExecTime = 0;
    return (...args) => {
      const currentTime = Date.now();
      
      if (currentTime - lastExecTime > delay) {
        func.apply(this, args);
        lastExecTime = currentTime;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecTime = Date.now();
        }, delay - (currentTime - lastExecTime));
      }
    };
  }
  updateSortOptions() {
    if (this.elements.scoreOption) {
      if (this.state.showScoreSort) {
        this.elements.scoreOption.style.display = 'block';
      } else {
        this.elements.scoreOption.style.display = 'none';
        if (this.elements.sortOrder.value === 'score') {
          this.elements.sortOrder.value = 'newest';
        }
      }
    }
  }
  updateConfigFromGlobals() {
    debugLog('updateConfigFromGlobals前の状態:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures
    });
    
    this.state.isStudentMode = window.isStudentMode;
    this.state.showCounts = window.showCounts;
    this.state.showAdminFeatures = window.showAdminFeatures;
    this.state.showHighlightToggle = this.state.isAdminUser; // 管理者なら常に表示
    this.state.showScoreSort = window.showScoreSort;
    
    debugLog('updateConfigFromGlobals後の状態:', {
      isAdminUser: this.state.isAdminUser,
      showHighlightToggle: this.state.showHighlightToggle,
      windowShowHighlightToggle: window.showHighlightToggle,
      showAdminFeatures: this.state.showAdminFeatures,
      windowShowAdminFeatures: window.showAdminFeatures
    });
    this.state.showPublishControls = window.showPublishControls;
    this.state.displayMode = window.displayMode;
  }
  escapeHtml(str) {
    if (!str) return '';
    return str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }

  // Performance optimization methods
  detectLowPerformanceDevice() {
    const userAgent = navigator.userAgent;
    const platform = navigator.platform;
    const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
    const cores = navigator.hardwareConcurrency || 4;
    
    // Detect low-end devices
    if (memory <= 2 || cores <= 2) return true;
    if (userAgent.includes('Mobile') && !userAgent.includes('iPad')) return true;
    if (platform.includes('Win32') && cores <= 4) return true;
    
    return false;
  }

  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measurePerformance = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      if (frameCount > 0) {
        this.performanceMetrics.frameTime = delta;
        
        // If frame time is consistently over 16ms, enable low performance mode
        if (delta > PERFORMANCE_BUDGET && !this.isLowPerformanceMode) {
          console.warn('Low performance detected, enabling optimizations');
          this.isLowPerformanceMode = true;
          this.optimizeForLowPerformance();
        }
      }
      
      lastTime = now;
      frameCount++;
      
      if (frameCount < 60) { // Monitor first 60 frames
        requestAnimationFrame(measurePerformance);
      }
    };
    
    requestAnimationFrame(measurePerformance);
  }

  optimizeForLowPerformance() {
    debugLog('Enabling low performance optimizations');
    
    // Reduce animation and transition durations
    document.documentElement.style.setProperty('--transition-duration', '0.1s');
    document.documentElement.style.setProperty('--animation-duration', '0.1s');
    document.documentElement.style.setProperty('--backdrop-blur', '4px');
    
    // Create comprehensive low-performance stylesheet
    const style = document.createElement('style');
    style.id = 'low-performance-optimizations';
    style.textContent = `
      /* Disable expensive visual effects */
      .glass-panel {
        -webkit-backdrop-filter: blur(4px) !important;
        backdrop-filter: blur(4px) !important;
        background: var(--color-surface) !important;
      }
      
      /* Simplify hover effects */
      .answer-card:hover {
        transform: none !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      .reaction-btn:hover {
        transform: scale(1.02) !important;
      }
      
      .game-btn:hover {
        transform: translateY(-1px) !important;
      }
      
      /* Disable complex animations */
      .answer-card.highlighted {
        transform: none !important;
        border: 3px solid #9333ea !important;
        border-image: none !important;
        box-shadow: 0 0 12px rgba(147, 51, 234, 0.5) !important;
      }
      
      /* Remove will-change to reduce GPU usage */
      * {
        will-change: auto !important;
      }
      
      /* Simplify shadows */
      .answer-card {
        box-shadow: var(--shadow-sm) !important;
      }
      
    `;
    document.head.appendChild(style);
    
    // Add low-performance class to body for CSS targeting
    document.body.classList.add('low-performance');
    
    // Reduce polling frequency
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = setInterval(() => this.loadSheetData(false), 30000); // 30s instead of 15s
    }
  }

  setupObservers() {
    // Intersection Observer for virtual scrolling
    if ('IntersectionObserver' in window) {
      this.visibilityObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const card = entry.target;
          const rect = card.getBoundingClientRect();
          const isPartiallyVisible = rect.top < window.innerHeight && rect.bottom > 0;
          
          if (entry.isIntersecting) {
            card.classList.add('visible');
            card.classList.remove('hidden-card');
          } else if (!isPartiallyVisible) {
            // Only mark as hidden if the card is completely outside the viewport
            card.classList.remove('visible');
            card.classList.add('hidden-card');
          }
          // If partially visible but not intersecting, keep it accessible
        });
      }, {
        rootMargin: `${VIEWPORT_BUFFER}px`,
        threshold: [0, 0.1, 0.5, 1.0] // Multiple thresholds for better visibility detection
      });
    }

    // ResizeObserver for responsive adjustments
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(this.debounce(() => {
        this.adjustLayout();
      }, 100));
      this.resizeObserver.observe(this.elements.answersContainer);
    }
  }

  deferredRender(callback, priority = 'normal') {
    if (this.isLowPerformanceMode) {
      // Use requestIdleCallback for low priority updates
      this.idleCallbackId = requestIdleCallback(callback, { timeout: IDLE_TIMEOUT });
    } else {
      // Use requestAnimationFrame for normal updates
      this.animationFrameId = requestAnimationFrame(callback);
    }
  }

  batchDOMUpdates(updates) {
    const startTime = performance.now();
    let processedCount = 0;
    
    const processBatch = () => {
      while (processedCount < updates.length && (performance.now() - startTime) < PERFORMANCE_BUDGET) {
        updates[processedCount]();
        processedCount++;
      }
      
      if (processedCount < updates.length) {
        // Continue in next frame
        requestAnimationFrame(processBatch);
      }
    };
    
    processBatch();
  }

  getReusableFragment() {
    if (this.domFragmentPool.length > 0) {
      return this.domFragmentPool.pop();
    }
    return document.createDocumentFragment();
  }

  recycleFragment(fragment) {
    // Clear fragment content and reuse
    while (fragment.firstChild) {
      fragment.removeChild(fragment.firstChild);
    }
    if (this.domFragmentPool.length < 10) { // Limit pool size
      this.domFragmentPool.push(fragment);
    }
  }

  throttledUpdate(key, callback, delay = 100) {
    if (this.deferredUpdates.has(key)) {
      return;
    }
    
    this.deferredUpdates.add(key);
    setTimeout(() => {
      callback();
      this.deferredUpdates.delete(key);
    }, delay);
  }

  cleanup() {
    // Consolidated cache cleanup
    this.cache.cleanup();

    // Clear DOM fragment pool
    this.domFragmentPool.length = 0;

    debugLog('Cache cleanup completed', {
      cacheSize: this.cache.size
    });
  }
  
  // Enhanced cache methods with timestamp tracking
}
// ===== 共通ドメイン情報処理関数 =====
// AdminPanel.html と Registration.html で共通使用

/**
 * ドメイン情報を取得して表示する共通関数
 * @param {Function} onSuccess - 成功時のコールバック（オプション）
 * @param {Function} onError - エラー時のコールバック（オプション）
 */
function loadDomainInfo(onSuccess, onError) {
  google.script.run
    .withSuccessHandler(info => {
      displayDomainInfo(info);
      if (onSuccess) onSuccess(info);
    })
    .withFailureHandler(error => {
      console.error('ドメイン情報の取得に失敗しました:', error);
      displayDomainInfo({ error: error.message || error });
      if (onError) onError(error);
    })
    .getDeployUserDomainInfo();
}

/**
 * ドメイン情報を表示する共通関数
 * @param {Object} info - ドメイン情報オブジェクト
 */
function displayDomainInfo(info) {
  const headerDomainMatch = document.getElementById('header-domain-match');
  const headerDomainMismatch = document.getElementById('header-domain-mismatch');
  const headerDomainInitial = document.getElementById('header-domain-initial');
  const headerDomainMatchText = document.getElementById('header-domain-match-text');
  const headerDomainMismatchText = document.getElementById('header-domain-mismatch-text');

  // 全ての表示を一旦非表示にする
  if (headerDomainMatch) headerDomainMatch.classList.add('hidden');
  if (headerDomainMismatch) headerDomainMismatch.classList.add('hidden');
  if (headerDomainInitial) headerDomainInitial.classList.add('hidden');
  
  if (!info || info.error) {
    console.warn('ドメイン情報エラー:', info?.error);
    if (headerDomainInitial) headerDomainInitial.classList.remove('hidden');
    return;
  }

  if (info.isDomainMatch) {
    // ドメインが一致している場合
    if (headerDomainMatch && headerDomainMatchText) {
      headerDomainMatch.classList.remove('hidden');
      if (info.deployDomain) {
        headerDomainMatchText.textContent = `${info.deployDomain} ドメイン`;
      } else {
        headerDomainMatchText.textContent = 'グローバルアクセス';
      }
    }
  } else {
    // ドメイン不一致の場合
    if (headerDomainMismatch && headerDomainMismatchText) {
      headerDomainMismatch.classList.remove('hidden');
      headerDomainMismatchText.textContent = info.currentDomain;
    }
  }
}

/**
 * フォームリンクを取得して表示する関数
 */
function loadFormLink() {
  google.script.run
    .withSuccessHandler(formInfo => {
      if (formInfo && formInfo.formUrl) {
        const formLinkBtn = document.getElementById('form-link-btn');
        if (formLinkBtn) {
          formLinkBtn.href = formInfo.formUrl;
          formLinkBtn.classList.remove('hidden');
        }
      }
    })
    .withFailureHandler(error => {
      console.warn('フォーム情報の取得に失敗しました:', error);
    })
    .getActiveFormInfo();
}

function initializeApp() {
  try {
    if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
      window.studyQuestApp.destroy();
    }
    window.studyQuestApp = new StudyQuestApp();
    
    
    // ドメイン情報とフォームリンクを取得
    loadDomainInfo();
    loadFormLink();
    
    window.addEventListener('beforeunload', () => {
      if (window.studyQuestApp && typeof window.studyQuestApp.destroy === 'function') {
        window.studyQuestApp.destroy();
      }
    });
  } catch (error) {
    console.error('Error creating StudyQuestApp instance:', error);
    const container = document.getElementById('answers');
    if (container) {
      const msg = StudyQuestApp.prototype.escapeHtml(error.message || '');
      container.innerHTML = '<div class="text-red-400 p-4">アプリケーションの初期化に失敗しました: ' + msg + '</div>';
    }
  }
}

// DOM準備完了後にアプリケーションを初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  initializeApp();
}
</script>
