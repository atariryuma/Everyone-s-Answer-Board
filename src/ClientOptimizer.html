<script>
/**
 * @fileoverview クライアントサイド最適化ユーティリティ
 * GAS HTML Service用の最適化されたクライアント関数群
 */

/**
 * GAS最適化クラス
 */
class GASOptimizer {
  constructor() {
    this.cache = new Map();
    this.loadingStates = new Map();
    this.concurrentLimit = 10;
    this.activeCalls = 0;
    this.callQueue = [];
  }

  /**
   * Promise化されたgoogle.script.run呼び出し
   * @param {string} functionName - 呼び出す関数名
   * @param {...any} args - 関数の引数
   * @returns {Promise} 結果のPromise
   */
  call(functionName, ...args) {
    return new Promise((resolve, reject) => {
      // 同時実行制限の確認
      if (this.activeCalls >= this.concurrentLimit) {
        this.callQueue.push(() => {
          this.executeCall(functionName, args, resolve, reject);
        });
        return;
      }

      this.executeCall(functionName, args, resolve, reject);
    });
  }

  /**
   * 実際の関数呼び出し実行
   */
  executeCall(functionName, args, resolve, reject) {
    this.activeCalls++;
    
    // ローディング状態の管理
    this.setLoadingState(functionName, true);

    // GAS function call validation
    if (typeof google === 'undefined' || !google.script || !google.script.run || typeof google.script.run[functionName] !== 'function') {
      throw new Error('GAS function \'' + functionName + '\' is not available');
    }

    const self = this;
    google.script.run
      .withSuccessHandler(function(result) {
        self.activeCalls--;
        self.setLoadingState(functionName, false);
        resolve(result);
        self.processQueue();
      })
      .withFailureHandler(function(error) {
        self.activeCalls--;
        self.setLoadingState(functionName, false);
        console.error('GAS Function Error [' + functionName + ']:', error);
        reject(self.enhanceError(error, functionName));
        self.processQueue();
      })[functionName].apply(null, args);
  }

  /**
   * キューの処理
   */
  processQueue() {
    if (this.callQueue.length > 0 && this.activeCalls < this.concurrentLimit) {
      const nextCall = this.callQueue.shift();
      nextCall();
    }
  }

  /**
   * エラー情報の拡張
   */
  enhanceError(error, functionName) {
    const enhanced = { ...error };
    enhanced.function = functionName;
    enhanced.timestamp = new Date().toISOString();
    enhanced.userMessage = this.getUserFriendlyErrorMessage(error.message);
    return enhanced;
  }

  /**
   * ユーザーフレンドリーなエラーメッセージ
   */
  getUserFriendlyErrorMessage(originalMessage) {
    const errorMap = {
      'Exception: 認証エラー': 'ログインセッションが期限切れです。ページを更新してから再度お試しください。',
      'Exception: 無効なユーザーID': 'アクセス権限に問題があります。管理者にお問い合わせください。',
      'Exception: データベース': 'データの保存に失敗しました。しばらく待ってから再度お試しください。',
      'ScriptError': 'システムエラーが発生しました。管理者にお問い合わせください。'
    };

    for (const [key, message] of Object.entries(errorMap)) {
      if (originalMessage && originalMessage.includes(key)) {
        return message;
      }
    }
    
    return '予期しないエラーが発生しました。しばらく待ってから再度お試しください。';
  }

  /**
   * ローディング状態の管理
   */
  setLoadingState(functionName, isLoading) {
    this.loadingStates.set(functionName, isLoading);
    this.updateGlobalLoadingIndicator();
  }

  /**
   * グローバルローディングインジケーターの更新
   */
  updateGlobalLoadingIndicator() {
    const hasActiveLoading = Array.from(this.loadingStates.values()).some(state => state);
    document.body.classList.toggle('gas-loading', hasActiveLoading);
  }

  /**
   * キャッシュ付きの関数呼び出し
   */
  callWithCache(functionName, args, ttl = 5 * 60 * 1000) {
    const cacheKey = `${functionName}_${JSON.stringify(args)}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && (Date.now() - cached.timestamp) < ttl) {
      return Promise.resolve(cached.data);
    }

    return this.call(functionName, ...args).then(result => {
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
      });
      return result;
    });
  }

  /**
   * バッチ処理対応の関数呼び出し
   */
  batchCall(calls) {
    const promises = calls.map(call => 
      this.call(call.functionName, ...(call.args || []))
        .catch(error => ({ error, functionName: call.functionName }))
    );
    return Promise.all(promises);
  }

  /**
   * キャッシュのクリア
   */
  clearCache() {
    this.cache.clear();
  }

  /**
   * 統計情報の取得
   */
  getStats() {
    return {
      activeCalls: this.activeCalls,
      queueLength: this.callQueue.length,
      cacheSize: this.cache.size,
      loadingStates: Object.fromEntries(this.loadingStates)
    };
  }
}

// グローバルインスタンスの作成
window.gasOptimizer = new GASOptimizer();

/**
 * 便利な関数のエイリアス
 */
window.gasCall = (functionName, ...args) => {
  return window.gasOptimizer.call(functionName, ...args);
};
window.gasCacheCall = (functionName, args, ttl) => {
  return window.gasOptimizer.callWithCache(functionName, args, ttl);
};

/**
 * メッセージ表示の最適化 - SharedUtilitiesに移行済み
 * グローバル関数のエイリアス
 */
// MessageManagerはSharedUtilitiesに移行済み
// グローバル関数のエイリアス設定
window.messageManager = window.sharedUtilities?.messages;
// showMessage関数はSharedUtilitiesで定義済み

/**
 * ローディング状態のCSS
 */
const loadingCSS = `
<style>
.gas-loading {
  cursor: wait;
}

.gas-loading * {
  pointer-events: none;
}

.spinner {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(139, 233, 253, 0.3);
  border-top: 2px solid var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  100% { transform: rotate(360deg); }
}

/* Loading overlay styles moved to UnifiedStyles.html for consistency */
</style>
`;

// CSSを注入
document.head.insertAdjacentHTML('beforeend', loadingCSS);

// デバッグ用（開発時のみ）
if (window.location.hostname === 'localhost' || window.location.hostname.includes('script.google.com')) {
  window.gasDebug = () => console.log('GAS Optimizer Stats:', window.gasOptimizer.getStats());
}
</script>
