<script>
/**
 * SharedErrorHandling - フロントエンド統一エラーハンドリング
 * すべてのHTMLファイルで共通利用
 */

window.ErrorHandler = {

  ErrorTypes: Object.freeze({
    AUTHENTICATION: 'authentication',
    AUTHORIZATION: 'authorization',
    VALIDATION: 'validation',
    NOT_FOUND: 'not_found',
    NETWORK: 'network',
    SYSTEM: 'system',
    USER_INPUT: 'user_input',
    EXTERNAL_API: 'external_api'
  }),

  /**
   * エラーを分類
   * @param {Error|string} error - エラーオブジェクトまたはメッセージ
   * @returns {string} エラータイプ
   */
  classifyError(error) {
    const message = typeof error === 'string' ? error : (error?.message || '');
    const lowerMessage = message.toLowerCase();

    if (lowerMessage.includes('permission') || lowerMessage.includes('権限')) {
      return this.ErrorTypes.AUTHORIZATION;
    }
    if (lowerMessage.includes('not found') || lowerMessage.includes('見つかりません')) {
      return this.ErrorTypes.NOT_FOUND;
    }
    if (lowerMessage.includes('network') || lowerMessage.includes('timeout')) {
      return this.ErrorTypes.NETWORK;
    }
    if (lowerMessage.includes('validation') || lowerMessage.includes('無効')) {
      return this.ErrorTypes.VALIDATION;
    }
    if (lowerMessage.includes('authentication') || lowerMessage.includes('認証')) {
      return this.ErrorTypes.AUTHENTICATION;
    }

    return this.ErrorTypes.SYSTEM;
  },

  /**
   * ユーザー向けエラーメッセージの生成
   * @param {Error|string} error - エラーオブジェクトまたはメッセージ
   * @param {string} [context] - コンテキスト
   * @returns {string} ユーザー向けメッセージ
   */
  getUserMessage(error, context = '') {
    const errorType = this.classifyError(error);

    const messages = {
      [this.ErrorTypes.AUTHENTICATION]: 'ログインが必要です。再度ログインしてください。',
      [this.ErrorTypes.AUTHORIZATION]: 'この操作を実行する権限がありません。',
      [this.ErrorTypes.VALIDATION]: '入力内容に問題があります。正しい形式で入力してください。',
      [this.ErrorTypes.NOT_FOUND]: '指定されたリソースが見つかりません。',
      [this.ErrorTypes.NETWORK]: 'ネットワークエラーが発生しました。時間をおいて再試行してください。',
      [this.ErrorTypes.EXTERNAL_API]: '外部サービスとの通信に失敗しました。',
      [this.ErrorTypes.SYSTEM]: 'システムエラーが発生しました。管理者に連絡してください。'
    };

    let baseMessage = messages[errorType] || messages[this.ErrorTypes.SYSTEM];

    if (context) {
      baseMessage = `${context}: ${baseMessage}`;
    }

    return baseMessage;
  },

  /**
   * エラーログの出力
   * @param {Error|string} error - エラーオブジェクトまたはメッセージ
   * @param {string} [context] - コンテキスト
   * @param {Object} [additionalData] - 追加データ
   */
  logError(error, context = '', additionalData = {}) {
    const errorInfo = {
      message: typeof error === 'string' ? error : (error?.message || ''),
      type: this.classifyError(error),
      context,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent.substring(0, 100),
      ...additionalData
    };

    console.error(`[Frontend ErrorHandler] ${context}:`, errorInfo);
  },

  /**
   * 統一エラー表示
   * @param {Error|string} error - エラーオブジェクトまたはメッセージ
   * @param {string} [context] - コンテキスト
   */
  showError(error, context = '') {
    const message = this.getUserMessage(error, context);
    this.logError(error, context);

    if (window.notifications) {
      window.notifications.error(message);
    } else if (typeof alert === 'function') {
      alert(message);
    } else {
      console.error('Error notification fallback:', message);
    }
  },

  /**
   * GAS関数呼び出しのエラーハンドリング - UnifiedDataLoaderと統合
   * @param {string} funcName - 関数名
   * @param {Object} options - オプション
   * @param {Array} args - 引数
   * @returns {Promise} エラーハンドリング付きPromise
   */
  async callGAS(funcName, options = {}, ...args) {
    try {
      if (window.unifiedDataLoader) {
        return await window.unifiedDataLoader.loadData(funcName, {
          showLoading: options.showLoading !== false,
          cache: options.cache !== false,
          retryOnError: options.retryOnError !== false,
          ...options
        }, ...args);
      }

      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script?.run) {
          const error = new Error('Google Apps Script環境が利用できません');
          this.logError(error, `GAS呼び出し: ${funcName}`);
          reject(error);
          return;
        }

        google.script.run
          .withSuccessHandler((result) => {
            resolve(result);
          })
          .withFailureHandler((error) => {
            this.logError(error, `GAS呼び出し: ${funcName}`, { args });
            const userMessage = this.getUserMessage(error, funcName);
            reject(new Error(userMessage));
          })
          [funcName](...args);
      });
    } catch (error) {
      this.logError(error, `callGAS: ${funcName}`);
      throw error;
    }
  },

  /**
   * バッチGAS呼び出し - 複数の関数を並列実行
   * @param {Array} requests - [{funcName, options, args}]の配列
   * @returns {Promise<Array>} 結果配列
   */
  async callGASBatch(requests) {
    try {
      if (window.unifiedDataLoader) {
        const formattedRequests = requests.map(req => ({
          functionName: req.funcName,
          args: req.args || [],
          options: req.options || {}
        }));
        return await window.unifiedDataLoader.loadBatchData(formattedRequests);
      }

      const promises = requests.map(req =>
        this.callGAS(req.funcName, req.options || {}, ...(req.args || []))
          .catch(error => ({ error: error.message, funcName: req.funcName }))
      );
      return Promise.all(promises);
    } catch (error) {
      this.logError(error, 'callGASBatch');
      throw error;
    }
  },

  /**
   * try-catch のヘルパー関数
   * @param {Function} fn - 実行する関数
   * @param {string} [context] - コンテキスト
   * @returns {*} 実行結果またはundefined
   */
  async safeExecute(fn, context = '') {
    try {
      return await fn();
    } catch (error) {
      this.showError(error, context);
      return undefined;
    }
  },

  /**
   * フォーム送信のエラーハンドリング
   * @param {Function} submitFunction - 送信処理関数
   * @param {string} context - コンテキスト
   * @param {Object} options - オプション
   * @returns {Promise} 送信結果
   */
  async handleFormSubmission(submitFunction, context = '', options = {}) {
    const {
      showLoadingMessage = '送信中...',
      successMessage = '送信が完了しました',
      validateForm = null,
      onSuccess = null,
      onError = null
    } = options;

    try {
      if (validateForm && typeof validateForm === 'function') {
        const validationResult = await validateForm();
        if (!validationResult.isValid) {
          throw new Error(validationResult.message || '入力内容に問題があります');
        }
      }

      if (window.unifiedLoading && showLoadingMessage) {
        window.unifiedLoading.show(showLoadingMessage);
      }

      const result = await submitFunction();

      if (successMessage) {
        if (window.notifications) {
          window.notifications.success(successMessage);
        } else if (typeof showMessage === 'function') {
          showMessage(successMessage, 'success');
        }
      }
      if (onSuccess && typeof onSuccess === 'function') {
        await onSuccess(result);
      }

      return result;

    } catch (error) {
      this.logError(error, context);
      const userMessage = this.getUserMessage(error, context);

      if (window.notifications) {
        window.notifications.error(userMessage);
      } else if (typeof showMessage === 'function') {
        showMessage(userMessage, 'error');
      } else {
        this.showError(error, context);
      }

      if (onError && typeof onError === 'function') {
        await onError(error);
      }

      throw error;
    } finally {
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      }
    }
  },

  /**
   * 非同期データ読み込みのエラーハンドリング
   * @param {Function} loadFunction - データ読み込み関数
   * @param {string} context - コンテキスト
   * @param {Object} options - オプション
   * @returns {Promise} 読み込み結果
   */
  async handleDataLoading(loadFunction, context = '', options = {}) {
    const {
      fallbackData = null,
      showErrors = true,
      retryCount = 1,
      retryDelay = 1000
    } = options;

    let lastError;

    for (let attempt = 1; attempt <= retryCount; attempt++) {
      try {
        return await loadFunction();
      } catch (error) {
        lastError = error;
        this.logError(error, `${context} (試行${attempt}/${retryCount})`);

        if (attempt < retryCount) {
          await new Promise(resolve => {
            const createPromiseDelay = (ms) => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            };
            createPromiseDelay(retryDelay);
          });
          continue;
        }

        if (showErrors) {
          const userMessage = this.getUserMessage(error, context);
          if (window.notifications) {
            window.notifications.error(userMessage);
          } else if (typeof showMessage === 'function') {
            showMessage(userMessage, 'error');
          }
        }

        if (fallbackData !== null) {
          return fallbackData;
        }

        throw error;
      }
    }
  },

  /**
   * リアルタイム検証エラーハンドリング
   * @param {HTMLElement} field - 入力フィールド
   * @param {Function} validator - 検証関数
   * @param {Object} options - オプション
   */
  setupFieldValidation(field, validator, options = {}) {
    const {
      validClass = 'border-green-500',
      invalidClass = 'border-red-500',
      showTooltip = true,
      debounceDelay = 300
    } = options;

    if (!field || typeof validator !== 'function') {
      console.warn('setupFieldValidation: 無効なパラメータ');
      return;
    }

    let timeoutId;
    const validate = async () => {
      try {
        const result = await validator(field.value);

        field.classList.remove(invalidClass);
        field.classList.add(validClass);

        if (showTooltip) {
          this.removeTooltip(field);
        }

        return { isValid: true, result };
      } catch (error) {
        field.classList.remove(validClass);
        field.classList.add(invalidClass);

        if (showTooltip) {
          this.showTooltip(field, error.message);
        }

        return { isValid: false, error: error.message };
      }
    };

    let debouncePromise = null;
    field.addEventListener('input', () => {
      if (debouncePromise) {
        debouncePromise.cancelled = true;
      }

      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => {
          if (debouncePromise?.cancelled) return;
          (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        };
        check();
      });

      debouncePromise = createPromiseDelay(debounceDelay);
      debouncePromise.then(() => {
        if (!debouncePromise.cancelled) {
          validate();
        }
      });
    });

    field.addEventListener('blur', validate);
  },

  /**
   * ツールチップ表示ヘルパー
   */
  showTooltip(element, message) {
    this.removeTooltip(element);

    const tooltip = document.createElement('div');
    tooltip.className = 'error-tooltip absolute z-50 bg-red-600 text-white text-xs p-2 rounded shadow-lg';
    tooltip.textContent = message;
    tooltip.setAttribute('data-tooltip-for', element.id || 'unknown');

    const rect = element.getBoundingClientRect();
    tooltip.style.left = rect.left + 'px';
    tooltip.style.top = (rect.bottom + 5) + 'px';

    document.body.appendChild(tooltip);
  },

  /**
   * ツールチップ削除ヘルパー
   */
  removeTooltip(element) {
    const existing = document.querySelector(`[data-tooltip-for="${element.id || 'unknown'}"]`);
    if (existing) {
      existing.remove();
    }
  }
};

window.addEventListener('error', (event) => {
  window.ErrorHandler.logError(event.error, 'グローバルエラー', {
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });
});

window.addEventListener('unhandledrejection', (event) => {
  window.ErrorHandler.logError(event.reason, '未処理Promise拒否');
  event.preventDefault(); // デフォルトのコンソールログを防ぐ
});

</script>