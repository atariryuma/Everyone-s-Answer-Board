<script>
/**
 * SharedErrorHandling - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
 * ã™ã¹ã¦ã®HTMLãƒ•ã‚¡ã‚¤ãƒ«ã§å…±é€šåˆ©ç”¨
 */

window.ErrorHandler = {

  // ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—å®šç¾©ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨çµ±ä¸€ï¼‰
  ErrorTypes: Object.freeze({
    AUTHENTICATION: 'authentication',
    AUTHORIZATION: 'authorization',
    VALIDATION: 'validation',
    NOT_FOUND: 'not_found',
    NETWORK: 'network',
    SYSTEM: 'system',
    USER_INPUT: 'user_input',
    EXTERNAL_API: 'external_api'
  }),

  /**
   * ã‚¨ãƒ©ãƒ¼ã‚’åˆ†é¡
   * @param {Error|string} error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @returns {string} ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—
   */
  classifyError(error) {
    const message = typeof error === 'string' ? error : (error?.message || '');
    const lowerMessage = message.toLowerCase();

    if (lowerMessage.includes('permission') || lowerMessage.includes('æ¨©é™')) {
      return this.ErrorTypes.AUTHORIZATION;
    }
    if (lowerMessage.includes('not found') || lowerMessage.includes('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')) {
      return this.ErrorTypes.NOT_FOUND;
    }
    if (lowerMessage.includes('network') || lowerMessage.includes('timeout')) {
      return this.ErrorTypes.NETWORK;
    }
    if (lowerMessage.includes('validation') || lowerMessage.includes('ç„¡åŠ¹')) {
      return this.ErrorTypes.VALIDATION;
    }
    if (lowerMessage.includes('authentication') || lowerMessage.includes('èªè¨¼')) {
      return this.ErrorTypes.AUTHENTICATION;
    }

    return this.ErrorTypes.SYSTEM;
  },

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç”Ÿæˆ
   * @param {Error|string} error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param {string} [context] - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @returns {string} ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   */
  getUserMessage(error, context = '') {
    const errorType = this.classifyError(error);

    const messages = {
      [this.ErrorTypes.AUTHENTICATION]: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ã€‚å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚',
      [this.ErrorTypes.AUTHORIZATION]: 'ã“ã®æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚',
      [this.ErrorTypes.VALIDATION]: 'å…¥åŠ›å†…å®¹ã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚æ­£ã—ã„å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚',
      [this.ErrorTypes.NOT_FOUND]: 'æŒ‡å®šã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
      [this.ErrorTypes.NETWORK]: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚',
      [this.ErrorTypes.EXTERNAL_API]: 'å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®é€šä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚',
      [this.ErrorTypes.SYSTEM]: 'ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«é€£çµ¡ã—ã¦ãã ã•ã„ã€‚'
    };

    let baseMessage = messages[errorType] || messages[this.ErrorTypes.SYSTEM];

    if (context) {
      baseMessage = `${context}: ${baseMessage}`;
    }

    return baseMessage;
  },

  /**
   * ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®å‡ºåŠ›
   * @param {Error|string} error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param {string} [context] - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param {Object} [additionalData] - è¿½åŠ ãƒ‡ãƒ¼ã‚¿
   */
  logError(error, context = '', additionalData = {}) {
    const errorInfo = {
      message: typeof error === 'string' ? error : (error?.message || ''),
      type: this.classifyError(error),
      context,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent.substring(0, 100),
      ...additionalData
    };

    console.error(`[Frontend ErrorHandler] ${context}:`, errorInfo);
  },

  /**
   * çµ±ä¸€ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
   * @param {Error|string} error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param {string} [context] - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   */
  showError(error, context = '') {
    const message = this.getUserMessage(error, context);
    this.logError(error, context);

    if (typeof showError === 'function') {
      showError(message);
    } else if (typeof alert === 'function') {
      alert(message);
    }
  },

  /**
   * GASé–¢æ•°å‘¼ã³å‡ºã—ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° - UnifiedDataLoaderã¨çµ±åˆ
   * @param {string} funcName - é–¢æ•°å
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {Array} args - å¼•æ•°
   * @returns {Promise} ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãPromise
   */
  async callGAS(funcName, options = {}, ...args) {
    try {
      // UnifiedDataLoaderãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
      if (window.unifiedDataLoader) {
        return await window.unifiedDataLoader.loadData(funcName, {
          showLoading: options.showLoading !== false,
          cache: options.cache !== false,
          retryOnError: options.retryOnError !== false,
          ...options
        }, ...args);
      }

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®GASå‘¼ã³å‡ºã—
      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script?.run) {
          const error = new Error('Google Apps Scriptç’°å¢ƒãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
          this.logError(error, `GASå‘¼ã³å‡ºã—: ${funcName}`);
          reject(error);
          return;
        }

        google.script.run
          .withSuccessHandler((result) => {
            resolve(result);
          })
          .withFailureHandler((error) => {
            this.logError(error, `GASå‘¼ã³å‡ºã—: ${funcName}`, { args });
            const userMessage = this.getUserMessage(error, funcName);
            reject(new Error(userMessage));
          })
          [funcName](...args);
      });
    } catch (error) {
      this.logError(error, `callGAS: ${funcName}`);
      throw error;
    }
  },

  /**
   * ãƒãƒƒãƒGASå‘¼ã³å‡ºã— - è¤‡æ•°ã®é–¢æ•°ã‚’ä¸¦åˆ—å®Ÿè¡Œ
   * @param {Array} requests - [{funcName, options, args}]ã®é…åˆ—
   * @returns {Promise<Array>} çµæœé…åˆ—
   */
  async callGASBatch(requests) {
    try {
      if (window.unifiedDataLoader) {
        const formattedRequests = requests.map(req => ({
          functionName: req.funcName,
          args: req.args || [],
          options: req.options || {}
        }));
        return await window.unifiedDataLoader.loadBatchData(formattedRequests);
      }

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å€‹åˆ¥å®Ÿè¡Œ
      const promises = requests.map(req =>
        this.callGAS(req.funcName, req.options || {}, ...(req.args || []))
          .catch(error => ({ error: error.message, funcName: req.funcName }))
      );
      return Promise.all(promises);
    } catch (error) {
      this.logError(error, 'callGASBatch');
      throw error;
    }
  },

  /**
   * try-catch ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
   * @param {Function} fn - å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * @param {string} [context] - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @returns {*} å®Ÿè¡Œçµæœã¾ãŸã¯undefined
   */
  async safeExecute(fn, context = '') {
    try {
      return await fn();
    } catch (error) {
      this.showError(error, context);
      return undefined;
    }
  },

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   * @param {Function} submitFunction - é€ä¿¡å‡¦ç†é–¢æ•°
   * @param {string} context - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {Promise} é€ä¿¡çµæœ
   */
  async handleFormSubmission(submitFunction, context = '', options = {}) {
    const {
      showLoadingMessage = 'é€ä¿¡ä¸­...',
      successMessage = 'é€ä¿¡ãŒå®Œäº†ã—ã¾ã—ãŸ',
      validateForm = null,
      onSuccess = null,
      onError = null
    } = options;

    try {
      // ãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼
      if (validateForm && typeof validateForm === 'function') {
        const validationResult = await validateForm();
        if (!validationResult.isValid) {
          throw new Error(validationResult.message || 'å…¥åŠ›å†…å®¹ã«å•é¡ŒãŒã‚ã‚Šã¾ã™');
        }
      }

      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
      if (window.unifiedLoading && showLoadingMessage) {
        window.unifiedLoading.show(showLoadingMessage);
      }

      // é€ä¿¡å®Ÿè¡Œ
      const result = await submitFunction();

      // æˆåŠŸå‡¦ç†
      if (successMessage && typeof showMessage === 'function') {
        showMessage(successMessage, 'success');
      }
      if (onSuccess && typeof onSuccess === 'function') {
        await onSuccess(result);
      }

      return result;

    } catch (error) {
      this.logError(error, context);
      const userMessage = this.getUserMessage(error, context);

      if (typeof showMessage === 'function') {
        showMessage(userMessage, 'error');
      } else {
        this.showError(error, context);
      }

      if (onError && typeof onError === 'function') {
        await onError(error);
      }

      throw error;
    } finally {
      if (window.unifiedLoading) {
        window.unifiedLoading.hide();
      }
    }
  },

  /**
   * éåŒæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   * @param {Function} loadFunction - ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é–¢æ•°
   * @param {string} context - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {Promise} èª­ã¿è¾¼ã¿çµæœ
   */
  async handleDataLoading(loadFunction, context = '', options = {}) {
    const {
      fallbackData = null,
      showErrors = true,
      retryCount = 1,
      retryDelay = 1000
    } = options;

    let lastError;

    for (let attempt = 1; attempt <= retryCount; attempt++) {
      try {
        return await loadFunction();
      } catch (error) {
        lastError = error;
        this.logError(error, `${context} (è©¦è¡Œ${attempt}/${retryCount})`);

        if (attempt < retryCount) {
          console.log(`ğŸ”„ ${context}: ${retryDelay}mså¾Œã«ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™`);
          // CLAUDE.md V8 compliant: Promise-based delay for retry logic
          await new Promise(resolve => {
            const createPromiseDelay = (ms) => {
              const start = Date.now();
              const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
              check();
            };
            createPromiseDelay(retryDelay);
          });
          continue;
        }

        // æœ€çµ‚è©¦è¡Œã§ã‚‚å¤±æ•—ã—ãŸå ´åˆ
        if (showErrors) {
          const userMessage = this.getUserMessage(error, context);
          if (typeof showMessage === 'function') {
            showMessage(userMessage, 'error');
          }
        }

        if (fallbackData !== null) {
          console.log(`ğŸ“¦ ${context}: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨`);
          return fallbackData;
        }

        throw error;
      }
    }
  },

  /**
   * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œè¨¼ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   * @param {HTMLElement} field - å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
   * @param {Function} validator - æ¤œè¨¼é–¢æ•°
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   */
  setupFieldValidation(field, validator, options = {}) {
    const {
      validClass = 'border-green-500',
      invalidClass = 'border-red-500',
      showTooltip = true,
      debounceDelay = 300
    } = options;

    if (!field || typeof validator !== 'function') {
      console.warn('setupFieldValidation: ç„¡åŠ¹ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿');
      return;
    }

    let timeoutId;
    const validate = async () => {
      try {
        const result = await validator(field.value);

        // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
        field.classList.remove(invalidClass);
        field.classList.add(validClass);

        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—å‰Šé™¤
        if (showTooltip) {
          this.removeTooltip(field);
        }

        return { isValid: true, result };
      } catch (error) {
        // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
        field.classList.remove(validClass);
        field.classList.add(invalidClass);

        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤º
        if (showTooltip) {
          this.showTooltip(field, error.message);
        }

        return { isValid: false, error: error.message };
      }
    };

    // CLAUDE.md V8 compliant: Promise-based debouncing
    let debouncePromise = null;
    field.addEventListener('input', () => {
      if (debouncePromise) {
        debouncePromise.cancelled = true;
      }

      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => {
          if (debouncePromise?.cancelled) return;
          (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        };
        check();
      });

      debouncePromise = createPromiseDelay(debounceDelay);
      debouncePromise.then(() => {
        if (!debouncePromise.cancelled) {
          validate();
        }
      });
    });

    field.addEventListener('blur', validate);
  },

  /**
   * ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤ºãƒ˜ãƒ«ãƒ‘ãƒ¼
   */
  showTooltip(element, message) {
    this.removeTooltip(element);

    const tooltip = document.createElement('div');
    tooltip.className = 'error-tooltip absolute z-50 bg-red-600 text-white text-xs p-2 rounded shadow-lg';
    tooltip.textContent = message;
    tooltip.setAttribute('data-tooltip-for', element.id || 'unknown');

    const rect = element.getBoundingClientRect();
    tooltip.style.left = rect.left + 'px';
    tooltip.style.top = (rect.bottom + 5) + 'px';

    document.body.appendChild(tooltip);
  },

  /**
   * ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—å‰Šé™¤ãƒ˜ãƒ«ãƒ‘ãƒ¼
   */
  removeTooltip(element) {
    const existing = document.querySelector(`[data-tooltip-for="${element.id || 'unknown'}"]`);
    if (existing) {
      existing.remove();
    }
  }
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¨­å®š
window.addEventListener('error', (event) => {
  window.ErrorHandler.logError(event.error, 'ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼', {
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });
});

window.addEventListener('unhandledrejection', (event) => {
  window.ErrorHandler.logError(event.reason, 'æœªå‡¦ç†Promiseæ‹’å¦');
  event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’é˜²ã
});

console.info('SharedErrorHandling loaded successfully');
</script>