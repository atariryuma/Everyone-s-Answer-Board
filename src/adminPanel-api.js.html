<script>
// =============================================================================
// ADMIN PANEL API COMMUNICATIONS & BACKEND CALLS
// =============================================================================

// =============================================================================
// BACKEND FUNCTION WRAPPERS
// =============================================================================

// マルチテナント対応: 新しいrunGasWithUserId関数 - ローディング機能付き
function runGasWithUserId(functionName, loadingMessage = '処理中...', ...args) {
  // ローディング表示が必要な場合は callWithLoading を使用
  if (loadingMessage && loadingMessage !== false) {
    // userIdが設定されていない場合は初期化を待つ
    if (!userId) {
      return userIdPromise.then(() => {
        if (!userId) {
          logError('No userId available for:', functionName);
          throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
        }
        
        // ローディング機能付きでuserIdを第一引数として追加 - Admin Panel uses overlay loading
        return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args);
      }).catch((error) => {
        logError('Error in runGasWithUserId (after userIdPromise):', error);
        throw error;
      });
    }
    
    // userIdが既に設定されている場合 - ローディング機能付き - Admin Panel uses overlay loading
    return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args).catch((error) => {
      logError('Error in runGasWithUserId (direct call with loading):', error);
      throw error;
    });
  }
  
  // ローディング不要の場合（loadingMessage = false）は従来通り
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        logError('No userId available for:', functionName);
        throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
      }
      
      // userIdを第一引数として追加
      return gasOptimizer.call(functionName, userId, ...args);
    }).catch((error) => {
      logError('userIdPromise rejected:', error);
      throw error;
    });
  }
  
  // userIdを第一引数として追加
  return gasOptimizer.call(functionName, userId, ...args);
}

// callWithCache 関数 - 読み取り専用操作用
function callWithCache(functionName, cacheKey, ttl, ...args) {
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, ...args);
  }, ttl);
}

// runGasWithUserId with cache support
function callWithCacheWithUserId(functionName, cacheKey, ttl, ...args) {
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        throw new Error('ユーザーIDが設定されていません。');
      }
      return unifiedCache.getOrSet(cacheKey, function() {
        return gasOptimizer.call(functionName, userId, ...args);
      }, ttl);
    });
  }
  
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, userId, ...args);
  }, ttl);
}

// =============================================================================
// STATUS AND DATA LOADING
// =============================================================================

// Load system status - OPTIMIZED with integrated API
// Load system status - OPTIMIZED with integrated API
function loadStatus(bypassCache = false) {
  console.group('🔄 loadStatus - Integrated API');
  logDebug('🚀 Loading system status with integrated API, bypassCache:', bypassCache);
  logDebug('📞 About to call runGasWithUserId for getAppConfig'); // getInitialData -> getAppConfig

  // userIdPromise が解決されるのを待ってから getAppConfig を呼び出す
  return userIdPromise.then(() => {
    if (!userId) {
      console.error('❌ userId is not available after userIdPromise resolution in loadStatus!');
      showMessage('ユーザーIDが取得できません。ページを再読み込みしてください。', 'error');
      console.groupEnd();
      return Promise.reject(new Error('userId is not available'));
    }

    logDebug('✅ userId is available:', userId);
    logDebug('🌐 Calling getAppConfig with userId:', userId); // getInitialData -> getAppConfig

    // runGasWithUserId を使用して getAppConfig を呼び出す
    // 最新のステータスを取得するため追加の引数は不要
    console.log('DEBUG: Calling getAppConfig via runGasWithUserId'); // ★追加
    return runGasWithUserId('getAppConfig', 'システム情報を読み込み中...') // getInitialData -> getAppConfig
      .then(response => {
        logDebug('✅ Integrated data loaded:', response);

        // Update UI with integrated response
        try {
          if (typeof updateUIWithNewStatus === 'function') {
            updateUIWithNewStatus(response);
          } else {
            console.error('❌ updateUIWithNewStatus関数が未定義、フォールバック処理実行');
            // フォールバック: 直接データベース情報を更新
            emergencyUpdateDatabaseInfo(response);
          }
        } catch (updateError) {
          console.error('❌ updateUIWithNewStatus実行エラー:', updateError);
          // フォールバック: 直接データベース情報を更新
          emergencyUpdateDatabaseInfo(response);
        }

        // If sheet details are included, apply them immediately
        if (response.sheetDetails && response.activeSheetName) {
          logDebug('✅ Sheet details included in integrated response, applying configuration');
          try {
            populateHeaderOptions(response.sheetDetails.allHeaders);
            logDebug('✅ Header options populated from integrated data');
            populateConfig(response.sheetDetails.guessedConfig);
            logDebug('✅ AI configuration applied from integrated data');
          } catch (configError) {
            console.error('Error applying sheet configuration from integrated data:', configError);
          }
        }

        logInfo('⚡ Performance: Single API call replaced 3-4 separate calls');
        return response; // Promiseチェーンを維持するためレスポンスを返す
      })
      .catch(error => {
        console.error('❌ Integrated API failed:', error);
        showMessage('システムステータスの読み込みに失敗しました', 'error');
        throw error; // エラーを再スロー
      })
      .finally(() => {
        console.groupEnd();
      });
  }).catch(error => {
    console.error('❌ Error resolving userIdPromise in loadStatus:', error);
    showMessage('ユーザーIDの初期化に失敗しました。ページを再読み込みしてください。', 'error');
    console.groupEnd();
    throw error; // エラーを再スロー
  });
}

// 🚨 緊急フォールバック: 直接データベース情報更新
function emergencyUpdateDatabaseInfo(response) {
  console.log('🚨 emergencyUpdateDatabaseInfo: 開始');
  
  try {
    if (!response || !response.userInfo) {
      console.error('❌ emergencyUpdateDatabaseInfo: response.userInfoがありません');
      return;
    }
    
    // 直接DOM要素を更新
    const updateElement = (id, value) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value || '-';
        console.log(`✅ ${id} = "${value}"`);
      } else {
        console.error(`❌ 要素が見つかりません: ${id}`);
      }
    };
    
    // 基本情報の更新
    updateElement('info-admin-email', response.userInfo.adminEmail);
    updateElement('info-user-id', response.userInfo.userId);
    updateElement('info-answer-count', response.answerCount || '0');
    
    // 公開シート名の更新
    const publishedSheetName = (response.config && response.config.publishedSheetName) || 
                              response.publishedSheetName || 'なし';
    updateElement('info-published-sheet', publishedSheetName);
    
    // 作成日と最終アクセス日
    if (response.userInfo.createdAt) {
      const createdAt = new Date(response.userInfo.createdAt).toLocaleDateString('ja-JP');
      updateElement('info-created-at', createdAt);
    }
    
    if (response.userInfo.lastAccessedAt) {
      const lastAccessed = new Date(response.userInfo.lastAccessedAt).toLocaleDateString('ja-JP');
      updateElement('info-last-access', lastAccessed);
    }
    
    // 表示モード
    const displayMode = (response.config && response.config.showNames) ? '名前表示' : '匿名表示';
    updateElement('info-display-mode', displayMode);
    
    // カウント表示
    const showCounts = (response.config && response.config.showCounts) ? '表示' : '非表示';
    updateElement('info-show-counts', showCounts);
    
    console.log('✅ emergencyUpdateDatabaseInfo: 完了');
    
  } catch (error) {
    console.error('❌ emergencyUpdateDatabaseInfo: エラー:', error);
  }
}

// Load sheet configuration for selected sheet
function loadConfigForSelected() {
  if (!selectedSheet) {
    logWarn('No sheet selected for config loading');
    return;
  }
  
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
    logError('Missing required data for loadConfigForSelected');
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return;
  }
  
  runGasWithUserId('getSheetDetails', 'シート情報を読み込み中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
    .then(handleSheetDetailsSuccess)
    .catch(handleSheetDetailsError);
}

// Handle successful sheet details loading
function handleSheetDetailsSuccess(details) {
  if (details && details.allHeaders) {
    populateHeaderOptions(details.allHeaders);
    
    // Show config area and hide placeholder
    const configArea = document.getElementById('config-area');
    const configPlaceholder = document.getElementById('config-placeholder');
    
    if (configArea) {
      configArea.classList.remove('hidden');
    }
    
    if (configPlaceholder) {
      configPlaceholder.classList.add('hidden');
    }
    
    if (details.guessedConfig) {
      // DOMの更新が完了するのを待ってからpopulateConfigを呼び出す
      setTimeout(() => {
        populateConfig(details.guessedConfig);
        
        // Enhanced auto-detection success message with specifics
        const detectedColumns = [];
        if (details.guessedConfig.opinionColumn) detectedColumns.push(`回答列: ${details.guessedConfig.opinionColumn}`);
        if (details.guessedConfig.nameColumn) detectedColumns.push(`名前列: ${details.guessedConfig.nameColumn}`);
        if (details.guessedConfig.classColumn) detectedColumns.push(`クラス列: ${details.guessedConfig.classColumn}`);
        
        const message = detectedColumns.length > 0 
          ? `🤖 AI列判定が自動実行されました！検出された列: ${detectedColumns.join(', ')}。設定を確認してください。`
          : '🤖 AI列判定が自動実行されました。設定を確認してください。';
        
        showMessage(message, 'success');
      }, 0);
    }
  } else {
    logWarn('No headers in sheet details:', details);
    showMessage('シートの詳細情報を取得できませんでした。', 'warning');
  }
}

// Handle sheet details loading error
function handleSheetDetailsError(error) {
  logError('Sheet details failed:', error);
  handleError(error, 'loadConfigForSelected', 'シート情報の読み込みに失敗しました。');
}

// =============================================================================
// AI COLUMN DETECTION
// =============================================================================

// Run AI-powered header guessing
function runHeaderGuessing() {
  if (!selectedSheet) {
    showMessage('シートを選択してください。', 'warning');
    return;
  }
  
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return;
  }
  
  // Update button state to show AI is working
  const reguessBtn = document.getElementById('reguess-headers-btn');
  if (reguessBtn) {
    const originalContent = reguessBtn.innerHTML;
    reguessBtn.disabled = true;
    reguessBtn.innerHTML = `
      <span class="relative z-10 flex items-center gap-1">
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        <span class="text-xs font-bold">AI分析中</span>
      </span>
    `;
    
    // Restore button after completion
    const restoreButton = () => {
      reguessBtn.disabled = false;
      reguessBtn.innerHTML = originalContent;
    };
    
    // Show start notification
    showMessage('🤖 高精度AI判定システムが起動しました。データを分析中...', 'info');
    
    runGasWithUserId('getSheetDetails', 'AI搭載高精度列判定システムが分析中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(function(details) {
        if (!details || !details.guessedConfig) {
          restoreButton();
          showMessage('❌ AI列判定が失敗しました。手動で列を設定してください。', 'warning');
          return;
        }
        
        const configToUse = {
          ...details.guessedConfig,
          sheetName: selectedSheet
        };
        
        setTimeout(() => {
          populateConfig(configToUse);
          restoreButton();
          
          // Enhanced completion notification with analysis details
          const detectedColumns = [];
          if (configToUse.opinionColumn) detectedColumns.push(`💬 回答列: ${configToUse.opinionColumn}`);
          if (configToUse.nameColumn) detectedColumns.push(`👤 名前列: ${configToUse.nameColumn}`);
          if (configToUse.classColumn) detectedColumns.push(`🏫 クラス列: ${configToUse.classColumn}`);
          if (configToUse.reasonColumn) detectedColumns.push(`💭 理由列: ${configToUse.reasonColumn}`);
          
          const message = detectedColumns.length > 0 
            ? `🎉 高精度AI判定が完了しました！\n\n検出された列:\n${detectedColumns.join('\n')}\n\n自動的にセットアップを完了します...`
            : '🎉 高精度AI判定が完了しました！自動的にセットアップを完了します...';
          
          showMessage(message, 'success');
          
          // ✨ 重要: AI判定完了後に自動的にセットアップを完了
          setTimeout(() => {
            console.log('🚀 AI判定完了 - 自動セットアップ完了処理を開始');
            
            // セットアップ状態を確認して必要な場合のみ実行
            if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
              const config = getConfigJSON(currentStatus.userInfo);
              
              if (config.setupStatus === 'pending' || !config.formCreated) {
                console.log('🔧 セットアップ未完了状態を検出 - 自動完了を実行');
                completeAIDetectionProcess();
              } else {
                console.log('✅ セットアップは既に完了済み - 自動完了をスキップ');
              }
            } else {
              console.log('🔧 ステータス情報が不明 - 念のため自動完了を実行');
              completeAIDetectionProcess();
            }
          }, 1000);
        }, 100);
      })
      .catch(function(error) {
        restoreButton();
        console.error('AI column detection error:', error);
        
        // Enhanced error message with specific guidance
        let errorMessage = '❌ 高精度AI判定システムでエラーが発生しました。\n\n';
        if (error?.message?.includes('permission') || error?.message?.includes('権限')) {
          errorMessage += '📋 スプレッドシートへのアクセス権限を確認してください。';
        } else if (error?.message?.includes('network') || error?.message?.includes('timeout')) {
          errorMessage += '🌐 ネットワーク接続を確認して再試行してください。';
        } else {
          errorMessage += '⚙️ 手動で列を設定するか、再度お試しください。';
        }
        
        errorMessage += '\n\n💡 問題が続く場合は、管理者にお問い合わせください。';
        
        showMessage(errorMessage, 'error');
      });
  }
}

// ✨ AI判定完了後の自動セットアップ完了処理
function completeAIDetectionProcess() {
  try {
    console.log('🔧 AI判定完了 - セットアップ自動完了を実行中...');
    
    // 1. 設定検証
    if (!validateConfig()) {
      console.warn('⚠️ AI判定結果の設定が不完全 - 手動設定が必要');
      showMessage('AI判定結果を確認してください。設定に不備があります。', 'warning');
      return;
    }
    
    // 2. フォームURL検出・作成の実行
    console.log('🔍 フォームURL検出を実行中...');
    
    runGasWithUserId('detectFormUrlFromSpreadsheet', 'フォーム検出中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(result => {
        console.log('📋 フォーム検出結果:', result);
        
        if (result && result.success && result.formUrl) {
          console.log('✅ フォームURL検出成功:', result.formUrl);
          
          // 3. 設定の自動保存と完了状態への更新
          const config = buildConfigObject();
          config.formUrl = result.formUrl;
          config.formCreated = true;
          config.setupStatus = 'completed';
          
          console.log('💾 AI判定完了後の設定を自動保存中...', config);
          
          return runGasWithUserId('saveSheetConfig', '設定保存中...', currentStatus.userInfo.spreadsheetId, selectedSheet, config);
        } else {
          throw new Error('フォームURLの検出に失敗しました');
        }
      })
      .then(saveResult => {
        if (saveResult && saveResult.success) {
          console.log('✅ AI判定完了 - 設定自動保存完了');
          showMessage('🎉 AI判定とセットアップが自動完了しました！', 'success');
          
          // 4. UI状態の更新
          if (typeof loadSystemStatus === 'function') {
            loadSystemStatus();
          }
          
          // 5. ステップ表示の更新
          if (typeof navigateToStep === 'function') {
            navigateToStep(3); // ステップ3（表示設定）に進む
          }
          
        } else {
          throw new Error(saveResult?.message || '設定の保存に失敗しました');
        }
      })
      .catch(error => {
        console.error('❌ AI判定完了処理でエラー:', error);
        showMessage(`⚠️ セットアップの自動完了に失敗しました: ${error.message}\n手動で「保存・公開」を実行してください。`, 'warning');
      });
      
  } catch (error) {
    console.error('❌ completeAIDetectionProcess 致命的エラー:', error);
    showMessage('セットアップ自動完了でエラーが発生しました。手動で設定を確認してください。', 'error');
  }
}

// ✨ セットアップ状態の診断・修復機能
function repairSetupStateInconsistencies() {
  return new Promise((resolve, reject) => {
    try {
      console.log('🔧 セットアップ状態の診断・修復を開始...');
      
      if (!currentStatus || !currentStatus.userInfo) {
        reject(new Error('ユーザー情報が利用できません'));
        return;
      }
      
      // getConfigJSON関数の代替処理（サーバーサイド関数が未定義のため）
      let config;
      try {
        if (currentStatus.userInfo.configJson) {
          config = JSON.parse(currentStatus.userInfo.configJson);
        } else {
          config = {};
        }
      } catch (parseError) {
        console.error('❌ ConfigJSON parse error:', parseError);
        config = {};
      }
        
      const issues = [];
      const fixes = [];
      
      // 1. フォームURL vs formCreated の整合性チェック
      if (config.formUrl && config.formUrl.trim() && !config.formCreated) {
        issues.push('フォームURLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正');
      }
      
      // 2. formCreated vs setupStatus の整合性チェック
      if (config.formCreated && config.setupStatus !== 'completed') {
        issues.push('フォームが作成済みだが setupStatus != completed');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正');
      }
      
      // 3. スプレッドシートIDとactiveSheetNameの整合性チェック
      if (currentStatus.userInfo.spreadsheetId && !currentStatus.activeSheetName && selectedSheet) {
        issues.push('スプレッドシートが存在するが activeSheetName が未設定');
        // これはconfigではなくstatusの問題なので、バックエンドで修正が必要
        fixes.push('activeSheetName の更新が必要（要バックエンド処理）');
      }
      
      // 4. 公開状態の整合性チェック（publishedSheetName vs appPublished）
      if (config.publishedSheetName && !config.appPublished) {
        issues.push('公開シート名が存在するが appPublished=false');
        // これは慎重に判断する必要があるため、警告のみ
        fixes.push('注意: 公開状態の確認が必要');
      }
      
      // 5. 🔧 新ルール: appPublished=true だが setupStatus='pending' の場合（公開済み不整合）
      if (config.appPublished && config.setupStatus === 'pending') {
        issues.push('公開済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（既に公開済みのため）');
      }
      
      // 6. 🔧 新ルール: 公開URLが存在するが formCreated=false の場合
      if (currentStatus.viewUrl && currentStatus.viewUrl.trim() && !config.formCreated) {
        issues.push('公開URLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正（公開URL存在のため）');
      }
      
      // 7. 🔧 新ルール: isPublished=true だが setupStatus='pending' の場合（システム状態不整合）
      if (currentStatus.isPublished && config.setupStatus === 'pending') {
        issues.push('システムで公開済み判定だが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（公開状態確認済み）');
      }
      
      // 8. 🔧 新ルール: AI判定結果が存在するがsetupStatus='pending'の場合（AI完了後の状態更新漏れ）
      if (currentStatus.sheetDetails?.guessedConfig && 
          currentStatus.sheetDetails.guessedConfig.opinionHeader && 
          config.setupStatus === 'pending') {
        issues.push('AI列判定完了済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        config.formCreated = true; // AI判定完了時はフォームも準備完了とみなす
        config.customSetupCompleted = true; // カスタムセットアップ完了フラグ
        fixes.push('AI判定完了に基づいてカスタムセットアップ状態を完了に更新');
        
        // カスタムセットアップの自動完了処理をトリガー
        setTimeout(() => {
          triggerCustomSetupCompletion(selectedSheet);
        }, 1000);
      }
      
      console.log('📋 診断結果:', { issues, fixes });
      
      if (fixes.length === 0) {
        resolve({
          success: true,
          message: '✅ セットアップ状態に問題は見つかりませんでした',
          issues: [],
          fixes: []
        });
        return;
      }
      
      // 修正された設定を保存
      console.log('💾 修正された設定を保存中...', config);

        runGasWithUserId('syncConfigurationState', '設定修復中...', config, 'repair')
        .then(saveResult => {
          if (saveResult && saveResult.success) {
            console.log('✅ セットアップ状態の修復完了');
            
            // UI状態の更新
            if (typeof loadSystemStatus === 'function') {
              loadSystemStatus();
            }
            
            resolve({
              success: true,
              message: `🔧 ${fixes.length}件のセットアップ問題を修復しました`,
              issues,
              fixes
            });
          } else {
            reject(new Error(saveResult?.message || '設定の保存に失敗しました'));
          }
        })
        .catch(saveError => {
          reject(new Error(`設定保存エラー: ${saveError.message}`));
        });
        
    } catch (error) {
      console.error('❌ セットアップ状態修復でエラー:', error);
      reject(error);
    }
  });
}

// ✨ セットアップ診断・修復を実行するUI関数
function runSetupRepair() {
  const btn = document.getElementById('setup-repair-btn');
  if (btn) {
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<div class="spinner mr-2"></div>修復中...';
    
    repairSetupStateInconsistencies()
      .then(result => {
        if (result.success) {
          showMessage(result.message, 'success');
          if (result.fixes.length > 0) {
            console.log('修復詳細:', result.fixes);
            
            // 🔧 修復実行後は強制的にUI状態を更新
            setTimeout(() => {
              console.log('🔄 修復後のUI状態更新を実行中...');
              if (typeof loadSystemStatus === 'function') {
                loadSystemStatus();
              }
              if (typeof validateCurrentStep === 'function') {
                validateCurrentStep();
              }
            }, 200);
          }
        }
      })
      .catch(error => {
        console.error('セットアップ修復エラー:', error);
        showMessage(`セットアップ修復に失敗しました: ${error.message}`, 'error');
      })
      .finally(() => {
        btn.disabled = false;
        btn.innerHTML = originalText;
      });
  }
}

// =============================================================================
// SAVE AND PUBLISH OPERATIONS
// =============================================================================

// Save configuration and publish board - 修正版（公開モーダル経由）
function saveAndPublish() {
  if (!validateConfig()) {
    showMessage('必須項目（回答データ列）が選択されていません。', 'error');
    return;
  }
  
  // UIからconfigオブジェクトを構築
  const config = buildConfigObject();
  
  // 自動停止設定を準備
  const autoStopSettings = {
    enabled: true,
    minutes: 360 // 6時間 = 360分（config.gsと統一）
  };
  
  // Check for privacy-sensitive settings and show warning if enabled
  const showNames = document.getElementById('show-names')?.checked || false;
  const showCounts = document.getElementById('show-counts')?.checked || false;
  
  if (showNames || showCounts) {
    // Show privacy warning modal first
    if (window.sharedModals) {
      const privacySettings = [];
      if (showNames) privacySettings.push('名前表示');
      if (showCounts) privacySettings.push('リアクション数表示');
      
      console.log(`⚠️ プライバシー警告: ${privacySettings.join('・')}が有効です`);
      
      window.sharedModals.showPrivacyWarning(
        // onConfirm - show publish modal after privacy confirmation
        () => {
          console.log('✅ プライバシー警告を確認、公開モーダルを表示');
          showPublishModalAfterChecks(config, autoStopSettings);
        },
        // onCancel - user wants to review settings
        () => {
          console.log('❌ ユーザーがプライバシー設定の見直しを選択');
          showMessage('設定を見直してから再度お試しください。', 'info');
        }
      );
      return;
    }
  }
  
  // If no privacy concerns, show publish modal directly
  showPublishModalAfterChecks(config, autoStopSettings);
}

// 公開モーダル表示（プライバシーチェック後）
function showPublishModalAfterChecks(config, autoStopSettings) {
  if (window.sharedModals && typeof window.sharedModals.showPublish === 'function') {
    window.sharedModals.showPublish(
      // 公開実行時のコールバック
      () => {
        console.log('📤 公開モーダルで公開が選択されました');
        proceedWithSaveAndPublish(config);
      },
      // キャンセル時のコールバック
      () => {
        console.log('❌ 公開がキャンセルされました');
      },
      // 自動停止設定
      autoStopSettings
    );
  } else {
    // フォールバック: モーダルが利用できない場合は直接実行
    console.warn('⚠️ 公開モーダルが利用できません。直接実行します。');
    proceedWithSaveAndPublish(config);
  }
}

// Proceed with the actual save and publish operation
function proceedWithSaveAndPublish(config) {

  // Set save protection flags to prevent interference
  isSaveInProgress = true;
  freshSaveTimestamp = Date.now();
  window.freshSaveTimestamp = freshSaveTimestamp;
  
  runGasWithUserId('saveAndPublish', '設定を保存し、ボードを公開しています...', selectedSheet, config)
    .then(function(result) {
      isSaveInProgress = false;
      
      // Check if result has data (from integrated API) or legacy success status
      if (result && (result.userInfo || result.status === 'success')) {
        showMessage('✅ 設定が保存され、ボードが公開されました！', 'success');
        
        // 履歴に保存
        // 公開時は履歴保存を行わない（公開停止時に保存するため）
        logDebug('Board published successfully - history will be saved on unpublish');
        
        // ボードビューアーに即座更新を通知
        try {
          // メインウィンドウにメッセージを送信（あれば）
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            }, '*');
            logInfo('ボード公開メッセージをメインウィンドウに送信');
          }
          
          // 同じドメインの他のタブにも通知
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            });
            channel.close();
            logInfo('ボード公開メッセージをBroadcastChannelで送信');
          }
        } catch (broadcastError) {
          console.warn('リアルタイム更新通知でエラー:', broadcastError);
        }
        
        // 6時間自動停止の確認モーダルを表示
        setTimeout(() => {
          // ローディングオーバーレイを確実に非表示にしてからモーダル表示
          if (window.unifiedLoadingManager) {
            window.unifiedLoadingManager.setLoading(false);
            console.log('🔄 通常公開後にローディングを非表示にしました');
          }
          
          // 公開完了確認とURL生成後に自動停止確認モーダルを表示
          setTimeout(() => {
            // 公開状態とURL生成の確認
            if (result && (result.publishedAt || result.userInfo)) {
              const publishResult = {
                publishedAt: result.publishedAt || new Date().toISOString(),
                autoStopMinutes: result.autoStopMinutes || 360,
                boardUrl: result.boardUrl || result.viewUrl || '',
                status: 'success',
                ...result
              };
              
              console.log('📊 通常公開完了データ確認:', {
                hasPublishedAt: !!publishResult.publishedAt,
                hasAutoStopMinutes: !!publishResult.autoStopMinutes,
                hasBoardUrl: !!publishResult.boardUrl,
                publishResult
              });
              
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(publishResult);
                console.log('✅ 通常公開後に自動停止確認モーダルを表示しました');
              } else {
                console.warn('⚠️ 自動停止確認モーダルが利用できません');
              }
            } else {
              console.warn('⚠️ 通常公開結果データが不完全のため、自動停止モーダルをスキップします:', result);
            }
          }, 800); // URL生成待ちのため少し長めに設定
        }, 2000); // 成功メッセージの後に表示
        
        // Use fresh data from save response if available
        if (result.userInfo && result._meta) {
          logInfo('Using fresh data from save response');
          updateUIWithNewStatus(result);
        } else {
          // Only force refresh if no fresh data available
          logInfo('No fresh data in response, forcing refresh');
          loadStatus(true).then(() => {
            // ステップ進行を更新
            const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
            updateStepIndicators(currentStep);
            manageSectionStates(currentStep);
          });
        }
      } else {
        logError('Save failed:', result);
        showMessage(result.message || '設定の保存に失敗しました。', 'error');
        isSaveInProgress = false;
      }
    })
    .catch(function(error) {
      logError('saveAndPublish error:', error);
      isSaveInProgress = false;
      
      // Clear caches after error and reload
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      
      loadStatus(true).then(() => {
        // エラー後もステップ進行を更新
        const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
        updateStepIndicators(currentStep);
        manageSectionStates(currentStep);
      });
      handleError(error, 'saveAndPublish', '設定の保存に失敗しました。システム状態を再読み込みしました。');
    });
}

/**
 * 公開停止時の強化されたキャッシュクリア処理
 * キャッシュ関連のアクセス問題を防ぐため、あらゆるキャッシュを完全にクリア
 */
function clearAllCachesForUnpublish() {
  console.log('🧹 公開停止時の包括的キャッシュクリア処理を開始');
  
  try {
    // 1. アプリケーションレベルのキャッシュクリア
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      console.log('🗑️ Unified cache cleared');
      window.unifiedCache.clear();
    }
    
    if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
      console.log('🗑️ GAS optimizer cache cleared');
      window.gasOptimizer.clearCache();
    }
    
    // 2. ローカルストレージのキャッシュクリア（StudyQuest関連のみ）
    try {
      const localStorageKeys = Object.keys(localStorage);
      const studyQuestKeys = localStorageKeys.filter(key => 
        key.includes('studyquest') || 
        key.includes('board') || 
        key.includes('sheet') ||
        key.includes('admin') ||
        key.includes('publication') ||
        key.includes('answer')
      );
      
      studyQuestKeys.forEach(key => {
        console.log('🗑️ Removing localStorage key:', key);
        localStorage.removeItem(key);
      });
      
      console.log(`🗑️ Cleared ${studyQuestKeys.length} localStorage keys`);
    } catch (e) {
      console.warn('⚠️ localStorage clear warning:', e);
    }
    
    // 3. セッションストレージのクリア
    try {
      if (window.sessionStorage) {
        const sessionKeys = Object.keys(sessionStorage);
        const studyQuestSessionKeys = sessionKeys.filter(key => 
          key.includes('studyquest') || 
          key.includes('board') || 
          key.includes('admin')
        );
        
        studyQuestSessionKeys.forEach(key => {
          console.log('🗑️ Removing sessionStorage key:', key);
          sessionStorage.removeItem(key);
        });
        
        console.log(`🗑️ Cleared ${studyQuestSessionKeys.length} sessionStorage keys`);
      }
    } catch (e) {
      console.warn('⚠️ sessionStorage clear warning:', e);
    }
    
    // 4. BroadcastChannel通知（他のタブに公開停止を通知）
    try {
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.postMessage({
          type: 'BOARD_UNPUBLISHED',
          timestamp: Date.now(),
          userId: window.userId || 'unknown'
        });
        console.log('📢 BroadcastChannel: 公開停止を他のタブに通知');
        channel.close();
      }
    } catch (e) {
      console.warn('⚠️ BroadcastChannel notification warning:', e);
    }
    
    // 5. キャッシュ無効化のためのタイムスタンプ更新
    try {
      localStorage.setItem('lastUnpublishTime', Date.now().toString());
      localStorage.setItem('cacheInvalidationToken', Math.random().toString(36));
      console.log('🔄 Cache invalidation tokens updated');
    } catch (e) {
      console.warn('⚠️ Cache invalidation token update warning:', e);
    }
    
    console.log('✅ 公開停止時のキャッシュクリア処理が完了しました');
    
  } catch (error) {
    console.error('❌ キャッシュクリア処理でエラー:', error);
    // エラーがあっても処理は継続
  }
}

// Unpublish board
function unpublishBoard() {
  return runGasWithUserId('unpublishBoard', 'ボードの公開を停止中...')
    .then(function(response) {
      logDebug('公開停止レスポンス:', response);
      showMessage(response.message || '✅ 回答ボードの公開を停止しました。', 'success');
      
      // 公開停止時に履歴を保存
      saveHistoryOnUnpublish(response);
      
      // 強化されたキャッシュクリア処理（キャッシュバスティング対応）
      clearAllCachesForUnpublish();
      
      // Reset column selection dropdowns to default "--列を選択--" state
      resetColumnSelections();
      
      loadStatus(true); // ステータスを強制更新
      
      // 公開停止処理が成功したことを返す
      return Promise.resolve(response);
    })
    .catch(function(error) {
      handleError(error, 'unpublishBoard', 'ボードの公開停止に失敗しました。');
      // エラーを再スローして呼び出し元でキャッチできるようにする
      return Promise.reject(error);
    });
}

// 公開停止時に履歴を保存する関数
function saveHistoryOnUnpublish(unpublishResponse) {
  try {
    // 現在のステータスを取得（キャッシュから）
    const currentStatus = window.lastStatusCache;
    if (!currentStatus || !currentStatus.config) {
      logWarn('履歴保存: 現在のステータス情報が取得できません');
      return;
    }
    
    const config = currentStatus.config;
    const userInfo = currentStatus.userInfo || {};
    
    // 履歴アイテムを作成
    const historyItem = {
      questionText: config.opinionHeader || config.opinionColumn || userInfo.customFormInfo?.mainQuestion || '（問題文未設定）',
      sheetName: config.publishedSheetName || '',
      publishedAt: config.publishedAt || config.lastPublishedAt || new Date().toISOString(),
      endTime: new Date().toISOString(), // 実際の終了日時
      scheduledEndTime: config.scheduledEndTime || null, // 予定終了日時
      answerCount: unpublishResponse.answerCount || currentStatus.answerCount || 0,
      reactionCount: unpublishResponse.reactionCount || currentStatus.reactionCount || 0,
      config: config,
      formUrl: userInfo.formUrl || '',
      spreadsheetUrl: userInfo.spreadsheetUrl || '',
      setupType: determineSetupType(config, userInfo),
      isActive: false // 終了したのでfalse
    };
    
    // LocalStorage履歴保存を実行
    saveToHistory(historyItem);
    
    // サーバーサイド履歴保存も実行
    try {
      runGasWithUserId('saveHistoryToSheetAPI', '履歴をサーバーに保存中...', historyItem)
        .then(response => {
          if (response && response.status === 'success') {
            logDebug('✅ サーバーサイド履歴保存完了:', response);
          } else {
            logWarn('⚠️ サーバーサイド履歴保存で警告:', response);
          }
        })
        .catch(error => {
          logWarn('❌ サーバーサイド履歴保存エラー:', error);
        });
    } catch (serverError) {
      logWarn('❌ サーバーサイド履歴保存の呼び出しに失敗:', serverError);
    }
    
    logDebug('履歴保存完了（公開停止時）:', historyItem);
    
  } catch (error) {
    logWarn('公開停止時の履歴保存に失敗:', error);
  }
}

// セットアップタイプを判定する補助関数
function determineSetupType(config, userInfo) {
  if (userInfo.customFormInfo) {
    return 'カスタムセットアップ';
  } else if (config.isQuickStart || config.setupType === 'quickstart') {
    return 'クイックスタート';
  } else if (config.isExternalResource) {
    return '外部リソース';
  } else {
    return 'unknown';
  }
}

// Reset column selection dropdowns to default state
function resetColumnSelections() {
  console.log('🔄 Resetting column selections to default state');
  
  const columnSelects = [
    'opinion-column-select',
    'name-column-select', 
    'reason-column-select',
    'class-column-select',
    'timestamp-column-select'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.value = ''; // Reset to empty value
      console.log(`✅ Reset ${selectId} to default`);
    }
  });
  
  // Also reset any display checkboxes
  const checkboxes = ['show-names', 'show-counts'];
  checkboxes.forEach(checkboxId => {
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      checkbox.checked = false;
      console.log(`✅ Reset ${checkboxId} to unchecked`);
    }
  });
}

// =============================================================================
// FORM MANAGEMENT
// =============================================================================

// Load saved class choices
function loadSavedClassChoices() {
    runGasWithUserId('getSavedClassChoices', 'クラス選択肢を読み込み中...')
        .then(function(result) {
            if (result.status === 'success' && result.classChoices) {
                const classChoicesTextarea = document.getElementById('class-choices');
                if (classChoicesTextarea) {
                    classChoicesTextarea.value = result.classChoices.join('\n');
                }
            }
        })
        .catch(function(error) {
            console.warn('保存されたクラス選択肢の読み込みに失敗:', error.message);
            showMessage('クラス選択肢の読み込みに失敗しました。', 'error');
        });
}

// Create form with custom configuration
function createFormWithConfig() {
  const questionTextarea = document.getElementById('custom-main-question');
  const questionTypeSelect = document.getElementById('main-question-type');
  const questionChoicesTextarea = document.getElementById('main-question-choices');
  const classChoicesTextarea = document.getElementById('class-choices');
  const includeOthersOption = document.getElementById('include-others-option').checked;
  const enableClassSelection = document.getElementById('enable-class-selection').checked;
  
  if (!questionTextarea || !questionTypeSelect) {
    showMessage('フォーム作成に必要な要素が見つかりません。', 'error');
    return;
  }
  
  const question = questionTextarea.value.trim();
  const questionType = questionTypeSelect.value; // 回答方法を取得
  const questionChoicesText = questionChoicesTextarea ? questionChoicesTextarea.value.trim() : '';
  const classChoicesText = enableClassSelection && classChoicesTextarea ? classChoicesTextarea.value.trim() : '';
  
  if (!question) {
    showMessage('問題文は必須です。', 'warning');
    return;
  }
  
  // 選択肢タイプの場合は選択肢が必要
  if ((questionType === 'choice' || questionType === 'multiple') && !questionChoicesText) {
    showMessage('選択肢タイプの場合は選択肢を入力してください。', 'warning');
    return;
  }
  
  // 選択肢を配列に変換
  const questionChoices = questionChoicesText ? 
    questionChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  // クラス選択肢を配列に変換  
  const classChoices = classChoicesText ? 
    classChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  const config = {
    mainQuestion: question,
    responseType: questionType, // 回答方法を追加
    questionChoices: questionChoices, // メイン質問の選択肢
    classChoices: classChoices,
    includeOthers: includeOthersOption,
    enableClass: enableClassSelection && classChoices.length > 0,
  };
  
  console.log('📋 カスタムフォーム設定:', config);
  
  hideFormConfigModal();
  
  // カスタムセットアップ用進捗表示を開始
  // Use the new unified custom setup system
  console.log('🎨 統合カスタムセットアップ開始:', config);
  
  // userEmailは現在のユーザー情報から取得
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.adminEmail) {
    showMessage('ユーザー情報が取得できません。ページを再読み込みしてください。', 'error');
    return;
  }
  
  // Call the new unified custom setup handler - this replaces the old createCustomFormUI flow
  handleCustomSetup(config);
  
  // クラス選択肢をデータベースに保存
  saveClassChoicesToDatabase(classChoices);
}


// Save class choices to database
function saveClassChoicesToDatabase(classChoices) {
    runGasWithUserId('saveClassChoices', classChoices)
        .catch(function(error) {
            console.warn('クラス選択肢の保存に失敗:', error.message);
        });
}

// =============================================================================
// RESOURCE MANAGEMENT
// =============================================================================

// Add spreadsheet resource
function addResource() {
  const urlInput = document.getElementById('resource-url-input');
  if (!urlInput) {
    showMessage('URL入力フィールドが見つかりません。', 'error');
    return;
  }
  
  const url = urlInput.value.trim();
  if (!url) {
    showMessage('URLを入力してください。', 'warning');
    return;
  }

  // URLの種類を判定（スプレッドシートのみ対応）
  let resourceType = 'spreadsheet';
  let backendFunction = 'addSpreadsheetUrl';
  
  if (!url.includes('docs.google.com/spreadsheets/')) {
    showMessage('GoogleスプレッドシートのURLを入力してください。', 'warning');
    return;
  }
  
  const resourceTypeText = 'スプレッドシート';

  runGasWithUserId(backendFunction, `${resourceTypeText}を追加しています...`, url)
    .then(function(result) {
      if (result.status === 'success') {
        showMessage(result.message, 'success');
        urlInput.value = ''; // Clear input
        loadStatus(true); // Refresh status
      } else {
        showMessage(result.message || `${resourceTypeText}の追加に失敗しました。`, 'error');
      }
    })
    .catch(function(error) {
      handleError(error, 'addResource', `${resourceTypeText}の追加に失敗しました。`);
    });
}

// =============================================================================
// EXTERNAL LINKS AND NAVIGATION
// =============================================================================

// Copy board URL to clipboard
function copyBoardUrl(buttonElement) {
  const urlInput = document.getElementById('board-url');
  if (!urlInput) {
    console.error('board-url input element not found.');
    return;
  }

  const urlToCopy = urlInput.value;

  if (!urlToCopy) {
    showMessage('コピーするURLがありません。', 'warning');
    return;
  }

  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(urlToCopy).then(() => {
        const originalText = buttonElement.innerHTML;
        buttonElement.innerHTML = '<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>コピー完了!';
        buttonElement.disabled = true;
        setTimeout(() => {
          buttonElement.innerHTML = originalText;
          buttonElement.disabled = false;
        }, 2000);
      }).catch((error) => {
        console.error('Clipboard API failed:', error);
        // Fallback to manual copy message
        const messageElement = document.createElement('span');
        messageElement.textContent = ' (手動でコピーしてください)';
        messageElement.style.color = 'orange';
        buttonElement.parentNode.insertBefore(messageElement, buttonElement.nextSibling);
        setTimeout(() => messageElement.remove(), 5000);
      });
    } else {
      // Fallback for browsers that don't support Clipboard API
      urlInput.select();
      urlInput.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      showMessage('URLがクリップボードにコピーされました！', 'success'); // Fallback uses showMessage
    }
  } catch (err) {
    console.error('copyBoardUrl error:', err);
    showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning'); // Fallback uses showMessage
  }
}

// Copy form URL to clipboard
function copyFormUrl() {
  const urlInput = document.getElementById('form-url-input');
  if (urlInput && urlInput.value) {
    urlInput.select();
    urlInput.setSelectionRange(0, 99999); // For mobile devices
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(urlInput.value).then(() => {
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        });
      } else {
        document.execCommand('copy');
        showMessage('フォームURLがクリップボードにコピーされました！', 'success');
      }
    } catch (err) {
      showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning');
    }
  } else {
    showMessage('コピーするフォームURLがありません。', 'warning');
  }
}

// Open database spreadsheet
function openDatabaseSpreadsheet() {
  if (currentSpreadsheetUrl) {
    window.open(currentSpreadsheetUrl, '_blank');
  } else {
    showMessage('スプレッドシートのURLが見つかりません。', 'warning');
  }
}

// Open form
function openForm() {
  console.log('🔗 openForm function called');
  
  // ボタンが無効化されている場合はクリックを無視
  const formBtn = document.getElementById('open-form-btn');
  if (formBtn && formBtn.disabled) {
    console.log('⚠️ Form button is disabled, ignoring click');
    showMessage('フォームを作成してからクリックしてください。', 'warning');
    return;
  }
  
  // データベースからフォームURLを取得する優先順位を設定
  let formUrl = null;
  
  // 1. configJsonから直接取得（最も確実）
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
    try {
      const configJson = await runGasWithUserId('getConfigJSON', false, currentStatus.userInfo);
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        logDebug('✅ FormURL取得: configJsonから直接取得成功');
      }
    } catch (error) {
      logWarn('⚠️ configJsonの解析でエラー:', error);
    }
  }
  
  // 2. ユーザー情報のformUrlから取得（フォールバック）
  if (!formUrl && currentStatus && currentStatus.userInfo && currentStatus.userInfo.formUrl) {
    formUrl = currentStatus.userInfo.formUrl;
    logDebug('📋 FormURL取得: userInfo.formUrlから取得');
  }
  
  // 3. カスタムフォーム情報から取得（後方互換性）
  if (!formUrl && currentStatus && currentStatus.customFormInfo && currentStatus.customFormInfo.formUrl) {
    formUrl = currentStatus.customFormInfo.formUrl;
    logDebug('📄 FormURL取得: customFormInfo.formUrlから取得');
  }
  
  if (formUrl) {
    window.open(formUrl, '_blank');
  } else {
    showMessage('フォームのURLが見つかりません。先にフォームを作成してください。', 'warning');
  }
}

// Open app setup page
function openAppSetupPage() {
  const loadingMessage = 'アプリ設定ページを準備中...';
  const errorMessage = 'アプリ設定ページへの移動に失敗しました。';
  const timeoutMessage = 'リダイレクトがタイムアウトしました。新しいタブで開きます。';
  const fallbackMessage = 'アプリ設定ページを新しいタブで開きます。';

  runGasWithUserId('getWebAppUrl', loadingMessage)
    .then(function(webAppUrl) {
      const setupUrl = webAppUrl + '?setup=true&mode=appsetup&userId=' + encodeURIComponent(userId);

      // ユーザーにリダイレクト中であることを伝える
      showMessage('アプリ設定ページへ移動中...', 'info');
      window.unifiedLoading.showSimple('アプリ設定ページへ移動中...');

      const redirectTimeout = setTimeout(() => {
        console.warn('Redirect to app setup page timed out. Attempting fallback.');
        window.unifiedLoading.hide();
        showMessage(timeoutMessage, 'warning');
        window.open(setupUrl, '_blank'); // Fallback: open in new tab
      }, 10000); // 10秒でタイムアウト

      // 直接リダイレクトを試みる
      try {
        clearTimeout(redirectTimeout);
        window.unifiedLoading.hide();
        window.open(setupUrl, '_top'); // _top を使用して現在のウィンドウで開く
      } catch (e) {
        console.error('Error opening app setup page:', e);
        window.unifiedLoading.hide();
        showMessage(errorMessage + ' ' + (e.message || ''), 'error');
        // フォールバック: 新しいタブで開く
        showMessage(fallbackMessage, 'info');
        window.open(setupUrl, '_blank');
      }
    })
    .catch(function(error) {
      console.error('Failed to get web app URL for app setup page:', error);
      window.unifiedLoading.hide();
      showMessage('アプリ設定ページのURLを取得できませんでした。' + (error.message || ''), 'error');
    });
}

// =============================================================================
// POLLING AND REAL-TIME UPDATES
// =============================================================================

// System status polling variables
let lastUserActivity = Date.now();
let currentPollInterval = 5 * 60 * 1000; // 開始は5分間隔
let statusPollTimer = null;

// Fresh save management to prevent interference
let freshSaveTimestamp = 0;
let isSaveInProgress = false;
const FRESH_SAVE_PROTECTION_DURATION = 30000; // 30 seconds

// Make freshSaveTimestamp globally accessible
window.freshSaveTimestamp = freshSaveTimestamp;

// =============================================================================
// CONFIG VERIFICATION MECHANISM
// =============================================================================

/**
 * 設定保存後の検証機能
 * カスタムセットアップで設定した内容が正しく保存・反映されているかを確認
 */
async function verifyConfigAfterSave(expectedSheetName, expectedConfig) {
  try {
    console.log('🔍 設定反映確認開始:', expectedSheetName);
    
    // 少し待ってからステータスを再取得
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const verificationStatus = await runGasWithUserId('getAppConfig', '設定反映を確認中...');
    
    if (verificationStatus && verificationStatus.userInfo) {
      const configJson = getConfigJSON(verificationStatus.userInfo);
      const sheetKey = 'sheet_' + expectedSheetName;
      const savedConfig = configJson[sheetKey];
      
      console.log('🔍 保存された設定:', savedConfig);
      console.log('🔍 期待する設定:', expectedConfig);
      
      // 基本的な整合性チェック
      const isConsistent = (
        savedConfig &&
        savedConfig.guessedConfig &&
        expectedConfig.opinionHeader &&
        savedConfig.guessedConfig.opinionHeader === expectedConfig.opinionHeader
      );
      
      if (isConsistent) {
        console.log('✅ 設定反映確認: 正常に保存されています');
        return { success: true, message: '設定が正常に反映されました' };
      } else {
        console.warn('⚠️ 設定反映確認: 設定に不整合があります');
        
        // 自動修復を試行
        console.log('🔧 設定不整合を検出 - 自動修復を試行中...');
        await runGasWithUserId('saveSheetConfig', '設定を修復中...',
          currentStatus.userInfo.spreadsheetId, expectedSheetName, expectedConfig, { batchMode: true });
        
        return { success: false, message: '設定不整合を検出し、修復を試行しました', repaired: true };
      }
    }
    
    return { success: false, message: '設定確認中にエラーが発生しました' };
    
  } catch (error) {
    console.error('❌ 設定反映確認エラー:', error);
    return { success: false, message: '設定確認処理でエラーが発生しました: ' + error.message };
  }
}

/**
 * セットアップフロー完了確認（QuickStart・Custom Setup共通）
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {string} sheetName - 対象シート名
 * @returns {Object} 完了確認結果
 */
async function verifySetupFlowCompletion(flowType, sheetName) {
  try {
    console.log(`🎯 ${flowType}フロー完了確認開始:`, sheetName);
    
    // 設定が安定するまで少し待つ
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const completionStatus = await runGasWithUserId('getAppConfig', 'フロー完了状態を確認中...');
    
    if (!completionStatus || !completionStatus.userInfo) {
      console.error('❌ フロー完了確認: ステータス取得失敗');
      return { success: false, message: 'ステータス取得に失敗しました' };
    }
    
    const configJson = await runGasWithUserId('getConfigJSON', false, completionStatus.userInfo);
    const issues = [];
    
    // 必須完了状態の確認
    console.log('🔍 完了状態確認 - configJson:', {
      setupStatus: configJson.setupStatus,
      appPublished: configJson.appPublished,
      formCreated: configJson.formCreated,
      publishedSheetName: configJson.publishedSheetName,
      publishedSpreadsheetId: configJson.publishedSpreadsheetId
    });
    
    // 1. setupStatus='completed' 確認
    if (configJson.setupStatus !== 'completed') {
      issues.push(`❌ setupStatus: "${configJson.setupStatus}" → "completed"が必要`);
    }
    
    // 2. appPublished=true 確認  
    if (configJson.appPublished !== true) {
      issues.push(`❌ appPublished: ${configJson.appPublished} → trueが必要`);
    }
    
    // 3. formCreated=true 確認
    if (configJson.formCreated !== true) {
      issues.push(`❌ formCreated: ${configJson.formCreated} → trueが必要`);
    }
    
    // 4. 公開情報の確認
    if (!configJson.publishedSheetName) {
      issues.push(`❌ publishedSheetName未設定 → "${sheetName}"が必要`);
    } else if (configJson.publishedSheetName !== sheetName) {
      issues.push(`❌ publishedSheetName不一致: "${configJson.publishedSheetName}" → "${sheetName}"`);
    }
    
    if (!configJson.publishedSpreadsheetId) {
      issues.push('❌ publishedSpreadsheetId未設定');
    }
    
    // 5. シート固有設定の確認
    const sheetKey = 'sheet_' + sheetName;
    const sheetConfig = configJson[sheetKey];
    if (!sheetConfig || !sheetConfig.guessedConfig) {
      issues.push(`❌ シート設定未保存: ${sheetKey}`);
    }
    
    if (issues.length === 0) {
      console.log(`✅ ${flowType}フロー完了確認: すべての要件を満たしています`);
      return {
        success: true,
        message: `${flowType}フローが正常に完了しました`,
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!sheetConfig?.guessedConfig
        }
      };
    } else {
      console.warn(`⚠️ ${flowType}フロー完了確認: 未完了項目があります`, issues);
      return {
        success: false,
        message: `${flowType}フローに未完了項目があります`,
        issues: issues,
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!sheetConfig?.guessedConfig
        }
      };
    }
    
  } catch (error) {
    console.error(`❌ ${flowType}フロー完了確認エラー:`, error);
    return { 
      success: false, 
      message: `フロー完了確認でエラーが発生しました: ${error.message}` 
    };
  }
}

/**
 * 設定同期メカニズム強化 - フロー完了状態との整合性を保つ
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {Object} expectedState - 期待される設定状態
 * @returns {Promise<Object>} 同期結果
 */
async function enhanceConfigSynchronization(flowType, expectedState) {
  try {
    console.log(`🔄 ${flowType}フロー: 設定同期メカニズム開始`, expectedState);
    
    // 現在のステータスを取得
    const currentStatus = await runGasWithUserId('getAppConfig', '設定同期のため最新状態を取得中...');
    
    if (!currentStatus || !currentStatus.userInfo) {
      throw new Error('設定同期: ステータス取得失敗');
    }
    
    const configJson = await runGasWithUserId('getConfigJSON', false, currentStatus.userInfo);
    const synchronizationIssues = [];
    const appliedFixes = [];
    
    // 1. 必須設定状態の確認と修正
    const requiredStates = {
      setupStatus: 'completed',
      appPublished: true,
      formCreated: true,
      publishedSheetName: expectedState.sheetName,
      publishedSpreadsheetId: expectedState.spreadsheetId || currentStatus.userInfo.spreadsheetId
    };
    
    let needsSync = false;
    const updatedConfig = { ...configJson };
    
    for (const [key, expectedValue] of Object.entries(requiredStates)) {
      if (configJson[key] !== expectedValue) {
        synchronizationIssues.push(`${key}: "${configJson[key]}" → "${expectedValue}"`);
        updatedConfig[key] = expectedValue;
        needsSync = true;
      }
    }
    
    // 2. シート固有設定の同期確認
    if (expectedState.sheetName && expectedState.config) {
      const sheetKey = 'sheet_' + expectedState.sheetName;
      const currentSheetConfig = configJson[sheetKey];
      
      if (!currentSheetConfig || !currentSheetConfig.guessedConfig) {
        synchronizationIssues.push(`シート設定未保存: ${sheetKey}`);
        updatedConfig[sheetKey] = {
          guessedConfig: expectedState.config,
          lastUpdated: new Date().toISOString(),
          flowType: flowType
        };
        needsSync = true;
      }
    }
    
    // 3. 設定の同期適用（必要な場合のみ）
    if (needsSync) {
      console.log(`🔧 ${flowType}フロー: 設定不整合を検出 - 同期修正を実行`, synchronizationIssues);
      
      // バックエンドに同期修正を依頼
      const syncResult = await runGasWithUserId('syncConfigurationState', '設定同期を実行中...', 
        userId, updatedConfig, flowType);
      
      if (syncResult && syncResult.success) {
        appliedFixes.push(...synchronizationIssues);
        console.log(`✅ ${flowType}フロー: 設定同期修正完了`, appliedFixes);
        
        // キャッシュをクリアして最新状態を反映
        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
        }
        
        return {
          success: true,
          synchronized: true,
          appliedFixes: appliedFixes,
          message: `${flowType}フローの設定同期が完了しました`
        };
      } else {
        console.warn(`⚠️ ${flowType}フロー: 設定同期修正に失敗`, syncResult);
        return {
          success: false,
          synchronized: false,
          issues: synchronizationIssues,
          message: '設定同期修正に失敗しました'
        };
      }
    } else {
      console.log(`✅ ${flowType}フロー: 設定は既に同期されています`);
      return {
        success: true,
        synchronized: false,
        message: `${flowType}フローの設定は既に正しく同期されています`
      };
    }
    
  } catch (error) {
    console.error(`❌ ${flowType}フロー設定同期エラー:`, error);
    return {
      success: false,
      synchronized: false,
      error: error.message,
      message: `設定同期処理でエラーが発生しました: ${error.message}`
    };
  }
}

/**
 * 統合的な設定整合性チェック - 複数フローに対応
 * @param {Object} status - 現在のステータス
 * @returns {Object} 整合性チェック結果
 */
function performIntegratedConfigConsistencyCheck(status) {
  if (!status || !status.userInfo) {
    return { consistent: false, issues: ['ステータスデータが不正です'] };
  }
  
  try {
    const configJson = getConfigJSON(status.userInfo);
    const issues = [];
    const recommendations = [];
    
    // 1. 基本的な設定整合性チェック
    const basicChecks = [
      {
        condition: configJson.setupStatus === 'completed',
        issue: 'setupStatusがcompletedではありません',
        recommendation: 'セットアップフローを完了してください'
      },
      {
        condition: configJson.formCreated === true,
        issue: 'formCreatedがtrueではありません',
        recommendation: 'フォーム作成処理を実行してください'
      },
      {
        condition: !!configJson.publishedSheetName,
        issue: 'publishedSheetNameが未設定です',
        recommendation: 'シート選択を確認してください'
      },
      {
        condition: !!configJson.publishedSpreadsheetId,
        issue: 'publishedSpreadsheetIdが未設定です',
        recommendation: 'スプレッドシート設定を確認してください'
      }
    ];
    
    basicChecks.forEach(check => {
      if (!check.condition) {
        issues.push(check.issue);
        recommendations.push(check.recommendation);
      }
    });
    
    // 2. 公開状態の整合性チェック
    if (configJson.appPublished === true) {
      if (configJson.setupStatus !== 'completed') {
        issues.push('公開状態なのにセットアップが未完了です');
        recommendations.push('セットアップを完了するか、公開を停止してください');
      }
      if (!configJson.formCreated) {
        issues.push('公開状態なのにフォームが未作成です');
        recommendations.push('フォームを作成するか、公開を停止してください');
      }
    }
    
    // 3. シート固有設定の整合性チェック
    if (configJson.publishedSheetName) {
      const sheetKey = 'sheet_' + configJson.publishedSheetName;
      const sheetConfig = configJson[sheetKey];
      
      if (!sheetConfig || !sheetConfig.guessedConfig) {
        issues.push(`シート固有設定が未保存です: ${configJson.publishedSheetName}`);
        recommendations.push('列設定を確認・保存してください');
      }
    }
    
    const isConsistent = issues.length === 0;
    
    return {
      consistent: isConsistent,
      issues: issues,
      recommendations: recommendations,
      severity: issues.length > 3 ? 'high' : issues.length > 1 ? 'medium' : 'low',
      summary: isConsistent ? '設定は整合性が保たれています' : `${issues.length}件の整合性問題が見つかりました`
    };
    
  } catch (error) {
    console.error('設定整合性チェックエラー:', error);
    return {
      consistent: false,
      issues: ['設定解析エラーが発生しました'],
      recommendations: ['設定を再確認してください'],
      error: error.message
    };
  }
}

// Get optimal polling interval based on user activity
function getOptimalPollInterval() {
  const timeSinceActivity = Date.now() - lastUserActivity;
  
  if (timeSinceActivity < 2 * 60 * 1000) { // 2分以内
    return 30 * 1000; // 30秒間隔
  } else if (timeSinceActivity < 10 * 60 * 1000) { // 10分以内
    return 2 * 60 * 1000; // 2分間隔
  } else {
    return 10 * 60 * 1000; // 10分間隔
  }
}

// Restart status polling with new interval
function restartStatusPolling() {
  if (statusPollTimer) {
    clearInterval(statusPollTimer);
  }
  currentPollInterval = getOptimalPollInterval();
  startSystemStatusUpdate();
}

// Start system status update polling
function startSystemStatusUpdate() {
  statusPollTimer = setInterval(function() {
    // UIが非表示の時は更新しない
    if (document.hidden) return;
    
    // Skip background updates if save operation is in progress or recently completed
    if (isSaveInProgress) {
      logDebug('Skipping background update: save in progress');
      return;
    }
    
    const timeSinceFreshSave = Date.now() - freshSaveTimestamp;
    if (timeSinceFreshSave < FRESH_SAVE_PROTECTION_DURATION) {
      logDebug('Skipping background update: fresh save protection active');
      return;
    }
    
    // 現在のポーリング間隔を確認し、必要に応じて調整
    const optimalInterval = getOptimalPollInterval();
    if (Math.abs(currentPollInterval - optimalInterval) > 30000) { // 30秒以上の差
      restartStatusPolling();
      return;
    }
    
    // キャッシュを利用して静かに更新
    runGasWithUserId('getStatus', false)
      .then(function(status) {
        // 変更があった場合のみUIを更新
        if (JSON.stringify(status) !== JSON.stringify(currentStatus)) {
          updateUIWithNewStatus(status);
        }
      })
      .catch(function(error) {
        logWarn('Background status update failed:', error);
      });
  }, currentPollInterval);
}

// =============================================================================
// CONFIG MANAGEMENT
// =============================================================================

// Reset configJson to initial values
function resetConfigJson() {
  // 危険操作の確認ダイアログ
  const confirmMessage = `⚠️ 設定リセットの確認

この操作を実行すると、以下の設定が初期値にリセットされます：
• フォーム設定（質問文、回答方法など）
• 表示設定（匿名表示、集計表示など）
• シート設定（回答連携など）

※ スプレッドシートやフォーム自体は削除されませんが、
　 設定の再構築が必要になる場合があります。

本当に設定をリセットしますか？`;

  if (!confirm(confirmMessage)) {
    return;
  }
  
  const button = document.getElementById('reset-config-btn');
  const originalHTML = button ? button.innerHTML : '';
  
  try {
    if (button) {
      // ローディング状態
      button.disabled = true;
      button.innerHTML = `
        <svg class="w-3 h-3 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        リセット中...
      `;
    }
    
    logInfo('🔄 ConfigJsonリセット開始');
    
    runGasWithUserId('resetConfigJson', '設定をリセット中...')
      .then(function(result) {
        if (result.success) {
          showMessage('✅ 設定を初期値にリセットしました。ページを再読み込みして変更を確認してください。', 'success');
          logInfo('✅ ConfigJsonリセット完了');
          
          // UIを更新するために最新データを取得
          setTimeout(() => {
            runGasWithUserId('getInitialData', 'データを更新中...')
              .then(function(updatedStatus) {
                updateUIWithNewStatus(updatedStatus);
                logInfo('🔄 リセット後のUI更新完了');
              })
              .catch(function(error) {
                logWarn('⚠️ リセット後のUI更新でエラー:', error);
                showMessage('設定はリセットされましたが、表示の更新に失敗しました。ページを再読み込みしてください。', 'warning');
              });
          }, 1000);
        } else {
          throw new Error(result.message || '設定リセットに失敗しました');
        }
      })
      .catch(function(error) {
        logError('❌ ConfigJsonリセットでエラー:', error);
        showMessage('設定リセットに失敗しました: ' + (error.message || error), 'error');
      })
      .finally(() => {
        if (button) {
          // ボタンを元の状態に戻す
          button.disabled = false;
          button.innerHTML = originalHTML;
        }
      });
      
  } catch (error) {
    logError('❌ ConfigJsonリセット実行中にエラー:', error);
    showMessage('設定リセットの実行に失敗しました', 'error');
    if (button) {
      button.disabled = false;
      button.innerHTML = originalHTML;
    }
  }
}

// =============================================================================
// QUICKSTART FUNCTIONALITY
// =============================================================================

// QuickStart progress management
const quickStartSteps = [
  { id: 1, text: 'ユーザー専用フォルダの作成', detail: 'フォルダ構造を準備中...' },
  { id: 2, text: 'Googleフォームとスプレッドシートの作成', detail: 'データ収集の仕組みを構築中...' },
  { id: 3, text: 'シート設定と列構造の最適化', detail: 'データ構造を設定中...' },
  { id: 4, text: '高精度AI列判定の実行', detail: 'AIによる列の自動判定を実行中...' },
  { id: 5, text: '公開設定と時間モーダル表示', detail: 'Webアプリケーションを公開中...' },
  { id: 6, text: 'セットアップ完了', detail: '利用準備が整いました！' }
];

// Custom setup progress management
const customSetupSteps = [
  { id: 1, text: 'カスタムフォーム設定の解析', detail: 'フォーム設定を検証中...' },
  { id: 2, text: 'Googleフォームとスプレッドシートの作成', detail: 'カスタムフォームを構築中...' },
  { id: 3, text: '高精度AI列判定の自動実行', detail: 'AIによる列の自動判定を実行中...' },
  { id: 4, text: '設定の自動保存と適用', detail: 'AI判定結果を設定に適用中...' },
  { id: 5, text: '回答ボードの自動公開', detail: 'Webアプリケーションを公開中...' },
  { id: 6, text: 'カスタムセットアップ完了', detail: 'すべての設定が完了しました！' }
];

// Show QuickStart progress bar
function showQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetProgressSteps();
  }
}

// Hide QuickStart progress bar
function hideQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset all progress steps to initial state
function resetProgressSteps() {
  quickStartSteps.forEach(step => {
    updateProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateOverallProgress(0, '初期化中...');
}

// Update individual progress step
function updateProgressStep(stepId, status, text, detail) {
  const stepElement = document.getElementById(`progress-step-${stepId}`);
  const dotElement = document.getElementById(`progress-step-${stepId}-dot`);
  const textElement = document.getElementById(`progress-step-${stepId}-text`);
  const detailElement = document.getElementById(`progress-step-${stepId}-detail`);
  
  if (!stepElement || !dotElement || !textElement || !detailElement) return;
  
  // Update text and detail
  textElement.textContent = text;
  detailElement.textContent = detail;
  
  // Update visual state based on status
  switch (status) {
    case 'waiting':
      dotElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      textElement.className = 'text-sm text-gray-300';
      detailElement.className = 'text-xs text-gray-500';
      break;
    case 'active':
      dotElement.className = 'w-2 h-2 rounded-full bg-emerald-400 animate-pulse';
      textElement.className = 'text-sm text-emerald-300 font-medium';
      detailElement.className = 'text-xs text-emerald-400';
      break;
    case 'completed':
      dotElement.className = 'w-2 h-2 rounded-full bg-green-400';
      textElement.className = 'text-sm text-green-300 font-medium';
      detailElement.className = 'text-xs text-green-400';
      break;
    case 'error':
      dotElement.className = 'w-2 h-2 rounded-full bg-red-400';
      textElement.className = 'text-sm text-red-300 font-medium';
      detailElement.className = 'text-xs text-red-400';
      break;
  }
}

// Update overall progress bar
function updateOverallProgress(percentage, statusMessage) {
  const progressBar = document.getElementById('progress-bar');
  const progressPercentage = document.getElementById('progress-percentage');
  const progressStatus = document.getElementById('progress-status');
  
  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
  }
  
  if (progressPercentage) {
    progressPercentage.textContent = `${percentage}%`;
  }
  
  if (progressStatus) {
    progressStatus.textContent = statusMessage;
  }
}

// Simulate QuickStart progress with enhanced backend synchronization
function simulateQuickStartProgress() {
  console.log('🚀 Starting enhanced QuickStart progress simulation');
  
  // Step 1: Initialize
  updateProgressStep(1, 'active', 'ユーザー専用フォルダの作成', 'フォルダ構造を準備中...');
  updateOverallProgress(5, 'フォルダを作成しています...');
  
  // Continue with timed simulation to ensure progress doesn't stop
  setTimeout(() => {
    updateProgressStep(1, 'completed', 'ユーザー専用フォルダの作成', '✅ フォルダが作成されました');
    updateProgressStep(2, 'active', 'Googleフォームとスプレッドシートの作成', 'データ収集の仕組みを構築中...');
    updateOverallProgress(20, 'フォームとスプレッドシートを作成しています...');
    
    setTimeout(() => {
      updateProgressStep(2, 'completed', 'Googleフォームとスプレッドシートの作成', '✅ フォームとスプレッドシートが作成されました');
      updateProgressStep(3, 'active', 'シート設定と列構造の最適化', 'データ構造を設定中...');
      updateOverallProgress(40, 'シート設定を最適化しています...');
      
      setTimeout(() => {
        updateProgressStep(3, 'completed', 'シート設定と列構造の最適化', '✅ データ構造が最適化されました');
        updateProgressStep(4, 'active', '高精度AI列判定の実行', 'AIによる列の自動判定を実行中...');
        updateOverallProgress(60, 'AI列判定を実行しています...');
        
        setTimeout(() => {
          updateProgressStep(4, 'completed', '高精度AI列判定の実行', '✅ AI列判定が完了しました');
          updateProgressStep(5, 'active', '公開設定の適用', 'Webアプリケーションを公開中...');
          updateOverallProgress(80, '公開設定を適用しています...');
          
          setTimeout(() => {
            updateProgressStep(5, 'completed', '公開設定の適用', '✅ アプリケーションが公開されました');
            updateProgressStep(6, 'active', 'セットアップ完了確認', '最終確認を実行中...');
            updateOverallProgress(95, '最終確認を実行しています...');
            
            setTimeout(() => {
              console.log('✅ QuickStart progress simulation completed - backend should be ready');
              // ここで最終完了状態は executeQuickStartProcess の成功ハンドラーで設定される
            }, 800);
          }, 1800);
        }, 3500);
      }, 1200);
    }, 1800);
  }, 1000);
  
  // Optional folder creation check (non-blocking - doesn't affect main progress)
  runGasWithUserId('createUserFolder', false)
    .then(function(folderResult) {
      console.log('✅ QuickStart folder creation check successful:', folderResult);
    })
    .catch(function(error) {
      console.warn('⚠️ QuickStart folder creation check failed, but continuing:', error);
    });
}

// Simulate Custom Form progress (for custom form creation)
function simulateCustomFormProgressWithFolderCheck() {
  // Step 1: Real folder creation/check
  updateProgressStep(1, 'active', 'ユーザー専用フォルダの作成', 'フォルダ構造を準備中...');
  updateOverallProgress(5, 'フォルダを作成しています...');
  
  // Actually call the folder creation API to sync with real backend progress
  runGasWithUserId('createUserFolder', 'フォルダを確認・作成中...')
    .then(function(folderResult) {
      console.log('✅ Custom form folder creation successful:', folderResult);
      updateProgressStep(1, 'completed', 'ユーザー専用フォルダの作成', '✅ フォルダが作成されました');
      updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
      updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
      
      // Step 2: Custom form/spreadsheet creation
      setTimeout(() => {
        updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
        updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
        updateOverallProgress(50, 'カスタム設定を適用しています...');
        
        // Step 3: Custom configuration
        setTimeout(() => {
          updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
          updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
          updateOverallProgress(75, 'シート構造を最適化しています...');
          
          // Step 4: Sheet optimization
          setTimeout(() => {
            updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
            updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
            updateOverallProgress(90, '最終準備を実行しています...');
            
            // Step 5: Final preparation
            setTimeout(() => {
              updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
              updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
              updateOverallProgress(100, 'セットアップが完了しました！');
              
              setTimeout(() => {
                updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
              }, 500);
            }, 1000);
          }, 1500);
        }, 1000);
      }, 2000);
    })
    .catch(function(error) {
      console.warn('⚠️ Custom form folder creation failed, continuing with fallback:', error);
      updateProgressStep(1, 'error', 'ユーザー専用フォルダの作成', '⚠️ フォルダ作成でエラーが発生しましたが処理を続行します');
      showMessage('フォルダの作成に警告がありましたが、カスタムフォーム作成を続行します。', 'warning');
      
      // Continue with fallback timing even if folder creation fails
      setTimeout(() => {
        updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
        updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
        
        setTimeout(() => {
          updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
          updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
          updateOverallProgress(50, 'カスタム設定を適用しています...');
          
          setTimeout(() => {
            updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
            updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
            updateOverallProgress(75, 'シート構造を最適化しています...');
            
            setTimeout(() => {
              updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
              updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
              updateOverallProgress(90, '最終準備を実行しています...');
              
              setTimeout(() => {
                updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
                updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
                updateOverallProgress(100, 'セットアップが完了しました！');
                
                setTimeout(() => {
                  updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
                }, 500);
              }, 1000);
            }, 1500);
          }, 1000);
        }, 2000);
      }, 1000);
    });
}

// =============================================================================
// CUSTOM SETUP COMPLETION MANAGEMENT
// =============================================================================

/**
 * カスタムセットアップの自動完了処理をトリガー
 * @param {string} sheetName - 完了対象のシート名
 */
function triggerCustomSetupCompletion(sheetName) {
  console.log('🎯 カスタムセットアップ自動完了処理開始:', sheetName);
  
  try {
    // オプション設定セクションを表示
    showCustomSetupOptionsSection();
    
    // 完了状態を表示
    showCustomSetupCompletionMessage(sheetName);
    
    // セットアップステップを自動更新
    updateSetupStepIndicator(3); // ステップ3（完了）に更新
    
    console.log('✅ カスタムセットアップ自動完了処理完了');
    
  } catch (error) {
    console.error('❌ カスタムセットアップ自動完了処理エラー:', error);
  }
}

/**
 * カスタムセットアップのオプション設定セクションを表示
 */
function showCustomSetupOptionsSection() {
  const optionsSection = document.getElementById('custom-options-section');
  const setupSection = document.getElementById('setup-section');
  
  if (optionsSection) {
    optionsSection.classList.remove('hidden');
    console.log('✅ オプション設定セクションを表示');
  }
  
  if (setupSection) {
    // セットアップセクションは非表示にしない（ユーザーが設定を確認できるように）
    console.log('ℹ️ セットアップセクションは表示のまま維持');
  }
}

/**
 * カスタムセットアップ完了メッセージを表示
 * @param {string} sheetName - 完了したシート名
 */
function showCustomSetupCompletionMessage(sheetName) {
  showMessage(
    `🎉 カスタムセットアップが完了しました！シート「${sheetName}」でAI列判定が完了し、設定可能な詳細オプションが表示されました。お好みに応じて設定を調整してください。`,
    'success',
    8000 // 8秒間表示
  );
  
  // 詳細な完了情報もログ出力
  console.log('🎉 カスタムセットアップ完了詳細:', {
    sheetName: sheetName,
    completedAt: new Date().toISOString(),
    nextSteps: ['オプション設定の調整（任意）', '公開設定の確認']
  });
}

/**
 * セットアップステップインジケーターを更新
 * @param {number} step - 更新するステップ番号
 */
function updateSetupStepIndicator(step) {
  try {
    // 既存のアクティブステップを無効化
    const activeSteps = document.querySelectorAll('.step-indicator.active');
    activeSteps.forEach(el => el.classList.remove('active'));
    
    // 新しいステップをアクティブに
    const targetStep = document.getElementById(`step-${step}-indicator`);
    if (targetStep) {
      targetStep.classList.add('active');
      console.log(`✅ ステップ${step}インジケーターをアクティブに更新`);
    }
    
    // ステップ完了の視覚的フィードバック
    for (let i = 1; i < step; i++) {
      const completedStep = document.getElementById(`step-${i}-indicator`);
      if (completedStep) {
        completedStep.classList.add('completed');
      }
    }
    
  } catch (error) {
    console.warn('⚠️ ステップインジケーター更新エラー:', error);
  }
}

// =============================================================================
// CUSTOM SETUP FUNCTIONALITY - Unified Automation
// =============================================================================

// Show Custom Setup progress bar
function showCustomSetupProgress() {
  const progressContainer = document.getElementById('quickstart-progress'); // Reuse same container
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetCustomSetupProgressSteps();
  }
}

// Hide Custom Setup progress bar
function hideCustomSetupProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset Custom Setup progress steps
function resetCustomSetupProgressSteps() {
  customSetupSteps.forEach(step => {
    updateProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateOverallProgress(0, '初期化中...');
}

// Simulate Custom Setup progress with real backend synchronization
function simulateCustomSetupProgress() {
  console.log('🎨 Starting enhanced Custom Setup progress simulation');
  
  // Step 1: Custom form configuration analysis
  updateProgressStep(1, 'active', 'カスタムフォーム設定の解析', 'フォーム設定を検証中...');
  updateOverallProgress(10, 'カスタム設定を解析しています...');
  
  setTimeout(() => {
    updateProgressStep(1, 'completed', 'カスタムフォーム設定の解析', '✅ 設定解析が完了しました');
    updateProgressStep(2, 'active', 'Googleフォームとスプレッドシートの作成', 'カスタムフォームを構築中...');
    updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
    
    setTimeout(() => {
      updateProgressStep(2, 'completed', 'Googleフォームとスプレッドシートの作成', '✅ カスタムフォームが作成されました');
      updateProgressStep(3, 'active', '高精度AI列判定の自動実行', 'AIによる列の自動判定を実行中...');
      updateOverallProgress(50, 'AI列判定を実行しています...');
      
      setTimeout(() => {
        updateProgressStep(3, 'completed', '高精度AI列判定の自動実行', '✅ AI列判定が完了しました');
        updateProgressStep(4, 'active', '設定の自動保存と適用', 'AI判定結果を設定に適用中...');
        updateOverallProgress(70, 'AI判定結果を設定に適用しています...');
        
        setTimeout(() => {
          updateProgressStep(4, 'completed', '設定の自動保存と適用', '✅ 設定が正常に保存されました');
          updateProgressStep(5, 'active', '回答ボードの自動公開', 'Webアプリケーションを公開中...');
          updateOverallProgress(85, '回答ボードを公開しています...');
          
          setTimeout(() => {
            updateProgressStep(5, 'completed', '回答ボードの自動公開', '✅ 回答ボードが公開されました');
            updateProgressStep(6, 'active', 'カスタムセットアップ完了確認', '最終確認を実行中...');
            updateOverallProgress(95, '最終確認を実行しています...');
            
            setTimeout(() => {
              updateProgressStep(6, 'completed', 'カスタムセットアップ完了', '🎉 カスタムセットアップが完了しました！');
              updateOverallProgress(100, 'カスタムセットアップが完了しました！');
            }, 800);
          }, 1200);
        }, 1500);
      }, 2000);
    }, 1800);
  }, 1000);
}

// Handle unified custom setup
function handleCustomSetup(config) {
  console.log('🎨 カスタムセットアップ開始:', config);
  
  // Show progress and start simulation
  showCustomSetupProgress();
  simulateCustomSetupProgress();
  
  // Call the unified backend custom setup function
  runGasWithUserId('customSetup', false, config)
    .then(function(result) {
      if (result && result.status === 'success') {
        console.log('🎉 CustomSetupバックエンド処理完了:', result);
        
        // Enhanced completion notification with detailed backend response
        const setupStatus = result.autoPublished ? 'カスタムセットアップ完了！ボードが公開されました！' : 'カスタムセットアップ完了！';
        updateOverallProgress(100, setupStatus);
        updateProgressStep(6, 'completed', 'カスタムセットアップ完了', '🎉 すべての設定が完了しました！');
        
        // Enhanced message display based on actual backend results
        let detailMessage = '';
        if (result.aiDetected && result.autoConfigured && result.autoPublished) {
          detailMessage = 'AI列判定、設定保存、自動公開がすべて正常に完了しました。すぐに利用できます！';
        } else if (result.aiDetected && result.autoConfigured) {
          detailMessage = 'AI列判定と設定保存が完了しました。管理パネルから手動で公開してください。';
        } else {
          // Check for specific error reasons
          const aiError = result.aiDetectionResult?.error;
          const configError = result.saveResult?.error;
          const publishError = result.publishResult?.error;
          
          detailMessage = 'カスタムフォームが作成されました。';
          if (aiError) detailMessage += `AI判定: ${aiError}。`;
          if (configError) detailMessage += `設定保存: ${configError}。`;
          if (publishError) detailMessage += `自動公開: ${publishError}。`;
          detailMessage += '管理パネルで設定を確認してください。';
        }
        
        showMessage(`✅ カスタムセットアップが完了しました！${detailMessage}`, 'success');
        
        // Update progress step with specific status
        if (result.autoPublished) {
          updateProgressStep(5, 'completed', '回答ボードの自動公開', '🌐 ボードが自動的に公開されました');
        } else {
          updateProgressStep(5, 'completed', '回答ボード作成完了', '📝 手動公開の準備ができました');
        }
        
        // Log detailed completion status
        console.log('📊 CustomSetup完了詳細:', {
          setupComplete: result.setupComplete,
          aiDetected: result.aiDetected,
          autoConfigured: result.autoConfigured,
          autoPublished: result.autoPublished,
          completedSteps: result.completedSteps,
          completedAt: result.completedAt
        });
        
        // Log custom setup specific information
        if (result.aiDetectionResult) {
          console.log('🤖 AI列判定結果詳細:', {
            success: result.aiDetectionResult.success,
            aiDetected: result.aiDetectionResult.aiDetected,
            guessedConfig: result.aiDetectionResult.guessedConfig
          });
        }
        
        if (result.saveResult) {
          console.log('💾 設定保存結果詳細:', {
            success: result.saveResult.success,
            configured: result.saveResult.configured,
            savedConfig: result.saveResult.savedConfig
          });
        }
        
        if (result.publishResult) {
          console.log('🌐 自動公開結果詳細:', {
            success: result.publishResult.success,
            published: result.publishResult.published,
            publishedAt: result.publishResult.publishedAt
          });
        }
        
        // Update status after custom setup
        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
        }
        loadStatus(true);
        
        // CustomSetupフロー完了確認（包括的な完了状態検証）
        setTimeout(async () => {
          try {
            const sheetName = result.sheetName || 'unknown_sheet';
            const completionResult = await verifySetupFlowCompletion('custom', sheetName);
            
            if (completionResult.success) {
              console.log('🎉 CustomSetupフロー完了確認: 全要件を満たしています', completionResult.details);
              
              // CustomSetup成功時も設定同期を実行（堅牢性の向上）
              try {
                const syncResult = await enhanceConfigSynchronization('custom', {
                  sheetName: sheetName,
                  spreadsheetId: result.spreadsheetId,
                  config: result.aiDetectionResult?.guessedConfig || {}
                });
                
                if (syncResult.synchronized) {
                  console.log('🔧 CustomSetup: 設定同期で追加最適化を実行', syncResult.appliedFixes);
                }
              } catch (syncError) {
                console.warn('⚠️ CustomSetup: 設定同期処理でエラー（フロー完了には影響なし）', syncError);
              }
            } else {
              console.warn('⚠️ CustomSetupフロー: 未完了項目があります', completionResult);
              
              // CustomSetupで未完了項目がある場合は積極的に同期修正を試行
              try {
                const syncResult = await enhanceConfigSynchronization('custom', {
                  sheetName: sheetName,
                  spreadsheetId: result.spreadsheetId,
                  config: result.aiDetectionResult?.guessedConfig || {}
                });
                
                if (syncResult.synchronized) {
                  console.log('🔧 CustomSetup: 未完了項目を同期修正で自動解決', syncResult.appliedFixes);
                }
              } catch (syncError) {
                console.error('❌ CustomSetup: 同期修正処理エラー', syncError);
              }
            }
          } catch (verificationError) {
            console.error('❌ CustomSetupフロー完了確認エラー:', verificationError);
          }
        }, 2000);
        
        // Hide progress after completion
        setTimeout(() => {
          hideCustomSetupProgress();
        }, 5000);
        
      } else {
        console.error('❌ CustomSetup backend error:', result);
        updateProgressStep(6, 'error', 'カスタムセットアップ失敗', '❌ セットアップでエラーが発生しました');
        showMessage('❌ カスタムセットアップに失敗しました: ' + (result?.message || 'unknown error'), 'error');
        hideCustomSetupProgress();
      }
    })
    .catch(function(error) {
      console.error('❌ CustomSetup backend call failed:', error);
      updateProgressStep(6, 'error', 'カスタムセットアップ失敗', '❌ バックエンドエラーが発生しました');
      showMessage('❌ カスタムセットアップでエラーが発生しました: ' + error.message, 'error');
      hideCustomSetupProgress();
    });
}

// Handle quick start setup
function handleQuickStart() {
  const quickstartBtn = document.getElementById('quickstart-btn');
  const quickstartText = document.getElementById('quickstart-text');
  
  if (!quickstartBtn || !quickstartText) {
    console.error('QuickStart elements not found');
    return;
  }

  // 公開状態に応じたクイックスタート処理を実行
  executeQuickStart(quickstartBtn, quickstartText);
}

// 公開状態チェックとモーダル表示
function checkPublicationStatusAndProceed(onProceed, onCancel) {
  // 現在のステータスから公開状態を確認
  if (currentStatus && currentStatus._normalized && currentStatus._normalized.isPublished) {
    // 公開中の場合、確認モーダルを表示
    window.sharedModals.showQuickStartStopConfirmation(
      () => {
        console.log('✅ ユーザーが停止して新規作成を選択');
        if (onProceed) onProceed();
      },
      () => {
        console.log('❌ ユーザーがキャンセルを選択');
        if (onCancel) onCancel();
      }
    );
  } else {
    // 公開していない場合、直接進行
    console.log('📝 公開されていないため、直接クイックスタートを開始');
    if (onProceed) onProceed();
  }
}

// クイックスタートの実際の実行
function executeQuickStart(quickstartBtn, quickstartText) {
  // 現在の公開状態を確認（簡素化・安定化）
  const isCurrentlyPublished = currentStatus && (
    currentStatus.isPublished || 
    currentStatus.appPublished ||
    (currentStatus.config && currentStatus.config.isPublished) ||
    (currentStatus._normalized && currentStatus._normalized.isPublished)
  );
  
  console.log('🚀 クイックスタート実行: 公開状態チェック（修正版）', {
    isCurrentlyPublished: isCurrentlyPublished,
    hasCurrentStatus: !!currentStatus,
    isPublished: currentStatus?.isPublished,
    appPublished: currentStatus?.appPublished
  });
  
  if (isCurrentlyPublished) {
    // 公開中の場合: シンプルな新規作成モーダルを表示（停止確認をスキップ）
    console.log('📢 公開中のため、シンプルな新規作成モーダルを表示します');
    showSimpleQuickStartModal(quickstartBtn, quickstartText);
  } else {
    // 非公開の場合: 直接クイックスタート実行（自動公開フラグ付き）
    console.log('📝 現在非公開のため、直接クイックスタートを実行します（自動公開）');
    executeQuickStartProcess(quickstartBtn, quickstartText, true); // autoPublish = true
  }
}

// 公開中ボード停止確認モーダル表示
function showQuickStartStopConfirmation(quickstartBtn, quickstartText) {
  if (window.sharedModals && typeof window.sharedModals.showQuickStartStopConfirmation === 'function') {
    window.sharedModals.showQuickStartStopConfirmation(
      // 確認時のコールバック
      () => {
        console.log('✅ ユーザーが停止して新規作成を確認しました');
        executeQuickStartProcess(quickstartBtn, quickstartText, true); // autoPublish = true
      },
      // キャンセル時のコールバック
      () => {
        console.log('❌ クイックスタートがキャンセルされました');
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタートを開始';
      }
    );
  } else {
    // フォールバック: 通常の確認ダイアログ
    if (confirm('現在公開中のボードを停止して、新しいフォームとボードを作成しますか？')) {
      executeQuickStartProcess(quickstartBtn, quickstartText, true);
    } else {
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタートを開始';
    }
  }
}

// 公開中ボード用のシンプルなクイックスタートモーダル表示
function showSimpleQuickStartModal(quickstartBtn, quickstartText) {
  console.log('📱 シンプルクイックスタートモーダルを表示します');
  
  // sharedModalsが利用可能な場合は専用のモーダルを使用
  if (window.sharedModals && typeof window.sharedModals.showConfirmation === 'function') {
    const modalTitle = '新しいフォームを作成しますか？';
    const modalContent = `
      <div class="text-gray-700 mb-4">
        <p class="mb-3">現在公開中の回答ボードを一時停止して、新しいフォームとボードを作成します。</p>
        
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
          <h4 class="font-semibold text-blue-800 mb-2 flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            📋 実行内容
          </h4>
          <ul class="text-sm text-blue-700 space-y-1">
            <li>• 既存の回答データは保持されます</li>
            <li>• 新しいフォームとスプレッドシートを作成</li>
            <li>• 高精度AI列判定を実行</li>
            <li>• 作成完了後に自動で再公開</li>
          </ul>
        </div>
      </div>
    `;
    
    window.sharedModals.showConfirmation(
      modalTitle,
      modalContent,
      function() {
        // 停止して新規作成ボタンクリック時の処理
        console.log('✅ ユーザーが「停止して新規作成」を選択しました');
        
        // 公開停止処理とクイックスタートを統合実行
        executeStopAndQuickStart(quickstartBtn, quickstartText);
      },
      function() {
        // キャンセル時の処理
        console.log('❌ シンプルクイックスタートがキャンセルされました');
        resetQuickStartButton(quickstartBtn, quickstartText);
      },
      '停止して新規作成', // 確認ボタンのテキスト
      'キャンセル'      // キャンセルボタンのテキスト
    );
  } else {
    // フォールバック: 標準confirm
    const confirmMessage = '現在公開中の回答ボードを停止して、新しいフォームとボードを作成しますか？\n\n• 既存の回答データは保持されます\n• 新しいフォームとスプレッドシートを作成\n• 高精度AI列判定を実行\n• 作成完了後に自動で再公開';
    
    if (confirm(confirmMessage)) {
      executeStopAndQuickStart(quickstartBtn, quickstartText);
    } else {
      resetQuickStartButton(quickstartBtn, quickstartText);
    }
  }
}

// 公開停止とクイックスタートの統合処理
function executeStopAndQuickStart(quickstartBtn, quickstartText) {
  console.log('🛑📋 公開停止→クイックスタートの統合処理を開始します');
  
  // ボタン状態を更新
  quickstartBtn.disabled = true;
  quickstartText.textContent = '公開停止中...';
  
  // 1. まず公開停止処理を実行
  if (typeof unpublishBoard === 'function') {
    showMessage('現在の回答ボードを停止しています...', 'info');
    
    unpublishBoard()
      .then(function(stopResult) {
        console.log('✅ 公開停止が完了しました:', stopResult);
        showMessage('✅ 公開停止が完了しました。新しいフォームを作成します...', 'success');
        
        // 公開停止が完了したら、少し遅延してからクイックスタートを実行
        setTimeout(() => {
          quickstartText.textContent = 'セットアップ中...';
          console.log('🚀 クイックスタート処理を開始します（自動公開モード）');
          
          // 2. クイックスタート実行（自動公開フラグ付き）
          executeQuickStartProcess(quickstartBtn, quickstartText, true);
        }, 1000);
      })
      .catch(function(stopError) {
        console.error('❌ 公開停止に失敗しました:', stopError);
        showMessage('❌ 公開停止に失敗しました。再度お試しください。', 'error');
        resetQuickStartButton(quickstartBtn, quickstartText);
      });
  } else {
    console.error('❌ unpublishBoard function not found');
    showMessage('❌ 公開停止機能が見つかりません。ページを再読み込みしてください。', 'error');
    resetQuickStartButton(quickstartBtn, quickstartText);
  }
}

// クイックスタートボタンの状態をリセット
function resetQuickStartButton(quickstartBtn, quickstartText) {
  if (quickstartBtn && quickstartText) {
    quickstartBtn.disabled = false;
    quickstartText.textContent = 'クイックスタートを開始';
  }
}

// クイックスタートの実際の処理実行
function executeQuickStartProcess(quickstartBtn, quickstartText, autoPublish = false) {
  // Update button state
  quickstartBtn.disabled = true;
  quickstartText.textContent = 'セットアップ中...';
  
  // Show progress bar and start simulation
  showQuickStartProgress();
  simulateQuickStartProgress();
  
  // Show loading message optimized for QuickStart
  // クイックスタート中は専用のプログレスバーを使用するため、汎用ローディングは表示しない
  
  runGasWithUserId('quickStartSetup', false)
    .then(function(result) {
      if (result && result.status === 'success') {
        console.log('🎉 QuickStartバックエンド処理完了:', result);
        
        // Enhanced completion notification with detailed backend response
        updateOverallProgress(100, result.autoPublished ? 'セットアップ完了！ボードが公開されました！' : 'セットアップ完了！');
        updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 すべての準備が整いました！');
        
        // Enhanced message display based on actual backend results
        const publishStatus = result.autoPublished ? '公開されました' : '作成されました';
        let detailMessage;
        
        if (result.autoPublished) {
          detailMessage = 'フォームとボードが自動作成され、公開されました。すぐに利用できます！';
        } else {
          // Check if there's a specific reason for auto-publish failure
          const publishError = result.publishResult?.error;
          const manualInstructions = result.publishResult?.manualPublishInstructions;
          
          detailMessage = 'フォームとボードが自動作成されました。';
          if (publishError) {
            detailMessage += `自動公開は失敗しました（${publishError}）。`;
          }
          if (manualInstructions) {
            detailMessage += manualInstructions;
          } else {
            detailMessage += '管理パネルから手動で公開してください。';
          }
        }
        
        showMessage(`✅ クイックスタートが完了しました！${detailMessage}`, 'success');
        
        // Update progress step with auto-publish status
        if (result.autoPublished) {
          updateProgressStep(5, 'completed', '回答ボードの自動公開', '🌐 ボードが自動的に公開されました');
        } else {
          updateProgressStep(5, 'completed', '回答ボード作成完了', '📝 手動公開の準備ができました');
        }
        
        // Log detailed completion status
        console.log('📊 QuickStart完了詳細:', {
          setupComplete: result.setupComplete,
          autoPublished: result.autoPublished,
          publishResult: result.publishResult,
          completedSteps: result.completedSteps,
          completedAt: result.completedAt
        });
        
        // Log auto-publish specific information if available
        if (result.publishResult) {
          console.log('🌐 自動公開結果詳細:', {
            success: result.publishResult.success,
            published: result.publishResult.published,
            publishedAt: result.publishResult.publishedAt,
            error: result.publishResult.error,
            manualInstructions: result.publishResult.manualPublishInstructions
          });
        }
        
        // Update status after quick start
        if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
          window.unifiedCache.clear();
        }
        loadStatus(true);
        
        // QuickStartフロー完了確認（包括的な完了状態検証）
        setTimeout(async () => {
          try {
            const sheetName = result.sheetName || result.publishedSheetName || 'unknown_sheet';
            const completionResult = await verifySetupFlowCompletion('quickstart', sheetName);
            
            if (completionResult.success) {
              console.log('🎉 QuickStartフロー完了確認: 全要件を満たしています', completionResult.details);
              
              // QuickStart成功時も設定同期を実行（堅牢性の向上）
              try {
                const syncResult = await enhanceConfigSynchronization('quickstart', {
                  sheetName: sheetName,
                  spreadsheetId: result.spreadsheetId,
                  config: result.config || {}
                });
                
                if (syncResult.synchronized) {
                  console.log('🔧 QuickStart: 設定同期で追加最適化を実行', syncResult.appliedFixes);
                }
              } catch (syncError) {
                console.warn('⚠️ QuickStart: 設定同期処理でエラー（フロー完了には影響なし）', syncError);
              }
            } else {
              console.warn('⚠️ QuickStartフロー: 未完了項目があります', completionResult);
              
              // QuickStartで未完了項目がある場合は積極的に同期修正を試行
              try {
                const syncResult = await enhanceConfigSynchronization('quickstart', {
                  sheetName: sheetName,
                  spreadsheetId: result.spreadsheetId,
                  config: result.config || {}
                });
                
                if (syncResult.synchronized) {
                  console.log('🔧 QuickStart: 未完了項目を同期修正で自動解決', syncResult.appliedFixes);
                  
                  // 再度完了確認を実行
                  const reVerificationResult = await verifySetupFlowCompletion('quickstart', sheetName);
                  if (reVerificationResult.success) {
                    console.log('✅ QuickStart: 同期修正後の再確認で完了を確認');
                  } else {
                    console.warn('⚠️ QuickStart: 同期修正後も未完了項目が残存', reVerificationResult.issues);
                  }
                } else {
                  // 同期修正できない場合の警告（QuickStartでは控えめに）
                  let notificationMessage = `🔍 QuickStart完了確認:\n`;
                  if (completionResult.issues && completionResult.issues.length > 0) {
                    notificationMessage += `未完了項目: ${completionResult.issues.length}件\n`;
                    console.log('📋 QuickStart未完了詳細:', completionResult.issues);
                  }
                  notificationMessage += '詳細はコンソールログをご確認ください。';
                  console.info(notificationMessage);
                }
              } catch (syncError) {
                console.error('❌ QuickStart: 同期修正処理エラー', syncError);
              }
            }
          } catch (verificationError) {
            console.error('❌ QuickStartフロー完了確認エラー:', verificationError);
          }
        }, 2000);
        
        // 公開時は履歴保存を行わない（公開停止時に保存するため）
        logDebug('QuickStart completed - history will be saved on unpublish');
        
        // フォーム作成完了フラグを設定
        sessionStorage.setItem('form_just_created', 'true');
        
        // フォームURL表示の強制更新（管理パネルのリソース欄用）
        setTimeout(() => {
          updateFormUrlDisplay();
          
          // 予定終了時間の表示を更新
          const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
          if (scheduledEndTimeElement && window.lastStatusCache?.config) {
            updateScheduledEndTime(window.lastStatusCache.config, scheduledEndTimeElement);
          }
          
          // 公開停止ボタンの状態を更新
          if (typeof updateUnpublishButton === 'function' && window.lastStatusCache) {
            updateUnpublishButton(window.lastStatusCache);
          }
        }, 1000);
        
        // 回答ボードにフォーム作成完了を通知（フォームリンク更新用）
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            }, '*');
          }
          
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            });
            channel.close();
          }
        } catch (notifyError) {
          console.warn('クイックスタート - フォーム作成通知でエラー:', notifyError);
        }
        
        // Reset button state
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタート完了';
        
        // 自動公開の場合のみ自動停止確認モーダルを表示
        if (autoPublish) {
          console.log('🚀 自動公開が有効なため、自動停止確認モーダルを表示します');
          
          setTimeout(() => {
            // ローディングオーバーレイを非表示にしてからモーダル表示
            if (window.unifiedLoadingManager) {
              window.unifiedLoadingManager.setLoading(false);
            }
            
            // URL生成確認とデータ検証を実行
            const enhancedResult = {
              ...result,
              url: result?.url || '',
              autoStopMinutes: result?.autoStopMinutes || 360,
              autoStopTime: result?.autoStopTime || '',
              publicationData: {
                isPublished: result?.success || false,
                hasValidUrl: !!(result?.url && result.url.length > 0),
                timestamp: new Date().toISOString()
              }
            };
            
            console.log('📊 QuickStart公開データ検証:', {
              autoPublish: autoPublish,
              hasResult: !!result,
              hasUrl: !!(result?.url && result.url.length > 0),
              enhancedResult: enhancedResult
            });
            
            // 自動停止確認モーダルを表示（検証済みデータで）
            setTimeout(() => {
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(enhancedResult);
                console.log('✅ QuickStart自動公開後に自動停止確認モーダルを表示しました');
              } else {
                console.warn('⚠️ 自動停止モーダルが利用できません');
              }
            }, 800);
          }, 2000);
        } else {
          console.log('ℹ️ 自動公開が無効のため、自動停止確認モーダルをスキップします');
        }
        
        // Hide progress bar after delay and reset button
        setTimeout(() => {
          hideQuickStartProgress();
          quickstartText.textContent = 'クイックスタートを開始';
          quickstartBtn.disabled = false;
        }, 5000);
      } else {
        logWarn('QuickStart returned error result:', result);
        
        // Show error in progress
        updateProgressStep(6, 'error', 'セットアップエラー', result?.message || 'エラーが発生しました');
        updateOverallProgress(0, 'セットアップに失敗しました');
        
        // 権限エラーの可能性を考慮したメッセージ
        let errorMessage = result?.message || 'クイックスタートに失敗しました。';
        if (errorMessage.includes('permission') || errorMessage.includes('権限') || 
            errorMessage.includes('Drive') || errorMessage.includes('Sheets')) {
          errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
        }
        
        showMessage(errorMessage, 'error');
        
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタートを開始';
        
        // Hide progress bar after delay
        setTimeout(() => {
          hideQuickStartProgress();
        }, 3000);
      }
    })
    .catch(function(error) {
      logError('QuickStart error:', error);
      
      // Show error in progress
      updateProgressStep(6, 'error', 'セットアップエラー', '通信エラーが発生しました');
      updateOverallProgress(0, 'セットアップに失敗しました');
      
      // 権限エラーの可能性を考慮したメッセージ
      let errorMessage = 'クイックスタートに失敗しました。';
      if (error.toString().includes('permission') || error.toString().includes('権限') || 
          error.toString().includes('Drive') || error.toString().includes('Sheets')) {
        errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
      }
      
      if (typeof handleError === 'function') {
        handleError(error, 'handleQuickStart', errorMessage);
      } else {
        showMessage(errorMessage, 'error');
      }
      
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタートを開始';
      
      // Hide progress bar after delay
      setTimeout(() => {
        hideQuickStartProgress();
      }, 3000);
    });
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Initialize API communications
function initializeAPI() {
  logDebug('🔧 API初期化開始');
  
  // Start background status updates
  startSystemStatusUpdate();
  
  // Setup user activity tracking
  document.addEventListener('click', updateUserActivity);
  document.addEventListener('keypress', updateUserActivity);
  document.addEventListener('scroll', updateUserActivity);

  // 初回ロード時にシステムステータスをロード
  logDebug('🚀 loadStatus()を呼び出します');
  loadStatus();
  
  logDebug('✅ API初期化完了');
}

// =============================================================================
// MISSING FUNCTIONS RESTORATION
// =============================================================================

// Wrapper for loadStatus to maintain compatibility
function loadSystemStatus(bypassCache = false) {
  loadStatus(bypassCache);
}

// Basic loadUserInfo implementation
function loadUserInfo() {
  logDebug('📋 loadUserInfo called - delegating to loadStatus');
  loadStatus();
}

// Update answer count function
function updateAnswerCount() {
  if (!currentStatus || !currentStatus._normalized || !currentStatus._normalized.isPublished) {
    return;
  }
  
  const answerCountElement = document.getElementById('answer-count');
  if (answerCountElement && currentStatus.answerCount !== undefined) {
    answerCountElement.textContent = currentStatus.answerCount || '0';
  }
}

// Setup real-time updates
function setupRealtimeUpdates() {
  // Update system status every 30 seconds
  setInterval(loadSystemStatus, 30000);
  
  // Update answer count every 10 seconds when published
  setInterval(() => {
    const publishText = document.getElementById('info-publish-text');
    if (publishText && publishText.textContent === '公開中') {
      updateAnswerCount();
    }
  }, 10000);
}

// Initialize when DOM is ready
// 初期化は adminPanel-core.js の統合初期化システムで管理されます


</script>
