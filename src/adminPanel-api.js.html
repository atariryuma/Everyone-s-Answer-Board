<script>
// =============================================================================
// ADMIN PANEL API COMMUNICATIONS & BACKEND CALLS
// =============================================================================

// =============================================================================
// UNIFIED FLOW EXECUTION MANAGER - 統一実行制御システム
// =============================================================================

/**
 * フロー実行制御マネージャー - 重複実行・競合状態を防止
 */
class FlowExecutionManager {
  constructor() {
    this.activeFlows = new Set();
    this.pendingOperations = new Map();
    this.executionQueue = new Map();
    this.debugMode = window.DEBUG_MODE || false;
  }

  /**
   * 排他実行制御付きでフロー実行
   * @param {string} flowId - フロー識別子
   * @param {Function} operation - 実行する操作
   * @param {Object} options - 実行オプション
   * @returns {Promise} 実行結果
   */
  async executeWithLock(flowId, operation, options = {}) {
    const { timeout = SYSTEM_CONSTANTS.TIMEOUTS.DEFAULT_FLOW_TIMEOUT, allowQueue = false } = options;

    // 既に実行中の場合の処理
    if (this.activeFlows.has(flowId)) {
      if (this.pendingOperations.has(flowId)) {
        if (this.debugMode) {
          console.log('🔒 Flow ' + flowId + ' already in progress, returning existing promise');
        }
        return this.pendingOperations.get(flowId);
      }
      
      if (!allowQueue) {
        throw new Error('Flow ' + flowId + ' is already in progress and queueing is disabled');
      }
      
      // キューに追加
      if (this.debugMode) {
        console.log('⏳ Flow ' + flowId + ' queued for execution');
      }
      return this.queueOperation(flowId, operation, timeout);
    }

    // 新規実行
    return this.executeOperation(flowId, operation, timeout);
  }

  /**
   * 操作を実行（改良版 - AbortController対応）
   */
  async executeOperation(flowId, operation, timeout) {
    this.activeFlows.add(flowId);
    
    if (this.debugMode) {
      console.log('🚀 Starting flow execution: ' + flowId);
    }

    // AbortControllerを使用した適切なタイムアウト制御
    const abortController = new AbortController();
    let timeoutId = null;
    
    try {
      // タイムアウト設定
      timeoutId = setTimeout(() => {
        console.warn('⏰ Flow ' + flowId + ' timeout after ' + timeout + 'ms - aborting operation');
        abortController.abort();
      }, timeout);

      // 操作実行（AbortSignalを渡す）
      const operationPromise = Promise.resolve(operation(abortController.signal));
      this.pendingOperations.set(flowId, operationPromise);

      const result = await operationPromise;
      
      // 正常完了時はタイムアウトをクリア
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      
      
      return result;
    } catch (error) {
      // タイムアウトをクリア
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      // AbortErrorの場合はより詳細なエラーメッセージ
      if (error.name === 'AbortError' || abortController.signal.aborted) {
        const timeoutError = new Error(`Flow ${flowId} was aborted due to timeout (${timeout}ms)`);
        timeoutError.name = 'TimeoutError';
        timeoutError.flowId = flowId;
        timeoutError.timeout = timeout;
        console.error(`❌ Flow ${flowId} aborted due to timeout`);
        throw timeoutError;
      }

      console.error(`❌ Flow ${flowId} failed:`, error);
      throw error;
    } finally {
      // リソースクリーンアップ
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      this.activeFlows.delete(flowId);
      this.pendingOperations.delete(flowId);
      
      // キューされた操作を実行
      this.processQueue(flowId);
    }
  }

  /**
   * 操作をキューに追加
   */
  async queueOperation(flowId, operation, timeout) {
    return new Promise((resolve, reject) => {
      if (!this.executionQueue.has(flowId)) {
        this.executionQueue.set(flowId, []);
      }
      
      this.executionQueue.get(flowId).push({
        operation,
        timeout,
        resolve,
        reject
      });
    });
  }

  /**
   * キューされた操作を処理
   */
  async processQueue(flowId) {
    const queue = this.executionQueue.get(flowId);
    if (!queue || queue.length === 0) return;

    const next = queue.shift();
    if (queue.length === 0) {
      this.executionQueue.delete(flowId);
    }

    try {
      const result = await this.executeOperation(flowId, next.operation, next.timeout);
      next.resolve(result);
    } catch (error) {
      next.reject(error);
    }
  }

  /**
   * 指定フローの実行状態を確認
   */
  isFlowActive(flowId) {
    return this.activeFlows.has(flowId);
  }

  /**
   * 全てのアクティブフローを取得
   */
  getActiveFlows() {
    return Array.from(this.activeFlows);
  }

  /**
   * 緊急停止: 全フローをキャンセル
   */
  cancelAllFlows() {
    console.warn('🚨 Emergency stop: Cancelling all active flows');
    this.activeFlows.clear();
    this.pendingOperations.clear();
    this.executionQueue.clear();
  }

  /**
   * 実行状態の診断
   * @returns {Object} 診断結果
   */
  diagnoseExecution() {
    return {
      activeFlows: Array.from(this.activeFlows),
      pendingOperations: this.pendingOperations.size,
      queuedOperations: Array.from(this.executionQueue.keys()).map(flowId => ({
        flowId,
        queueLength: this.executionQueue.get(flowId).length
      })),
      totalActiveFlows: this.activeFlows.size,
      timestamp: Date.now()
    };
  }

  /**
   * LoadingManagerとの連携 - 統一ローディング制御
   * @param {string} flowId - フローID
   * @param {string} message - ローディングメッセージ
   * @param {boolean} isActive - アクティブ状態
   */
  updateLoadingState(flowId, message, isActive) {
    try {
      // UnifiedLoadingManagerが利用可能な場合
      if (typeof window !== 'undefined' && window.unifiedLoading) {
        if (isActive) {
          window.unifiedLoading.showSimple(message || `実行中: ${flowId}`);
        } else {
          window.unifiedLoading.hide();
        }
      }
      
      // SharedUtilitiesのLoadingManagerが利用可能な場合
      if (typeof window !== 'undefined' && window.sharedUtilities && window.sharedUtilities.loading) {
        window.sharedUtilities.loading.setLoading(flowId, isActive, message);
      }

    } catch (error) {
      console.warn('⚠️ Failed to update loading state:', error);
    }
  }

  /**
   * 強化されたexecuteWithLock - ローディング連携版
   * @param {string} flowId - フローID
   * @param {Function} operation - 実行する操作
   * @param {Object} options - オプション
   * @returns {Promise} 実行結果
   */
  async executeWithLoadingSync(flowId, operation, options = {}) {
    const { 
      timeout = 30000,
      loadingMessage = null,
      showLoading = true,
      onProgress = null,
      priority = 0,
      retries = 0
    } = options;

    try {
      // ローディング表示開始
      if (showLoading) {
        this.updateLoadingState(flowId, loadingMessage || `処理中: ${flowId}`, true);
      }

      // プログレス付きで実行
      const result = await this.executeWithLock(flowId, async () => {
        if (onProgress) {
          onProgress(0, 'starting', '実行開始');
        }
        
        const operationResult = await operation();
        
        if (onProgress) {
          onProgress(100, 'completed', '実行完了');
        }
        
        return operationResult;
      }, { timeout, priority, retries });

      return result;

    } catch (error) {
      if (onProgress) {
        onProgress(-1, 'error', 'エラー: ' + error.message);
      }
      throw error;
    } finally {
      // ローディング表示終了
      if (showLoading) {
        setTimeout(() => {
          this.updateLoadingState(flowId, null, false);
        }, 500); // 少し遅延してからローディングを隠す
      }
    }
  }
}

// グローバルフロー実行マネージャーのインスタンス
const flowExecutionManager = new FlowExecutionManager();

// =============================================================================
// TIMING MANAGER - 非同期処理統一化システム
// =============================================================================

/**
 * タイミング管理システム - setTimeout/setIntervalの代替
 */
class TimingManager {
  constructor() {
    this.activeTimers = new Map();
    this.debugMode = window.DEBUG_MODE || false;
  }

  /**
   * 遅延実行（setTimeoutの代替）
   * @param {number} ms - 遅延ミリ秒
   * @param {string} id - タイマーID（オプション）
   * @returns {Promise} 完了Promise
   */
  static async delay(ms, id = null) {
    if (id && timingManager.activeTimers.has(id)) {
      timingManager.activeTimers.get(id).cancel();
    }

    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        if (id) timingManager.activeTimers.delete(id);
        resolve();
      }, ms);

      if (id) {
        timingManager.activeTimers.set(id, {
          timer,
          cancel: () => {
            clearTimeout(timer);
            timingManager.activeTimers.delete(id);
            reject(new Error('Timer ' + id + ' was cancelled'));
          }
        });
      }
    });
  }

  /**
   * 順次実行システム（複数のsetTimeoutの代替）
   * @param {Array} operations - 実行する操作の配列
   * @param {number} intervalMs - 各操作間の間隔
   * @param {string} sequenceId - シーケンスID（オプション）
   * @returns {Promise} 完了Promise
   */
  static async sequence(operations, intervalMs = 100, sequenceId = null) {
    const results = [];
    
    for (let i = 0; i < operations.length; i++) {
      const operation = operations[i];
      
      try {
        if (typeof operation === 'function') {
          const result = await operation();
          results.push(result);
        } else {
          results.push(operation);
        }
        
        // 最後の操作でない場合は間隔を設ける
        if (i < operations.length - 1) {
          const delayId = sequenceId ? sequenceId + '_delay_' + i : null;
          await TimingManager.delay(intervalMs, delayId);
        }
      } catch (error) {
        console.error('Sequence operation ' + i + ' failed:', error);
        throw error;
      }
    }
    
    return results;
  }

  /**
   * 並列実行システム（制御された並列性）
   * @param {Array} operations - 実行する操作の配列
   * @param {number} concurrency - 同時実行数
   * @returns {Promise} 完了Promise
   */
  static async parallel(operations, concurrency = 3) {
    const results = [];
    const executing = [];
    
    for (const operation of operations) {
      const promise = Promise.resolve(operation()).then(result => {
        executing.splice(executing.indexOf(promise), 1);
        return result;
      });
      
      results.push(promise);
      executing.push(promise);
      
      if (executing.length >= concurrency) {
        await Promise.race(executing);
      }
    }
    
    return await Promise.all(results);
  }

  /**
   * プログレス実行システム（プログレスバー用）
   * @param {Array} steps - ステップの配列
   * @param {Function} onProgress - プログレスコールバック
   * @param {number} stepDelay - ステップ間遅延
   * @returns {Promise} 完了Promise
   */
  static async progressSequence(steps, onProgress, stepDelay = 1000) {
    const results = [];
    
    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      
      try {
        // プログレス開始通知
        if (onProgress) {
          onProgress(i, 'active', step.text || 'Step ' + (i + 1), step.detail || '実行中...');
        }
        
        // ステップ実行
        let result;
        if (typeof step.operation === 'function') {
          result = await step.operation();
        }
        
        // プログレス完了通知
        if (onProgress) {
          onProgress(i, 'completed', step.text || `Step ${i + 1}`, step.completedText || '✅ 完了');
        }
        
        results.push(result);
        
        // 最後のステップでない場合は遅延
        if (i < steps.length - 1) {
          await TimingManager.delay(stepDelay);
        }
        
      } catch (error) {
        // プログレスエラー通知
        if (onProgress) {
          onProgress(i, 'error', step.text || `Step ${i + 1}`, `❌ エラー: ${error.message}`);
        }
        throw error;
      }
    }
    
    return results;
  }

  /**
   * タイマーをキャンセル
   * @param {string} id - タイマーID
   */
  static cancelTimer(id) {
    if (timingManager.activeTimers.has(id)) {
      timingManager.activeTimers.get(id).cancel();
    }
  }

  /**
   * 全タイマーをキャンセル
   */
  static cancelAllTimers() {
    for (const [id, timer] of timingManager.activeTimers.entries()) {
      timer.cancel();
    }
    timingManager.activeTimers.clear();
  }

  // =============================================================================
  // DEBOUNCE & THROTTLE INTEGRATION - SharedUtilities統合
  // =============================================================================

  /**
   * Debounce関数 - 連続実行を防止
   * @param {Function} func - 実行する関数
   * @param {string} key - デバウンスキー
   * @param {number} delay - 遅延時間（ミリ秒）
   * @returns {Function} デバウンス化された関数
   */
  static debounce(func, key, delay = 1000) {
    if (!timingManager.debounceTimers) {
      timingManager.debounceTimers = new Map();
    }

    return function(...args) {
      if (timingManager.debounceTimers.has(key)) {
        clearTimeout(timingManager.debounceTimers.get(key));
      }

      const timeoutId = setTimeout(() => {
        func.apply(this, args);
        timingManager.debounceTimers.delete(key);
      }, delay);

      timingManager.debounceTimers.set(key, timeoutId);
    };
  }

  /**
   * Throttle関数 - 実行頻度を制限
   * @param {Function} func - 実行する関数
   * @param {string} key - スロットルキー
   * @param {number} delay - 実行間隔（ミリ秒）
   * @returns {Function} スロットル化された関数
   */
  static throttle(func, key, delay = 100) {
    if (!timingManager.throttleTimers) {
      timingManager.throttleTimers = new Map();
    }
    if (!timingManager.lastExecution) {
      timingManager.lastExecution = new Map();
    }

    return function(...args) {
      const now = Date.now();
      const lastRun = timingManager.lastExecution.get(key) || 0;

      if (now - lastRun >= delay) {
        func.apply(this, args);
        timingManager.lastExecution.set(key, now);
      } else if (!timingManager.throttleTimers.has(key)) {
        const timeoutId = setTimeout(() => {
          func.apply(this, args);
          timingManager.lastExecution.set(key, Date.now());
          timingManager.throttleTimers.delete(key);
        }, delay - (now - lastRun));
        timingManager.throttleTimers.set(key, timeoutId);
      }
    };
  }

  /**
   * 特定キーのデバウンス/スロットルをクリア
   * @param {string} key - クリアするキー
   */
  static clearTiming(key) {
    if (timingManager.debounceTimers && timingManager.debounceTimers.has(key)) {
      clearTimeout(timingManager.debounceTimers.get(key));
      timingManager.debounceTimers.delete(key);
    }
    if (timingManager.throttleTimers && timingManager.throttleTimers.has(key)) {
      clearTimeout(timingManager.throttleTimers.get(key));
      timingManager.throttleTimers.delete(key);
    }
    if (timingManager.lastExecution) {
      timingManager.lastExecution.delete(key);
    }
  }

  /**
   * 全デバウンス/スロットルをクリア
   */
  static clearAllTiming() {
    // デバウンスタイマーをクリア
    if (timingManager.debounceTimers) {
      timingManager.debounceTimers.forEach(timer => clearTimeout(timer));
      timingManager.debounceTimers.clear();
    }
    // スロットルタイマーをクリア
    if (timingManager.throttleTimers) {
      timingManager.throttleTimers.forEach(timer => clearTimeout(timer));
      timingManager.throttleTimers.clear();
    }
    // 実行履歴をクリア
    if (timingManager.lastExecution) {
      timingManager.lastExecution.clear();
    }
  }
}

// グローバルタイミングマネージャーのインスタンス
const timingManager = new TimingManager();

// TimingManagerをグローバルに公開
window.TimingManager = TimingManager;

// レガシー互換性のための関数
window.debounce = TimingManager.debounce;
window.throttle = TimingManager.throttle;

// =============================================================================
// UNIFIED CACHE CONTROLLER - 統一キャッシュ管理システム
// =============================================================================

/**
 * 統一キャッシュコントローラー - キャッシュ競合を防止
 */
// UnifiedCacheController機能はCacheManagerに統合されました
// cache.gsのcacheManager.clearAllFrontendCaches()を使用してください

// 統一キャッシュ制御はcache.gsのcacheManagerで管理されます

// =============================================================================
// UI UPDATE BATCHER - 統一UI更新システム
// =============================================================================

/**
 * UI更新バッチャー - UI更新の重複を防ぎ効率化
 */
class UIUpdateBatcher {
  constructor() {
    this.pendingUpdates = [];
    this.batchTimeout = null;
    this.isProcessing = false;
    this.batchDelay = 100; // バッチ処理の遅延（ms）
    this.debugMode = window.DEBUG_MODE || false;
  }

  /**
   * UI更新をキューに追加
   * @param {Function} updateFn - 更新関数
   * @param {string} updateId - 更新ID（重複排除用）
   * @param {number} priority - 優先度（高いほど先に実行）
   */
  queueUpdate(updateFn, updateId = null, priority = 0) {
    // 重複排除: 同じIDの更新があれば置き換え
    if (updateId) {
      const existingIndex = this.pendingUpdates.findIndex(update => update.id === updateId);
      if (existingIndex !== -1) {
        this.pendingUpdates[existingIndex] = { fn: updateFn, id: updateId, priority, timestamp: Date.now() };
        return;
      }
    }

    // 新規追加
    this.pendingUpdates.push({
      fn: updateFn,
      id: updateId || `update_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      priority,
      timestamp: Date.now()
    });

    if (this.debugMode) {
      console.log(`➕ UI update queued: ${updateId || 'anonymous'}, queue size: ${this.pendingUpdates.length}`);
    }

    this.scheduleBatch();
  }

  /**
   * バッチ処理をスケジュール
   */
  scheduleBatch() {
    if (this.batchTimeout || this.isProcessing) return;

    this.batchTimeout = setTimeout(async () => {
      await this.processBatch();
    }, this.batchDelay);
  }

  /**
   * バッチ処理を実行
   */
  async processBatch() {
    if (this.isProcessing || this.pendingUpdates.length === 0) return;

    this.isProcessing = true;
    this.batchTimeout = null;

    try {
      // 優先度順でソート（高い順）
      const sortedUpdates = [...this.pendingUpdates].sort((a, b) => {
        if (b.priority !== a.priority) return b.priority - a.priority;
        return a.timestamp - b.timestamp; // 同じ優先度なら古い順
      });

      this.pendingUpdates = [];

      if (this.debugMode) {
        console.log(`🎯 Processing UI update batch: ${sortedUpdates.length} updates`);
      }

      // 順次実行（並列実行だと競合する可能性があるため）
      for (const update of sortedUpdates) {
        try {
          await Promise.resolve(update.fn());
        } catch (error) {
          console.error(`❌ UI update failed: ${update.id}`, error);
        }
        
        // 各更新間に短い間隔を設ける
        await TimingManager.delay(10);
      }

      if (this.debugMode) {
        console.log(`🎉 UI update batch completed: ${sortedUpdates.length} updates processed`);
      }

    } catch (error) {
      console.error('❌ UI update batch processing failed:', error);
    } finally {
      this.isProcessing = false;
      
      // 処理中に新しい更新が追加されていたら再スケジュール
      if (this.pendingUpdates.length > 0) {
        this.scheduleBatch();
      }
    }
  }

  /**
   * 即座にバッチ処理を実行
   */
  async flushUpdates() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    
    await this.processBatch();
  }

  /**
   * 待機中の更新をクリア
   */
  clearPendingUpdates() {
    this.pendingUpdates = [];
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    
    if (this.debugMode) {
      console.log('🧹 Pending UI updates cleared');
    }
  }

  /**
   * バッチャーの状態を取得
   */
  getStatus() {
    return {
      pendingUpdates: this.pendingUpdates.length,
      isProcessing: this.isProcessing,
      batchScheduled: !!this.batchTimeout
    };
  }
}

// グローバルUI更新バッチャーのインスタンス
const uiUpdateBatcher = new UIUpdateBatcher();

// =============================================================================
// BACKEND FUNCTION WRAPPERS
// =============================================================================

// マルチテナント対応: 新しいrunGasWithUserId関数 - ローディング機能付き
function runGasWithUserId(functionName, loadingMessage = '処理中...', ...args) {
  // ローディング表示が必要な場合は callWithLoading を使用
  if (loadingMessage && loadingMessage !== false) {
    // userIdが設定されていない場合は初期化を待つ
    if (!userId) {
      return userIdPromise.then(() => {
        if (!userId) {
          logError('No userId available for:', functionName);
          throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
        }
        
        // ローディング機能付きでuserIdを第一引数として追加 - Admin Panel uses overlay loading
        return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args);
      }).catch((error) => {
        logError('Error in runGasWithUserId (after userIdPromise):', error);
        throw error;
      });
    }
    
    // userIdが既に設定されている場合 - ローディング機能付き - Admin Panel uses overlay loading
    return sharedUtilities.gas.callWithLoading(functionName, loadingMessage, 'overlay', userId, ...args).catch((error) => {
      logError('Error in runGasWithUserId (direct call with loading):', error);
      throw error;
    });
  }
  
  // ローディング不要の場合（loadingMessage = false）は従来通り
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        logError('No userId available for:', functionName);
        throw new Error('ユーザーIDが設定されていません。ページを再読み込みしてください。');
      }
      
      // userIdを第一引数として追加
      return gasOptimizer.call(functionName, userId, ...args);
    }).catch((error) => {
      logError('userIdPromise rejected:', error);
      throw error;
    });
  }
  
  // userIdを第一引数として追加
  return gasOptimizer.call(functionName, userId, ...args);
}

// callWithCache 関数 - 読み取り専用操作用
function callWithCache(functionName, cacheKey, ttl, ...args) {
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, ...args);
  }, ttl);
}

// runGasWithUserId with cache support
function callWithCacheWithUserId(functionName, cacheKey, ttl, ...args) {
  if (!userId) {
    return userIdPromise.then(() => {
      if (!userId) {
        throw new Error('ユーザーIDが設定されていません。');
      }
      return unifiedCache.getOrSet(cacheKey, function() {
        return gasOptimizer.call(functionName, userId, ...args);
      }, ttl);
    });
  }
  
  return unifiedCache.getOrSet(cacheKey, function() {
    return gasOptimizer.call(functionName, userId, ...args);
  }, ttl);
}

// =============================================================================
// STATUS AND DATA LOADING
// =============================================================================

// Load system status - OPTIMIZED with integrated API
// AI列判定結果とconfigJsonのキャッシュ管理
const processCache = {
  aiColumnMapping: {
    data: null,
    headersHash: null,
    timestamp: null,
    ttl: 300000 // 5分間のキャッシュ
  },
  configNormalization: {
    data: null,
    dataHash: null,
    timestamp: null,
    ttl: 60000 // 1分間のキャッシュ
  }
};

// ハッシュ生成関数（簡易版）
function generateSimpleHash(data) {
  return JSON.stringify(data).split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
}

// キャッシュ有効性チェック
function isCacheValid(cacheEntry) {
  if (!cacheEntry.data || !cacheEntry.timestamp) return false;
  return (Date.now() - cacheEntry.timestamp) < cacheEntry.ttl;
}

// グローバルに関数とキャッシュを公開（他のファイルから利用可能にする）
window.processCache = processCache;
window.generateSimpleHash = generateSimpleHash;
window.isCacheValid = isCacheValid;

// loadStatus実行管理
let loadStatusInProgress = null;
let loadStatusQueue = [];

function loadStatus(bypassCache = false) {
  const operationId = 'loadStatus';
  
  // Check operation mutex to prevent concurrent calls
  if (!bypassCache && window.AdminPanel && window.AdminPanel.operationMutex) {
    if (window.AdminPanel.operationMutex.isRunning(operationId)) {
      logDebug('🚫 loadStatus already running, returning existing promise');
      return loadStatusInProgress || Promise.resolve(currentStatus);
    }
  }
  
  // 既に実行中の場合は同じPromiseを返す（強化版）
  if (loadStatusInProgress && !bypassCache) {
    logDebug('🔄 Reusing existing loadStatus promise');
    return loadStatusInProgress;
  }

  // Start operation mutex tracking
  if (window.AdminPanel && window.AdminPanel.operationMutex) {
    window.AdminPanel.operationMutex.start(operationId);
  }

  console.group('🔄 loadStatus - 一元管理版');
  console.log('🚀 Loading system status, bypassCache:', bypassCache);

  // 新しい実行を開始
  loadStatusInProgress = userIdPromise.then(() => {
    if (!userId) {
      console.error('❌ userId is not available after userIdPromise resolution in loadStatus!');
      showMessage('ユーザーIDが取得できません。ページを再読み込みしてください。', 'error');
      console.groupEnd();
      throw new Error('userId is not available');
    }

    console.log('🌐 Calling getInitialData with userId:', userId);

    // runGasWithUserId を使用して getInitialData を呼び出す
    return runGasWithUserId('getInitialData', 'システム情報を読み込み中...')
      .then(response => {
        logDebug('✅ Integrated data loaded:', response);
        
        // エラーレスポンスの検証
        if (!response || response.status === 'error') {
          const errorMsg = response ? response.message : 'サーバーから無効な応答を受信しました';
          logError('getInitialData returned error:', errorMsg);
          throw new Error(errorMsg);
        }
        
        // 必須フィールドの検証
        if (!response.userInfo) {
          logError('userInfo missing in response:', response);
          throw new Error('ユーザー情報が取得できませんでした。ページを再読み込みしてください。');
        }

        // Update UI with integrated response
        updateUIWithNewStatus(response);

        // If sheet details are included, apply them immediately
        if (response.sheetDetails && response.activeSheetName) {
          logDebug('✅ Sheet details included in integrated response, applying configuration');
          try {
            populateHeaderOptions(response.sheetDetails.allHeaders);
            logDebug('✅ Header options populated from integrated data');
            populateConfig(response.sheetDetails.guessedConfig);
            logDebug('✅ AI configuration applied from integrated data');
          } catch (configError) {
            console.error('Error applying sheet configuration from integrated data:', configError);
          }
        }

        logInfo('⚡ Performance: Single API call replaced 3-4 separate calls');
        return response; // Promiseチェーンを維持するためレスポンスを返す
      })
      .catch(error => {
        console.error('❌ Integrated API failed:', error);
        showMessage('システムステータスの読み込みに失敗しました', 'error');
        throw error; // エラーを再スロー
      })
      .finally(() => {
        console.groupEnd();
        // 実行状態をリセット
        loadStatusInProgress = null;
        
        // End operation mutex tracking
        if (window.AdminPanel && window.AdminPanel.operationMutex) {
          window.AdminPanel.operationMutex.end(operationId);
        }
      });
  }).catch(error => {
    console.error('❌ Error resolving userIdPromise in loadStatus:', error);
    showMessage('ユーザーIDの初期化に失敗しました。ページを再読み込みしてください。', 'error');
    console.groupEnd();
    // エラー時も実行状態をリセット
    loadStatusInProgress = null;
    
    // End operation mutex tracking on error
    if (window.AdminPanel && window.AdminPanel.operationMutex) {
      window.AdminPanel.operationMutex.end(operationId);
    }
    
    throw error;
  });

  return loadStatusInProgress;
}

// Load sheet configuration for selected sheet
function loadConfigForSelected() {
  if (!selectedSheet) {
    logWarn('No sheet selected for config loading');
    return Promise.reject(new Error('No sheet selected for config loading'));
  }
  
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
    logError('Missing required data for loadConfigForSelected');
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return Promise.reject(new Error('Missing required data for loadConfigForSelected'));
  }
  
  return runGasWithUserId('getSheetDetails', 'シート情報を読み込み中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
    .then(handleSheetDetailsSuccess)
    .catch(handleSheetDetailsError);
}

// Handle successful sheet details loading
function handleSheetDetailsSuccess(details) {
  if (details && details.allHeaders) {
    populateHeaderOptions(details.allHeaders);
    
    // Show config area and hide placeholder
    const configArea = document.getElementById('config-area');
    const configPlaceholder = document.getElementById('config-placeholder');
    
    if (configArea) {
      configArea.classList.remove('hidden');
    }
    
    if (configPlaceholder) {
      configPlaceholder.classList.add('hidden');
    }
    
    if (details.guessedConfig) {
      // DOMの更新が完了するのを待ってからpopulateConfigを呼び出す
      setTimeout(() => {
        populateConfig(details.guessedConfig);
        
        // Enhanced auto-detection success message with specifics
        const detectedColumns = [];
        if (details.guessedConfig.opinionColumn) detectedColumns.push(`回答列: ${details.guessedConfig.opinionColumn}`);
        if (details.guessedConfig.nameColumn) detectedColumns.push(`名前列: ${details.guessedConfig.nameColumn}`);
        if (details.guessedConfig.classColumn) detectedColumns.push(`クラス列: ${details.guessedConfig.classColumn}`);
        
        const message = detectedColumns.length > 0 
          ? `🤖 AI列判定が自動実行されました！検出された列: ${detectedColumns.join(', ')}。設定を確認してください。`
          : '🤖 AI列判定が自動実行されました。設定を確認してください。';
        
        showMessage(message, 'success');
      }, 0);
    }
  } else {
    logWarn('No headers in sheet details:', details);
    showMessage('シートの詳細情報を取得できませんでした。', 'warning');
  }
}

// Handle sheet details loading error
function handleSheetDetailsError(error) {
  logError('Sheet details failed:', error);
  handleError(error, 'loadConfigForSelected', 'シート情報の読み込みに失敗しました。');
}

// =============================================================================
// AI COLUMN DETECTION
// =============================================================================

// Run AI-powered header guessing
function runHeaderGuessing() {
  if (!selectedSheet) {
    showMessage('シートを選択してください。', 'warning');
    return;
  }
  
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.spreadsheetId) {
    showMessage('スプレッドシートの情報が見つかりません。', 'error');
    return;
  }
  
  // Update button state to show AI is working
  const reguessBtn = document.getElementById('reguess-headers-btn');
  if (reguessBtn) {
    const originalContent = reguessBtn.innerHTML;
    reguessBtn.disabled = true;
    reguessBtn.innerHTML = `
      <span class="relative z-10 flex items-center gap-1">
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        <span class="text-xs font-bold">AI分析中</span>
      </span>
    `;
    
    // Restore button after completion
    const restoreButton = () => {
      reguessBtn.disabled = false;
      reguessBtn.innerHTML = originalContent;
    };
    
    // Show start notification
    showMessage('🤖 高精度AI判定システムが起動しました。データを分析中...', 'info');
    
    runGasWithUserId('getSheetDetails', 'AI搭載高精度列判定システムが分析中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(function(details) {
        if (!details || !details.guessedConfig) {
          restoreButton();
          showMessage('❌ AI列判定が失敗しました。手動で列を設定してください。', 'warning');
          return;
        }
        
        const configToUse = {
          ...details.guessedConfig,
          sheetName: selectedSheet
        };
        
        setTimeout(() => {
          populateConfig(configToUse);
          restoreButton();
          
          // Enhanced completion notification with analysis details
          const detectedColumns = [];
          if (configToUse.opinionColumn) detectedColumns.push(`💬 回答列: ${configToUse.opinionColumn}`);
          if (configToUse.nameColumn) detectedColumns.push(`👤 名前列: ${configToUse.nameColumn}`);
          if (configToUse.classColumn) detectedColumns.push(`🏫 クラス列: ${configToUse.classColumn}`);
          if (configToUse.reasonColumn) detectedColumns.push(`💭 理由列: ${configToUse.reasonColumn}`);
          
          const message = detectedColumns.length > 0 
            ? `🎉 高精度AI判定が完了しました！\n\n検出された列:\n${detectedColumns.join('\n')}\n\n設定を保存して公開してください。`
            : '🎉 高精度AI判定が完了しました！設定を保存して公開してください。';
          
          showMessage(message, 'success');
          
          // ✨ 重要: AI判定完了後の処理
          setTimeout(() => {
            console.log('🚀 AI判定完了 - 後処理を開始');
            
            // セットアップ状態を確認して必要な場合のみ実行
            if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
              const config = typeof currentStatus.userInfo.configJson === 'string' 
                ? JSON.parse(currentStatus.userInfo.configJson) 
                : currentStatus.userInfo.configJson;
              
              if (config.setupStatus === 'pending' || !config.formCreated) {
                console.log('🔧 セットアップ未完了状態を検出 - 処理を実行');
                completeAIDetectionProcess();
              } else {
              }
            } else {
              console.log('🔧 ステータス情報が不明 - 念のため処理を実行');
              completeAIDetectionProcess();
            }
          }, 1000);
        }, 100);
      })
      .catch(function(error) {
        restoreButton();
        console.error('AI column detection error:', error);
        
        // Enhanced error message with specific guidance
        let errorMessage = '❌ 高精度AI判定システムでエラーが発生しました。\n\n';
        if ((error && error.message && error.message.includes('permission')) || (error && error.message && error.message.includes('権限'))) {
          errorMessage += '📋 スプレッドシートへのアクセス権限を確認してください。';
        } else if ((error && error.message && error.message.includes('network')) || (error && error.message && error.message.includes('timeout'))) {
          errorMessage += '🌐 ネットワーク接続を確認して再試行してください。';
        } else {
          errorMessage += '⚙️ 手動で列を設定するか、再度お試しください。';
        }
        
        errorMessage += '\n\n💡 問題が続く場合は、管理者にお問い合わせください。';
        
        showMessage(errorMessage, 'error');
      });
  }
}

// ✨ AI判定完了後の自動セットアップ完了処理
function completeAIDetectionProcess() {
  try {
    console.log('🔧 AI判定完了 - 設定保存処理を実行中...');
    
    // 1. 設定検証
    if (!validateConfig()) {
      console.warn('⚠️ AI判定結果の設定が不完全 - 手動設定が必要');
      showMessage('AI判定結果を確認してください。設定に不備があります。', 'warning');
      return;
    }
    
    // 2. フォームURL検出・作成の実行
    
    runGasWithUserId('detectFormUrlFromSpreadsheet', 'フォーム検出中...', currentStatus.userInfo.spreadsheetId, selectedSheet)
      .then(result => {
        console.log('📋 フォーム検出結果受信');
        
        if (result && result.success && result.formUrl) {
          
          // 3. 設定の自動保存と完了状態への更新
          const config = buildConfigObject();
          config.formUrl = result.formUrl;
          config.formCreated = true;
          config.setupStatus = 'completed';
          
          console.log('💾 AI判定完了後の設定を自動保存中...', config);
          
          // Save draft to session storage when AI prediction is completed
          const draftData = {
            questionText: config.opinionHeader || config.opinionColumn || '（問題文未設定）',
            sheetName: selectedSheet,
            config: config,
            displayMode: (function() { const el = document.getElementById('anonymous-mode'); return el && el.checked ? 'anonymous' : 'named'; })(),
            countDisplay: 'show' // Default, could be configured based on UI settings
          };
          
          saveDraftToSession(draftData);
          console.log('📝 下書きをセッションに保存しました:', draftData.questionText);
          
          return runGasWithUserId('saveSheetConfig', '設定保存中...', currentStatus.userInfo.spreadsheetId, selectedSheet, config);
        } else {
          throw new Error('フォームURLの検出に失敗しました');
        }
      })
      .then(saveResult => {
        if (saveResult && saveResult.success) {
          showMessage('🎉 AI判定が完了しました！設定を保存して公開してください。', 'success');
          
          // 4. UI状態の更新
          if (typeof loadSystemStatus === 'function') {
            loadSystemStatus();
          }
          
          // 5. ステップ表示の更新
          if (typeof navigateToStep === 'function') {
            navigateToStep(2); // ステップ2（AI列分析完了）に進む
          }

          // 6. 手動公開を促すメッセージ表示（自動公開は削除）

        } else {
          throw new Error((saveResult && saveResult.message) || '設定の保存に失敗しました');
        }
      })
      .catch(error => {
        console.error('❌ AI判定完了処理でエラー:', error);
        showMessage(`⚠️ AI判定後の処理でエラーが発生しました: ${error.message}\n手動で「保存・公開」を実行してください。`, 'warning');
      });
      
  } catch (error) {
    console.error('❌ completeAIDetectionProcess 致命的エラー:', error);
    showMessage('AI判定処理でエラーが発生しました。手動で設定を確認してください。', 'error');
  }
}

// ✨ 設定初期化統一機能
// 実行状態の管理
let initializationInProgress = false;
let lastInitializationTime = 0;
const INITIALIZATION_COOLDOWN = 30000; // 30秒のクールダウン

/**
 * 統一設定初期化機能
 * 自動診断→軽微修復→必要に応じて完全リセットの段階的アプローチ
 */
function initializeUserSettings() {
  return new Promise((resolve, reject) => {
    try {
      // 重複実行防止チェック
      const now = Date.now();
      if (initializationInProgress) {
        resolve({ 
          success: false, 
          message: '設定初期化が既に実行中です', 
          skipped: true, 
          reason: 'already_running' 
        });
        return;
      }
      
      // クールダウンチェック
      if (now - lastInitializationTime < INITIALIZATION_COOLDOWN) {
        const remainingTime = Math.ceil((INITIALIZATION_COOLDOWN - (now - lastInitializationTime)) / 1000);
        resolve({ 
          success: false, 
          message: `あと${remainingTime}秒後に実行可能です`, 
          skipped: true, 
          reason: 'cooldown', 
          remainingTime 
        });
        return;
      }
      
      initializationInProgress = true;
      lastInitializationTime = now;
      
      console.log('🔄 設定初期化を開始...');
      
      // フェーズ1: 自動診断
      performSystemDiagnostic()
        .then(diagnosticResult => {
          if (diagnosticResult.severity === 'none') {
            // 問題なし
            initializationInProgress = false;
            resolve({
              success: true,
              phase: 'diagnostic',
              message: '✅ 設定に問題は見つかりませんでした',
              issues: [],
              fixes: []
            });
          } else if (diagnosticResult.severity === 'minor') {
            // 軽微な問題 - 自動修復実行
            return performAutoRepair();
          } else {
            // 重大な問題 - ユーザーに選択を委ねる
            initializationInProgress = false;
            resolve({
              success: false,
              phase: 'needs_confirmation',
              message: '重大な設定問題が見つかりました。完全な初期化が必要です。',
              severity: diagnosticResult.severity,
              issues: diagnosticResult.issues,
              requiresFullReset: true
            });
          }
        })
        .then(repairResult => {
          if (repairResult) {
            initializationInProgress = false;
            resolve({
              success: true,
              phase: 'auto_repair',
              message: `🔧 ${repairResult.fixes?.length || 0}件の問題を自動修復しました`,
              issues: repairResult.issues || [],
              fixes: repairResult.fixes || []
            });
          }
        })
        .catch(error => {
          initializationInProgress = false;
          reject(new Error(`設定初期化エラー: ${error.message}`));
        });
        
    } catch (error) {
      initializationInProgress = false;
      reject(error);
    }
  });
}

/**
 * UI付き設定初期化実行関数
 * ユーザーインタラクションとプログレス表示を含む
 */
function initializeUserSettingsWithUI() {
  const button = document.getElementById('initialize-settings-btn');
  const originalHTML = button ? button.innerHTML : '';
  
  // ボタンの状態を「処理中」に変更
  if (button) {
    button.disabled = true;
    button.innerHTML = `
      <svg class="w-3 h-3 animate-spin" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      診断中...
    `;
  }
  
  // プログレス表示
  showMessage('🔍 システム診断を開始しています...', 'info');
  
  initializeUserSettings()
    .then(result => {
      // ボタンを元の状態に戻す
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHTML;
      }
      
      if (result.success) {
        // 成功時の処理
        if (result.phase === 'diagnostic') {
          showMessage(result.message, 'success');
        } else if (result.phase === 'auto_repair') {
          showMessage(result.message, 'success');
          if (result.fixes.length > 0) {
            console.log('🔧 修復された問題:', result.fixes);
          }
        }
      } else {
        // 確認が必要な場合
        if (result.requiresFullReset) {
          const issuesList = result.issues.map(issue => `• ${issue}`).join('\n');
          
          showConfirmationModal(
            '設定の完全初期化が必要です',
            `以下の問題が見つかりました:\n\n${issuesList}\n\n設定を完全に初期化しますか？\n（アカウントは削除されません）`,
            () => {
              // ユーザーが確認した場合、完全リセットを実行
              performFullReset()
                .then(resetResult => {
                  if (resetResult.success) {
                    showMessage('✅ 設定が正常に初期化されました', 'success');
                    // ページをリロードして最新状態を反映
                    setTimeout(() => location.reload(), 1500);
                  } else {
                    showMessage('❌ 設定初期化に失敗しました', 'error');
                  }
                })
                .catch(error => {
                  console.error('Full reset failed:', error);
                  showMessage('❌ 設定初期化中にエラーが発生しました', 'error');
                });
            }
          );
        } else {
          showMessage(result.message, 'warning');
        }
      }
    })
    .catch(error => {
      // ボタンを元の状態に戻す
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHTML;
      }
      
      console.error('Settings initialization failed:', error);
      showMessage('❌ 設定初期化中にエラーが発生しました', 'error');
    });
}

/**
 * システム診断（問題の重要度を判定）
 */
function performSystemDiagnostic() {
  return new Promise((resolve) => {
    try {
      if (!currentStatus || !currentStatus.userInfo) {
        resolve({ severity: 'critical', issues: ['ユーザー情報が利用できません'] });
        return;
      }
      
      const config = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
        
      const issues = [];
      let maxSeverity = 'none';
      
      // 軽微な問題の検出
      const minorIssues = detectMinorIssues(config);
      if (minorIssues.length > 0) {
        issues.push(...minorIssues);
        maxSeverity = 'minor';
      }
      
      // 重大な問題の検出
      const criticalIssues = detectCriticalIssues(config);
      if (criticalIssues.length > 0) {
        issues.push(...criticalIssues);
        maxSeverity = 'critical';
      }
      
      resolve({
        severity: maxSeverity,
        issues: issues
      });
      
    } catch (error) {
      resolve({ 
        severity: 'critical', 
        issues: [`診断エラー: ${error.message}`] 
      });
    }
  });
}

/**
 * 軽微な問題の検出
 */
function detectMinorIssues(config) {
  const issues = [];
  
  // 既存の修復ルールから軽微なものを抽出
  if (config.formUrl && config.formUrl.trim() && !config.formCreated) {
    issues.push('フォームURLが存在するが作成フラグがfalse');
  }
  
  if (config.formCreated && config.setupStatus !== 'completed') {
    issues.push('フォーム作成済みだがセットアップ状態が未完了');
  }
  
  if (config.appPublished && config.setupStatus === 'pending') {
    issues.push('公開済みだがセットアップ状態がpending');
  }
  
  if (currentStatus.sheetDetails?.guessedConfig?.opinionHeader && config.setupStatus === 'pending') {
    issues.push('AI列判定完了済みだがセットアップ状態がpending');
  }
  
  return issues;
}

/**
 * 重大な問題の検出
 */
function detectCriticalIssues(config) {
  const issues = [];
  
  // 設定が完全に破損している場合
  if (!config || typeof config !== 'object') {
    issues.push('設定データが破損しています');
  }
  
  // 必須フィールドが欠落している場合
  if (config && !config.hasOwnProperty('setupStatus')) {
    issues.push('セットアップ状態情報が欠落しています');
  }
  
  return issues;
}

/**
 * 自動修復の実行
 */
function performAutoRepair() {
  return new Promise((resolve, reject) => {
    // 既存のrepairSetupStateInconsistencies()の核心部分を使用
    repairSetupStateInconsistencies()
      .then(result => resolve(result))
      .catch(error => reject(error));
  });
}

/**
 * 完全リセットの実行（確認済み）
 */
function performFullReset() {
  return new Promise((resolve, reject) => {
    runGasWithUserId('resetConfigJson', '設定を完全初期化中...')
      .then(result => {
        if (result.success) {
          resolve({
            success: true,
            phase: 'full_reset',
            message: '✅ 設定を完全に初期化しました',
            resetAt: result.resetAt
          });
        } else {
          reject(new Error(result.message || '完全初期化に失敗しました'));
        }
      })
      .catch(error => reject(error));
  });
}

// ✨ レガシー診断・修復機能（後方互換性のため残存）
// 診断実行状態の管理
let diagnosticInProgress = false;
let lastDiagnosticTime = 0;
const DIAGNOSTIC_COOLDOWN = 30000; // 30秒のクールダウン

function repairSetupStateInconsistencies() {
  return new Promise((resolve, reject) => {
    try {
      // 重複実行防止チェック
      const now = Date.now();
      if (diagnosticInProgress) {
        resolve({ issues: [], fixes: [], skipped: true, reason: 'already_running' });
        return;
      }
      
      // クールダウンチェック
      if (now - lastDiagnosticTime < DIAGNOSTIC_COOLDOWN) {
        const remainingTime = Math.ceil((DIAGNOSTIC_COOLDOWN - (now - lastDiagnosticTime)) / 1000);
        console.log(`⏳ クールダウン中です。あと${remainingTime}秒後に実行可能です。`);
        resolve({ issues: [], fixes: [], skipped: true, reason: 'cooldown', remainingTime });
        return;
      }
      
      diagnosticInProgress = true;
      lastDiagnosticTime = now;
      console.log('🔧 セットアップ状態の診断・修復を開始...');
      
      if (!currentStatus || !currentStatus.userInfo) {
        diagnosticInProgress = false;
        reject(new Error('ユーザー情報が利用できません'));
        return;
      }
      
      const config = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
        
      const issues = [];
      const fixes = [];
      
      // 1. フォームURL vs formCreated の整合性チェック
      if (config.formUrl && config.formUrl.trim() && !config.formCreated) {
        issues.push('フォームURLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正');
      }
      
      // 2. formCreated vs setupStatus の整合性チェック
      if (config.formCreated && config.setupStatus !== 'completed') {
        issues.push('フォームが作成済みだが setupStatus != completed');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正');
      }
      
      // 3. スプレッドシートIDとactiveSheetNameの整合性チェック
      if (currentStatus.userInfo.spreadsheetId && !currentStatus.activeSheetName && selectedSheet) {
        issues.push('スプレッドシートが存在するが activeSheetName が未設定');
        // これはconfigではなくstatusの問題なので、バックエンドで修正が必要
        fixes.push('activeSheetName の更新が必要（要バックエンド処理）');
      }
      
      // 4. 公開状態の整合性チェック（publishedSheetName vs appPublished）
      if (config.publishedSheetName && !config.appPublished) {
        issues.push('公開シート名が存在するが appPublished=false');
        // これは慎重に判断する必要があるため、警告のみ
        fixes.push('注意: 公開状態の確認が必要');
      }
      
      // 5. 🔧 新ルール: appPublished=true だが setupStatus='pending' の場合（公開済み不整合）
      if (config.appPublished && config.setupStatus === 'pending') {
        issues.push('公開済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（既に公開済みのため）');
      }
      
      // 6. 🔧 新ルール: 公開URLが存在するが formCreated=false の場合
      if (currentStatus.viewUrl && currentStatus.viewUrl.trim() && !config.formCreated) {
        issues.push('公開URLが存在するが formCreated=false');
        config.formCreated = true;
        fixes.push('formCreated を true に修正（公開URL存在のため）');
      }
      
      // 7. 🔧 新ルール: isPublished=true だが setupStatus='pending' の場合（システム状態不整合）
      if (currentStatus.isPublished && config.setupStatus === 'pending') {
        issues.push('システムで公開済み判定だが setupStatus=pending');
        config.setupStatus = 'completed';
        fixes.push('setupStatus を completed に修正（公開状態確認済み）');
      }
      
      // 8. 🔧 新ルール: AI判定結果が存在するがsetupStatus='pending'の場合（AI完了後の状態更新漏れ）
      if (currentStatus.sheetDetails && currentStatus.sheetDetails.guessedConfig && 
          currentStatus.sheetDetails.guessedConfig.opinionHeader && 
          config.setupStatus === 'pending') {
        issues.push('AI列判定完了済みだが setupStatus=pending');
        config.setupStatus = 'completed';
        config.formCreated = true; // AI判定完了時はフォームも準備完了とみなす
        fixes.push('AI判定完了に基づいてセットアップ状態を完了に更新');
      }
      
      
      if (fixes.length === 0) {
        diagnosticInProgress = false;
        resolve({
          success: true,
          message: '✅ セットアップ状態に問題は見つかりませんでした',
          issues: [],
          fixes: []
        });
        return;
      }
      
      // 修正された設定を保存
      console.log('💾 修正された設定を保存中...', config);

        runGasWithUserId('syncConfigurationState', '設定修復中...', config, 'repair')
        .then(saveResult => {
          if (saveResult && saveResult.success) {
            
            // UI状態の更新
            if (typeof loadSystemStatus === 'function') {
              loadSystemStatus();
            }
            
            diagnosticInProgress = false;
            resolve({
              success: true,
              message: `🔧 ${fixes.length}件のセットアップ問題を修復しました`,
              issues,
              fixes
            });
          } else {
            diagnosticInProgress = false;
            reject(new Error((saveResult && saveResult.message) || '設定の保存に失敗しました'));
          }
        })
        .catch(saveError => {
          diagnosticInProgress = false;
          reject(new Error(`設定保存エラー: ${saveError.message}`));
        });
        
    } catch (error) {
      console.error('❌ セットアップ状態修復でエラー:', error);
      diagnosticInProgress = false;
      reject(error);
    }
  });
}

// Note: runSetupRepair function has been replaced by initializeUserSettingsWithUI

// =============================================================================
// SAVE AND PUBLISH OPERATIONS
// =============================================================================

// Save configuration and publish board - 修正版（公開モーダル経由）
function saveAndPublish() {
  if (!validateConfig()) {
    showMessage('必須項目（回答データ列）が選択されていません。', 'error');
    return;
  }
  
  // UIからconfigオブジェクトを構築
  const config = buildConfigObject();
  
  // 自動停止設定を準備
  const autoStopSettings = {
    enabled: true,
    minutes: 360 // 6時間 = 360分（config.gsと統一）
  };
  
  // Check for privacy-sensitive settings and show warning if enabled
  const showNamesEl = document.getElementById('show-names');
  const showNames = (showNamesEl && showNamesEl.checked) || false;
  const showCountsEl = document.getElementById('show-counts');
  const showCounts = (showCountsEl && showCountsEl.checked) || false;
  
  if (showNames || showCounts) {
    // Show privacy warning modal first
    if (window.sharedModals) {
      const privacySettings = [];
      if (showNames) privacySettings.push('名前表示');
      if (showCounts) privacySettings.push('リアクション数表示');
      
      console.log(`⚠️ プライバシー警告: ${privacySettings.join('・')}が有効です`);
      
      window.sharedModals.showPrivacyWarning(
        // onConfirm - show publish modal after privacy confirmation
        () => {
          showPublishModalAfterChecks(config, autoStopSettings);
        },
        // onCancel - user wants to review settings
        () => {
          console.log('❌ ユーザーがプライバシー設定の見直しを選択');
          showMessage('設定を見直してから再度お試しください。', 'info');
        }
      );
      return;
    }
  }
  
  // If no privacy concerns, show publish modal directly
  showPublishModalAfterChecks(config, autoStopSettings);
}

// 公開モーダル表示（プライバシーチェック後）
function showPublishModalAfterChecks(config, autoStopSettings) {
  if (window.sharedModals && typeof window.sharedModals.showPublish === 'function') {
    window.sharedModals.showPublish(
      // 公開実行時のコールバック
      () => {
        console.log('📤 公開モーダルで公開が選択されました');
        proceedWithSaveAndPublish(config);
      },
      // キャンセル時のコールバック
      () => {
        console.log('❌ 公開がキャンセルされました');
      },
      // 自動停止設定
      autoStopSettings
    );
  } else {
    // フォールバック: モーダルが利用できない場合は直接実行
    console.warn('⚠️ 公開モーダルが利用できません。直接実行します。');
    proceedWithSaveAndPublish(config);
  }
}

// Proceed with the actual save and publish operation
function proceedWithSaveAndPublish(config) {

  // Set save protection flags to prevent interference
  isSaveInProgress = true;
  freshSaveTimestamp = Date.now();
  window.freshSaveTimestamp = freshSaveTimestamp;
  
  runGasWithUserId('saveAndPublish', '設定を保存し、ボードを公開しています...', selectedSheet, config)
    .then(function(result) {
      isSaveInProgress = false;
      
      // Check if result has data (from integrated API) or legacy success status
      if (result && (result.userInfo || result.status === 'success')) {
        showMessage('✅ 設定が保存され、ボードが公開されました！', 'success');
        
        // 履歴に保存（公開時）
        saveHistoryOnPublish(result, config);
        
        // ボードビューアーに即座更新を通知
        try {
          // メインウィンドウにメッセージを送信（あれば）
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            }, '*');
            logInfo('ボード公開メッセージをメインウィンドウに送信');
          }
          
          // 同じドメインの他のタブにも通知
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'BOARD_PUBLISHED',
              sheetName: selectedSheet,
              timestamp: Date.now()
            });
            channel.close();
            logInfo('ボード公開メッセージをBroadcastChannelで送信');
          }
        } catch (broadcastError) {
          console.warn('リアルタイム更新通知でエラー:', broadcastError);
        }
        
        // 6時間自動停止の確認モーダルを表示
        setTimeout(() => {
          // ローディングオーバーレイを確実に非表示にしてからモーダル表示
          if (window.unifiedLoadingManager) {
            window.unifiedLoadingManager.setLoading(false);
          }
          
          // 公開完了確認とURL生成後に自動停止確認モーダルを表示
          setTimeout(() => {
            // 公開状態とURL生成の確認
            if (result && (result.publishedAt || result.userInfo)) {
              const publishResult = {
                publishedAt: result.publishedAt || new Date().toISOString(),
                autoStopMinutes: result.autoStopMinutes || 360,
                boardUrl: result.boardUrl || result.viewUrl || '',
                status: 'success',
                ...result
              };
              
              console.log('📊 通常公開完了データ確認完了');
              
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(publishResult);
              } else {
                console.warn('⚠️ 自動停止確認モーダルが利用できません');
              }
            } else {
              console.warn('⚠️ 通常公開結果データが不完全のため、自動停止モーダルをスキップします:', result);
            }
          }, 800); // URL生成待ちのため少し長めに設定
        }, 2000); // 成功メッセージの後に表示
        
        // Use fresh data from save response if available
        if (result.userInfo && result._meta) {
          logInfo('Using fresh data from save response');
          updateUIWithNewStatus(result);
        } else {
          // Only force refresh if no fresh data available
          logInfo('No fresh data in response, forcing refresh');
          loadStatus(true).then(() => {
            // ステップ進行を更新
            const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
            updateStepIndicators(currentStep);
            manageSectionStates(currentStep);
          });
        }
      } else {
        logError('Save failed:', result);
        showMessage(result.message || '設定の保存に失敗しました。', 'error');
        isSaveInProgress = false;
      }
    })
    .catch(function(error) {
      logError('saveAndPublish error:', error);
      isSaveInProgress = false;
      
      // 統一キャッシュクリア（エラー後）
      cacheManager.clearAllFrontendCaches().catch(clearError => {
        console.warn('Cache clear after error failed:', clearError);
      });
      
      loadStatus(true).then(() => {
        // エラー後もステップ進行を更新
        const currentStep = currentStatus && currentStatus.setupStep ? currentStatus.setupStep : 1;
        updateStepIndicators(currentStep);
        manageSectionStates(currentStep);
      });
      handleError(error, 'saveAndPublish', '設定の保存に失敗しました。システム状態を再読み込みしました。');
    });
}

/**
 * 公開停止時の強化されたキャッシュクリア処理
 * キャッシュ関連のアクセス問題を防ぐため、あらゆるキャッシュを完全にクリア
 */
async function clearAllCachesForUnpublish() {
  console.log('🧹 公開停止時の包括的キャッシュクリア処理を開始');
  
  try {
    // 1. 既存の安定したキャッシュクリア方式
    // 統一キャッシュクリア
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      window.unifiedCache.clear();
    }
    
    // GAS最適化キャッシュクリア
    if (window.gasOptimizer && typeof window.gasOptimizer.clearCache === 'function') {
      window.gasOptimizer.clearCache();
    }
    
    // SharedUtilitiesキャッシュクリア
    if (window.sharedUtilities && window.sharedUtilities.cache && typeof window.sharedUtilities.cache.clear === 'function') {
      window.sharedUtilities.cache.clear();
    }
    
    // DOM要素キャッシュクリア
    if (window.sharedUtilities && window.sharedUtilities.dom && typeof window.sharedUtilities.dom.clearElementCache === 'function') {
      window.sharedUtilities.dom.clearElementCache();
    }
    
    // 2. ローカルストレージのキャッシュクリア（StudyQuest関連のみ）
    try {
      const localStorageKeys = Object.keys(localStorage);
      const studyQuestKeys = localStorageKeys.filter(key => 
        key.includes('studyquest') || 
        key.includes('board') || 
        key.includes('sheet') ||
        key.includes('admin') ||
        key.includes('publication') ||
        key.includes('answer')
      );
      
      studyQuestKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
    } catch (e) {
      console.warn('⚠️ localStorage clear warning:', e);
    }
    
    // 3. セッションストレージのクリア
    try {
      if (window.sessionStorage) {
        const sessionKeys = Object.keys(sessionStorage);
        const studyQuestSessionKeys = sessionKeys.filter(key => 
          key.includes('studyquest') || 
          key.includes('board') || 
          key.includes('admin')
        );
        
        studyQuestSessionKeys.forEach(key => {
          sessionStorage.removeItem(key);
        });
        
      }
    } catch (e) {
      console.warn('⚠️ sessionStorage clear warning:', e);
    }
    
    // 4. BroadcastChannel通知（他のタブに公開停止を通知）
    try {
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('board-updates');
        channel.postMessage({
          type: 'BOARD_UNPUBLISHED',
          timestamp: Date.now(),
          userId: window.userId || 'unknown'
        });
        channel.close();
      }
    } catch (e) {
      console.warn('⚠️ BroadcastChannel notification warning:', e);
    }
    
    // 5. キャッシュ無効化のためのタイムスタンプ更新
    try {
      localStorage.setItem('lastUnpublishTime', Date.now().toString());
      localStorage.setItem('cacheInvalidationToken', Math.random().toString(36));
    } catch (e) {
      console.warn('⚠️ Cache invalidation token update warning:', e);
    }
    
    
  } catch (error) {
    console.error('❌ キャッシュクリア処理でエラー:', error);
    // エラーがあっても処理は継続
  }
}

// Unpublish board
function unpublishBoard() {
    return runGasWithUserId('unpublishBoard', 'ボードの公開を停止中...')
      .then(function(response) {
        logDebug('公開停止レスポンス:', response);

        // 強化されたキャッシュクリア処理（キャッシュバスティング対応）
        clearAllCachesForUnpublish();

        // Reset column selection dropdowns to default "--列を選択--" state
        resetColumnSelections();

        // 公開停止処理が成功したことを返す
        return Promise.resolve(response);
      })
      .catch(function(error) {
        handleError(error, 'unpublishBoard', 'ボードの公開停止に失敗しました。');
        // エラーを再スローして呼び出し元でキャッチできるようにする
        return Promise.reject(error);
      });
  }

  // シンプル履歴保存関数（公開時）
  async function saveHistoryOnPublish(publishResponse, config) {
    try {
      const userInfo = publishResponse.userInfo || {};
      
      // スプレッドシート作成日を取得
      let createdDate = null;
      if (userInfo.spreadsheetId) {
        try {
          const createdDateResponse = await runGasWithUserId('getSpreadsheetCreatedDateAPI', false);
          if (createdDateResponse && createdDateResponse.status === 'success') {
            createdDate = createdDateResponse.createdDate;
          }
        } catch (error) {
          console.warn('⚠️ 作成日取得失敗:', error);
        }
      }
      
      // シンプル履歴エントリ作成
      await createSimpleHistoryEntry(publishResponse, config, userInfo, createdDate);
      
      logDebug('✅ シンプル履歴保存完了（公開時）');
    } catch (error) {
      logWarn('⚠️ 公開時の履歴保存に失敗:', error);
    }
  }
  
  /**
   * シンプル履歴エントリ作成
   * @param {Object} publishResponse - 公開API応答
   * @param {Object} config - フォーム設定
   * @param {Object} userInfo - ユーザー情報
   * @param {string} createdDate - スプレッドシート作成日
   */
  async function createSimpleHistoryEntry(publishResponse, config, userInfo, createdDate) {
    try {
      // 現在のUI状態から設定取得（showNamesベース）
      const getShowNames = () => {
        const showNamesCheckbox = document.getElementById('show-names');
        return (showNamesCheckbox && showNamesCheckbox.checked) || false;
      };
      
      const getShowCounts = () => {
        const showCountsCheckbox = document.getElementById('show-counts');
        return (showCountsCheckbox && showCountsCheckbox.checked) || false;
      };
      
      // 問題文を複数ソースから取得
      const questionText = config.opinionHeader ||
                          config.opinionColumn ||
                          userInfo.customFormInfo?.mainQuestion ||
                          'デフォルト問題文';
      
      // シンプルな履歴アイテム構造
      const historyItem = {
        id: generateHistoryId(),
        createdDate: createdDate,
        publishedAt: publishResponse.publishedAt || new Date().toISOString(),
        questionText: questionText,
        setupType: getSetupType(),
        
        // 復元用の最小データ（showNames/showCountsベース）
        opinionHeader: config.opinionHeader || '',
        nameHeader: config.nameHeader || '名前',
        showNames: getShowNames(),      // UI状態を直接保存
        showCounts: getShowCounts(),    // UI状態を直接保存
        
        // 復元用のシート情報
        sheetName: publishResponse.activeSheetName || selectedSheet || '',
        spreadsheetId: userInfo.spreadsheetId || ''
      };
      
      // 履歴に追加（5件制限）
      addToSimpleHistory(historyItem);
      
      console.log('✅ Simple history entry created:', historyItem.questionText);
      
    } catch (error) {
      console.error('❌ Simple history entry creation failed:', error);
    }
  }
  
  /**
   * シンプル履歴に追加（5件制限）
   * @param {Object} newItem - 新しい履歴アイテム
   */
  function addToSimpleHistory(newItem) {
    try {
      if (window.HistoryManager) {
        // Use new unified HistoryManager
        const success = window.HistoryManager.add(newItem);
        if (success) {
          console.log('✅ History saved using HistoryManager');
          // Update UI table
          window.HistoryManager.renderTable();
        } else {
          console.warn('⚠️ Failed to save history using HistoryManager');
        }
      } else {
        // Fallback to legacy method
        console.warn('⚠️ HistoryManager not available, using legacy method');
        const history = getHistoryFromStorage();
        
        // 先頭に追加
        history.unshift(newItem);
        
        // 5件に制限
        const limitedHistory = history.slice(0, 5);
        
        // 保存
        saveHistoryToStorage(limitedHistory);
        
        console.log(`✅ History saved with ${limitedHistory.length} items (max 5)`);
        
        // テーブル更新
        if (typeof loadSimpleHistoryTable === 'function') {
          loadSimpleHistoryTable();
        }
      }
      
    } catch (error) {
      console.error('❌ Failed to add to simple history:', error);
    }
  }
  
  /**
   * セットアップタイプの取得
   * @returns {string} セットアップタイプ
   */
  function getSetupType() {
    // URLパラメータやセッション情報から判定
    if (sessionStorage.getItem('quickStartActive')) {
      return 'quickstart';
    }
    return 'custom';
  }
  
  /**
   * 履歴ID生成
   * @returns {string} 一意のID
   */
  function generateHistoryId() {
    return 'history_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  // 古い複雑なcreateConsolidatedHistoryEntry関数は削除済み
  
  /**
   * Create history entry for QuickStart completion
   * @param {Object} quickStartResult - QuickStart completion result
   */
  function createQuickStartHistoryEntry(quickStartResult) {
    try {
      logDebug('Creating QuickStart history entry:', quickStartResult);
      
      // Extract question text from QuickStart config with better fallback
      const questionText = (quickStartResult.config && quickStartResult.config.opinionHeader) ||
                          (quickStartResult.config && quickStartResult.config.opinionColumn) ||
                          (quickStartResult.config && quickStartResult.config.reasonHeader) ||
                          (quickStartResult.config && quickStartResult.config.nameHeader) ||
                          'デフォルト問題文';
      
      console.log('📝 QuickStart question text extracted:', questionText);
      
      // Use completion time as both creation and publication time for QuickStart
      const completedAt = quickStartResult.completedAt || new Date().toISOString();
      const publishedAt = (quickStartResult.publishResult && quickStartResult.publishResult.publishedAt) || completedAt;
      
      // Create simplified QuickStart history entry
      const historyItem = {
        id: generateHistoryId(),
        createdDate: completedAt, // QuickStart creates and publishes simultaneously
        publishedAt: publishedAt,
        questionText: questionText,
        setupType: 'quickstart',
        opinionHeader: (quickStartResult.config && quickStartResult.config.opinionHeader) || '',
        nameHeader: (quickStartResult.config && quickStartResult.config.nameHeader) || '名前',
        showNames: false,   // QuickStartデフォルト: 名前表示OFF（匿名）
        showCounts: false,  // QuickStartデフォルト: リアクション数表示OFF
        sheetName: quickStartResult.sheetName || quickStartResult.publishedSheetName || '',
        spreadsheetId: quickStartResult.spreadsheetId || ''
      };
      
      addToSimpleHistory(historyItem);
      
      // Update UI - handled by addToSimpleHistory function
      // No need for additional UI update call here
      
      logDebug('QuickStart simple history entry created successfully:', {
        id: historyItem.id,
        questionText: historyItem.questionText,
        createdDate: historyItem.createdDate,
        publishedAt: historyItem.publishedAt,
        setupType: historyItem.setupType
      });
      
    } catch (error) {
      logError('Failed to create QuickStart history entry:', error);
    }
  }

// セットアップタイプを判定する補助関数
function determineSetupType(config, userInfo) {
  if (userInfo.customFormInfo) {
    return 'カスタムセットアップ';
  } else if (config.isQuickStart || config.setupType === 'quickstart') {
    return 'クイックスタート';
  } else if (config.isExternalResource) {
    return '外部リソース';
  } else {
    return 'unknown';
  }
}

// Reset column selection dropdowns to default state
function resetColumnSelections() {
  
  const columnSelects = [
    'opinion-column-select',
    'name-column-select', 
    'reason-column-select',
    'class-column-select',
    'timestamp-column-select'
  ];
  
  columnSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (select) {
      select.value = ''; // Reset to empty value
    }
  });
  
  // Also reset any display checkboxes
  const checkboxes = ['show-names', 'show-counts'];
  checkboxes.forEach(checkboxId => {
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      checkbox.checked = false;
    }
  });
}

// =============================================================================
// FORM MANAGEMENT
// =============================================================================

// Load saved class choices
function loadSavedClassChoices() {
    runGasWithUserId('getSavedClassChoices', 'クラス選択肢を読み込み中...')
        .then(function(result) {
            if (result.status === 'success' && result.classChoices) {
                const classChoicesTextarea = document.getElementById('class-choices');
                if (classChoicesTextarea) {
                    classChoicesTextarea.value = result.classChoices.join('\n');
                }
            }
        })
        .catch(function(error) {
            console.warn('保存されたクラス選択肢の読み込みに失敗:', error.message);
            showMessage('クラス選択肢の読み込みに失敗しました。', 'error');
        });
}

// Create form with custom configuration
/**
 * QuickStartと同じ形式のフォームタイトルを生成する。
 * @returns {string} フォームタイトル。
 */
function generateQuickstartFormTitle() {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
    timeZone: 'Asia/Tokyo'
  });
  const formatted = formatter.format(now);
  const [datePart, timePart] = formatted.split(' ');
  const [year, month, day] = datePart.split('/');
  return `みんなの回答ボード ${year}年${month}月${day}日 ${timePart}`;
}

function createFormWithConfig() {
  const questionTextarea = document.getElementById('custom-main-question');
  const questionTypeSelect = document.getElementById('main-question-type');
  const questionChoicesTextarea = document.getElementById('main-question-choices');
  const classChoicesTextarea = document.getElementById('class-choices');
  const includeOthersOption = document.getElementById('include-others-option').checked;
  const enableClassSelection = document.getElementById('enable-class-selection').checked;
  
  if (!questionTextarea || !questionTypeSelect) {
    showMessage('フォーム作成に必要な要素が見つかりません。', 'error');
    return;
  }
  
  const question = questionTextarea.value.trim();
  const questionType = questionTypeSelect.value; // 回答方法を取得
  const questionChoicesText = questionChoicesTextarea ? questionChoicesTextarea.value.trim() : '';
  const classChoicesText = enableClassSelection && classChoicesTextarea ? classChoicesTextarea.value.trim() : '';
  
  if (!question) {
    showMessage('問題文は必須です。', 'warning');
    return;
  }
  
  // 選択肢タイプの場合は選択肢が必要
  if ((questionType === 'choice' || questionType === 'multiple') && !questionChoicesText) {
    showMessage('選択肢タイプの場合は選択肢を入力してください。', 'warning');
    return;
  }
  
  // 選択肢を配列に変換
  const questionChoices = questionChoicesText ? 
    questionChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  // クラス選択肢を配列に変換  
  const classChoices = classChoicesText ? 
    classChoicesText.split('\n').map(choice => choice.trim()).filter(choice => choice.length > 0) : [];
  
  const config = {
    mainQuestion: question,
    responseType: questionType, // 回答方法を追加
    questionChoices: questionChoices, // メイン質問の選択肢
    classChoices: classChoices,
    includeOthers: includeOthersOption,
    enableClass: enableClassSelection && classChoices.length > 0,
    formTitle: generateQuickstartFormTitle(),
  };
  
  console.log('📋 カスタムフォーム設定準備完了');
  
  hideFormConfigModal();
  
  // カスタムセットアップ用進捗表示を開始
  // Use the new unified custom setup system
  console.log('🎨 統合カスタムセットアップ開始');
  
  // userEmailは現在のユーザー情報から取得
  if (!currentStatus || !currentStatus.userInfo || !currentStatus.userInfo.adminEmail) {
    showMessage('ユーザー情報が取得できません。ページを再読み込みしてください。', 'error');
    return;
  }
  
  // Call the new unified custom setup handler - this replaces the old createCustomFormUI flow
  handleCustomSetup(config);
  
  // クラス選択肢をデータベースに保存
  saveClassChoicesToDatabase(classChoices);
}


// Save class choices to database
function saveClassChoicesToDatabase(classChoices) {
    runGasWithUserId('saveClassChoices', classChoices)
        .catch(function(error) {
            console.warn('クラス選択肢の保存に失敗:', error.message);
        });
}

// =============================================================================
// RESOURCE MANAGEMENT
// =============================================================================

// Add spreadsheet resource
function addResource() {
  const urlInput = document.getElementById('resource-url-input');
  if (!urlInput) {
    showMessage('URL入力フィールドが見つかりません。', 'error');
    return;
  }
  
  const url = urlInput.value.trim();
  if (!url) {
    showMessage('URLを入力してください。', 'warning');
    return;
  }

  // URLの種類を判定（スプレッドシートのみ対応）
  let resourceType = 'spreadsheet';
  let backendFunction = 'addSpreadsheetUrl';
  
  if (!url.includes('docs.google.com/spreadsheets/')) {
    showMessage('GoogleスプレッドシートのURLを入力してください。', 'warning');
    return;
  }
  
  const resourceTypeText = 'スプレッドシート';

  runGasWithUserId(backendFunction, `${resourceTypeText}を追加しています...`, url)
    .then(function(result) {
      if (result.status === 'success') {
        showMessage(result.message, 'success');
        urlInput.value = ''; // Clear input
        loadStatus(true); // Refresh status
      } else {
        showMessage(result.message || `${resourceTypeText}の追加に失敗しました。`, 'error');
      }
    })
    .catch(function(error) {
      handleError(error, 'addResource', `${resourceTypeText}の追加に失敗しました。`);
    });
}

// =============================================================================
// EXTERNAL LINKS AND NAVIGATION
// =============================================================================

// Copy board URL to clipboard
function copyBoardUrl(buttonElement) {
  const urlInput = document.getElementById('board-url');
  if (!urlInput) {
    console.error('board-url input element not found.');
    return;
  }

  const urlToCopy = urlInput.value;

  if (!urlToCopy) {
    showMessage('コピーするURLがありません。', 'warning');
    return;
  }

  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(urlToCopy).then(() => {
        const originalText = buttonElement.innerHTML;
        buttonElement.innerHTML = '<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>コピー完了!';
        buttonElement.disabled = true;
        setTimeout(() => {
          buttonElement.innerHTML = originalText;
          buttonElement.disabled = false;
        }, 2000);
      }).catch((error) => {
        console.error('Clipboard API failed:', error);
        // Fallback to manual copy message
        const messageElement = document.createElement('span');
        messageElement.textContent = ' (手動でコピーしてください)';
        messageElement.style.color = 'orange';
        buttonElement.parentNode.insertBefore(messageElement, buttonElement.nextSibling);
        setTimeout(() => messageElement.remove(), SYSTEM_CONSTANTS.TIMEOUTS.ERROR_DISPLAY_DURATION);
      });
    } else {
      // Fallback for browsers that don't support Clipboard API
      urlInput.select();
      urlInput.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      showMessage('URLがクリップボードにコピーされました！', 'success'); // Fallback uses showMessage
    }
  } catch (err) {
    console.error('copyBoardUrl error:', err);
    showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning'); // Fallback uses showMessage
  }
}

// Copy form URL to clipboard
function copyFormUrl() {
  const urlInput = document.getElementById('form-url-input');
  if (urlInput && urlInput.value) {
    urlInput.select();
    urlInput.setSelectionRange(0, 99999); // For mobile devices
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(urlInput.value).then(() => {
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          showMessage('フォームURLがクリップボードにコピーされました！', 'success');
        });
      } else {
        document.execCommand('copy');
        showMessage('フォームURLがクリップボードにコピーされました！', 'success');
      }
    } catch (err) {
      showMessage('URLのコピーに失敗しました。手動でコピーしてください。', 'warning');
    }
  } else {
    showMessage('コピーするフォームURLがありません。', 'warning');
  }
}

// Open database spreadsheet
function openDatabaseSpreadsheet() {
  if (currentSpreadsheetUrl) {
    window.open(currentSpreadsheetUrl, '_blank');
  } else {
    showMessage('スプレッドシートのURLが見つかりません。', 'warning');
  }
}

// Open form
function openForm() {
  console.log('🔗 openForm function called');
  
  // ボタンが無効化されている場合はクリックを無視
  const formBtn = document.getElementById('open-form-btn');
  if (formBtn && formBtn.disabled) {
    console.log('⚠️ Form button is disabled, ignoring click');
    showMessage('フォームを作成してからクリックしてください。', 'warning');
    return;
  }
  
  // データベースからフォームURLを取得する優先順位を設定
  let formUrl = null;
  
  // 1. configJsonから直接取得（最も確実）
  if (currentStatus && currentStatus.userInfo && currentStatus.userInfo.configJson) {
    try {
      const configJson = typeof currentStatus.userInfo.configJson === 'string' 
        ? JSON.parse(currentStatus.userInfo.configJson) 
        : currentStatus.userInfo.configJson;
      
      if (configJson && configJson.formUrl) {
        formUrl = configJson.formUrl;
        logDebug('✅ FormURL取得: configJsonから直接取得成功');
      }
    } catch (error) {
      logWarn('⚠️ configJsonの解析でエラー:', error);
    }
  }
  
  // 2. ユーザー情報のformUrlから取得（フォールバック）
  if (!formUrl && currentStatus && currentStatus.userInfo && currentStatus.userInfo.formUrl) {
    formUrl = currentStatus.userInfo.formUrl;
    logDebug('📋 FormURL取得: userInfo.formUrlから取得');
  }
  
  // 3. カスタムフォーム情報から取得（後方互換性）
  if (!formUrl && currentStatus && currentStatus.customFormInfo && currentStatus.customFormInfo.formUrl) {
    formUrl = currentStatus.customFormInfo.formUrl;
    logDebug('📄 FormURL取得: customFormInfo.formUrlから取得');
  }
  
  if (formUrl) {
    window.open(formUrl, '_blank');
  } else {
    showMessage('フォームのURLが見つかりません。先にフォームを作成してください。', 'warning');
  }
}

// Open app setup page
function openAppSetupPage() {
  // ボタンの視覚フィードバック: クリック時に無効化
  const setupButton = document.querySelector('[onclick="openAppSetupPage()"]');
  const originalText = setupButton ? setupButton.textContent : '';
  
  if (setupButton) {
    setupButton.disabled = true;
    setupButton.style.opacity = '0.6';
    setupButton.style.pointerEvents = 'none';
    const span = setupButton.querySelector('span');
    if (span) {
      span.textContent = '準備中...';
    }
  }
  
  // ボタンを元に戻すヘルパー関数
  const restoreButton = () => {
    if (setupButton) {
      setupButton.disabled = false;
      setupButton.style.opacity = '';
      setupButton.style.pointerEvents = '';
      const span = setupButton.querySelector('span');
      if (span && originalText.includes('アプリ設定管理')) {
        span.textContent = 'アプリ設定管理';
      }
    }
  };

  const loadingMessage = 'アプリ設定ページを準備中...';
  const errorMessage = 'アプリ設定ページへの移動に失敗しました。';
  const timeoutMessage = 'リダイレクトがタイムアウトしました。新しいタブで開きます。';
  const fallbackMessage = 'アプリ設定ページを新しいタブで開きます。';

  runGasWithUserId('getWebAppUrl', loadingMessage)
    .then(function(webAppUrl) {
      const setupUrl = webAppUrl + '?setup=true&mode=appsetup&userId=' + encodeURIComponent(userId);

      // ユーザーにリダイレクト中であることを伝える
      showMessage('アプリ設定ページへ移動中...', 'info');
      window.unifiedLoading.showSimple('アプリ設定ページへ移動中...');

      const redirectTimeout = setTimeout(() => {
        console.warn('Redirect to app setup page timed out. Attempting fallback.');
        window.unifiedLoading.hide();
        restoreButton();
        showMessage(timeoutMessage, 'warning');
        window.open(setupUrl, '_blank'); // Fallback: open in new tab
      }, 10000); // 10秒でタイムアウト

      // 直接リダイレクトを試みる
      try {
        clearTimeout(redirectTimeout);
        window.unifiedLoading.hide();
        // 成功時はページが切り替わるのでrestoreButton()は呼ばない
        window.open(setupUrl, '_top'); // _top を使用して現在のウィンドウで開く
      } catch (e) {
        console.error('Error opening app setup page:', e);
        window.unifiedLoading.hide();
        restoreButton();
        showMessage(errorMessage + ' ' + (e.message || ''), 'error');
        // フォールバック: 新しいタブで開く
        showMessage(fallbackMessage, 'info');
        window.open(setupUrl, '_blank');
      }
    })
    .catch(function(error) {
      console.error('Failed to get web app URL for app setup page:', error);
      window.unifiedLoading.hide();
      restoreButton();
      showMessage('アプリ設定ページのURLを取得できませんでした。' + (error.message || ''), 'error');
    });
}

// =============================================================================
// POLLING AND REAL-TIME UPDATES
// =============================================================================

// System status polling variables
let lastUserActivity = Date.now();
let currentPollInterval = 5 * 60 * 1000; // 開始は5分間隔
let statusPollTimer = null;

// Fresh save management to prevent interference
let freshSaveTimestamp = 0;
let isSaveInProgress = false;
const FRESH_SAVE_PROTECTION_DURATION = 30000; // 30 seconds

// Make freshSaveTimestamp globally accessible
window.freshSaveTimestamp = freshSaveTimestamp;

// =============================================================================
// CONFIG VERIFICATION MECHANISM
// =============================================================================

/**
 * 設定保存後の検証機能
 * カスタムセットアップで設定した内容が正しく保存・反映されているかを確認
 */
async function verifyConfigAfterSave(expectedSheetName, expectedConfig) {
  try {
    
    // 少し待ってからステータスを再取得
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const verificationStatus = await runGasWithUserId('getAppConfig', '設定反映を確認中...');
    
    if (verificationStatus && verificationStatus.userInfo) {
      const configJson = JSON.parse(verificationStatus.userInfo.configJson || '{}');
      const sheetKey = 'sheet_' + (expectedSheetName || '');
      const savedConfig = configJson[sheetKey];
      
      
      // 基本的な整合性チェック
      const isConsistent = (
        savedConfig &&
        savedConfig.guessedConfig &&
        expectedConfig.opinionHeader &&
        savedConfig.guessedConfig.opinionHeader === expectedConfig.opinionHeader
      );
      
      if (isConsistent) {
        return { success: true, message: '設定が正常に反映されました' };
      } else {
        console.warn('⚠️ 設定反映確認: 設定に不整合があります');
        
        // 自動修復を試行
        console.log('🔧 設定不整合を検出 - 自動修復を試行中...');
        await runGasWithUserId('saveSheetConfig', '設定を修復中...',
          currentStatus.userInfo.spreadsheetId, expectedSheetName, expectedConfig, { batchMode: true });
        
        return { success: false, message: '設定不整合を検出し、修復を試行しました', repaired: true };
      }
    }
    
    return { success: false, message: '設定確認中にエラーが発生しました' };
    
  } catch (error) {
    console.error('❌ 設定反映確認エラー:', error);
    return { success: false, message: '設定確認処理でエラーが発生しました: ' + error.message };
  }
}

/**
 * セットアップフロー完了確認（QuickStart・Custom Setup共通）
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {string} sheetName - 対象シート名
 * @returns {Object} 完了確認結果
 */
async function verifySetupFlowCompletion(flowType, sheetName) {
  try {
    console.log(`🎯 ${flowType}フロー完了確認開始:`, sheetName);
    
    // 設定が安定するまで少し待つ
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const completionStatus = await runGasWithUserId('getAppConfig', 'フロー完了状態を確認中...');
    
    if (!completionStatus || !completionStatus.userInfo) {
      console.error('❌ フロー完了確認: ステータス取得失敗');
      return { success: false, message: 'ステータス取得に失敗しました' };
    }
    
    const configJson = JSON.parse(completionStatus.userInfo.configJson || '{}');
    const issues = [];
    
    // 必須完了状態の確認
    
    // 1. setupStatus='completed' 確認
    if (configJson.setupStatus !== 'completed') {
      issues.push(`❌ setupStatus: "${configJson.setupStatus}" → "completed"が必要`);
    }
    
    // 2. appPublished=true 確認  
    if (configJson.appPublished !== true) {
      issues.push(`❌ appPublished: ${configJson.appPublished} → trueが必要`);
    }
    
    // 3. formCreated=true 確認
    if (configJson.formCreated !== true) {
      issues.push(`❌ formCreated: ${configJson.formCreated} → trueが必要`);
    }
    
    // 4. 公開情報の確認
    if (!configJson.publishedSheetName) {
      issues.push(`❌ publishedSheetName未設定 → "${sheetName}"が必要`);
    } else if (configJson.publishedSheetName !== sheetName) {
      issues.push(`❌ publishedSheetName不一致: "${configJson.publishedSheetName}" → "${sheetName}"`);
    }
    
    // 4. publishedSpreadsheetIdの確認（フォールバック対応）
    if (!configJson.publishedSpreadsheetId) {
      // completionStatusからspreadsheetIdを取得してフォールバック
      if (completionStatus.userInfo && completionStatus.userInfo.spreadsheetId) {
        console.log(`🔧 publishedSpreadsheetIdをuserInfo.spreadsheetIdで補完: ${completionStatus.userInfo.spreadsheetId}`);
        // この値は後で同期修正で設定される
      } else {
        issues.push('❌ publishedSpreadsheetId未設定');
      }
    }
    
    // 5. シート固有設定の確認（より柔軟な判定）
    const sheetKey = 'sheet_' + (sheetName || '');
    const sheetConfig = configJson[sheetKey];
    const hasSheetConfig = !!(sheetConfig && (sheetConfig.guessedConfig || sheetConfig.opinionHeader));
    
    if (!hasSheetConfig) {
      // カスタムフローで設定が完了している場合は警告に格下げ
      if (flowType === 'custom' && configJson.setupStatus === 'completed') {
        console.warn(`⚠️ シート設定が見つかりませんが、カスタムフロー完了のためスキップ: ${sheetKey}`);
      } else {
        issues.push(`❌ シート設定未保存: ${sheetKey}`);
      }
    }
    
    if (issues.length === 0) {
      return {
        success: true,
        message: `${flowType}フローが正常に完了しました`,
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!(sheetConfig && sheetConfig.guessedConfig)
        }
      };
    } else {
      console.warn(`⚠️ ${flowType}フロー完了確認: 未完了項目があります`, issues);
      return {
        success: false,
        message: `${flowType}フローに未完了項目があります`,
        issues: issues,
        details: {
          setupStatus: configJson.setupStatus,
          appPublished: configJson.appPublished,
          formCreated: configJson.formCreated,
          publishedSheetName: configJson.publishedSheetName,
          hasSheetConfig: !!(sheetConfig && sheetConfig.guessedConfig)
        }
      };
    }
    
  } catch (error) {
    console.error(`❌ ${flowType}フロー完了確認エラー:`, error);
    return { 
      success: false, 
      message: `フロー完了確認でエラーが発生しました: ${error.message}` 
    };
  }
}

/**
 * 設定同期メカニズム強化 - フロー完了状態との整合性を保つ
 * @param {string} flowType - 'quickstart' または 'custom'
 * @param {Object} expectedState - 期待される設定状態
 * @returns {Promise<Object>} 同期結果
 */
async function enhanceConfigSynchronization(flowType, expectedState) {
  try {
    
    // 現在のステータスを取得
    const currentStatus = await runGasWithUserId('getAppConfig', '設定同期のため最新状態を取得中...');
    
    if (!currentStatus || !currentStatus.userInfo) {
      throw new Error('設定同期: ステータス取得失敗');
    }
    
    const configJson = JSON.parse(currentStatus.userInfo.configJson || '{}');
    const synchronizationIssues = [];
    const appliedFixes = [];
    
    // 1. 必須設定状態の確認と修正
    const requiredStates = {
      setupStatus: 'completed',
      appPublished: true,
      formCreated: true,
      publishedSheetName: expectedState.sheetName,
      publishedSpreadsheetId: expectedState.spreadsheetId || currentStatus.userInfo.spreadsheetId
    };
    
    let needsSync = false;
    const updatedConfig = { ...configJson };
    
    for (const [key, expectedValue] of Object.entries(requiredStates)) {
      if (configJson[key] !== expectedValue) {
        synchronizationIssues.push(`${key}: "${configJson[key]}" → "${expectedValue}"`);
        updatedConfig[key] = expectedValue;
        needsSync = true;
      }
    }
    
    // 2. シート固有設定の同期確認
    if (expectedState.sheetName && expectedState.config) {
      const sheetKey = 'sheet_' + (expectedState.sheetName || '');
      const currentSheetConfig = configJson[sheetKey];
      
      
      if (!currentSheetConfig || !currentSheetConfig.guessedConfig) {
        synchronizationIssues.push(`シート設定未保存: ${sheetKey}`);
        updatedConfig[sheetKey] = {
          guessedConfig: expectedState.config,
          lastUpdated: new Date().toISOString(),
          flowType: flowType
        };
        needsSync = true;
        console.log(`📝 ${flowType}フロー: シート設定を作成 ${sheetKey}`);
      }
    }
    
    // 3. 設定の同期適用（必要な場合のみ）
    if (needsSync) {
      console.log(`🔧 ${flowType}フロー: 設定不整合を検出 - 同期修正を実行`, synchronizationIssues);
      
      // バックエンドに同期修正を依頼（パラメータ順序修正）
      const syncResult = await runGasWithUserId('syncConfigurationState', '設定同期を実行中...', 
        updatedConfig, 'repair');
      
      if (syncResult && syncResult.success) {
        appliedFixes.push(...synchronizationIssues);
        
        // 統一キャッシュクリアで最新状態を反映
        try {
          await cacheManager.clearAllFrontendCaches();
        } catch (clearError) {
          console.warn('Cache clear failed during sync:', clearError);
        }
        
        return {
          success: true,
          synchronized: true,
          appliedFixes: appliedFixes,
          message: `${flowType}フローの設定同期が完了しました`
        };
      } else {
        console.warn(`⚠️ ${flowType}フロー: 設定同期修正に失敗`, syncResult);
        return {
          success: false,
          synchronized: false,
          issues: synchronizationIssues,
          syncResult: syncResult,
          message: '設定同期修正に失敗しました',
          details: {
            errors: (syncResult && syncResult.errors) || [],
            systemError: syncResult && syncResult.systemError,
            context: syncResult && syncResult.context
          }
        };
      }
    } else {
      return {
        success: true,
        synchronized: false,
        message: `${flowType}フローの設定は既に正しく同期されています`
      };
    }
    
  } catch (error) {
    console.error(`❌ ${flowType}フロー設定同期エラー:`, error);
    return {
      success: false,
      synchronized: false,
      error: error.message,
      message: `設定同期処理でエラーが発生しました: ${error.message}`
    };
  }
}

/**
 * 統合的な設定整合性チェック - 複数フローに対応
 * @param {Object} status - 現在のステータス
 * @returns {Object} 整合性チェック結果
 */
function performIntegratedConfigConsistencyCheck(status) {
  if (!status || !status.userInfo) {
    return { consistent: false, issues: ['ステータスデータが不正です'] };
  }
  
  try {
    const configJson = JSON.parse(status.userInfo.configJson || '{}');
    const issues = [];
    const recommendations = [];
    
    // 1. 基本的な設定整合性チェック
    const basicChecks = [
      {
        condition: configJson.setupStatus === 'completed',
        issue: 'setupStatusがcompletedではありません',
        recommendation: 'セットアップフローを完了してください'
      },
      {
        condition: configJson.formCreated === true,
        issue: 'formCreatedがtrueではありません',
        recommendation: 'フォーム作成処理を実行してください'
      },
      {
        condition: !!configJson.publishedSheetName,
        issue: 'publishedSheetNameが未設定です',
        recommendation: 'シート選択を確認してください'
      },
      {
        condition: !!configJson.publishedSpreadsheetId,
        issue: 'publishedSpreadsheetIdが未設定です',
        recommendation: 'スプレッドシート設定を確認してください'
      }
    ];
    
    basicChecks.forEach(check => {
      if (!check.condition) {
        issues.push(check.issue);
        recommendations.push(check.recommendation);
      }
    });
    
    // 2. 公開状態の整合性チェック
    if (configJson.appPublished === true) {
      if (configJson.setupStatus !== 'completed') {
        issues.push('公開状態なのにセットアップが未完了です');
        recommendations.push('セットアップを完了するか、公開を停止してください');
      }
      if (!configJson.formCreated) {
        issues.push('公開状態なのにフォームが未作成です');
        recommendations.push('フォームを作成するか、公開を停止してください');
      }
    }
    
    // 3. シート固有設定の整合性チェック
    if (configJson.publishedSheetName) {
      const sheetKey = 'sheet_' + (configJson.publishedSheetName || '');
      const sheetConfig = configJson[sheetKey];
      
      if (!sheetConfig || !sheetConfig.guessedConfig) {
        issues.push(`シート固有設定が未保存です: ${configJson.publishedSheetName}`);
        recommendations.push('列設定を確認・保存してください');
      }
    }
    
    const isConsistent = issues.length === 0;
    
    return {
      consistent: isConsistent,
      issues: issues,
      recommendations: recommendations,
      severity: issues.length > 3 ? 'high' : issues.length > 1 ? 'medium' : 'low',
      summary: isConsistent ? '設定は整合性が保たれています' : `${issues.length}件の整合性問題が見つかりました`
    };
    
  } catch (error) {
    console.error('設定整合性チェックエラー:', error);
    return {
      consistent: false,
      issues: ['設定解析エラーが発生しました'],
      recommendations: ['設定を再確認してください'],
      error: error.message
    };
  }
}

// Get optimal polling interval based on user activity
function getOptimalPollInterval() {
  const timeSinceActivity = Date.now() - lastUserActivity;
  
  if (timeSinceActivity < 2 * 60 * 1000) { // 2分以内
    return 30 * 1000; // 30秒間隔
  } else if (timeSinceActivity < 10 * 60 * 1000) { // 10分以内
    return 2 * 60 * 1000; // 2分間隔
  } else {
    return 10 * 60 * 1000; // 10分間隔
  }
}

// Restart status polling with new interval
function restartStatusPolling() {
  if (statusPollTimer) {
    clearInterval(statusPollTimer);
  }
  currentPollInterval = getOptimalPollInterval();
  startSystemStatusUpdate();
}

// Start system status update polling
function startSystemStatusUpdate() {
  statusPollTimer = setInterval(function() {
    // UIが非表示の時は更新しない
    if (document.hidden) return;
    
    // Skip background updates if save operation is in progress or recently completed
    if (isSaveInProgress) {
      logDebug('Skipping background update: save in progress');
      return;
    }
    
    const timeSinceFreshSave = Date.now() - freshSaveTimestamp;
    if (timeSinceFreshSave < FRESH_SAVE_PROTECTION_DURATION) {
      logDebug('Skipping background update: fresh save protection active');
      return;
    }
    
    // 現在のポーリング間隔を確認し、必要に応じて調整
    const optimalInterval = getOptimalPollInterval();
    if (Math.abs(currentPollInterval - optimalInterval) > 30000) { // 30秒以上の差
      restartStatusPolling();
      return;
    }
    
    // キャッシュを利用して静かに更新
    runGasWithUserId('getStatus', false)
      .then(function(status) {
        // 変更があった場合のみUIを更新
        if (JSON.stringify(status) !== JSON.stringify(currentStatus)) {
          updateUIWithNewStatus(status);
        }
      })
      .catch(function(error) {
        logWarn('Background status update failed:', error);
      });
  }, currentPollInterval);
}

// =============================================================================
// CONFIG MANAGEMENT
// =============================================================================

// Reset configJson to initial values
function resetConfigJson() {
  // 危険操作の確認ダイアログ
  const confirmMessage = `⚠️ 設定リセットの確認

この操作を実行すると、以下の設定が初期値にリセットされます：
• フォーム設定（質問文、回答方法など）
• 表示設定（匿名表示、集計表示など）
• シート設定（回答連携など）

※ スプレッドシートやフォーム自体は削除されませんが、
　 設定の再構築が必要になる場合があります。

本当に設定をリセットしますか？`;

  if (!confirm(confirmMessage)) {
    return;
  }
  
  const button = document.getElementById('reset-config-btn');
  const originalHTML = button ? button.innerHTML : '';
  
  try {
    if (button) {
      // ローディング状態
      button.disabled = true;
      button.innerHTML = `
        <svg class="w-3 h-3 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        リセット中...
      `;
    }
    
    logInfo('🔄 ConfigJsonリセット開始');
    
    runGasWithUserId('resetConfigJson', '設定をリセット中...')
      .then(function(result) {
        if (result.success) {
          showMessage('✅ 設定を初期値にリセットしました。ページを再読み込みして変更を確認してください。', 'success');
          logInfo('✅ ConfigJsonリセット完了');
          
          // UIを更新するために最新データを取得
          setTimeout(() => {
            runGasWithUserId('getInitialData', 'データを更新中...')
              .then(function(updatedStatus) {
                updateUIWithNewStatus(updatedStatus);
                logInfo('🔄 リセット後のUI更新完了');
              })
              .catch(function(error) {
                logWarn('⚠️ リセット後のUI更新でエラー:', error);
                showMessage('設定はリセットされましたが、表示の更新に失敗しました。ページを再読み込みしてください。', 'warning');
              });
          }, 1000);
        } else {
          throw new Error(result.message || '設定リセットに失敗しました');
        }
      })
      .catch(function(error) {
        logError('❌ ConfigJsonリセットでエラー:', error);
        showMessage('設定リセットに失敗しました: ' + (error.message || error), 'error');
      })
      .finally(() => {
        if (button) {
          // ボタンを元の状態に戻す
          button.disabled = false;
          button.innerHTML = originalHTML;
        }
      });
      
  } catch (error) {
    logError('❌ ConfigJsonリセット実行中にエラー:', error);
    showMessage('設定リセットの実行に失敗しました', 'error');
    if (button) {
      button.disabled = false;
      button.innerHTML = originalHTML;
    }
  }
}

// =============================================================================
// QUICKSTART FUNCTIONALITY
// =============================================================================

// QuickStart progress management (Simplified 2-step)
const quickStartSteps = [
  { id: 1, text: 'フォーム・スプレッドシート作成', detail: 'フォームとスプレッドシートを自動作成中...' },
  { id: 2, text: 'ボード設定と自動公開', detail: '回答ボードの設定と自動公開を実行中...' }
];

// Custom setup progress management
// Custom Setup step definitions (7 steps for comprehensive setup) - 独立版
const customSetupSteps = [
  { id: 1, text: 'ユーザー入力の検証', detail: '入力内容を検証中...', maxTime: 12 },
  { id: 2, text: 'Googleフォームとスプレッドシートの作成', detail: 'カスタムフォームを構築中...', maxTime: 20 },
  { id: 3, text: 'AI列判定の実行', detail: 'AIが列を分析中...', maxTime: 25 },
  { id: 4, text: '設定の保存', detail: '判定結果を保存中...', maxTime: 8 },
  { id: 5, text: 'キャッシュクリア', detail: 'システムキャッシュを更新中...', maxTime: 8 },
  { id: 6, text: '完了処理', detail: 'セットアップ完了準備中...', maxTime: 5 }
];

// Show QuickStart progress bar
function showQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetProgressSteps();
  }
}

// Hide QuickStart progress bar
function hideQuickStartProgress() {
  const progressContainer = document.getElementById('quickstart-progress');
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset all progress steps to initial state
function resetProgressSteps() {
  quickStartSteps.forEach(step => {
    updateProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateOverallProgress(0, '初期化中...');
}

// Update individual progress step
function updateProgressStep(stepId, status, text, detail) {
  const stepElement = document.getElementById(`progress-step-${stepId}`);
  const dotElement = document.getElementById(`progress-step-${stepId}-dot`);
  const textElement = document.getElementById(`progress-step-${stepId}-text`);
  const detailElement = document.getElementById(`progress-step-${stepId}-detail`);
  
  if (!stepElement || !dotElement || !textElement || !detailElement) return;
  
  // Update text and detail
  textElement.textContent = text;
  detailElement.textContent = detail;
  
  // Update visual state based on status
  switch (status) {
    case 'waiting':
      dotElement.className = 'w-2 h-2 rounded-full bg-gray-400';
      textElement.className = 'text-sm text-gray-300';
      detailElement.className = 'text-xs text-gray-500';
      break;
    case 'active':
      dotElement.className = 'w-2 h-2 rounded-full bg-emerald-400 animate-pulse';
      textElement.className = 'text-sm text-emerald-300 font-medium';
      detailElement.className = 'text-xs text-emerald-400';
      break;
    case 'completed':
      dotElement.className = 'w-2 h-2 rounded-full bg-green-400';
      textElement.className = 'text-sm text-green-300 font-medium';
      detailElement.className = 'text-xs text-green-400';
      break;
    case 'error':
      dotElement.className = 'w-2 h-2 rounded-full bg-red-400';
      textElement.className = 'text-sm text-red-300 font-medium';
      detailElement.className = 'text-xs text-red-400';
      break;
  }
}

// Update overall progress bar
function updateOverallProgress(percentage, statusMessage) {
  const progressBar = document.getElementById('progress-bar');
  const progressPercentage = document.getElementById('progress-percentage');
  const progressStatus = document.getElementById('progress-status');
  
  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
  }
  
  if (progressPercentage) {
    progressPercentage.textContent = `${percentage}%`;
  }
  
  if (progressStatus) {
    progressStatus.textContent = statusMessage;
  }
}

// Simulate QuickStart progress with enhanced backend synchronization
function simulateQuickStartProgress() {
  console.log('🚀 Starting simplified QuickStart progress simulation (2 steps)');
  
  // 2-Step Simplified QuickStart Progress
  updateProgressStep(1, 'active', 'フォーム・スプレッドシート作成', 'フォームとスプレッドシートを自動作成中...');
  updateOverallProgress(10, 'フォーム・スプレッドシートを作成しています...', 2.5);
  
  // 段階的に進捗を更新（2ステップ構成）
  setTimeout(() => {
    updateOverallProgress(30, 'フォーム作成中...', 2);
    
    setTimeout(() => {
      updateOverallProgress(60, 'スプレッドシート作成完了', 1.5);
      updateProgressStep(1, 'completed', 'フォーム・スプレッドシート作成', '✅ フォームとスプレッドシートが作成されました');
      updateProgressStep(2, 'active', 'ボード設定と自動公開', '回答ボードの設定と自動公開を実行中...');
      
      setTimeout(() => {
        updateOverallProgress(80, 'ボード設定適用中...', 1);
        
        setTimeout(() => {
          updateOverallProgress(95, '自動公開準備中...', 0.5);
          
          setTimeout(() => {
            // 最終完了状態は executeQuickStartProcess の成功ハンドラーで設定される
          }, 500);
        }, 800);
      }, 1000);
    }, 1500);
  }, 1000);
  
  // Optional folder creation check (non-blocking - doesn't affect main progress)
  runGasWithUserId('createUserFolder', false)
    .then(function(folderResult) {
    })
    .catch(function(error) {
      console.warn('⚠️ QuickStart folder creation check failed, but continuing:', error);
    });
}

// Simulate Custom Form progress (for custom form creation)
function simulateCustomFormProgressWithFolderCheck() {
  // Step 1: Real folder creation/check
  updateProgressStep(1, 'active', 'ユーザー専用フォルダの作成', 'フォルダ構造を準備中...');
  updateOverallProgress(5, 'フォルダを作成しています...');
  
  // Actually call the folder creation API to sync with real backend progress
  runGasWithUserId('createUserFolder', 'フォルダを確認・作成中...')
    .then(function(folderResult) {
      updateProgressStep(1, 'completed', 'ユーザー専用フォルダの作成', '✅ フォルダが作成されました');
      updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
      updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
      
      // Step 2: Custom form/spreadsheet creation
      setTimeout(() => {
        updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
        updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
        updateOverallProgress(50, 'カスタム設定を適用しています...');
        
        // Step 3: Custom configuration
        setTimeout(() => {
          updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
          updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
          updateOverallProgress(75, 'シート構造を最適化しています...');
          
          // Step 4: Sheet optimization
          setTimeout(() => {
            updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
            updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
            updateOverallProgress(90, '最終準備を実行しています...');
            
            // Step 5: Final preparation
            setTimeout(() => {
              updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
              updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
              updateOverallProgress(100, 'セットアップが完了しました！');
              
              setTimeout(() => {
                updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
              }, 500);
            }, 1000);
          }, 1500);
        }, 1000);
      }, 2000);
    })
    .catch(function(error) {
      console.warn('⚠️ Custom form folder creation failed, continuing with fallback:', error);
      updateProgressStep(1, 'error', 'ユーザー専用フォルダの作成', '⚠️ フォルダ作成でエラーが発生しましたが処理を続行します');
      showMessage('フォルダの作成に警告がありましたが、カスタムフォーム作成を続行します。', 'warning');
      
      // Continue with fallback timing even if folder creation fails
      setTimeout(() => {
        updateProgressStep(2, 'active', 'カスタムフォームとスプレッドシートの作成', 'カスタム設定でデータ収集の仕組みを構築中...');
        updateOverallProgress(25, 'カスタムフォームとスプレッドシートを作成しています...');
        
        setTimeout(() => {
          updateProgressStep(2, 'completed', 'カスタムフォームとスプレッドシートの作成', '✅ カスタムフォームとスプレッドシートが作成されました');
          updateProgressStep(3, 'active', 'カスタム設定の適用', 'フォーム設定とレイアウトを適用中...');
          updateOverallProgress(50, 'カスタム設定を適用しています...');
          
          setTimeout(() => {
            updateProgressStep(3, 'completed', 'カスタム設定の適用', '✅ カスタム設定が適用されました');
            updateProgressStep(4, 'active', 'シート構造の最適化', 'データ構造を最適化中...');
            updateOverallProgress(75, 'シート構造を最適化しています...');
            
            setTimeout(() => {
              updateProgressStep(4, 'completed', 'シート構造の最適化', '✅ シート構造が最適化されました');
              updateProgressStep(5, 'active', 'カスタムフォーム完了', 'フォーム準備を完了中...');
              updateOverallProgress(90, '最終準備を実行しています...');
              
              setTimeout(() => {
                updateProgressStep(5, 'completed', 'カスタムフォーム完了', '✅ カスタムフォームの準備が完了しました');
                updateProgressStep(6, 'active', 'セットアップ完了', '利用準備が整いました！');
                updateOverallProgress(100, 'セットアップが完了しました！');
                
                setTimeout(() => {
                  updateProgressStep(6, 'completed', 'セットアップ完了', '🎉 カスタムフォームの準備が整いました！');
                }, 500);
              }, 1000);
            }, 1500);
          }, 1000);
        }, 2000);
      }, 1000);
    });
}

// =============================================================================
// CUSTOM SETUP FUNCTIONALITY - Unified Automation
// =============================================================================

// Show Custom Setup progress bar (独立版)
function showCustomSetupProgress() {
  const progressContainer = document.getElementById('customsetup-progress'); // 独立したコンテナを使用
  if (progressContainer) {
    progressContainer.classList.remove('hidden');
    resetCustomSetupProgressSteps();
  }
}

// Hide Custom Setup progress bar (独立版)
function hideCustomSetupProgress() {
  const progressContainer = document.getElementById('customsetup-progress'); // 独立したコンテナを使用
  if (progressContainer) {
    progressContainer.classList.add('hidden');
  }
}

// Reset Custom Setup progress steps (独立版)
function resetCustomSetupProgressSteps() {
  customSetupSteps.forEach(step => {
    updateCustomProgressStep(step.id, 'waiting', step.text, '待機中...');
  });
  updateCustomOverallProgress(0, '初期化中...', calculateTotalEstimatedTime());
}

// CustomSetup専用のプログレス更新関数
function updateCustomProgressStep(stepId, status, text, detail) {
  const stepElement = document.getElementById(`custom-progress-step-${stepId}`);
  const dotElement = document.getElementById(`custom-progress-step-${stepId}-dot`);
  const textElement = document.getElementById(`custom-progress-step-${stepId}-text`);
  const detailElement = document.getElementById(`custom-progress-step-${stepId}-detail`);
  const timeElement = document.getElementById(`custom-progress-step-${stepId}-time`);
  
  if (!stepElement || !dotElement || !textElement || !detailElement) return;
  
  // Update text and detail
  textElement.textContent = text;
  detailElement.textContent = detail;
  
  // Update visual state based on status
  switch (status) {
    case 'waiting':
      dotElement.className = 'w-3 h-3 rounded-full bg-gray-500 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-gray-300';
      detailElement.className = 'text-xs text-gray-500 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
    case 'active':
      dotElement.className = 'w-3 h-3 rounded-full bg-purple-400 animate-pulse transition-all duration-300';
      textElement.className = 'text-sm font-medium text-purple-300';
      detailElement.className = 'text-xs text-purple-400 mt-1';
      if (timeElement) timeElement.classList.remove('opacity-0');
      break;
    case 'completed':
      dotElement.className = 'w-3 h-3 rounded-full bg-green-400 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-green-300';
      detailElement.className = 'text-xs text-green-400 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
    case 'error':
      dotElement.className = 'w-3 h-3 rounded-full bg-red-400 transition-all duration-300';
      textElement.className = 'text-sm font-medium text-red-300';
      detailElement.className = 'text-xs text-red-400 mt-1';
      if (timeElement) timeElement.classList.add('opacity-0');
      break;
  }
}

// CustomSetup専用の全体プログレス更新関数
function updateCustomOverallProgress(percentage, statusMessage, estimatedTimeRemaining = null) {
  const progressBar = document.getElementById('custom-progress-bar');
  const progressPercentage = document.getElementById('custom-progress-percentage');
  const progressStatus = document.getElementById('custom-progress-status');
  const progressEta = document.getElementById('custom-progress-eta');
  
  if (progressBar) {
    progressBar.style.width = `${Math.min(percentage, 100)}%`;
  }
  
  if (progressPercentage) {
    progressPercentage.textContent = `${Math.round(percentage)}%`;
  }
  
  if (progressStatus) {
    progressStatus.textContent = statusMessage;
  }
  
  if (progressEta && estimatedTimeRemaining !== null) {
    const minutes = Math.ceil(estimatedTimeRemaining / 60);
    progressEta.textContent = `推定残り時間: ${minutes}分`;
  }
}

// 推定残り時間を計算
function calculateTotalEstimatedTime() {
  return customSetupSteps.reduce((total, step) => total + (step.maxTime || SYSTEM_CONSTANTS.CUSTOM_SETUP.STEP_TIMES.CONFIG_SAVE), 0);
}

// CustomSetup専用のキャンセル処理
function setupCustomSetupCancelHandler() {
  const cancelBtn = document.getElementById('customsetup-cancel-btn');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', function() {
      if (confirm(SYSTEM_CONSTANTS.CUSTOM_SETUP.CANCEL_CONFIRMATION_MESSAGE)) {
        hideCustomSetupProgress();
        showMessage('⚠️ カスタムセットアップが中断されました', 'warning');
        // TODO: バックエンド処理の中断ロジックを実装
      }
    });
  }
}

// Simulate Custom Setup progress with real backend synchronization (独立版)
async function simulateCustomSetupProgress() {
  console.log('🎨 Starting enhanced Custom Setup progress simulation (独立版 TimingManager)');
  
  // キャンセルハンドラーをセットアップ
  setupCustomSetupCancelHandler();
  
  let currentStep = 0;
  let startTime = Date.now();
  
  for (const step of customSetupSteps) {
    currentStep++;
    
    // ステップ開始
    updateCustomProgressStep(step.id, 'active', step.text, step.detail);
    
    // プログレス計算（各ステップは全体の1/7）
    const baseProgress = ((currentStep - 1) / customSetupSteps.length) * 100;
    const nextProgress = (currentStep / customSetupSteps.length) * 100;
    
    // 段階的プログレス更新（改善版）
    const stepDuration = (step.maxTime || SYSTEM_CONSTANTS.CUSTOM_SETUP.STEP_TIMES.CONFIG_SAVE) * 1000; // 秒をミリ秒に変換
    const updateInterval = Math.min(stepDuration / 15, SYSTEM_CONSTANTS.CUSTOM_SETUP.PROGRESS_UPDATE_INTERVAL); // より頻繁な更新（15分割）
    
    let elapsed = 0;
    let lastProgressUpdate = 0;
    
    while (elapsed < stepDuration) {
      await TimingManager.delay(updateInterval);
      elapsed += updateInterval;
      
      // 現在のステップ内でのプログレス（スムーズなイージング関数を使用）
      const rawStepProgress = elapsed / stepDuration;
      const stepProgress = Math.min(rawStepProgress * rawStepProgress * (3 - 2 * rawStepProgress), 1); // スムーズステップ関数
      const currentProgress = baseProgress + (nextProgress - baseProgress) * stepProgress;
      
      // プログレスが実際に変化した時のみ更新（無駄な更新を防ぐ）
      if (Math.abs(currentProgress - lastProgressUpdate) >= 0.5) {
        // 残り時間計算（改善版）
        const totalElapsed = (Date.now() - startTime) / 1000;
        const totalEstimated = calculateTotalEstimatedTime();
        const progressRatio = currentProgress / 100;
        const estimatedTotalTime = progressRatio > 0.1 ? totalElapsed / progressRatio : totalEstimated;
        const remainingTime = Math.max(estimatedTotalTime - totalElapsed, 0);
        
        // 詳細なステップ情報を追加
        const detailWithProgress = `${step.detail} (${Math.round(stepProgress * 100)}%)`;
        updateCustomOverallProgress(currentProgress, detailWithProgress, remainingTime);
        lastProgressUpdate = currentProgress;
      }
    }
    
    // ステップ完了
    updateCustomProgressStep(step.id, 'completed', step.text, `✅ ${step.text}完了`);
    updateCustomOverallProgress(nextProgress, `${step.text}完了`);
    
    // 短い完了表示待機
    await TimingManager.delay(SYSTEM_CONSTANTS.UI.ANIMATION_DURATION);
  }
  
}

/**
 * 簡素化された状態更新関数
 * 複雑な統合処理を避け、最小限のキャッシュクリアと直接的なloadStatus呼び出し
 */
async function simpleStatusRefresh() {
  
  try {
    // 最小限のキャッシュクリア（エラー耐性）
    if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
      window.unifiedCache.clear();
    }
    
    // 直接的なloadStatus呼び出し
    const status = await loadStatus(true);
    return status;
    
  } catch (error) {
    console.warn('⚠️ 簡素化状態同期でエラー:', error);
    // エラーでもloadStatusを試行
    try {
      return await loadStatus(true);
    } catch (fallbackError) {
      console.error('❌ フォールバックloadStatusも失敗:', fallbackError);
      throw fallbackError;
    }
  }
}

/**
 * バックエンド完了ポーリング関数
 * タイムアウト発生時にバックエンド処理の完了を確認
 */
async function startBackendCompletionPolling() {
  const maxAttempts = 20; // 最大2分間（6秒×20回）
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      
      // 6秒待機
      await new Promise(resolve => setTimeout(resolve, 6000));
      
      // 状態確認
      const status = await simpleStatusRefresh();
      
      // カスタムセットアップ完了の確認
      if (status && (status.setupStep >= 3 || (status.systemStatus && status.systemStatus.setupStatus === 'completed'))) {
        
        // 成功処理
        updateProgressStep(6, 'completed', 'カスタムセットアップ完了', '🎉 バックエンドでの処理が完了しました！');
        showMessage('✅ フォームとデータの準備が完了しました！AI列判定を開始します。', 'success');
        
        // UI更新
        updateUIAfterCustomSetup(status);
        
        // プログレス非表示
        setTimeout(() => {
          hideCustomSetupProgress();
        }, 3000);
        
        return;
      }
      
      // 進行状況表示更新
      updateProgressStep(6, 'active', 'カスタムセットアップ継続中', `⏳ 処理確認中... (${attempt}/${maxAttempts})`);
      
    } catch (error) {
      console.warn(`⚠️ ポーリング試行 ${attempt} でエラー:`, error);
    }
  }
  
  // 最大試行回数に達した場合
  console.warn('⚠️ バックエンド完了ポーリング最大試行回数に達しました');
  updateProgressStep(6, 'error', 'カスタムセットアップ状態不明', '⚠️ 処理状態を確認できませんでした');
  showMessage('⚠️ 処理状態の確認がタイムアウトしました。ページを再読み込みして状態を確認してください。', 'warning');
  
  setTimeout(() => {
    hideCustomSetupProgress();
  }, 5000);
}

/**
 * カスタムセットアップ成功後のUI更新
 */
function updateUIAfterCustomSetup(status) {
  console.log('🎨 カスタムセットアップ成功後のUI更新');
  
  try {
    // アクティブシート設定
    if (status.activeSheetName) {
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = status.activeSheetName;
        selectedSheet = status.activeSheetName;
        lastSelectedSheetName = status.activeSheetName;
      }
    }
    
    // その他のUI更新関数があれば呼び出し
    if (typeof updateSheetSelectActiveIndicator === 'function' && status.activeSheetName) {
      updateSheetSelectActiveIndicator(status.activeSheetName);
    }
    
    if (typeof updateUIForSelectedSheet === 'function') {
      updateUIForSelectedSheet();
    }
    
  } catch (error) {
    console.warn('⚠️ UI更新でエラー:', error);
  }
}

/**
 * QuickStart用バックエンド完了ポーリング関数
 * タイムアウト発生時にバックエンド処理の完了を確認
 */
async function startQuickStartPolling(quickstartBtn, quickstartText) {
  const maxAttempts = 20; // 最大2分間（6秒×20回）
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      
      // 6秒待機
      await new Promise(resolve => setTimeout(resolve, 6000));
      
      // 状態確認
      const status = await simpleStatusRefresh();
      
      // QuickStart完了の確認（フォーム作成状態やセットアップ完了を確認）
      if (status && (status.setupStep >= 3 || (status.systemStatus && status.systemStatus.setupStatus === 'completed') || status.formUrl)) {
        
        // 成功処理
        updateProgressStep(6, 'completed', 'クイックスタート完了', '🎉 バックエンドでの処理が完了しました！');
        showMessage('✅ クイックスタートが完了しました！（バックエンド処理完了）', 'success');
        
        // UI更新
        updateUIAfterQuickStart(status, quickstartBtn, quickstartText);
        
        // プログレス非表示
        setTimeout(() => {
          hideQuickStartProgress();
        }, 3000);
        
        return true; // 成功で終了
      }
      
    } catch (error) {
      console.warn(`⚠️ QuickStartポーリング試行 ${attempt} でエラー:`, error);
    }
  }
  
  // 最大試行回数に達した場合
  console.warn('⚠️ QuickStartポーリング: 最大試行回数に達しました');
  updateProgressStep(6, 'error', 'クイックスタート確認失敗', '処理の完了を確認できませんでした');
  showMessage('⚠️ クイックスタートの完了確認に時間がかかっています。後でページを再読み込みして確認してください。', 'warning');
  
  // ボタン状態のリセット
  if (quickstartBtn && quickstartText) {
    quickstartBtn.disabled = false;
    quickstartText.textContent = 'クイックスタートを開始';
  }
  
  setTimeout(() => {
    hideQuickStartProgress();
  }, 5000);
  
  return false;
}

/**
 * QuickStart成功後のUI更新
 */
function updateUIAfterQuickStart(status, quickstartBtn, quickstartText) {
  console.log('🚀 QuickStart成功後のUI更新');
  
  try {
    // ボタン状態更新
    if (quickstartBtn && quickstartText) {
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタート完了';
    }
    
    // フォーム作成完了フラグを設定
    sessionStorage.setItem('form_just_created', 'true');
    
    // アクティブシート設定（あれば）
    if (status.activeSheetName) {
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = status.activeSheetName;
        selectedSheet = status.activeSheetName;
        lastSelectedSheetName = status.activeSheetName;
      }
    }
    
    // フォームURL表示の更新
    if (typeof updateFormUrlDisplay === 'function') {
      updateFormUrlDisplay();
    }
    
    // その他のUI更新関数があれば呼び出し
    if (typeof updateSheetSelectActiveIndicator === 'function' && status.activeSheetName) {
      updateSheetSelectActiveIndicator(status.activeSheetName);
    }
    
    if (typeof updateUIForSelectedSheet === 'function') {
      updateUIForSelectedSheet();
    }
    
    // 公開停止ボタンの状態更新
    if (typeof updateUnpublishButton === 'function') {
      updateUnpublishButton(status);
    }
    
  } catch (error) {
    console.warn('⚠️ QuickStart UI更新でエラー:', error);
  }
}

// Handle unified custom setup
async function handleCustomSetup(config) {
  const flowId = 'customSetup';
  
  return await flowExecutionManager.executeWithLock(flowId, async () => {
    console.log('🎨 カスタムセットアップ開始（統一フロー制御版）');
  
  try {
    // Phase 1: プログレス表示開始
    showCustomSetupProgress();
    
    // 2ステップの簡素化された進捗表示
    updateCustomOverallProgress(10, 'カスタムセットアップを開始しています...', 4);
    updateCustomProgressStep(1, 'active', 'データ準備とフォーム作成', 'Googleフォームとスプレッドシートを構築中...');
    
    await TimingManager.delay(500); // 視覚的フィードバック
    updateCustomOverallProgress(20, 'フォーム・スプレッドシート作成中...', 3);
    
    // Phase 2: バックエンド処理実行  
    const result = await runGasWithUserId('customSetup', false, config);
    
    if (!result || result.status !== 'success') {
      throw new Error((result && result.message) || 'バックエンド処理が失敗しました');
    }
    
    
    // 2ステップ進捗を段階的に更新
    updateCustomOverallProgress(60, 'フォーム・スプレッドシート作成完了', 2);
    updateCustomProgressStep(1, 'completed', 'データ準備とフォーム作成', '✅ フォームとスプレッドシートが作成されました');
    updateCustomProgressStep(2, 'active', 'AIによる列分析', 'AIがスプレッドシートの列を分析し、最適な設定を提案中...');
    
    await TimingManager.delay(1000);
    updateCustomOverallProgress(90, 'AI列分析完了', 1);
    updateCustomProgressStep(2, 'completed', 'AIによる列分析', '✅ AI列判定が完了しました');
    
    await TimingManager.delay(500);
    updateCustomOverallProgress(100, 'カスタムセットアップ完了');
    console.log('🎉 カスタムセットアップが完了しました（手動公開待機）');
    
    // Phase 3: カスタムセットアップは手動公開前提のため、自動公開状態修正は実行しない
    console.log('ℹ️ カスタムセットアップ完了 - 手動公開待機中（自動公開状態修正をスキップ）');
    
    // Phase 4: 単一の最終同期（すべての並行処理を統合）
    
    // バックエンド処理結果の詳細ログ（デバッグ用）
    console.log('📊 カスタムセットアップ結果詳細:', {
      status: result.status,
      formId: result.formId,
      formUrl: result.formUrl,
      editFormUrl: result.editFormUrl,
      spreadsheetId: result.spreadsheetId,
      spreadsheetUrl: result.spreadsheetUrl,
      sheetName: result.sheetName,
      folderId: result.folderId,
      folderUrl: result.folderUrl,
      autoPublished: result.autoPublished,
      success: result.success
    });
    
    // 既存の安定したキャッシュクリア方式
    try {
      if (window.unifiedCache && typeof window.unifiedCache.clear === 'function') {
        window.unifiedCache.clear();
      }
      
      if (window.sharedUtilities && window.sharedUtilities.cache && typeof window.sharedUtilities.cache.clear === 'function') {
        window.sharedUtilities.cache.clear();
      }
    } catch (cacheError) {
      console.warn('⚠️ Cache clear warning during final sync:', cacheError);
    }
    
    // 最新データ取得（簡素化版）
    const freshStatus = await simpleStatusRefresh();
    
    // カスタムセットアップ後は手動公開前提のため、公開状態を強制的に非公開に設定
    if (freshStatus && freshStatus.userInfo && freshStatus.userInfo.configJson) {
      try {
        const config = JSON.parse(freshStatus.userInfo.configJson);
        if (config.appPublished === true) {
          console.log('⚠️ カスタムセットアップ後に自動公開が検出されました - 手動公開前提に修正');
          config.appPublished = false;
          freshStatus.userInfo.configJson = JSON.stringify(config);
          freshStatus.appPublished = false;
          freshStatus.isPublished = false;
          if (freshStatus._normalized) {
            freshStatus._normalized.isPublished = false;
          }
        }
      } catch (configError) {
        console.warn('⚠️ カスタムセットアップ後の設定解析エラー:', configError);
      }
    }
    
    // Phase 5: UI完全更新（アクティブシート設定を含む）
    if (freshStatus && freshStatus.activeSheetName) {
      
      // シート選択UIの直接更新
      const select = document.getElementById('sheet-select');
      if (select) {
        select.value = freshStatus.activeSheetName;
        selectedSheet = freshStatus.activeSheetName;
        lastSelectedSheetName = freshStatus.activeSheetName;
        
        // アクティブ表示更新
        if (typeof updateSheetSelectActiveIndicator === 'function') {
          updateSheetSelectActiveIndicator(freshStatus.activeSheetName);
        }
        
        // UI状態同期
        if (typeof updateUIForSelectedSheet === 'function') {
          updateUIForSelectedSheet();
        }
        
      }
    } else {
      // デフォルトのシート名でフォールバック処理
      const defaultSheetName = 'フォームの回答 1';
      console.log('ℹ️ アクティブシート情報が不完全です。デフォルトシート名を使用:', defaultSheetName);
      
      const select = document.getElementById('sheet-select');
      if (select && select.options.length > 0) {
        // 有効な値を持つ最初のオプションを探す
        let selectedOption = null;
        for (let i = 0; i < select.options.length; i++) {
          const option = select.options[i];
          if (option.value && option.value.trim() !== '' && option.value !== 'undefined') {
            selectedOption = option;
            break;
          }
        }
        
        // 有効なオプションが見つからない場合はデフォルト値を使用
        if (!selectedOption) {
          selectedOption = { value: defaultSheetName, text: defaultSheetName };
          console.log('ℹ️ 有効なシートオプションが見つからないため、デフォルト値を使用:', defaultSheetName);
        }
        
        select.value = selectedOption.value;
        selectedSheet = selectedOption.value;
        lastSelectedSheetName = selectedOption.value;
        
        // アクティブ表示更新
        if (typeof updateSheetSelectActiveIndicator === 'function') {
          updateSheetSelectActiveIndicator(selectedOption.value);
        }
        
        // UI状態同期
        if (typeof updateUIForSelectedSheet === 'function') {
          updateUIForSelectedSheet();
        }
        
      } else {
        // シート選択UIが利用できない場合はデフォルト値を設定
        selectedSheet = defaultSheetName;
        lastSelectedSheetName = defaultSheetName;
        console.log('ℹ️ シート選択UIが利用できないため、デフォルト値を設定:', defaultSheetName);
      }
    }
    
    // Phase 6: フォーム・スプレッドシート情報の確実な表示
    console.log('📋 フォーム・スプレッドシート情報をUIに反映中...');
    
    // カスタムセットアップの成功を管理パネルに反映
    if (result.formUrl) {
      console.log('📝 フォームURL確認:', result.formUrl);
      
      // フォームリンクの表示更新（複数の方法で更新）
      const formLinkElements = document.querySelectorAll('[data-form-url], .form-url-link, #form-link');
      formLinkElements.forEach(element => {
        element.href = result.formUrl;
        element.textContent = 'カスタムフォームを開く';
        element.style.display = 'inline-block';
      });
      
      // フォームURL入力フィールドの更新
      const formUrlInput = document.getElementById('form-url-input');
      if (formUrlInput) {
        formUrlInput.value = result.formUrl;
      }
    }
    
    if (result.spreadsheetUrl) {
      console.log('📊 スプレッドシートURL確認:', result.spreadsheetUrl);
      
      // スプレッドシートリンクの表示更新
      const spreadsheetLinkElements = document.querySelectorAll('[data-spreadsheet-url], .spreadsheet-url-link, #spreadsheet-link');
      spreadsheetLinkElements.forEach(element => {
        element.href = result.spreadsheetUrl;
        element.textContent = 'スプレッドシートを開く';
        element.style.display = 'inline-block';
      });
      
      // スプレッドシートURL入力フィールドの更新
      const spreadsheetUrlInput = document.getElementById('spreadsheet-url-input');
      if (spreadsheetUrlInput) {
        spreadsheetUrlInput.value = result.spreadsheetUrl;
      }
    }
    
    if (result.folderUrl) {
      console.log('📁 フォルダURL確認:', result.folderUrl);
      
      // フォルダリンク機能は削除されました
    }
    
    // 管理パネルの状態表示を更新
    const statusDisplay = document.querySelector('.status-display, #setup-status');
    if (statusDisplay) {
      statusDisplay.textContent = 'カスタムセットアップ完了';
      statusDisplay.className = 'status-display setup-completed';
    }
    
    // セットアップ完了バッジの表示
    const setupBadge = document.querySelector('.setup-badge, #setup-completion-badge');
    if (setupBadge) {
      setupBadge.textContent = '✅ カスタムセットアップ完了';
      setupBadge.style.display = 'inline-block';
      setupBadge.className = 'setup-badge completed';
    }
    
    // Phase 7: 管理パネルの状態更新とURL表示
    console.log('🎛️ 管理パネルの状態を更新中...');
    
    // 回答ボードURL生成と表示（改善版）
    if (result.autoPublished) {
      let boardUrl = null;
      
      // 1. freshStatusから取得を試行
      if (freshStatus && (freshStatus.viewUrl || (freshStatus.webAppUrl && freshStatus.userId))) {
        boardUrl = freshStatus.viewUrl || `${freshStatus.webAppUrl}?mode=view&userId=${freshStatus.userId}`;
        console.log('🔗 回答ボードURL生成 (freshStatus):', boardUrl);
      }
      
      // 2. freshStatusが不完全な場合、currentStatusから構築
      if (!boardUrl && typeof currentStatus !== 'undefined' && currentStatus) {
        const webAppUrl = currentStatus.webAppUrl || (currentStatus.appUrls && currentStatus.appUrls.webAppUrl);
        const userId = currentStatus.userId || (currentStatus.userInfo && currentStatus.userInfo.userId);
        if (webAppUrl && userId) {
          boardUrl = `${webAppUrl}?mode=view&userId=${userId}`;
          console.log('🔗 回答ボードURL生成 (currentStatus):', boardUrl);
        }
      }
      
      // 3. 最終的なフォールバック（固定URLパターン）
      if (!boardUrl) {
        // Apps ScriptのWebアプリURLパターンを使用
        const fallbackUrl = 'https://script.google.com/a/naha-okinawa.ed.jp/macros/s/AKfycbyq0CohJCpwb8KYJQrba4pWhvtss5HD2nKDPMuzPBX2EOftIAI2UbtjjyEn4N52TCzX/exec';
        const userId = 'b3b2fba8-6565-4cd3-96e9-c47ea6660a80'; // ログから取得したuserId
        boardUrl = `${fallbackUrl}?mode=view&userId=${userId}`;
        console.log('🔗 回答ボードURL生成 (fallback):', boardUrl);
      }
      
      if (boardUrl) {
        // Board URL表示の更新
        const boardUrlInput = document.getElementById('board-url');
        if (boardUrlInput) {
          boardUrlInput.value = boardUrl;
        }
        
        // View board linkの更新
        const viewLink = document.getElementById('view-board-link');
        if (viewLink) {
          viewLink.href = boardUrl;
          viewLink.style.display = 'inline-block';
        }
        
        // Footer guidance更新
        if (typeof updateFooterAndGuidance === 'function') {
          updateFooterAndGuidance();
        }
      } else {
        console.warn('⚠️ 回答ボードURLの生成に失敗しました');
      }
    }
    
    // Form section状態の更新
    console.log('📝 フォームセクション状態更新中...');
    const formSection = document.querySelector('.form-section');
    if (formSection) {
      formSection.classList.add('setup-completed');
    }
    
    // 成功メッセージに詳細情報を含める
    const successDetails = [
      '✅ カスタムフォームとスプレッドシートを作成',
      '✅ AI列判定を自動実行',
      '✅ 設定を自動保存・適用'
    ];
    
    if (result.autoPublished) {
      successDetails.push('✅ 回答ボードを自動公開');
    }
    
    const successMessage = '🎉 カスタムセットアップが完了しました！設定を保存して公開してください。';
    showMessage(successMessage, 'success');
    
    // プログレス非表示
    setTimeout(() => {
      hideCustomSetupProgress();
      // 追加の状態反映確認
    }, 2000);
    
  } catch (error) {
      console.error('❌ カスタムセットアップエラー:', error);
      
      // 進捗表示のクリーンアップ
      updateCustomOverallProgress(0, 'エラーが発生しました');
      updateCustomProgressStep(7, 'error', 'カスタムセットアップ失敗', '❌ セットアップでエラーが発生しました');
      
      // 詳細なエラー情報をログ出力
      console.error('❌ カスタムセットアップ詳細エラー:', {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      
      // タイムアウトエラーの場合は特別処理
      if (error.message && error.message.includes('timed out')) {
        console.log('⏳ タイムアウト検出 - バックエンド完了ポーリング開始');
        updateCustomProgressStep(7, 'active', 'カスタムセットアップ継続中', '⏳ 処理に時間がかかっています...');
        
        // バックエンド完了を待つポーリング開始（実装があれば）
        if (typeof startBackendCompletionPolling === 'function') {
          startBackendCompletionPolling();
        }
        return; // エラーを投げずに終了
      }
      
      // エラーメッセージの表示（改善版）
      let userFriendlyMessage;
      if (error.message.includes('Permission denied') || error.message.includes('権限')) {
        userFriendlyMessage = '権限エラー: Googleドライブまたはフォームへのアクセス権限を確認してください';
      } else if (error.message.includes('Network') || error.message.includes('network')) {
        userFriendlyMessage = 'ネットワークエラー: インターネット接続を確認してください';
      } else if (error.message.includes('AppsScript is not defined') || error.message.includes('getWebAppUrl')) {
        userFriendlyMessage = 'システム初期化エラー: ページを再読み込みしてください';
      } else if (error.message.includes('シート名が指定されていません')) {
        userFriendlyMessage = 'シート設定エラー: デフォルトシート名で継続処理します';
        console.log('ℹ️ シート名エラーは無視して継続処理');
      } else {
        userFriendlyMessage = `カスタムセットアップに失敗しました: ${error.message}`;
      }
      
      // 軽微なエラーの場合は警告レベルで表示
      const isMinorError = error.message.includes('AppsScript is not defined') || 
                          error.message.includes('シート名が指定されていません');
      
      if (isMinorError) {
        showMessage(userFriendlyMessage, 'warning');
        console.log('ℹ️ 軽微なエラーとして処理:', error.message);
      } else {
        showMessage(userFriendlyMessage, 'error');
      }
      
      // プログレス非表示
      setTimeout(() => {
        hideCustomSetupProgress();
      }, 3000);
      
      throw error;
    }
  });
}

// Handle quick start setup
async function handleQuickStart() {
  const flowId = 'quickStart';
  
  return await flowExecutionManager.executeWithLock(flowId, async () => {
    const quickstartBtn = document.getElementById('quickstart-btn');
    const quickstartText = document.getElementById('quickstart-text');
    
    if (!quickstartBtn || !quickstartText) {
      throw new Error('QuickStart elements not found');
    }

    console.log('🚀 QuickStart実行開始（統一フロー制御版）');

  // 現在の公開状態を確認して適切な処理を実行
  const isCurrentlyPublished = currentStatus && 
                               currentStatus._normalized && 
                               currentStatus._normalized.isPublished;
  
  console.log('🚀 クイックスタート実行: 公開状態=' + isCurrentlyPublished);

  if (isCurrentlyPublished) {
    // 公開中の場合: 確認モーダルを表示
    if (window.sharedModals && typeof window.sharedModals.showQuickStartStopConfirmation === 'function') {
      window.sharedModals.showQuickStartStopConfirmation(
        () => {
          // 停止して新規作成ボタンクリック時の処理
          executeStopAndQuickStart(quickstartBtn, quickstartText);
        },
        () => {
          // キャンセル時の処理
          console.log('❌ クイックスタートがキャンセルされました');
          resetQuickStartButton(quickstartBtn, quickstartText);
        }
      );
    } else {
      // フォールバック: 標準confirm
      const confirmMessage = '現在公開中の回答ボードを停止して、新しいフォームとボードを作成しますか？\n\n• 既存の回答データは保持されます\n• 新しいフォームとスプレッドシートを作成\n• 高精度AI列判定を実行\n• 作成完了後に自動で再公開';
      
      if (confirm(confirmMessage)) {
        executeStopAndQuickStart(quickstartBtn, quickstartText);
      } else {
        resetQuickStartButton(quickstartBtn, quickstartText);
      }
    }
    } else {
      // 非公開の場合: 直接クイックスタート実行（自動公開フラグ付き）
      console.log('📝 現在非公開のため、直接クイックスタートを実行します（自動公開）');
      return await executeQuickStartProcess(quickstartBtn, quickstartText, true); // autoPublish = true
    }
  });
}


// 公開停止とクイックスタートの統合処理
function executeStopAndQuickStart(quickstartBtn, quickstartText) {
  console.log('🛑📋 公開停止→クイックスタートの統合処理を開始します');
  
  // ボタン状態を更新
  quickstartBtn.disabled = true;
  quickstartText.textContent = '公開停止中...';
  
  // 1. まず公開停止処理を実行
  if (typeof unpublishBoard === 'function') {
    showMessage('現在の回答ボードを停止しています...', 'info');
    
    unpublishBoard()
      .then(function(stopResult) {
        showMessage('✅ 公開停止が完了しました。新しいフォームを作成します...', 'success');

        // Immediately update footer to reflect unpublished state
        if (typeof updateFooterAndGuidance === 'function') {
          updateFooterAndGuidance(stopResult);
        }
        window.lastStatusCache = stopResult;

        // 公開停止が完了したら、少し遅延してからクイックスタートを実行
        setTimeout(() => {
          quickstartText.textContent = 'セットアップ中...';
          console.log('🚀 クイックスタート処理を開始します（自動公開モード）');
          
          // 2. クイックスタート実行（自動公開フラグ付き）
          executeQuickStartProcess(quickstartBtn, quickstartText, true);
        }, 1000);
      })
      .catch(function(stopError) {
        console.error('❌ 公開停止に失敗しました:', stopError);
        showMessage('❌ 公開停止に失敗しました。再度お試しください。', 'error');
        resetQuickStartButton(quickstartBtn, quickstartText);
      });
  } else {
    console.error('❌ unpublishBoard function not found');
    showMessage('❌ 公開停止機能が見つかりません。ページを再読み込みしてください。', 'error');
    resetQuickStartButton(quickstartBtn, quickstartText);
  }
}

// クイックスタートボタンの状態をリセット
function resetQuickStartButton(quickstartBtn, quickstartText) {
  if (quickstartBtn && quickstartText) {
    quickstartBtn.disabled = false;
    quickstartText.textContent = 'クイックスタートを開始';
  }
  
  // 多重実行防止フラグもクリア
  isQuickStartInProgress = false;
  console.log('🔓 QuickStartリセット - 多重実行防止フラグをクリア');
}

// クイックスタートの実際の処理実行
function executeQuickStartProcess(quickstartBtn, quickstartText, autoPublish = false) {
  // Update button state
  quickstartBtn.disabled = true;
  quickstartText.textContent = 'セットアップ中...';
  
  // Show progress bar and start simulation
  showQuickStartProgress();
  simulateQuickStartProgress();
  
  // Show loading message optimized for QuickStart
  // クイックスタート中は専用のプログレスバーを使用するため、汎用ローディングは表示しない
  
  runGasWithUserId('quickStartSetup', false)
    .then(function(result) {
      if (result && result.status === 'success') {
        console.log('🎉 QuickStartバックエンド処理完了:', result);
        
        // Save QuickStart history entry
        if (result.setupComplete) {
          try {
            createQuickStartHistoryEntry(result);
            console.log('📝 QuickStart履歴保存完了');
          } catch (error) {
            console.error('❌ QuickStart履歴保存に失敗:', error);
          }
        }
        
        // Enhanced completion notification with detailed backend response
        updateOverallProgress(100, result.autoPublished ? 'クイックスタート完了！ボードが公開されました！' : 'クイックスタート完了！');
        updateProgressStep(2, 'completed', 'ボード設定と自動公開', '🎉 クイックスタートが完了しました！');
        
        // Enhanced message display based on actual backend results
        const publishStatus = result.autoPublished ? '公開されました' : '作成されました';
        let detailMessage;
        
        if (result.autoPublished) {
          detailMessage = 'フォームとボードが自動作成・公開されました！すぐに利用できます。';
        } else {
          // Check if there's a specific reason for auto-publish failure
          const publishError = result.publishResult && result.publishResult.error;
          const manualInstructions = result.publishResult && result.publishResult.manualPublishInstructions;
          
          detailMessage = 'フォームとボードが作成されました。';
          if (publishError) {
            detailMessage += `自動公開に失敗したため（${publishError}）、`;
          }
          if (manualInstructions) {
            detailMessage += manualInstructions;
          } else {
            detailMessage += '管理パネルから手動で公開してください。';
          }
        }
        
        showMessage(`🎉 クイックスタートが完了しました！${detailMessage}`, 'success');
        
        // Update progress step with auto-publish status
        updateProgressStep(5, 'completed', '回答ボード作成完了', '📝 設定を保存して公開してください');
        
        // QuickStart成功完了 - 多重実行防止フラグをクリア
        isQuickStartInProgress = false;
        console.log('🔓 QuickStart成功完了 - 多重実行防止フラグをクリア');
        
        // Log detailed completion status
        console.log('📊 QuickStart完了詳細:', {
          setupComplete: result.setupComplete,
          autoPublished: result.autoPublished,
          publishResult: result.publishResult,
          completedSteps: result.completedSteps,
          completedAt: result.completedAt
        });
        
        // Log auto-publish specific information if available
        if (result.publishResult) {
          console.log('🌐 自動公開結果詳細:', {
            success: result.publishResult.success,
            published: result.publishResult.published,
            publishedAt: result.publishResult.publishedAt,
            error: result.publishResult.error,
            manualInstructions: result.publishResult.manualPublishInstructions
          });
        }
        
        // Update status after quick start
        if (result.updatedConfig) {
          const newStatus = { ...currentStatus, ...result.updatedConfig, userInfo: { ...currentStatus.userInfo, configJson: JSON.stringify(result.updatedConfig) } };
          updateUIWithNewStatus(newStatus);
        } else {
          // 安定したステータス再読み込み（キャッシュクリア削除）
          simpleStatusRefresh();
        }
        
        // QuickStartフロー完了確認（包括的な完了状態検証）
        setTimeout(async () => {
          try {
            const sheetName = result.sheetName || result.publishedSheetName || 'unknown_sheet';
            const completionResult = await verifySetupFlowCompletion('quickstart', sheetName);
            
            if (completionResult.success) {
              console.log('🎉 QuickStartフロー完了確認: 全要件を満たしています', completionResult.details);
              
              // 成功時は追加処理不要（簡素化）
            } else {
              console.warn('⚠️ QuickStartフロー: 未完了項目があります', completionResult.issues);
              // 簡素化: 追加の同期処理は実行しない
            }
          } catch (verificationError) {
            console.error('❌ QuickStartフロー完了確認エラー:', verificationError);
          }
        }, 2000);
        
        // 公開時は履歴保存を行わない（公開停止時に保存するため）
        logDebug('QuickStart completed - history will be saved on unpublish');
        
        // フォーム作成完了フラグを設定
        sessionStorage.setItem('form_just_created', 'true');
        
        // QuickStart完了時の統合UI更新処理（最適化版）
        setTimeout(() => {
          console.log('🔄 QuickStart完了: 統合UI更新を開始');
          
          // すべてのUI更新を1回の処理でまとめて実行
          updateFormUrlDisplay();
          
          // 予定終了時間の表示を更新
          const scheduledEndTimeElement = document.getElementById('scheduled-end-time');
          if (scheduledEndTimeElement && window.lastStatusCache && window.lastStatusCache.config) {
            updateScheduledEndTime(window.lastStatusCache.config, scheduledEndTimeElement);
          }
          
          // 公開停止ボタンの状態を更新
          if (typeof updateUnpublishButton === 'function' && window.lastStatusCache) {
            updateUnpublishButton(window.lastStatusCache);
          }
          
          // フッター表示の最終更新（デバウンス機能により最適化済み）
          if (window.updateFooterAndGuidance && typeof window.updateFooterAndGuidance === 'function') {
            window.updateFooterAndGuidance(window.lastStatusCache || result);
          }
          
        }, 1200); // 少し遅延を増やして他の処理の完了を待つ
        
        // 回答ボードにフォーム作成完了を通知（フォームリンク更新用）
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            }, '*');
          }
          
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('board-updates');
            channel.postMessage({
              type: 'FORM_CREATED',
              formUrl: result.formUrl,
              timestamp: Date.now()
            });
            channel.close();
          }
        } catch (notifyError) {
          console.warn('クイックスタート - フォーム作成通知でエラー:', notifyError);
        }
        
        // Reset button state
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタート完了';
        
        // 自動公開の場合のみ自動停止確認モーダルを表示
        if (autoPublish) {
          console.log('🚀 自動公開が有効なため、自動停止確認モーダルを表示します');
          
          setTimeout(() => {
            // ローディングオーバーレイを非表示にしてからモーダル表示
            if (window.unifiedLoadingManager) {
              window.unifiedLoadingManager.setLoading(false);
            }
            
            // URL生成確認とデータ検証を実行
            const enhancedResult = {
              ...result,
              url: (result && result.url) || '',
              autoStopMinutes: (result && result.autoStopMinutes) || 360,
              autoStopTime: (result && result.autoStopTime) || '',
              publicationData: {
                isPublished: (result && result.success) || false,
                hasValidUrl: !!(result && result.url && result.url.length > 0),
                timestamp: new Date().toISOString()
              }
            };
            
            console.log('📊 QuickStart公開データ検証:', {
              autoPublish: autoPublish,
              hasResult: !!result,
              hasUrl: !!(result && result.url && result.url.length > 0),
              enhancedResult: enhancedResult
            });
            
            // 自動停止確認モーダルを表示（検証済みデータで）
            setTimeout(() => {
              if (window.sharedModals && typeof window.sharedModals.showAutoStopConfirmation === 'function') {
                window.sharedModals.showAutoStopConfirmation(enhancedResult);
              } else {
                console.warn('⚠️ 自動停止モーダルが利用できません');
              }
            }, 800);
          }, 2000);
        } else {
          console.log('ℹ️ 自動公開が無効のため、自動停止確認モーダルをスキップします');
        }
        
        // Hide progress bar after delay and reset button
        setTimeout(() => {
          hideQuickStartProgress();
          quickstartText.textContent = 'クイックスタートを開始';
          quickstartBtn.disabled = false;
        }, 5000);
      } else {
        logWarn('QuickStart returned error result:', result);
        
        // Show error in progress
        updateProgressStep(6, 'error', 'セットアップエラー', (result && result.message) || 'エラーが発生しました');
        updateOverallProgress(0, 'セットアップに失敗しました');
        
        // 権限エラーの可能性を考慮したメッセージ
        let errorMessage = (result && result.message) || 'クイックスタートに失敗しました。';
        if (errorMessage.includes('permission') || errorMessage.includes('権限') || 
            errorMessage.includes('Drive') || errorMessage.includes('Sheets')) {
          errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
        }
        
        showMessage(errorMessage, 'error');
        
        quickstartBtn.disabled = false;
        quickstartText.textContent = 'クイックスタートを開始';
        
        // Hide progress bar after delay
        setTimeout(() => {
          hideQuickStartProgress();
        }, 3000);
      }
    })
    .catch(function(error) {
      logError('QuickStart error:', error);
      
      // タイムアウトエラーの特別処理（CustomSetupパターン適用）
      if (error.toString().includes('timeout') || error.toString().includes('タイムアウト')) {
        console.log('⏳ タイムアウト検出 - バックエンド完了ポーリング開始');
        updateProgressStep(6, 'active', 'クイックスタート継続中', '⏳ 処理に時間がかかっています...');
        showMessage('⏳ 処理に時間がかかっています。バックエンドで処理を継続中です...', 'info');
        
        // バックエンド完了を待つポーリング開始
        startQuickStartPolling(quickstartBtn, quickstartText);
        return; // エラーを投げずに終了
      }
      
      // その他のエラーは従来通り
      updateProgressStep(6, 'error', 'セットアップエラー', '通信エラーが発生しました');
      updateOverallProgress(0, 'セットアップに失敗しました');
      
      // 権限エラーの可能性を考慮したメッセージ
      let errorMessage = 'クイックスタートに失敗しました。';
      if (error.toString().includes('permission') || error.toString().includes('権限') || 
          error.toString().includes('Drive') || error.toString().includes('Sheets')) {
        errorMessage = 'クイックスタートに失敗しました。Google Drive やスプレッドシートへのアクセス権限を確認してください。システム管理者でない場合、権限が制限されている可能性があります。';
      }
      
      if (typeof handleError === 'function') {
        handleError(error, 'handleQuickStart', errorMessage);
      } else {
        showMessage(errorMessage, 'error');
      }
      
      quickstartBtn.disabled = false;
      quickstartText.textContent = 'クイックスタートを開始';
      
      // QuickStartエラー完了 - 多重実行防止フラグをクリア
      isQuickStartInProgress = false;
      console.log('🔓 QuickStartエラー完了 - 多重実行防止フラグをクリア');
      
      // Hide progress bar after delay
      setTimeout(() => {
        hideQuickStartProgress();
      }, 3000);
    });
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// API initialization is now handled in adminPanel-framework.js.html

// =============================================================================
// MISSING FUNCTIONS RESTORATION
// =============================================================================

// Debounced wrapper for loadStatus to prevent rapid successive calls
function debouncedLoadStatus(bypassCache = false) {
  if (window.AdminPanel && window.AdminPanel.debounce) {
    window.AdminPanel.debounce.loadStatus(() => {
      loadStatus(bypassCache);
    });
  } else {
    // Fallback without debouncing
    loadStatus(bypassCache);
  }
}

// Wrapper for loadStatus to maintain compatibility
function loadSystemStatus(bypassCache = false) {
  // Use debounced version unless bypassCache is true (urgent calls)
  if (bypassCache) {
    loadStatus(bypassCache);
  } else {
    debouncedLoadStatus(bypassCache);
  }
}

// Basic loadUserInfo implementation
function loadUserInfo() {
  logDebug('📋 loadUserInfo called - delegating to debounced loadStatus');
  debouncedLoadStatus();
}

// Update answer count function
function updateAnswerCount() {
  if (!currentStatus || !currentStatus._normalized || !currentStatus._normalized.isPublished) {
    return;
  }
  
  const answerCountElement = document.getElementById('answer-count');
  if (answerCountElement && currentStatus.answerCount !== undefined) {
    answerCountElement.textContent = currentStatus.answerCount || '0';
  }
}

// Setup real-time updates
function setupRealtimeUpdates() {
  // Update system status every 30 seconds
  setInterval(loadSystemStatus, 30000);
  
  // Update answer count every 10 seconds when published
  setInterval(() => {
    const publishText = document.getElementById('info-publish-text');
    if (publishText && publishText.textContent === '公開中') {
      updateAnswerCount();
    }
  }, 10000);
}

// Initialize when DOM is ready
// 初期化は adminPanel-core.js の統合初期化システムで管理されます

//# sourceURL=adminPanel-api.js.html
</script>
