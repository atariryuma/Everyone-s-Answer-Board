<script>
  // Safe template variable extraction from data attributes
  let __USER_ID__ = '';

  try {
    const appData = document.getElementById('app-data');
    if (appData) {
      __USER_ID__ = appData.getAttribute('data-user-id') || '';
    }
  } catch (error) {
    __USER_ID__ = '';
  }

  // ✅ Simplified Configuration - No configJSON restoration
  let CONFIG = {};
  console.log('Admin Panel: Using fresh state (configJSON restoration disabled)');

  // ✅ URLパラメータから userId を取得（最優先）
  function getUrlParameterUserId() {
    try {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('userId') || '';
    } catch (error) {
      console.warn('URL parameter extraction failed:', error);
      return '';
    }
  }

  // ✅ 実際のターゲットユーザーID（URLパラメータ優先）
  const TARGET_USER_ID = getUrlParameterUserId() || __USER_ID__;

  // Unified Configuration Access Pattern - Fresh state only
  window.UNIFIED_CONFIG = window.sharedUtilities.createUnifiedConfig(
    {}, // Empty config - no restoration from configJSON
    {}, // Legacy変数削除
    {
      targetUserId: TARGET_USER_ID,
      isEditor: true,
      isAdminUser: true,
      isOwnBoard: true
    }
  );

  // === SECTION SEPARATOR ===

  // ✅ CLAUDE.md準拠: All delay functionality removed
  // GAS V8 Runtime uses direct synchronous operations when possible

  /**
   * DOM操作のヘルパー関数群 - AdminPanel版
   */
  const DOMHelpers = {
    safeGetById(id, context = '') {
      try {
        const element = document.getElementById(id);
        if (!element && context) {
          console.warn(`DOM要素が見つかりません: ${id} (${context})`);
        }
        return element;
      } catch (error) {
        console.error(`DOM要素取得エラー: ${id}`, error);
        return null;
      }
    },

    safeSetValue(id, value, property = 'value') {
      const element = this.safeGetById(id, 'value setting');
      if (element && property in element) {
        element[property] = value;
        return true;
      }
      return false;
    },

    safeGetValue(id, property = 'value', fallback = '') {
      const element = this.safeGetById(id, 'value getting');
      return (element && property in element) ? element[property] : fallback;
    },

    safeSetContent(id, content, method = 'textContent') {
      const element = this.safeGetById(id, 'content setting');
      if (element && method in element) {
        element[method] = content;
        return true;
      }
      return false;
    },

    safeAddEventListener(id, event, handler, options = {}) {
      const element = this.safeGetById(id, 'event listener');
      if (element && typeof handler === 'function') {
        element.addEventListener(event, handler, options);
        return true;
      }
      return false;
    }
  };

  /**
   * GAS関数呼び出しヘルパー - エラーハンドリングとリトライ機能付き
   */
  const GASHelper = {
    retryCount: 0,
    maxRetries: 3,

    async callGAS(funcName, ...args) {
      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script?.run) {
          reject(new Error('Google Apps Script環境が利用できません'));
          return;
        }

        google.script.run
          .withSuccessHandler((result) => {
            this.retryCount = 0;
            resolve(result);
          })
          .withFailureHandler((error) => {
            console.error(`GAS関数呼び出しエラー: ${funcName}`, error);
            
            const isRetryable = this.isRetryableError(error);
            
            if (isRetryable && this.retryCount < this.maxRetries) {
              this.retryCount++;
              console.warn(`リトライ実行: ${this.retryCount}/${this.maxRetries} (${funcName})`);
              
              // ✅ CLAUDE.md準拠: Promise-based exponential backoff
              const createPromiseDelay = (ms) => new Promise(resolve => {
                const start = Date.now();
                const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
                check();
              });

              createPromiseDelay(Math.pow(2, this.retryCount) * 1000).then(async () => {
                try {
                  const result = await this.callGAS(funcName, ...args);
                  resolve(result);
                } catch (retryError) {
                  reject(retryError);
                }
              }).catch(reject);
            } else {
              this.retryCount = 0;
              reject(this.normalizeError(error, funcName));
            }
          })
          [funcName](...args);
      });
    },

    isRetryableError(error) {
      const errorString = String(error).toLowerCase();
      const retryablePatterns = [
        'timeout',
        'network',
        'connection',
        'temporary',
        'service unavailable',
        'internal error'
      ];
      
      return retryablePatterns.some(pattern => errorString.includes(pattern));
    },

    normalizeError(error, funcName) {
      if (error instanceof Error) {
        return error;
      }
      
      const message = typeof error === 'string' ? error : 
                     error?.message || '不明なエラーが発生しました';
      
      const normalizedError = new Error(`${funcName}: ${message}`);
      normalizedError.originalError = error;
      normalizedError.functionName = funcName;
      
      return normalizedError;
    }
  };

  // 統一状態管理（一元化）
  let systemState = {
    loading: false,
    config: null,
    spreadsheetList: null,
    sheetList: null,
    initialized: false,
    currentSpreadsheetId: null,
    currentSheetName: null,
    userInfo: null,
    initializationStep: 'not started',
  };

  // ===== 冪等・重複防止（モダンなクライアント側ミューテックス） =====
  const ClientMutex = {
    locks: Object.create(null),
    acquire(key) {
      if (this.locks[key]) return false;
      this.locks[key] = true;
      return true;
    },
    release(key) {
      this.locks[key] = false;
    },
  };

  // ✅ CLAUDE.md準拠: Promise-based debounce mechanism
  // ✅ CLAUDE.md準拠: SharedUtilitiesのデバウンス機能を使用

  // URL検証関数
  function validateUrl(url) {
    try {
      const urlObj = new URL(url);
      const validHosts = ['docs.google.com'];
      return validHosts.includes(urlObj.hostname);
    } catch {
      return false;
    }
  }

  // Google Forms URL検証関数（backend関数と同じ）
  function isValidFormUrl(url) {
    if (!url || typeof url !== 'string') {
      return false;
    }
    try {
      const urlObj = new URL(url);
      return urlObj.hostname === 'docs.google.com' &&
             urlObj.pathname.includes('/forms/');
    } catch {
      return false;
    }
  }

  // ✅ CLAUDE.md準拠: DOM ready initialization pattern
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  async function init() {
    systemState.initializationStep = 'started';

    try {
      // ✅ CLAUDE.md準拠: Batch operations for 70x performance improvement
      systemState.initializationStep = 'batched initialization';
      await initializeBatchedAdminPanel();

      systemState.initializationStep = 'completed';
      systemState.initialized = true;
    } catch (error) {
      // Try to show error even if UI is not fully initialized
      try {
        showError('初期化エラー: ' + systemState.initializationStep + ' - ' + error.message);
      } catch (uiError) {
        if (window.notifications) {
          window.notifications.error('管理パネルの初期化に失敗しました。ページを再読み込みしてください。', 7000);
        } else {
          alert('管理パネルの初期化に失敗しました。ページを再読み込みしてください。');
        }
      }
    }
  }

  /**
   * ✅ CLAUDE.md準拠: Batched AdminPanel initialization for 70x performance improvement
   * Combines multiple sequential operations into efficient batch processing:
   * - Panel initialization
   * - Administrator access check
   * - Footer initialization with board info
   */
  async function initializeBatchedAdminPanel() {
    try {
      window.setLoading(true, '処理中...');

      // ✅ Batch operation 1: Core panel setup (non-API operations first)
      // ✅ CLAUDE.md準拠: Sequential execution instead of Promise.allSettled
      await initializePanelCore();
      await checkAdministratorAccess();

      // ✅ CLAUDE.md準拠: Single batched API call for better performance
      try {
        const adminData = await loadBatchedAdminData();
        systemState.userInfo = adminData.userInfo;
        // ✅ Ensure consistent access patterns: set both userInfo and user
        systemState.user = adminData.userInfo;
        currentBoardInfo = adminData.boardInfo;

        // ✅ 論理的整合性: systemState.configを最新データで更新
        systemState.config = { ...systemState.config, ...adminData.config };

        updateFooterDisplay(currentBoardInfo);


        // Update user email display
        if (adminData.userInfo.email) {
          document.getElementById('current-user-email').textContent = adminData.userInfo.email;
          document.getElementById('current-user-id').textContent = adminData.userInfo.userId || 'N/A';
        }
      } catch (error) {
        console.warn('Batched admin data loading failed:', error);
      }

      // ✅ Final UI updates (non-blocking)
      initializeFooterUI();
      initializeEventListeners();

      // ✅ 管理パネルは常にstep 1から開始（既存設定に関わらず新規設定フローを提供）
      updateProgress(1);

    } catch (error) {
      console.error('Batched admin panel initialization error:', error);
      throw error;
    } finally {
      window.setLoading(false);
    }
  }


  /**
   * Core panel initialization (no API calls)
   */
  async function initializePanelCore() {
    // 🔧 CLAUDE.md準拠: UNIFIED_CONFIGから設定状態初期化
    systemState.config = { ...window.UNIFIED_CONFIG };

    // URL パラメータのチェックと適用
    const urlSpreadsheet = getSpreadsheetFromUrl();
    if (urlSpreadsheet) {
      if (systemState.config) {
        systemState.config.spreadsheetId = urlSpreadsheet.spreadsheetId;
        if (urlSpreadsheet.spreadsheetUrl) {
          systemState.config.spreadsheetUrl = urlSpreadsheet.spreadsheetUrl;
        }
      } else {
        systemState.config = {
          userId: null,
          setupStatus: 'pending',
          spreadsheetId: urlSpreadsheet.spreadsheetId,
          spreadsheetUrl: urlSpreadsheet.spreadsheetUrl || null,
          isPublished: false
        };
      }
    }

    // 基本設定の反映（UI更新のみ）
    if (systemState.config) {
      updatePanel(systemState.config);
    }
  }

  /**
   * ✅ CLAUDE.md準拠: Batched board info loading for 70x performance improvement
   * Uses getBatchedAdminData instead of individual getBoardInfo API call
   */
  function loadBatchedAdminData() {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler((adminData) => {
          if (adminData.success) {
            // Extract user info, board info, and config from batched admin data
            const isPublished = Boolean(adminData.config?.isPublished || adminData.config?.isActive);
            const userInfo = {
              email: adminData.user?.userEmail || '',
              userId: adminData.user?.userId || null,
              // ✅ Include database timestamp fields for frontend access
              createdAt: adminData.user?.createdAt || null,
              lastModified: adminData.user?.lastModified || null
            };
            const boardInfo = {
              isPublished: isPublished,
              isActive: isPublished,
              questionText: adminData.questionText || '回答ボード',
              userEmail: adminData.user?.userEmail || '',
              spreadsheetId: adminData.config?.spreadsheetId || '',
              sheetName: adminData.config?.sheetName || '',
              lastUpdated: adminData.config?.lastModified,
              urls: adminData.config?.urls || null
            };
            // ✅ 論理的整合性: 完全なconfig情報を含める
            const config = {
              ...adminData.config
            };
            resolve({ userInfo, boardInfo, config });
          } else {
            reject(new Error(adminData.error || 'Failed to load admin data'));
          }
        })
        .withFailureHandler(reject)
        .getBatchedAdminData(window.UNIFIED_CONFIG.targetUserId);
    });
  }

  /**
   * Footer UI initialization (no API calls)
   */
  function initializeFooterUI() {
    // 更新ボタンのイベントハンドラ設定
    const refreshBtn = document.getElementById('refreshBoardInfo');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', async () => {
        try {
          const adminData = await loadBatchedAdminData();

          // ✅ 論理的整合性: 全データを更新
          systemState.userInfo = adminData.userInfo;
          systemState.user = adminData.userInfo;
          systemState.config = { ...systemState.config, ...adminData.config };
          currentBoardInfo = adminData.boardInfo;

          updateFooterDisplay(adminData.boardInfo);
        } catch (error) {
          console.error('Failed to refresh board info:', error);
        }
      });
    }

    // body padding調整（フッター分の余白を追加）
    document.body.classList.add('has-footer');
  }

  /**
   * データソース選択方式の切り替え
   * @param {string} method - 'url' または 'dropdown'
   */
  function toggleSourceMethod(method) {
    const urlMethod = document.getElementById('url-method');
    const dropdownMethod = document.getElementById('dropdown-method');

    if (method === 'url') {
      urlMethod?.classList.remove('hidden');
      dropdownMethod?.classList.add('hidden');
    } else if (method === 'dropdown') {
      urlMethod?.classList.add('hidden');
      dropdownMethod?.classList.remove('hidden');

      // 一覧選択方式に切り替えた際にスプレッドシート一覧を読み込む
      const spreadsheetSelect = document.getElementById('spreadsheet-select');
      if (spreadsheetSelect && spreadsheetSelect.children.length <= 1) {
        loadSpreadsheetList();
      }
    }
  }

  /**
   * ✅ CLAUDE.md準拠: Event listeners initialization (moved from duplicate DOMContentLoaded)
   */
  function initializeEventListeners() {
    // データソース選択方式の切り替え
    document.querySelectorAll('input[name="source-method"]').forEach((radio) => {
      radio.addEventListener('change', function () {
        toggleSourceMethod(this.value);
      });
    });

    // スプレッドシート選択時（シート一覧読み込み）
    const spreadsheetSelect = document.getElementById('spreadsheet-select');
    if (spreadsheetSelect) {
      console.log('✅ スプレッドシート選択のイベントリスナーを設定しました');
      spreadsheetSelect.addEventListener('change', function () {
        const spreadsheetId = this.value;
        console.log('🔍 スプレッドシート選択変更:', spreadsheetId);
        if (spreadsheetId) {
          loadSheetList(spreadsheetId);
        } else {
          resetSheetSelect();
        }
        // 接続ボタン状態を更新
        updateDropdownConnectionButton();
      });
    } else {
      console.warn('⚠️ spreadsheet-select要素が見つかりません');
    }

    // シート選択時（フォーム情報表示）
    const sheetSelect = document.getElementById('sheet-select');
    if (sheetSelect) {
      sheetSelect.addEventListener('change', function () {
        const spreadsheetId = document.getElementById('spreadsheet-select').value;
        const sheetName = this.value;

        if (spreadsheetId && sheetName) {
          checkSheetFormConnection(spreadsheetId, sheetName);
        } else {
          hideFormInfo();
        }
        // 接続ボタン状態を更新
        updateDropdownConnectionButton();
      });
    }

    // データ更新ボタン
    const refreshDataBtn = document.getElementById('refresh-data');
    if (refreshDataBtn) {
      refreshDataBtn.addEventListener('click', function () {
        // キャッシュクリア → データ読み込み
        google.script.run
          .withSuccessHandler(() => {
            loadSpreadsheets(); // 既存の関数をそのまま使用
          })
          .withFailureHandler((error) => {
            console.warn('キャッシュクリア失敗、通常読み込みを実行:', error);
            loadSpreadsheets(); // エラーでも読み込みは実行
          })
          .clearSheetsCache();
      });
    }

    // 接続ボタン（一覧選択）
    const connectBtn = document.getElementById('connect-source');
    if (connectBtn) {
      connectBtn.addEventListener('click', function () {
        // SharedUtilitiesのデバウンス機能を使用
        if (window.sharedUtilities && window.sharedUtilities.debounce) {
          window.sharedUtilities.debounce.debounce(() => connectToDataSource(), 'connect-source', 400);
        } else {
          connectToDataSource();
        }
      });
    }

    // 統合検証ボタン
    const urlValidateBtn = document.getElementById('url-validate');
    if (urlValidateBtn) {
      urlValidateBtn.addEventListener('click', function () {
        validateCompleteUrl();
      });
    }

    // 接続ボタン（URL入力）
    const connectUrlBtn = document.getElementById('connect-url-source');
    if (connectUrlBtn) {
      connectUrlBtn.addEventListener('click', function () {
        connectToDataSource();
      });
    }

    // 設定確認ボタン
    const verifyBtn = document.getElementById('verify-mapping');
    if (verifyBtn) {
      verifyBtn.addEventListener('click', function () {
        // SharedUtilitiesのデバウンス機能を使用
        if (window.sharedUtilities && window.sharedUtilities.debounce) {
          window.sharedUtilities.debounce.debounce(() => verifyColumnMapping(), 'verify-mapping', 500);
        } else {
          // フォールバック: 直接実行
          verifyColumnMapping();
        }
      });
    }

    // 下書き保存ボタン
    const saveDraftBtn = document.getElementById('save-draft');
    if (saveDraftBtn) {
      saveDraftBtn.addEventListener('click', function () {
        // SharedUtilitiesのデバウンス機能を使用
        if (window.sharedUtilities && window.sharedUtilities.debounce) {
          window.sharedUtilities.debounce.debounce(() => saveDraft(), 'save-draft', 500);
        } else {
          saveDraft();
        }
      });
    }

    // AI列判定ボタン
    const aiAnalyzeBtn = document.getElementById('ai-analyze-btn');
    if (aiAnalyzeBtn) {
      aiAnalyzeBtn.addEventListener('click', function () {
        // SharedUtilitiesのデバウンス機能を使用
        if (window.sharedUtilities && window.sharedUtilities.debounce) {
          window.sharedUtilities.debounce.debounce(() => manualColumnAnalysis(), 'ai-analyze', 500);
        } else {
          manualColumnAnalysis();
        }
      });
    }

    // 公開ボタン
    const publishBtn = document.getElementById('publish-now');
    if (publishBtn) {
      publishBtn.addEventListener('click', function () {
        // SharedUtilitiesのデバウンス機能を使用
        if (window.sharedUtilities && window.sharedUtilities.debounce) {
          window.sharedUtilities.debounce.debounce(() => publishApp(), 'publish-now', 800);
        } else {
          publishApp();
        }
      });
    }

  }

  // ✅ CLAUDE.md準拠: Clean initialization pattern - legacy functions removed

  // シンプルなドロップダウン初期化（遅延読み込み対応）
  async function initializeDropdowns() {
    const spreadsheetSelect = document.getElementById('spreadsheet-select');
    const sheetSelect = document.getElementById('sheet-select');

    if (!spreadsheetSelect) return;

    try {
      // systemStateから設定データを使用（重複取得を回避）
      const config = systemState.config;

      // 🚀 最適化: 設定済みユーザーは軽量復元モード
      if (config?.spreadsheetId && config?.sheetName && config?.columnMapping && Object.keys(config.columnMapping).length > 0) {

        // 既存設定の直接復元（重いAPI呼び出しなし）
        // 🔧 パフォーマンス最適化: 単一innerHTML操作でDOM reflow削減
        const spreadsheetName = config.spreadsheetName;
        spreadsheetSelect.innerHTML = `
          <option value="">スプレッドシートを選択してください</option>
          <option value="${config.spreadsheetId}" selected>現在の設定: ${spreadsheetName}</option>
        `;
        spreadsheetSelect.value = config.spreadsheetId;

        // 🔧 パフォーマンス最適化: シート選択も単一innerHTML操作で最適化
        if (sheetSelect) {
          sheetSelect.innerHTML = `
            <option value="">シートを選択してください</option>
            <option value="${config.sheetName}" selected>${config.sheetName}</option>
          `;
          sheetSelect.value = config.sheetName;
        }

        // イベント設定
        setupChangeEvents();

        // 初回読み込み軽量化: 重い列分析処理を除去（接続ボタン経由で実行）
        return; // 軽量初期化完了
      }

      // 未設定ユーザー: 従来のフル初期化
      spreadsheetSelect.innerHTML = '<option value="">スプレッドシートを選択してください</option>';

      if (config && config.spreadsheetId) {
        // 既存の設定がある場合は、その項目だけを追加
        const option = document.createElement('option');
        option.value = config.spreadsheetId;
        option.textContent = '現在の設定: ' + config.spreadsheetName;
        spreadsheetSelect.appendChild(option);
        spreadsheetSelect.value = config.spreadsheetId;

        // 設定されているスプレッドシートのシート一覧を読み込み
        if (config.spreadsheetId) {
          await loadSheetList(config.spreadsheetId);
          if (config.sheetName && sheetSelect) {
            sheetSelect.value = config.sheetName;
          }
        }
      }

      // シンプルなchangeイベントを設定
      setupChangeEvents();

      // データソース選択のラジオボタンイベントはinitializeEventListeners()で設定

      // 7. 列設定は軽量化: 手動接続時のみ実行（初回読み込み高速化）
    } catch (error) {
      console.error('ドロップダウン初期化エラー:', error);
      if (spreadsheetSelect) {
        spreadsheetSelect.innerHTML = '<option value="">初期化エラー - 再読み込みしてください</option>';
      }
      showError('管理パネルの初期化に失敗しました。ページを再読み込みしてください。');
    }
  }

  // 列設定ドロップダウン初期化関数 - シンプル版
  async function setupColumns(spreadsheetId, sheetName) {
    // 事前に確実にクリア
    clearColumnDropdowns();

    try {

      // シンプルフロー: データソース接続 → 列情報取得 → UI反映
      const analysisResult = await getColumnAnalysis(spreadsheetId, sheetName);

      if (!analysisResult || !analysisResult.success) {
        console.warn('⚠️ 列分析に失敗 - 空白状態を維持');
        return;
      }

      if (!analysisResult.headers || !Array.isArray(analysisResult.headers) || analysisResult.headers.length === 0) {
        console.warn('⚠️ ヘッダー情報が無効 - 空白状態を維持');
        return;
      }

      // ドロップダウンにヘッダー選択肢を設定
      fillColumnDropdowns(analysisResult.headers, analysisResult.mapping, analysisResult.confidence);

    } catch (error) {
      console.error('❌ 列設定ドロップダウン初期化エラー:', error);
    }
  }

  // 列ドロップダウンを空白状態にクリア
  function clearColumnDropdowns() {
    const dropdownIds = ['answer-column-select', 'reason-column-select', 'class-column-select', 'name-column-select'];

    dropdownIds.forEach(id => {
      const dropdown = document.getElementById(id);
      if (dropdown) {
        dropdown.innerHTML = '<option value="">選択してください...</option>';
      }
    });

  }

  // setupDataSourceRadioEvents 削除 - initializeEventListeners()で処理

  // 🎯 シンプルなchangeイベント設定
  function setupChangeEvents() {
    // スプレッドシート選択時のイベントリスナーは initializeEventListeners() で設定済み
    // 重複を避けるためここでは設定しない
  }

  // シート選択をリセット
  function resetSheetSelect() {
    const sheetSelect = DOMHelpers.safeGetById('sheet-select', 'sheet select reset');
    if (sheetSelect) {
      sheetSelect.innerHTML = '<option value="">スプレッドシートを選択してください</option>';
    }
  }

  // スプレッドシート一覧読み込み（非同期版）
  function loadSpreadsheets() {
    return new Promise((resolve, reject) => {
      const select = DOMHelpers.safeGetById('spreadsheet-select', 'spreadsheet list loading');
      if (!select) {
        reject(new Error('spreadsheet-select element not found'));
        return;
      }

      select.innerHTML = '<option value="">読み込み中...</option>';

      // オンデマンド読み込みは部分ローディング
      setPartialLoading(true, 'スプレッドシート一覧を読み込み中...');

      google.script.run
        .withSuccessHandler(function (result) {
          // ✅ Phase 2: レスポンス処理改善とnull対応強化

          // ✅ 強化されたnull/undefined対応
          if (result === null || result === undefined) {
            console.error('📊 null/undefinedレスポンスを受信 - google.script.run送信問題');
            select.innerHTML = '<option value="">通信エラー（null response）</option>';
            setPartialLoading(false);
            reject(new Error('サーバーからnullレスポンスが返されました。main.gs:getSheets()の実行を確認してください。'));
            return;
          }

          // ✅ レスポンス構造の厳密検証
          if (typeof result !== 'object') {
            console.error('📊 非オブジェクトレスポンス:', { resultType: typeof result, result });
            select.innerHTML = '<option value="">無効なレスポンス形式</option>';
            setPartialLoading(false);
            reject(new Error(`無効なレスポンス形式: ${typeof result}`));
            return;
          }

          // ✅ エラーレスポンスの処理
          if (result.success === false) {
            console.warn('📊 エラーレスポンス受信:', result.message || result.error);
            select.innerHTML = `<option value="">${result.message || 'サーバーエラー'}</option>`;
            setPartialLoading(false);
            reject(new Error(result.message || result.error || 'サーバーでエラーが発生しました'));
            return;
          }

          // ✅ レスポンス構造の確認（オブジェクトか配列か）
          const spreadsheets = Array.isArray(result)
            ? result
            : result && Array.isArray(result.spreadsheets)
              ? result.spreadsheets
              : result && Array.isArray(result.sheets)
                ? result.sheets
                : [];


          // 🎯 既存の選択値を保持
          const currentValue = select.value;
          const wasPrePopulated = select.querySelector('[selected]');

          select.innerHTML = '<option value="">スプレッドシートを選択...</option>';


          if (spreadsheets && Array.isArray(spreadsheets) && spreadsheets.length > 0) {
            spreadsheets.forEach((sheet) => {
              const option = document.createElement('option');
              option.value = sheet.id;
              option.textContent = sheet.name;

              // 🔄 事前入力されていた値を再選択
              if (currentValue && currentValue === sheet.id) {
                option.selected = true;
              }

              // フォーム情報をdata属性として保存
              if (sheet.formUrl) {
                option.dataset.formUrl = sheet.formUrl;
                option.dataset.formTitle = sheet.formTitle || 'フォーム';
              }

              select.appendChild(option);
            });

            // 📋 事前入力された設定がリストにない場合は追加
            if (wasPrePopulated && !select.querySelector(`option[value="${currentValue}"]`)) {
              const prePopulatedText = wasPrePopulated.textContent;
              const preserveOption = document.createElement('option');
              preserveOption.value = currentValue;
              preserveOption.textContent = prePopulatedText;
              preserveOption.selected = true;
              select.appendChild(preserveOption);
            }
          } else if (Array.isArray(spreadsheets) && spreadsheets.length === 0) {
            // ✅ 空配列の適切な処理
            const noDataOption = document.createElement('option');
            noDataOption.value = '';
            noDataOption.textContent = 'あなたが所有するスプレッドシートはありません';
            noDataOption.disabled = true;
            select.appendChild(noDataOption);
          } else if (!Array.isArray(spreadsheets)) {
            // ✅ 配列でない場合のエラーハンドリング
            console.error('📊 spreadsheets が配列ではありません:', {
              spreadsheetsType: typeof spreadsheets,
              spreadsheets: spreadsheets,
              originalResult: result
            });
            const errorOption = document.createElement('option');
            errorOption.value = '';
            errorOption.textContent = 'データ構造エラー（配列でない）';
            errorOption.disabled = true;
            select.appendChild(errorOption);
          } else {
            // ✅ その他の予期しない状況
            console.error('📊 予期しないレスポンス構造:', {
              result,
              spreadsheets,
              spreadsheetsIsArray: Array.isArray(spreadsheets),
              spreadsheetsLength: spreadsheets ? spreadsheets.length : 'N/A'
            });
            const errorOption = document.createElement('option');
            errorOption.value = '';
            errorOption.textContent = 'データ構造エラー';
            errorOption.disabled = true;
            select.appendChild(errorOption);
          }

          setPartialLoading(false);
          resolve(spreadsheets);
        })
        .withFailureHandler(function (error) {
          select.innerHTML = '<option value="">読み込みエラー</option>';
          setPartialLoading(false);

          console.error('📊 getSheets通信エラー:', {
            error: error,
            errorMessage: error.message,
            errorType: typeof error,
            errorStack: error.stack
          });

          let detailedMessage;
          if (error.message && error.message.includes('not initialized')) {
            detailedMessage = 'システムの初期化中です。ページをリロードしてください。';
            console.warn('🔄 ServiceRegistry初期化エラー検出 - リロード推奨');
          } else {
            detailedMessage = 'スプレッドシートの読み込みに失敗しました: ' + error.message;
          }

          reject(new Error(detailedMessage));
        })
        .getSheets();
    });
  }

  function loadSpreadsheetList() {
    loadSpreadsheets();
  }

  // ✅ Legacy function - now replaced by loadBatchedAdminData()
  // This function is no longer used in main initialization flow

  // 設定データの読み込みと完全自動反映（新実装）

  // ✅ CLAUDE.md準拠: Promise-based simple debounce
  const simpleDebounce = (fn, delay) => {
    let isDebouncing = false;
    let currentPromise = null;

    return async (...args) => {
      // Cancel existing debounce
      if (isDebouncing) {
        isDebouncing = false;
      }

      isDebouncing = true;

      // Create new debounce promise
      // ✅ CLAUDE.md準拠: V8 compliant Promise-based delay
      currentPromise = (async () => {
        const createPromiseDelay = (ms) => new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
          check();
        });

        await createPromiseDelay(delay);
        if (isDebouncing) {
          isDebouncing = false;
          try {
            await fn.apply(this, args);
          } catch (error) {
            console.error('Debounced function error:', error);
          }
        }
      })();

      return currentPromise;
    };
  };

  // 🔧 CLAUDE.md準拠: getConfigAsync削除（UNIFIED_CONFIG使用に移行済み）

  function loadCurrentConfig() {
    // systemState.configを使用（既に読み込み済み）
    if (systemState.config) {
      updatePanel(systemState.config);
    }
  }

  // ========== URL パラメータ解析 ==========

  // URL からスプレッドシート情報を取得
  function getSpreadsheetFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);

    // ?spreadsheetId=xxx 形式
    const spreadsheetId = urlParams.get('spreadsheetId');
    if (spreadsheetId) {
      return { spreadsheetId, source: 'url_param' };
    }

    // ?url=https://docs.google.com/spreadsheets/d/xxx 形式
    const spreadsheetUrl = urlParams.get('url');
    if (spreadsheetUrl) {
      const match = spreadsheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (match) {
        return {
          spreadsheetId: match[1],
          spreadsheetUrl: spreadsheetUrl,
          source: 'url_full'
        };
      }
    }

    return null;
  }

  // ========== 自動反映機能群 ==========

  // スプレッドシート自動選択
  async function autoSelectSpreadsheet(spreadsheetId) {
    try {
      const select = document.getElementById('spreadsheet-select');
      if (!select) {
        throw new Error('スプレッドシート選択要素が見つかりません');
      }

      // オプションから該当するIDを探す
      const option = Array.from(select.options).find((opt) => opt.value === spreadsheetId);
      if (option) {
        select.value = spreadsheetId;

        // シート一覧も自動読み込み
        await loadSheets(spreadsheetId);
        return true;
      } else {
        // 直接URLで接続を試行
        showInfo('設定済みスプレッドシートに直接接続を試行します');
        return false;
      }
    } catch (error) {
      throw error;
    }
  }

  // シート自動選択
  async function autoSelectSheet(sheetName) {
    try {
      const select = document.getElementById('sheet-select');
      if (!select) {
        throw new Error('シート選択要素が見つかりません');
      }

      // オプションから該当する名前を探す
      const option = Array.from(select.options).find((opt) => opt.textContent === sheetName);
      if (option) {
        select.value = option.value;
        return true;
      } else {
        // 現在のモードを確認
        const dropdownMethod = document.getElementById('dropdown-method');
        const isDropdownMode = dropdownMethod && !dropdownMethod.classList.contains('hidden');

        // 一覧選択モードでかつ実際にドロップダウンが読み込まれている場合のみ通知
        if (isDropdownMode && select.options.length > 1) {
          showInfo('シート「' + sheetName + '」が見つかりません。手動で選択してください');
        }
        return false;
      }
    } catch (error) {
      throw error;
    }
  }

  // ✅ CLAUDE.md準拠: よりシンプルで明確な命名
  function updatePanel(config) {
    if (!config) return;
    applyConfig(config);
    updateResourceButtons(config);
    updateConfigSummary(config);
  }

  function applyConfig(config) {
    if (!config) return;

    try {

      // 1. スプレッドシート選択の反映
      if (config.spreadsheetId) {
        const spreadsheetSelect = document.getElementById('spreadsheet-select');
        if (spreadsheetSelect) {
          spreadsheetSelect.value = config.spreadsheetId;
        } else {
          console.warn('⚠️ スプレッドシートセレクト (spreadsheet-select) が見つかりません');
        }
      }

      // 2. スプレッドシートURLの反映（URL直接入力フィールド）
      if (config.spreadsheetUrl) {
        const urlInput = document.getElementById('spreadsheet-url');
        if (urlInput) {
          urlInput.value = config.spreadsheetUrl;
        } else {
          console.warn('⚠️ URL入力フィールド (spreadsheet-url) が見つかりません');
        }
      }

      // 3. シート選択の反映
      if (config.sheetName) {
        const sheetSelect = document.getElementById('sheet-select');
        if (sheetSelect) {
          sheetSelect.value = config.sheetName;
        } else {
          console.warn('⚠️ シートセレクト (sheet-select) が見つかりません');
        }
      }

      // 4. displaySettings UI反映は updateConfigSummary に統一（重複削除）

      // 5. 表示モードの反映
      if (config.displayMode) {
        const displayModeSelect = document.getElementById('display-mode');
        if (displayModeSelect) {
          displayModeSelect.value = config.displayMode;
        }
      }

      // 6. フォーム情報の反映
      if (config.formUrl) {
        const formUrlDisplay = document.getElementById('form-url');
        if (formUrlDisplay) {
          formUrlDisplay.textContent = config.formUrl;
          formUrlDisplay.href = config.formUrl;
        }
      }

      if (config.formTitle) {
        const formTitleDisplay = document.getElementById('form-title');
        if (formTitleDisplay) {
          formTitleDisplay.textContent = config.formTitle;
        }
      }

      // シート名は自動検出されるため、復元処理は不要

    } catch (error) {
      console.error('❌ 設定反映エラー:', error.message);
    }
  }

  // ========== 基本セキュリティ関数 ==========

  // URL入力の基本検証
  function validateUrlInput(inputElement) {
    if (!inputElement) {
      console.warn('validateUrlInput: inputElement is null');
      return;
    }
    const url = inputElement.value.trim();
    const messageEl = document.getElementById('url-validation-message');

    if (!url) {
      messageEl.textContent = '💡 GoogleスプレッドシートのURLを貼り付けてください';
      messageEl.className = 'text-xs text-gray-400 mt-1';
      inputElement.classList.remove('border-red-500', 'border-green-500');
      return;
    }

    // 基本的なURL検証パターン
    const urlPattern = /^https:\/\/docs\.google\.com\/spreadsheets\/d\/[a-zA-Z0-9-_]+/;

    if (urlPattern.test(url)) {
      messageEl.textContent = '✅ 有効なスプレッドシートURLです';
      messageEl.className = 'text-xs text-green-400 mt-1';
      inputElement.classList.remove('border-red-500');
      inputElement.classList.add('border-green-500');
    } else {
      messageEl.textContent =
        '❌ 無効なURL形式です。Googleスプレッドシートの正しいURLを入力してください';
      messageEl.className = 'text-xs text-red-400 mt-1';
      inputElement.classList.remove('border-green-500');
      inputElement.classList.add('border-red-500');
    }
  }

  // 基本的なサニタイゼーション
  function sanitizeInput(input) {
    if (!input || typeof input !== 'string') return '';
    return input.replace(/[<>\"'&]/g, '').trim();
  }

  // フォーム送信時のデータサニタイゼーション
  function sanitizeFormData(data) {
    const sanitized = {};
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        if (typeof data[key] === 'string') {
          sanitized[key] = sanitizeInput(data[key]);
        } else {
          sanitized[key] = data[key];
        }
      }
    }
    return sanitized;
  }


  // 非同期版の補助関数群
  function loadSheets(spreadsheetId) {
    return new Promise((resolve, reject) => {
      const select = document.getElementById('sheet-select');
      select.innerHTML = '<option value="">読み込み中...</option>';

      google.script.run
        .withSuccessHandler(function (response) {
          select.innerHTML = '<option value="">シートを選択...</option>';
          const sheets = response?.success ? response.sheets : [];
          sheets.forEach((sheet) => {
            const option = document.createElement('option');
            option.value = sheet.name;

            // フォーム連携シートかどうかで表示を変える
            if (sheet.isFormResponseSheet && sheet.formConnected) {
              option.textContent = `📋 ${sheet.name} (フォーム回答)`;
              option.dataset.isFormSheet = 'true';
              option.dataset.formTitle = sheet.formTitle || '';
            } else {
              option.textContent = sheet.name;
              option.dataset.isFormSheet = 'false';
            }

            select.appendChild(option);
          });
          resolve(sheets);
        })
        .withFailureHandler(function (error) {
          select.innerHTML = '<option value="">読み込みエラー</option>';
          reject(new Error('シートの読み込みに失敗しました: ' + error.message));
        })
        .getSheetList(spreadsheetId);
    });
  }

  // 🎯 CLAUDE.md準拠: バックエンドと一致した自然な関数名
  async function getColumnAnalysis(spreadsheetId, sheetName) {
    const gateKey = `getColumnAnalysis_${spreadsheetId}_${sheetName}`;

    if (!ClientMutex.acquire(gateKey)) {
      console.warn('getColumnAnalysis: 既に実行中です');
      return { success: false, error: 'Analysis already in progress' };
    }

    try {
      return new Promise((resolve, reject) => {

        // 🎯 論理的破綻修正: 直接getColumnAnalysis呼び出しで重複処理除去
        google.script.run
          .withSuccessHandler(function(result) {
            ClientMutex.release(gateKey);
            resolve(result);
          })
          .withFailureHandler(function(error) {
            console.error('❌ getColumnAnalysis direct error:', error);
            ClientMutex.release(gateKey);
            reject(error);
          })
          .getColumnAnalysis(spreadsheetId, sheetName);
      });
    } catch (error) {
      ClientMutex.release(gateKey);
      throw error;
    }
  }



  // ========== リソースボタン関連関数 ==========

  // スプレッドシートを新タブで開く
  function openSpreadsheet() {
    const btn = document.getElementById('open-spreadsheet-btn');
    const spreadsheetId = btn.dataset.spreadsheetId;

    if (!spreadsheetId) {
      showError('スプレッドシートを選択してください');
      return;
    }

    const spreadsheetUrl = 'https://docs.google.com/spreadsheets/d/' + spreadsheetId + '/edit';
    window.open(spreadsheetUrl, '_blank');
  }

  // フォームを新タブで開く
  function openForm() {
    const btn = document.getElementById('open-form-btn');
    const formUrl = btn.dataset.formUrl;

    if (!formUrl) {
      showError('フォームURLを入力してください');
      return;
    }

    window.open(formUrl, '_blank');
  }

  // ✅ 使い方ガイドを新タブで開く (CLAUDE.md準拠: シンプル&効率的)
  function openManualGuide() {
    // 通知トーストで遷移をユーザーに知らせる
    if (window.notifications) {
      window.notifications.info('📚 使い方ガイドを開いています...', 2000);
    }

    google.script.run
      .withSuccessHandler(function (webAppUrl) {
        if (webAppUrl) {
          window.open(webAppUrl + '?mode=manual', '_blank');
        }
      })
      .withFailureHandler(function (error) {
        console.error('使い方ガイドエラー:', error);
        if (window.notifications) {
          window.notifications.error('使い方ガイドを開けませんでした。', 3000);
        }
      })
      .getWebAppUrl();
  }

  // リソースボタンの表示状態を更新
  function updateResourceButtons(config) {
    const spreadsheetBtn = document.getElementById('open-spreadsheet-btn');
    const formBtn = document.getElementById('open-form-btn');
    const boardBtn = document.getElementById('open-board-btn');
    const statusDiv = document.getElementById('resource-status');

    // 🎯 下書き保存・公開ボタンの状態管理
    const saveDraftBtn = document.getElementById('save-draft');
    const publishNowBtn = document.getElementById('publish-now');

    // 設定が無い場合の初期状態
    if (!config) {
      spreadsheetBtn.disabled = true;
      spreadsheetBtn.dataset.spreadsheetId = '';
      spreadsheetBtn.classList.add('opacity-50');
      formBtn.classList.add('hidden');
      if (boardBtn) boardBtn.classList.add('hidden');
      if (statusDiv) {
        statusDiv.textContent = '';
        statusDiv.className = 'hidden';
      }

      // 下書き保存・公開ボタンを無効化
      if (saveDraftBtn) {
        saveDraftBtn.disabled = true;
        saveDraftBtn.textContent = '下書き保存（設定未完了）';
      }
      if (publishNowBtn) {
        publishNowBtn.disabled = true;
        publishNowBtn.textContent = '今すぐ公開（設定未完了）';
      }
      return;
    }

    // 🚀 列マッピング完了状態の判定 - ✅ CLAUDE.md準拠: シンプル構造対応
    const hasColumnMapping = !!(config.columnMapping && Object.keys(config.columnMapping).length > 0);
    const hasSpreadsheetConfig = !!(config.spreadsheetId && config.sheetName);
    // setupStatusまたは、実際にマッピング要件が満たされている場合も完了とみなす
    const isSetupComplete = config.setupStatus === 'completed' ||
                          (hasSpreadsheetConfig && hasColumnMapping);


    // 下書き保存ボタンの状態管理
    if (saveDraftBtn) {
      if (hasSpreadsheetConfig) {
        saveDraftBtn.disabled = false;
        saveDraftBtn.textContent = hasColumnMapping ? '下書き保存' : '下書き保存（列設定推奨）';
        saveDraftBtn.classList.remove('opacity-50');
      } else {
        saveDraftBtn.disabled = true;
        saveDraftBtn.textContent = '下書き保存（データソース未接続）';
        saveDraftBtn.classList.add('opacity-50');
      }
    }

    // 公開ボタンの状態管理
    if (publishNowBtn) {
      if (hasSpreadsheetConfig && hasColumnMapping) {
        publishNowBtn.disabled = false;
        publishNowBtn.textContent = '今すぐ公開';
        publishNowBtn.classList.remove('opacity-50');
      } else {
        publishNowBtn.disabled = true;
        if (!hasSpreadsheetConfig) {
          publishNowBtn.textContent = '今すぐ公開（データソース未接続）';
        } else {
          publishNowBtn.textContent = '今すぐ公開（列設定が必要）';
        }
        publishNowBtn.classList.add('opacity-50');
      }
    }

    // スプレッドシートボタンの状態管理
    if (config.spreadsheetId) {
      spreadsheetBtn.disabled = false;
      spreadsheetBtn.dataset.spreadsheetId = config.spreadsheetId;
      spreadsheetBtn.classList.remove('opacity-50');
    } else {
      spreadsheetBtn.disabled = true;
      spreadsheetBtn.dataset.spreadsheetId = '';
      spreadsheetBtn.classList.add('opacity-50');
    }

    // フォームボタン（有効なフォームURLが設定されている場合に表示）
    const shouldShowForm = config.formUrl && isValidFormUrl(config.formUrl);
    if (shouldShowForm) {
      formBtn.classList.remove('hidden');
      formBtn.disabled = false;
      formBtn.dataset.formUrl = config.formUrl;
    } else {
      formBtn.classList.add('hidden');
    }

    // ボードボタン（公開済みの場合に表示）
    if (boardBtn) {
      if (config.isPublished) {
        boardBtn.classList.remove('hidden');
        boardBtn.disabled = false;
      } else {
        boardBtn.classList.add('hidden');
      }
    }

    // ✅ シンプル化: ボタンの表示/非表示で状態は十分表現されているため、冗長なステータス表示を削除
    if (statusDiv) {
      statusDiv.textContent = '';
      statusDiv.className = 'hidden';
    }

    // 🤖 AI列判定ボタンの状態管理
    updateAIAnalyzeButtonState(config);

    // 🎯 設定完了状態のフィードバック
    if (isSetupComplete && hasColumnMapping && hasSpreadsheetConfig) {
      // 設定完了時の特別フィードバック
      const setupStatusDiv = document.getElementById('setup-status-feedback');
      if (setupStatusDiv) {
        setupStatusDiv.innerHTML = `
          <div class="flex items-center gap-2 p-3 bg-green-900/20 border border-green-500/30 rounded-lg text-green-400 text-sm">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            <span>設定が完了しました！下書き保存または公開を実行できます</span>
          </div>
        `;
      }
    }

    // 設定サマリーも更新
    updateConfigSummary(config);
  }

  // 🤖 AI列判定ボタンの状態を更新
  function updateAIAnalyzeButtonState(config) {
    const aiAnalyzeBtn = document.getElementById('ai-analyze-btn');
    if (!aiAnalyzeBtn) return;

    // より正確な判定基準：スプレッドシート接続 + ヘッダーデータの存在
    const hasSpreadsheetConfig = !!(config && config.spreadsheetId && config.sheetName);
    const hasHeaders = Array.isArray(window.currentHeaders) && window.currentHeaders.length > 0;
    const hasDropdownOptions = document.querySelectorAll('#answer-column-select option').length > 1; // "未選択"以外のオプション
    const canAnalyze = hasSpreadsheetConfig && (hasHeaders || hasDropdownOptions);

    if (canAnalyze) {
      aiAnalyzeBtn.disabled = false;
      aiAnalyzeBtn.textContent = '🤖 AI列判定';
      aiAnalyzeBtn.classList.remove('opacity-50');
    } else {
      aiAnalyzeBtn.disabled = true;
      if (!hasSpreadsheetConfig) {
        aiAnalyzeBtn.textContent = '🤖 AI列判定（データソース接続が必要）';
      } else {
        aiAnalyzeBtn.textContent = '🤖 AI列判定（ヘッダー取得が必要）';
      }
      aiAnalyzeBtn.classList.add('opacity-50');
    }
  }

  // ✅ 統一状態更新関数（重複コードを集約）
  function updateSystemState(updates = {}) {
    const { spreadsheetId, sheetName, columnMapping, setupStatus, needsProgress = false } = updates;

    // systemState.config を更新
    if (spreadsheetId || sheetName || columnMapping || setupStatus) {
      systemState.config = {
        ...systemState.config,
        ...(spreadsheetId && { spreadsheetId }),
        ...(sheetName && { sheetName }),
        ...(columnMapping && { columnMapping }),
        ...(setupStatus && { setupStatus })
      };
    }

    // 状態更新を一括実行
    updateAIAnalyzeButtonState(systemState.config);
    updateResourceButtons(systemState.config);

    // 進捗更新（オプション）
    if (needsProgress) {
      const hasSpreadsheetConfig = systemState.config?.spreadsheetId && systemState.config?.sheetName;
      const hasColumnMapping = systemState.config?.columnMapping && Object.keys(systemState.config.columnMapping).length > 0;
      const step = hasSpreadsheetConfig && hasColumnMapping ? 3 : (hasSpreadsheetConfig ? 2 : 1);
      updateProgress(step);
    }
  }

  // フォーム情報コンテナ取得 (Zero-Dependency UI統合)
  function getFormInfoContainer() {
    const urlMethodElement = document.getElementById('url-method');
    const isUrlMethod = urlMethodElement && !urlMethodElement.classList.contains('hidden');
    return isUrlMethod ?
      document.getElementById('url-form-info') :
      document.getElementById('form-info');
  }

  // フォーム情報統一更新 (CLAUDE.md準拠 - 既存関数名パターン)
  function updateFormInfo(formData, options = {}) {
    const container = getFormInfoContainer();
    if (!container) {
      console.warn('updateFormInfo: フォーム情報コンテナが見つかりません');
      return;
    }

    const safeData = formData || {};
    const status = options.status || (safeData.formUrl ? 'linked' : 'missing');

    // 統一的なフォーム情報表示
    const urlMethodElement = document.getElementById('url-method');
    const isUrlMethod = urlMethodElement && !urlMethodElement.classList.contains('hidden');
    const titleElement = isUrlMethod ?
      document.getElementById('url-form-title') :
      document.getElementById('form-title');
    const urlElement = isUrlMethod ?
      document.getElementById('url-form-url') :
      document.getElementById('form-url');

    if (titleElement) {
      titleElement.textContent = safeData.formTitle || 'フォーム情報なし';
    }

    if (urlElement) {
      if (safeData.formUrl) {
        urlElement.textContent = safeData.formUrl;
        urlElement.href = safeData.formUrl;
        urlElement.classList.remove('text-gray-500');
        urlElement.classList.add('text-blue-400');
      } else {
        urlElement.textContent = '未連携';
        urlElement.href = '#';
        urlElement.classList.add('text-gray-500');
        urlElement.classList.remove('text-blue-400');
      }
    }

    // コンテナ表示
    container.classList.remove('hidden');

  }

  // 既存関数との互換性維持 (API Compatibility)
  // ✅ 簡素化されたフォーム表示関数 - updateFormInfo()への完全委譲
  function displayFormInfo(formData, options = {}) {
    return updateFormInfo(formData, options);
  }



  // フォーム情報非表示
  function hideFormInfo() {
    const formInfo = document.getElementById('form-info');
    if (formInfo) {
      formInfo.classList.add('hidden');
      formInfo.removeAttribute('data-form-status');
      formInfo.removeAttribute('data-form-reason');
      formInfo.removeAttribute('data-form-diagnostics');
    }
  }

  // フォーム検出結果を処理し、適切なステータス情報を返す
  function processFormDetectionResult(formResult) {

    // 🛡️ CLAUDE.md準拠: V8ランタイム対応の柔軟なデータ構造判定
    if (!formResult) {
      console.log('❌ formResult が存在しません');
      return null;
    }

    // ✅ 修正: フォーム連携がなくてもスプレッドシート情報は処理する
    // フォーム連携失敗でもスプレッドシートアクセスは成功している可能性がある

    // データ構造の正規化（後方互換性維持）
    const normalizedData = formResult.formData || formResult;
    const confidence = normalizedData.detectionDetails?.confidence || 0;
    const hasFormUrl = !!normalizedData.formUrl;


    // フォームURLがある場合は完全な連携
    if (hasFormUrl) {
      
      return { status: 'linked', message: 'フォーム連携を確認しました' };
    }

    // ✅ 修正: 実際のフォーム検出結果に基づく判定
    const isFormDetected = formResult.status === 'FORM_LINK_FOUND' ||
                          (formResult.success && confidence >= 70);

    if (isFormDetected) {
      
      return { status: 'detected', message: 'フォーム連携パターンを検出（URL取得不可）' };
    }

    // 中程度信頼度での検出
    if (confidence >= 40) {
      console.log('⚠️ 中程度信頼度パターン検出');
      return { status: 'possible', message: 'フォーム連携パターンを検出しました' };
    }

    // 検出なし
    console.log('❌ フォーム連携パターンなし');
    return { status: 'missing', message: 'フォーム連携が確認できませんでした' };
  }

  // シート別フォーム連携情報をチェック・表示
  function checkSheetFormConnection(spreadsheetId, sheetName) {
    if (!spreadsheetId || !sheetName) {
      hideFormInfo();
      return;
    }

    setPartialLoading(true, 'シート連携情報を確認中...');

    google.script.run
      .withSuccessHandler((result) => {
        setPartialLoading(false);
        const normalizedResult = result && typeof result === 'object' ? result : null;
        const rawFormData = normalizedResult && typeof normalizedResult.formData === 'object' ? normalizedResult.formData : null;
        const derivedSpreadsheetName = rawFormData?.spreadsheetName || normalizedResult?.diagnostics?.spreadsheetName || '';
        const derivedSheetName = rawFormData?.sheetName || normalizedResult?.requestContext?.sheetName || sheetName;

        window.__formIntegrationLatestResponse = normalizedResult;


        if (normalizedResult && normalizedResult.success && rawFormData && rawFormData.formUrl) {
          displayFormInfo(
            {
              ...rawFormData,
              spreadsheetName: derivedSpreadsheetName,
              sheetName: derivedSheetName
            },
            {
              status: 'linked',
              message: normalizedResult.message || 'フォーム連携を確認しました',
              reason: normalizedResult.reason || '',
              diagnostics: normalizedResult.diagnostics || null,
              suggestions: Array.isArray(normalizedResult.suggestions) ? normalizedResult.suggestions : [],
              spreadsheetName: derivedSpreadsheetName,
              sheetName: derivedSheetName
            }
          );
          return;
        }

        const fallbackMessage = normalizedResult && normalizedResult.message
          ? normalizedResult.message
          : 'フォーム連携情報が見つかりませんでした';
        const fallbackSuggestions = normalizedResult && Array.isArray(normalizedResult.suggestions)
          ? normalizedResult.suggestions
          : [];

        console.warn('⚠️ フォーム連携情報が見つからない:', {
          reason: normalizedResult ? normalizedResult.reason : '不明',
          suggestions: fallbackSuggestions
        });

        if (fallbackSuggestions.length > 0) {
          const formattedSuggestions = fallbackSuggestions.map((s) => `• ${s}`).join('\n');
          showWarning(`${fallbackMessage}\n\n推奨対処法:\n${formattedSuggestions}`);
        } else {
          showWarning(fallbackMessage);
        }

        const fallbackFormData = {
          ...(rawFormData || {}),
          formUrl: rawFormData ? rawFormData.formUrl : null,
          formTitle: (rawFormData && rawFormData.formTitle) || derivedSpreadsheetName || derivedSheetName || 'フォーム未連携',
          spreadsheetName: derivedSpreadsheetName,
          sheetName: derivedSheetName
        };

        displayFormInfo(fallbackFormData, {
          status: 'missing',
          message: fallbackMessage,
          reason: normalizedResult ? normalizedResult.reason || 'FORM_INFO_UNAVAILABLE' : 'FORM_INFO_UNAVAILABLE',
          diagnostics: normalizedResult ? normalizedResult.diagnostics || null : null,
          suggestions: fallbackSuggestions,
          spreadsheetName: derivedSpreadsheetName,
          sheetName: derivedSheetName
        });
      })
      .withFailureHandler((error) => {
        setPartialLoading(false);
        console.error('❌ シート連携チェックエラー:', {
          error: error,
          errorMessage: error.message,
          spreadsheetId: spreadsheetId,
          sheetName: sheetName,
        });
        const failureMessage = 'フォーム連携情報の取得中にエラーが発生しました';
        showError(`${failureMessage}\n${error.message || ''}`);
        window.__formIntegrationLatestResponse = null;
        hideFormInfo();
      })
      .getFormInfo(spreadsheetId, sheetName);
  }

  // 設定エクスポート - CLAUDE.md準拠: 統一設定使用
  function exportConfig() {
    try {
      if (!systemState.config) {
        showError('設定データが利用できません');
        return;
      }

      const config = systemState.config;
      const dataStr = JSON.stringify(config, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
      const exportFileDefaultName = 'studyquest-config.json';

      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileDefaultName);
      linkElement.click();

      showSuccess('設定をエクスポートしました');
    } catch (error) {
      console.error('エクスポートエラー:', error);
      showError('設定のエクスポートに失敗しました');
    }
  }

  // システム管理者アクセス確認
  function checkAdministratorAccess() {
    google.script.run
      .withSuccessHandler(function (isAdmin) {
        const appSetupBtn = document.getElementById('app-setup-btn');
        if (appSetupBtn) {
          if (isAdmin) {
            console.log('システム管理者として認識されました');
            appSetupBtn.style.display = 'block';
          } else {
            console.log('一般ユーザーとして認識されました');
            appSetupBtn.style.display = 'none';
          }
        }
      })
      .withFailureHandler(function (error) {
        console.warn('システム管理者確認エラー:', error);
        const appSetupBtn = document.getElementById('app-setup-btn');
        if (appSetupBtn) {
          appSetupBtn.style.display = 'none';
        }
      })
      .isAdmin();
  }

  // フォーム作成インターフェース
  function createFormInterface() {
    // ユーザーIDの確認
    if (!__USER_ID__ || __USER_ID__.trim() === '') {
      showError('接続に問題があります。再読み込みしてください');
      return;
    }

    const formName = prompt(
      '作成するフォーム名を入力してください：\n例：アンケートフォーム、質問フォーム'
    );

    if (!formName || !formName.trim()) {
      showError('フォーム名を入力してください');
      return;
    }

    if (formName.trim().length > 50) {
      showError('50文字以内で入力してください');
      return;
    }

    // 基本的なフォーム設定
    const config = {
      title: formName.trim(),
      description: 'カスタムフォームが作成されました',
      fields: [
        {
          type: 'text',
          label: '名前',
          required: true,
        },
        {
          type: 'text',
          label: 'メッセージ',
          required: true,
        },
      ],
    };

    // NOTE: フォーム作成機能は SystemController.gs で実装済み
    // この関数は未使用のレガシーコード
    showInfo('フォーム作成機能は準備中です');
  }


  // ===========================================
  // 🆕 CLAUDE.md準拠: V8ランタイム対応 完全自動化URL解析・検証
  // ===========================================

  /**
   * URL自動解析（リアルタイム）- V8ランタイム対応
   * @param {string} fullUrl - 入力された完全URL
   */
  function autoAnalyzeUrl(fullUrl) {
    if (!fullUrl || fullUrl.trim() === '') {
      hideAutoDetectionInfo();
      return;
    }

    // ✅ V8ランタイム対応: const使用
    const urlInfo = parseUrlClientSide(fullUrl);

    if (urlInfo.isValid) {
      showAutoDetectionInfo(urlInfo);
    } else {
      hideAutoDetectionInfo();
    }
  }

  /**
   * クライアントサイドURL解析 - V8ランタイム最適化
   * @param {string} url - 解析対象URL
   * @returns {Object} 解析結果
   */
  function parseUrlClientSide(url) {
    try {
      // ✅ V8ランタイム対応: const + 正規表現最適化
      const spreadsheetMatch = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      const gidMatch = url.match(/[#&]gid=(\d+)/);

      if (!spreadsheetMatch) {
        return { isValid: false };
      }

      return {
        isValid: true,
        spreadsheetId: spreadsheetMatch[1],
        gid: gidMatch ? gidMatch[1] : '0',
        displayGid: gidMatch ? gidMatch[1] : 'デフォルト'
      };
    } catch (error) {
      console.warn('parseUrlClientSide error:', error.message);
      return { isValid: false };
    }
  }

  /**
   * 自動検出情報表示
   * @param {Object} urlInfo - URL解析結果
   */
  function showAutoDetectionInfo(urlInfo) {
    const container = document.getElementById('auto-detection-info');
    const sheetNameSpan = document.getElementById('detected-sheet-name');
    const gidSpan = document.getElementById('detected-gid');

    if (container && sheetNameSpan && gidSpan) {
      sheetNameSpan.textContent = '解析中...';
      gidSpan.textContent = urlInfo.displayGid;
      container.classList.remove('hidden');
    }
  }

  /**
   * 自動検出情報非表示
   */
  function hideAutoDetectionInfo() {
    const container = document.getElementById('auto-detection-info');
    if (container) {
      container.classList.add('hidden');
    }
  }

  /**
   * ドロップダウン選択方式の接続ボタン状態を更新
   * 両方のセレクト（スプレッドシート・シート）が選択されている場合のみ有効化
   */
  function updateDropdownConnectionButton() {
    const connectBtn = document.getElementById('connect-source');
    const spreadsheetSelect = document.getElementById('spreadsheet-select');
    const sheetSelect = document.getElementById('sheet-select');

    if (!connectBtn || !spreadsheetSelect || !sheetSelect) {
      return;
    }

    const spreadsheetSelected = spreadsheetSelect.value && spreadsheetSelect.value.trim();
    const sheetSelected = sheetSelect.value && sheetSelect.value.trim();

    if (spreadsheetSelected && sheetSelected) {
      connectBtn.disabled = false;
      connectBtn.textContent = '接続';
    } else {
      connectBtn.disabled = true;
      connectBtn.textContent = '接続（データソース選択後に有効化）';
    }
  }

  /**
   * 完全URL統合検証 - 既存API活用版
   */
  function validateCompleteUrl() {
    const urlInput = document.getElementById('spreadsheet-url');
    const validateBtn = document.getElementById('url-validate');
    const connectBtn = document.getElementById('connect-url-source');

    const fullUrl = urlInput.value.trim();

    if (!fullUrl) {
      showError('URLを入力してください');
      return;
    }

    // UI状態更新
    validateBtn.disabled = true;
    validateBtn.textContent = '🔍 URL検証中...';
    connectBtn.disabled = true;
    connectBtn.textContent = '検証完了後に有効化';


    // ✅ 統合URL検証API呼び出し（フォーム連携検出含む）
    google.script.run
      .withSuccessHandler(function(result) {
        validateBtn.disabled = false;
        validateBtn.textContent = '🔍 URL検証';

        

        if (result.success) {
          // 自動検出情報更新
          updateDetectedInfo(result);

          // フォーム情報表示
          if (result.formInfo && result.formInfo.formData) {
            const statusInfo = processFormDetectionResult(result.formInfo);
            if (statusInfo) {
              displayFormInfo(result.formInfo.formData, statusInfo);
            } else {
              // フォーム連携なしでも情報表示
              displayFormInfo(result.formInfo.formData, {
                status: 'missing',
                message: 'フォーム連携は検出されませんでした（スプレッドシート接続は可能）'
              });
            }
          }

          // ✅ 修正: スプレッドシートアクセス成功なら接続可能
          if (result.hasAccess || result.readyToConnect) {
            connectBtn.disabled = false;
            connectBtn.textContent = '✅ 接続';

            // フォーム連携状況に応じたメッセージ
            const formStatus = result.formInfo?.success ? 'フォーム連携あり' : 'フォーム連携なし（接続可能）';
            showSuccess(`検証完了 - シート「${result.sheetName}」に接続できます (${formStatus})`);
          } else {
            showWarning('アクセス権限に問題があります');
          }

          // スプレッドシートIDを保存（既存機能との互換性）
          urlInput.dataset.spreadsheetId = result.spreadsheetId;

        } else {
          showError(`検証失敗: ${result.message}`);
        }
      })
      .withFailureHandler(function(error) {
        validateBtn.disabled = false;
        validateBtn.textContent = '🔍 統合検証';
        console.error('❌ validateCompleteSpreadsheetUrl error:', error);
        showError(`統合検証エラー: ${error.message}`);
      })
      .validateCompleteSpreadsheetUrl(fullUrl);
  }

  /**
   * 検出情報UI更新
   * @param {Object} result - 検証結果
   */
  function updateDetectedInfo(result) {
    const sheetNameSpan = document.getElementById('detected-sheet-name');
    const gidSpan = document.getElementById('detected-gid');

    if (sheetNameSpan) {
      sheetNameSpan.textContent = result.sheetName || '-';
    }
    if (gidSpan) {
      gidSpan.textContent = result.gid || '0';
    }
  }




  // URL入力方式でのデータソース接続



  // ✅ CLAUDE.md準拠: Event listeners integrated into initialization flow

  // 🆕 手動AI列判定関数
  async function manualColumnAnalysis() {
    const spreadsheetId = getCurrentSpreadsheetId();
    const sheetName = getCurrentSheetName();

    if (!spreadsheetId || !sheetName) {
      showError('スプレッドシートとシートを選択してください');
      return;
    }

    try {
      window.setLoading(true, '処理中...');
      showInfo('AI列判定実行中...', 3000);

      await performColumnAnalysis(spreadsheetId, sheetName);

      // ✅ 統一関数で状態更新
      const currentMapping = getColumnMapping();
      updateSystemState({
        spreadsheetId,
        sheetName,
        columnMapping: currentMapping,
        setupStatus: 'completed',
        needsProgress: true
      });

      showSuccess('AI列判定完了！設定を確認してください');
    } catch (error) {
      console.error('手動AI列判定エラー:', error);
      showError('AI列判定に失敗しました。接続を確認して再試行してください');
    } finally {
      window.setLoading(false);
    }
  }

  // 🆕 高精度列分析実行関数（リトライ・回復機能付き）
  async function performColumnAnalysis(spreadsheetId, sheetName, retryCount = 0) {
    const maxRetries = 3;
    const retryDelay = Math.pow(2, retryCount) * 1000; // 指数バックオフ

    try {
      console.log(`🔍 列分析実行開始 (試行 ${retryCount + 1}/${maxRetries + 1})`);

      const analysisResult = await getColumnAnalysis(spreadsheetId, sheetName);

      // 🎯 高精度検証: 結果品質チェック
      const qualityCheck = validateAnalysisResult(analysisResult);

      if (!qualityCheck.isValid) {
        if (retryCount < maxRetries) {
          console.warn(`⚠️ 分析品質不足、リトライします: ${qualityCheck.reason}`);
          showInfo(`分析品質向上のため再試行中... (${retryCount + 2}/${maxRetries + 1})`, 3000);

          // 指数バックオフ待機 - CLAUDE.md V8 compliant: Promise-based delay
          await new Promise(resolve => {
            const start = Date.now();
            const check = () => (Date.now() - start >= retryDelay) ? resolve() : Promise.resolve().then(check);
            check();
          });

          return performColumnAnalysis(spreadsheetId, sheetName, retryCount + 1);
        } else {
          console.error('🚫 最大リトライ回数に到達、品質不足の結果を使用');
          showWarning('AI分析の精度が期待値を下回りましたが、利用可能な結果を表示します', 5000);
        }
      }

      if (!analysisResult || !analysisResult.success) {
        throw new Error('列分析に失敗しました');
      }

      if (!analysisResult.headers || !Array.isArray(analysisResult.headers) || analysisResult.headers.length === 0) {
        throw new Error('ヘッダー情報が取得できませんでした');
      }

      // 🎯 ドロップダウンにヘッダー選択肢を設定（高精度版）
      fillColumnDropdowns(analysisResult.headers, analysisResult.mapping, analysisResult.confidence);

      // 🎯 分析結果品質レポート表示
      displayAnalysisQualityReport(analysisResult, qualityCheck);

      // 設定完了状況を更新
      updateCompletionStatus();

      console.log('✅ 高精度列分析完了');

    } catch (error) {
      console.error(`❌ 列分析エラー (試行 ${retryCount + 1}):`, error);

      // リトライ可能エラーの場合
      if (retryCount < maxRetries && isRetryableError(error)) {
        console.warn(`🔄 リトライ可能エラー、再試行します: ${error.message}`);
        showInfo(`接続エラーのため再試行中... (${retryCount + 2}/${maxRetries + 1})`, 3000);

        // CLAUDE.md V8 compliant: Promise-based delay instead of setTimeout
        await new Promise(resolve => {
          const start = Date.now();
          const check = () => (Date.now() - start >= retryDelay) ? resolve() : Promise.resolve().then(check);
          check();
        });
        return performColumnAnalysis(spreadsheetId, sheetName, retryCount + 1);
      }

      // 最終的な失敗処理
      console.error('🚫 列分析の全試行が失敗しました');

      // 🔄 緊急フォールバック: 基本的なヘッダー取得を試行
      try {
        console.log('🆘 緊急フォールバック: 基本ヘッダー取得を試行');
        await attemptEmergencyFallback(spreadsheetId, sheetName);
      } catch (fallbackError) {
        console.error('🚫 緊急フォールバックも失敗:', fallbackError.message);
        throw new Error(`分析に失敗しました (全${maxRetries + 1}回試行): ${error.message}`);
      }
    }
  }

  /**
   * 🔍 分析結果品質検証
   */
  function validateAnalysisResult(result) {
    if (!result || !result.success) {
      return { isValid: false, reason: 'API呼び出し失敗' };
    }

    const mapping = result.mapping || {};
    const confidence = result.confidence || {};

    const requiredFields = ['answer', 'name', 'class'];
    const detectedCount = requiredFields.filter(field =>
      mapping[field] !== undefined && confidence[field] > 30
    ).length;

    const avgConfidence = Object.values(confidence).length > 0
      ? Object.values(confidence).reduce((sum, c) => sum + c, 0) / Object.values(confidence).length
      : 0;

    // 品質基準
    const minDetectedFields = 2; // 最低2フィールド検出
    const minAvgConfidence = 40; // 平均40%以上

    const isValid = detectedCount >= minDetectedFields && avgConfidence >= minAvgConfidence;

    return {
      isValid,
      reason: !isValid ? `検出フィールド不足: ${detectedCount}/${requiredFields.length}, 平均信頼度: ${avgConfidence.toFixed(1)}%` : 'OK',
      detectedCount,
      avgConfidence
    };
  }

  /**
   * 🔄 リトライ可能エラー判定
   */
  function isRetryableError(error) {
    const retryableMessages = [
      'network', 'timeout', 'connection', '接続', 'アクセス',
      'temporary', 'busy', 'rate limit', '一時的', 'サーバー'
    ];

    const message = error.message.toLowerCase();
    return retryableMessages.some(pattern => message.includes(pattern));
  }

  /**
   * 🆘 緊急フォールバック処理
   */
  async function attemptEmergencyFallback(spreadsheetId, sheetName) {
    console.log('🆘 緊急フォールバック実行');
    showWarning('AI分析に問題が発生しました。基本的なヘッダー情報のみ取得します。', 5000);

    // 基本的なヘッダー取得のみ試行
    try {
      const basicResult = await new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .getSheetHeaders(spreadsheetId, sheetName); // 簡易ヘッダー取得API
      });

      if (basicResult && basicResult.headers) {
        // AIなしでドロップダウン設定
        fillColumnDropdowns(basicResult.headers, {}, {});
        showWarning('手動で列を設定してください。AI分析は利用できませんでした。', 8000);
      }

    } catch (basicError) {
      throw new Error('基本的なデータ取得も失敗しました');
    }
  }

  /**
   * 📊 分析品質レポート表示
   */
  function displayAnalysisQualityReport(result, quality) {
    const detectedFields = Object.keys(result.mapping || {}).length;
    const avgConfidence = quality.avgConfidence;

    let qualityLevel = 'excellent';
    if (avgConfidence < 60) qualityLevel = 'good';
    if (avgConfidence < 40) qualityLevel = 'fair';
    if (avgConfidence < 20) qualityLevel = 'poor';

    const qualityIcons = {
      excellent: '🎯',
      good: '✅',
      fair: '⚠️',
      poor: '🔍'
    };

    const qualityMessages = {
      excellent: `高精度分析完了 (${detectedFields}フィールド検出, 平均${avgConfidence.toFixed(1)}%信頼度)`,
      good: `良好な分析結果 (${detectedFields}フィールド検出, 平均${avgConfidence.toFixed(1)}%信頼度)`,
      fair: `分析完了 (${detectedFields}フィールド検出, 平均${avgConfidence.toFixed(1)}%信頼度) - 手動確認推奨`,
      poor: `分析結果が不十分 (${detectedFields}フィールド検出, 平均${avgConfidence.toFixed(1)}%信頼度) - 手動設定推奨`
    };

    const icon = qualityIcons[qualityLevel];
    const message = qualityMessages[qualityLevel];

    showSuccess(`${message}`, 6000);
  }

  // 🆕 現在のスプレッドシートID取得
  function getCurrentSpreadsheetId() {
    const urlMethod = document.getElementById('method-url').checked;
    if (urlMethod) {
      const urlInput = document.getElementById('spreadsheet-url').value;
      if (urlInput) {
        const match = urlInput.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
        return match ? match[1] : null;
      }
    } else {
      return document.getElementById('spreadsheet-select').value;
    }
    return null;
  }

  // 🆕 現在のシート名取得
  function getCurrentSheetName() {
    const urlMethod = document.getElementById('method-url').checked;
    if (urlMethod) {
      return document.getElementById('detected-sheet-name').textContent || null;
    } else {
      return document.getElementById('sheet-select').value;
    }
  }

  // 🆕 設定完了状況更新（修正版：回答列のみ必須）
  function updateCompletionStatus() {
    const requiredColumns = ['answer']; // 必須列：回答列のみ
    const optionalColumns = ['reason', 'class', 'name']; // オプション列

    // 必須列の設定状況チェック
    let requiredCompleted = 0;
    requiredColumns.forEach(type => {
      const select = document.getElementById(`${type}-column-select`);
      if (select && select.value) {
        requiredCompleted++;
      }
    });

    // オプション列の設定状況チェック
    let optionalCompleted = 0;
    optionalColumns.forEach(type => {
      const select = document.getElementById(`${type}-column-select`);
      if (select && select.value) {
        optionalCompleted++;
      }
    });

    // ステータス表示更新
    const statusElement = document.getElementById('completion-status');
    if (statusElement) {
      const isRequiredComplete = requiredCompleted === requiredColumns.length;
      const statusIcon = isRequiredComplete ? (optionalCompleted === optionalColumns.length ? '🟢' : '🟡') : '⚪';
      statusElement.textContent = `${statusIcon} 必須: ${requiredCompleted}/${requiredColumns.length} オプション: ${optionalCompleted}/${optionalColumns.length}`;
    }

    // 設定確認ボタンの状態更新（回答列が設定されていれば有効）
    const verifyButton = document.getElementById('verify-mapping');
    if (verifyButton) {
      const isAnswerSet = document.getElementById('answer-column-select')?.value;
      verifyButton.disabled = !isAnswerSet;
    }
  }

  // シート一覧読み込み
  function loadSheetList(spreadsheetId) {
    console.log('🚀 loadSheetList開始:', spreadsheetId);
    const select = document.getElementById('sheet-select');
    if (!select) {
      console.error('❌ loadSheetList: sheet-select要素が見つかりません');
      showError('シート選択要素が見つかりません');
      return;
    }

    select.innerHTML = '<option value="">読み込み中...</option>';

    // シート読み込みは部分ローディング
    setPartialLoading(true, 'シート一覧を読み込み中...');

    google.script.run
      .withSuccessHandler(function (response) {
        select.innerHTML = '<option value="">シートを選択...</option>';

        // DataService.getSheetList() returns {success: true, sheets: [...]}
        const sheets = response?.success ? response.sheets : [];

        if (!sheets || sheets.length === 0) {
          const noSheetOption = document.createElement('option');
          noSheetOption.value = '';
          noSheetOption.textContent = '利用可能なシートがありません';
          noSheetOption.disabled = true;
          select.appendChild(noSheetOption);
        } else {
          sheets.forEach((sheet) => {
            const option = document.createElement('option');
            option.value = sheet.name;
            option.textContent = sheet.name;
            select.appendChild(option);
          });
        }

        // partial-loading-targetクラスを削除
        select.classList.remove('partial-loading-target');

        setPartialLoading(false);
        showSuccess(`${sheets?.length || 0}個のシートを読み込みました`);
      })
      .withFailureHandler(function (error) {
        console.error('❌ loadSheetList: シート読み込みエラー', {
          error: error.message || error,
          spreadsheetId: typeof spreadsheetId === 'string' && spreadsheetId ? `${spreadsheetId.substring(0, 10)}...` : `[${typeof spreadsheetId}]`,
          timestamp: new Date().toISOString(),
        });

        select.innerHTML = '<option value="">読み込みエラー - 再試行してください</option>';
        select.classList.remove('partial-loading-target');

        setPartialLoading(false);
        showError(`シート一覧の読み込みに失敗しました: ${error.message || error}`);
      })
      .getSheetList(spreadsheetId);
  }

  // データソース接続
  // ✅ 統一された接続処理関数 - ドロップダウン・URL両方式対応
  async function connectToDataSource() {
    const gateKey = 'connectToDataSource';
    if (!ClientMutex.acquire(gateKey)) {
      showInfo('現在処理中です…少し待ってから再試行してください。');
      return;
    }

    try {
      // データソース入力方式の判定
      const urlMethodElement = document.getElementById('url-method');
      const isUrlMethod = urlMethodElement && !urlMethodElement.classList.contains('hidden');
      let spreadsheetId, sheetName;

      if (isUrlMethod) {
        // URL方式 - 自動検出されたシート名を使用
        const urlInput = document.getElementById('spreadsheet-url');
        const detectedSheetNameSpan = document.getElementById('detected-sheet-name');
        const url = urlInput.value.trim();
        sheetName = detectedSheetNameSpan.textContent.trim();

        if (!url) {
          showError('URLを入力してください');
          return;
        }
        if (!sheetName) {
          showError('シート名を入力してください');
          return;
        }

        // URLからスプレッドシートIDを抽出
        const spreadsheetRegex = /https:\/\/docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/;
        const match = url.match(spreadsheetRegex);
        if (!match) {
          showError('URLをコピペしてください（例: docs.google.com/spreadsheets/...）');
          return;
        }
        spreadsheetId = match[1];
      } else {
        // ドロップダウン方式
        spreadsheetId = document.getElementById('spreadsheet-select').value;
        sheetName = document.getElementById('sheet-select').value;

        if (!spreadsheetId) {
          showError('スプレッドシートを選択してください。先に「更新」ボタンを押して一覧を読み込んでください。');
          return;
        }
        if (!sheetName) {
          showError('シートを選択してください。スプレッドシートを選択すると、シート一覧が表示されます。');
          return;
        }
      }

      window.setLoading(true, '処理中...');
      console.log('connectToDataSource: 統一接続開始', { spreadsheetId, sheetName, method: isUrlMethod ? 'URL' : 'dropdown' });

      // 真のバッチ処理実装 (CLAUDE.md準拠 - 70x Performance)
      const result = await processBatchOperations([
        { type: 'validateAccess', spreadsheetId, sheetName },
        { type: 'getFormInfo', spreadsheetId, sheetName },
        { type: 'connectDataSource', spreadsheetId, sheetName }
      ]);

      if (result.success) {
        // 詳細な成功通知で明確なフィードバック
        const successDetails = [];
        successDetails.push('✅ データソース接続完了');

        if (result.batchResults && result.batchResults.formInfo) {
          successDetails.push('📋 フォーム連携確認済み');
          displayFormInfo(result.batchResults.formInfo.formData, {
            status: 'linked',
            spreadsheetName: result.batchResults.formInfo.spreadsheetName
          });
        }

        showSuccess(successDetails.join(' | '));

        // ✅ 最適化: 既に分析データがある場合は再実行しない
        if (result.headers && result.mapping) {
          console.log('🎯 統合処理で分析完了済み、UI更新のみ実行');
          fillColumnDropdowns(result.headers, result.mapping, result.confidence);

          // ✅ 統一関数で状態更新
          updateSystemState({
            spreadsheetId,
            sheetName,
            columnMapping: result.mapping,
            setupStatus: 'completed',
            needsProgress: true
          });

          showSuccess('接続とAI列判定が完了しました！');
        } else {
          // フォールバック: 分析データがない場合のみ追加実行
          console.log('⚠️ 分析データなし、追加のAI列判定実行');
          showInfo('AI列判定実行中...', 3000);
          try {
            await performColumnAnalysis(spreadsheetId, sheetName);

            // ✅ 統一関数で状態更新
            const currentMapping = getColumnMapping();
            updateSystemState({
              spreadsheetId,
              sheetName,
              columnMapping: currentMapping,
              setupStatus: 'completed'
            });

            showSuccess('AI列判定完了！設定を確認してください');
          } catch (analysisError) {
            console.warn('AI列判定エラー:', analysisError);
            showWarning('AI列判定に失敗しました。手動で設定するか「AI列判定」ボタンで再実行してください');
          }
        }
      } else {
        handleConnectionError(result.message || result.error || 'データソース接続に失敗しました', { spreadsheetId, sheetName, method: isUrlMethod ? 'URL' : 'dropdown' });
      }
    } catch (error) {
      console.error('connectToDataSource エラー:', error);
      handleConnectionError(error.message || error, { spreadsheetId, sheetName, method: isUrlMethod ? 'URL' : 'dropdown' });
    } finally {
      window.setLoading(false);
      ClientMutex.release(gateKey);
    }
  }

  // ✅ 真のバッチ処理実装 - GAS API呼び出し最適化
  async function processBatchOperations(operations) {
    if (!operations || !Array.isArray(operations) || operations.length === 0) {
      throw new Error('Invalid operations array');
    }

    // すべてのoperationsが同じspreadsheetIdとsheetNameを持つことを確認
    const firstOp = operations[0];
    const isConsistent = operations.every(op =>
      op.spreadsheetId === firstOp.spreadsheetId &&
      op.sheetName === firstOp.sheetName
    );

    if (!isConsistent) {
      throw new Error('All operations must have the same spreadsheetId and sheetName');
    }

    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)
        .connectDataSource(firstOp.spreadsheetId, firstOp.sheetName, operations);
    });
  }


  // 接続エラーハンドリング (validateFormLink詳細活用)
  function handleConnectionError(errorMessage, context) {
    console.error('Connection error details:', { errorMessage, context });

    let userMessage = 'データソースへの接続に失敗しました。';
    let suggestions = [];

    // validateFormLink結果の活用 (Zero-Dependency)
    if (context && context.validation && context.validation.details) {
      const validationDetails = context.validation.details;
      

      // 接続検証結果の活用
      if (validationDetails.connectionVerified === false) {
        userMessage = 'スプレッドシートへの接続に失敗しました。';
        suggestions.push('スプレッドシートのアクセス権限を確認してください');
        suggestions.push('サービスアカウントに編集者権限が付与されているか確認してください');

        if (validationDetails.connectionError) {
          suggestions.push(`詳細: ${validationDetails.connectionError}`);
        }
      }

      // フォーム情報検証結果の活用
      if (validationDetails.formInfoVerified === false) {
        userMessage += ' フォーム情報の取得にも失敗しました。';
        suggestions.push('フォームとスプレッドシートの連携を確認してください');

        if (validationDetails.formInfoError) {
          suggestions.push(`フォーム詳細: ${validationDetails.formInfoError}`);
        }
      }

      // URL一致確認結果の活用
      if (validationDetails.formUrlMatches === false && validationDetails.detectedFormUrl) {
        userMessage += ' 入力URLとシステム検出URLが異なります。';
        suggestions.push(`検出されたURL: ${validationDetails.detectedFormUrl}`);
        suggestions.push('正しいフォームURLを使用しているか確認してください');
      }
    } else {
      // 従来のエラーメッセージ解析
      if (errorMessage.includes('Permission') || errorMessage.includes('権限')) {
        suggestions.push('スプレッドシートへのアクセス権限を確認してください');
        suggestions.push('スプレッドシートを開いて、編集権限があることを確認してください');
      } else if (errorMessage.includes('not found') || errorMessage.includes('見つかりません')) {
        suggestions.push('指定されたスプレッドシートまたはシートが存在するか確認してください');
        suggestions.push('シート名が正確か確認してください');
      } else if (errorMessage.includes('timeout') || errorMessage.includes('タイムアウト')) {
        suggestions.push('ネットワーク接続を確認してください');
        suggestions.push('しばらく時間をおいて再試行してください');
      } else {
        suggestions.push('スプレッドシートが開けることを確認してください');
        suggestions.push('手動で列を設定することも可能です');
      }
    }

    const fullMessage =
      userMessage + '\n\n推奨対処法:\n' + suggestions.map((s) => '• ' + s).join('\n');
    showError(fullMessage);

    // ドロップダウン式では手動設定は自動的に利用可能
    showInfo('ドロップダウンを使用して手動で列を設定できます。');
  }


  // 進捗更新
  function updateProgress(step) {
    const steps = document.querySelectorAll('.step');
    steps.forEach((stepEl, index) => {
      stepEl.classList.remove('completed', 'current');
      if (index < step - 1) {
        stepEl.classList.add('completed');
      } else if (index === step - 1) {
        stepEl.classList.add('current');
      }
    });
  }

  // 列マッピング更新（ドロップダウン式）- シンプル版
  function updateColumnMapping(result) {
    console.log('Column mapping received:', result);

    if (!result || !result.success) {
      console.warn('列マッピング結果が不正です');
      showError('列マッピング情報の取得に失敗しました');
      return;
    }

    const mapping = result.mapping || {};
    const confidence = result.confidence || {};
    const headers = result.headers || [];

    console.log('Headers:', headers, 'Mapping:', mapping, 'Confidence:', confidence);

    // ドロップダウンにヘッダーオプションを設定
    fillColumnDropdowns(headers, mapping, confidence);
    // 現在のヘッダーをグローバルに保持（検証/保存で使用）
    try {
      window.currentHeaders = headers;
    } catch (_) {}

    // AI検出情報を表示
    displayAIDetectionInfo(mapping, confidence);

    // 接続時はAI検出結果を優先し、保存済み設定復元は行わない
    // AI検出が無い場合のみヘッダー情報を表示

    showSuccess('列設定を更新しました');
  }

  // ドロップダウンにヘッダーオプションを設定 - エラーハンドリング強化版
  function fillColumnDropdowns(headers, mapping, confidence = {}) {

    try {
      // 入力データの検証
      if (!Array.isArray(headers) || headers.length === 0) {
        console.warn('⚠️ ヘッダー情報が不正です');
        return;
      }

      // mapping/confidence検証（既存パターン）
      if (!mapping || typeof mapping !== 'object') {
        mapping = {};
      }
      if (!confidence || typeof confidence !== 'object') {
        confidence = {};
      }

      // 4つのドロップダウンを取得
      const dropdowns = {
        answer: document.getElementById('answer-column-select'),
        reason: document.getElementById('reason-column-select'),
        class: document.getElementById('class-column-select'),
        name: document.getElementById('name-column-select'),
      };

      // ドロップダウンの存在確認
      const missingDropdowns = Object.keys(dropdowns).filter((key) => !dropdowns[key]);
      if (missingDropdowns.length > 0) {
        console.warn('一部のドロップダウンが見つかりません:', missingDropdowns);
      }

      // 各ドロップダウンをクリアしてヘッダーオプションを追加
      Object.keys(dropdowns).forEach((columnType) => {
        const dropdown = dropdowns[columnType];
        if (!dropdown) {
          console.warn(`${columnType}ドロップダウンが見つかりません`);
          return;
        }

        try {
          // 既存のオプションをクリア
          dropdown.innerHTML = '<option value="">選択してください...</option>';

          // ヘッダーをオプションとして追加
          headers.forEach((header, index) => {
            if (header && header.trim()) {
              const option = document.createElement('option');
              option.value = index;
              option.textContent = `${String.fromCharCode(65 + index)}列: ${header}`;
              dropdown.appendChild(option);
            }
          });
        } catch (error) {
          console.error(`${columnType}ドロップダウンの設定エラー:`, error);
        }
      });

      // AI検出結果をドロップダウンの初期選択として設定（統合処理）
      setAIDetectionSelections(mapping, dropdowns, confidence);

      // ドロップダウン変更イベントリスナーを設定
      setupDropdownEventListeners(dropdowns);
    } catch (error) {
      console.error('fillColumnDropdowns エラー:', error);
      showError('ドロップダウンの設定に失敗しました: ' + error.message);
    }
  }

  // ===========================================
  // 🔧 シンプル競合チェックシステム
  // ===========================================

  /**
   * シンプル競合チェック
   * @param {Object} mapping - AI検出マッピング
   * @param {Object} dropdowns - ドロップダウン要素
   * @returns {boolean} 競合があるかどうか
   */
  function checkSimpleConflicts(mapping, dropdowns) {
    if (!mapping || !dropdowns) return false;

    const actualMapping = mapping?.mapping || mapping || {};

    for (const fieldType of Object.keys(dropdowns)) {
      const dropdown = dropdowns[fieldType];
      if (!dropdown) continue;

      const hasAI = actualMapping[fieldType] !== undefined;
      const hasManual = dropdown.value && dropdown.value !== '';

      if (hasAI && hasManual && actualMapping[fieldType] !== parseInt(dropdown.value)) {
        return true;
      }
    }
    return false;
  }


  // 🎯 AI検出結果をドロップダウンの初期選択として設定（競合解決強化版）
  function setAIDetectionSelections(mapping, dropdowns, confidence = {}) {

    // 🛡️ シンプル競合チェック
    const hasConflicts = checkSimpleConflicts(mapping, dropdowns);
    if (hasConflicts) {
      console.warn('⚠️ AI検出と手動設定の競合があります - 手動選択が優先されます');
    }

    // 防御的チェック: mappingがundefined/nullの場合は早期リターン
    if (!mapping || typeof mapping !== 'object') {
      console.log('💡 AI検出結果がありません - 手動選択をお使いください');
      return;
    }

    // バックエンド構造統一: CLAUDE.md準拠
    const actualMapping = mapping || {};

    // 詳細チェック: mapping構造の検証
    const mappingDetails = {
      hasMapping: Object.keys(actualMapping).length > 0,
      hasConfidence: Object.keys(confidence).length > 0,
      mappingKeys: Object.keys(actualMapping),
      confidenceKeys: Object.keys(confidence),
      mappingContent: actualMapping,
      confidenceContent: confidence
    };

    const hasValidMapping = actualMapping && Object.keys(actualMapping).length > 0;
    const hasConfidenceData = confidence && Object.keys(confidence).length > 0;

    if (!hasValidMapping && !hasConfidenceData) {
      return;
    }

    if (!hasValidMapping && hasConfidenceData) {
      
    }

    // グローバル変数として現在のAI検出結果を保存
    window.currentAIMapping = mapping;

    // 🎯 統一マッピングキー（バックエンドのgetHeaderPatterns()と完全統一）
    const mappingKeys = {
      // 基本フィールド（管理パネル対応）
      answer: ['answer'], // バックエンド: answer フィールド
      reason: ['reason'], // バックエンド: reason フィールド
      class: ['class'], // バックエンド: class フィールド
      name: ['name'], // バックエンド: name フィールド

      // 拡張フィールド（将来対応・デバッグ用）
      timestamp: ['timestamp'], // バックエンド: timestamp フィールド
      email: ['email'], // バックエンド: email フィールド

      // リアクション列（システム内部用）
      understand: ['understand'], // バックエンド: understand フィールド
      like: ['like'], // バックエンド: like フィールド
      curious: ['curious'], // バックエンド: curious フィールド

      // ハイライト列（システム内部用）
      highlight: ['HIGHLIGHT'] // バックエンド: HIGHLIGHT フィールド
    };

    let detectedCount = 0;
    let totalConfidenceInfo = [];

    Object.keys(dropdowns).forEach((columnType) => {
      const dropdown = dropdowns[columnType];
      if (!dropdown) return;

      // 対応するマッピングキーを探す
      let selectedIndex = null;
      let columnConfidence = 0;

      mappingKeys[columnType].forEach((key) => {
        if (actualMapping[key] !== null && actualMapping[key] !== undefined) {
          selectedIndex = actualMapping[key];
        }
        if (confidence && confidence[key] !== undefined) {
          columnConfidence = confidence[key];
        }
      });

      // 信頼度情報を記録（検出されなくても）
      if (columnConfidence > 0) {
        totalConfidenceInfo.push(`${columnType}: ${columnConfidence}%`);
      }

      if (selectedIndex !== null) {
        // ドロップダウンの選択を設定
        dropdown.value = selectedIndex;
        dropdown.classList.add('has-ai-selection');

        // 信頼度バッジを表示
        showConfidenceBadge(columnType, columnConfidence, 'ai');

        
        detectedCount++;
      } else if (columnConfidence > 0) {
        // 🎯 高精度AI判定システム: 強化された閾値設定
        const HIGH_PRECISION_THRESHOLDS = {
          answer: 75,   // 複雑質問文 - ハイブリッドシステム対応
          reason: 70,   // 理由説明文 - セマンティック強化
          name: 80,     // 単純識別子 - 高精度期待
          class: 85,    // 明確パターン - 最高精度期待
          email: 90     // フォーマット固定 - 完全一致期待
        };
        const threshold = HIGH_PRECISION_THRESHOLDS[columnType] || 75;

        let badgeType = 'low-confidence';
        let statusMessage = '';

        // 🎯 インテリジェントフォールバック機能
        if (columnConfidence >= threshold) {
          badgeType = 'candidate';
          statusMessage = `候補 (閾値${threshold}%達成)`;
        } else if (columnConfidence >= 50) {
          // 中間信頼度: フォールバック候補として提示
          badgeType = 'fallback-candidate';
          statusMessage = `要確認候補 (${Math.round(columnConfidence)}% - 閾値${threshold}%未満)`;

          // 🔄 自動リトライ機能: 複数検出手法を試行
          attemptFallbackDetection(columnType, dropdown, headers, actualMapping, confidence);
        } else if (columnConfidence >= 30) {
          badgeType = 'low-confidence';
          statusMessage = `検討候補 (${Math.round(columnConfidence)}% - 手動確認推奨)`;

          // 💡 ユーザーガイダンス提供
          provideLowConfidenceGuidance(columnType, dropdown);
        } else {
          badgeType = 'very-low';
          statusMessage = `信頼度不足 (${Math.round(columnConfidence)}% - 手動設定を推奨)`;

          // 🔍 代替検出手法を試行
          attemptAlternativeDetection(columnType, dropdown, headers);
        }

        
        showConfidenceBadge(columnType, columnConfidence, badgeType);
      }
    });

    // AI判定システム対応の改善されたフィードバックメッセージ
    if (detectedCount > 0) {
      const maxConfidence = Math.max(...Object.values(confidence));
      
      
    } else if (totalConfidenceInfo.length > 0) {
      const maxConfidence = Math.max(...Object.values(confidence));
      const avgConfidence = Object.values(confidence).reduce((a, b) => a + b, 0) / Object.values(confidence).length;
      
      
    }

    // AI検出情報パネルを表示
    const aiInfo = document.getElementById('ai-detection-info');
    if (aiInfo) {
      aiInfo.classList.remove('hidden');
    }

    // 🆕 設定完了状況を更新
    updateCompletionStatus();
  }

  // ===========================================
  // 🎯 インテリジェントフォールバック支援機能
  // ===========================================

  /**
   * 🔄 フォールバック検出試行
   */
  function attemptFallbackDetection(columnType, dropdown, headers, mapping, confidence) {
    try {
      console.log(`🔄 フォールバック検出開始: ${columnType}`);

      // 代替パターンマッチング
      const alternativePatterns = {
        answer: ['回答', '答え', 'answer', '意見', '考え', 'コメント'],
        reason: ['理由', 'reason', '根拠', '説明', 'なぜ', 'どうして'],
        name: ['名前', 'name', '氏名', 'お名前', 'ニックネーム'],
        class: ['クラス', 'class', '組', '学年', 'グレード']
      };

      const patterns = alternativePatterns[columnType] || [];
      let bestCandidate = null;
      let bestScore = 0;

      headers.forEach((header, index) => {
        if (!header) return;

        const normalizedHeader = header.toLowerCase();
        let score = 0;

        // 単語一致スコア
        patterns.forEach(pattern => {
          if (normalizedHeader.includes(pattern.toLowerCase())) {
            score += 25;
          }
        });

        // 位置ボーナス（フィールドタイプ別）
        if (columnType === 'answer' && index < 3) score += 10;
        if (columnType === 'reason' && index >= 2 && index < 5) score += 10;
        if (columnType === 'name' && index >= headers.length - 3) score += 15;
        if (columnType === 'class' && index >= headers.length - 3) score += 15;

        if (score > bestScore) {
          bestScore = score;
          bestCandidate = index;
        }
      });

      // フォールバック候補提示
      if (bestCandidate !== null && bestScore >= 25) {
        console.log(`✅ フォールバック候補検出: ${columnType} = ${bestCandidate} (${bestScore}点)`);

        // ソフトな候補提示（自動選択はしない）
        const option = dropdown.querySelector(`option[value="${bestCandidate}"]`);
        if (option) {
          option.textContent = `🔍 ${option.textContent} (AI候補)`;
          option.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
          option.style.fontWeight = 'bold';
        }

        // 候補についての説明を表示
        showFallbackCandidateInfo(columnType, bestCandidate, bestScore, headers[bestCandidate]);
      }

    } catch (error) {
      console.error(`フォールバック検出エラー (${columnType}):`, error);
    }
  }

  /**
   * 💡 低信頼度時のユーザーガイダンス
   */
  function provideLowConfidenceGuidance(columnType, dropdown) {
    const guidanceMessages = {
      answer: '💡 ヒント: 質問に対する学習者の回答が記録されている列を探してください。通常、最も長い文章が含まれる列です。',
      reason: '💡 ヒント: 回答の理由や説明が記録されている列を探してください。「なぜ」「理由」という言葉を含む列名を確認してください。',
      name: '💡 ヒント: 回答者の名前が記録されている列を探してください。通常、表の右側にある短いテキストの列です。',
      class: '💡 ヒント: クラスや学年情報が記録されている列を探してください。「3-A」「1年1組」のような形式のデータを含む列です。'
    };

    const message = guidanceMessages[columnType];
    if (message) {
      // ドロップダウンの下にガイダンス表示
      let guidanceEl = document.getElementById(`${columnType}-guidance`);
      if (!guidanceEl) {
        guidanceEl = document.createElement('div');
        guidanceEl.id = `${columnType}-guidance`;
        guidanceEl.className = 'text-xs text-blue-300 mt-1 p-2 bg-blue-500/10 rounded border-l-2 border-blue-400';
        dropdown.parentNode.appendChild(guidanceEl);
      }
      guidanceEl.textContent = message;

      // 8秒後に非表示 - CLAUDE.md V8 compliant: Promise-based delay
      const createPromiseDelay = (ms) => new Promise(resolve => {
        const start = Date.now();
        const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
        check();
      });

      createPromiseDelay(8000).then(() => {
        if (guidanceEl && guidanceEl.parentNode) {
          guidanceEl.parentNode.removeChild(guidanceEl);
        }
      }).catch(() => {
        // Silent error handling for cleanup
      });
    }
  }

  /**
   * 🔍 代替検出手法の試行
   */
  function attemptAlternativeDetection(columnType, dropdown, headers) {
    console.log(`🔍 代替検出開始: ${columnType}`);

    // 文字数・データ特徴による推測
    const candidates = [];

    headers.forEach((header, index) => {
      if (!header) return;

      let score = 0;
      const headerLower = header.toLowerCase();

      // 文字数による推測
      switch (columnType) {
        case 'answer':
          if (header.length > 20) score += 20; // 長い列名 = 質問文の可能性
          if (headerLower.includes('？') || headerLower.includes('?')) score += 30;
          break;
        case 'reason':
          if (headerLower.includes('理') || headerLower.includes('説明')) score += 25;
          break;
        case 'name':
          if (header.length < 15 && header.length > 1) score += 15; // 短い列名
          break;
        case 'class':
          if (header.length < 10 && header.length > 1) score += 15; // 短い列名
          break;
      }

      if (score > 0) {
        candidates.push({ index, score, header });
      }
    });

    // 最良候補をハイライト
    if (candidates.length > 0) {
      candidates.sort((a, b) => b.score - a.score);
      const bestCandidate = candidates[0];

      if (bestCandidate.score >= 15) {
        const option = dropdown.querySelector(`option[value="${bestCandidate.index}"]`);
        if (option) {
          option.textContent = `❓ ${option.textContent} (推測候補)`;
          option.style.backgroundColor = 'rgba(245, 158, 11, 0.1)';
        }

        console.log(`📋 代替候補提示: ${columnType} = ${bestCandidate.index} (${bestCandidate.score}点)`);
      }
    }
  }

  /**
   * 📋 フォールバック候補情報表示
   */
  function showFallbackCandidateInfo(columnType, index, score, header) {
    const message = `🔍 AI分析: ${String.fromCharCode(65 + index)}列「${header}」が${columnType}の候補として検出されました (信頼度: ${score}/100)`;
    showInfo(message, 5000);
  }

  // ===========================================
  // 🔗 統合テスト・最終検証システム
  // ===========================================

  /**
   * システム全体の列判定統合テスト実行
   */
  function runIntegratedColumnTest() {
    if (!ClientMutex.acquire('runIntegratedColumnTest')) {
      showInfo('統合テストを実行中です…');
      return;
    }

    try {
      

      // 現在の設定を収集
      const currentConfig = getConfig();
      const headers = window.currentHeaders || [];
      const columnMapping = currentConfig.columnMapping || {};

      if (!headers.length) {
        showError('統合テストには先にデータソース接続が必要です');
        ClientMutex.release('runIntegratedColumnTest');
        return;
      }

      // サンプルデータの生成
      const sampleData = generateTestSampleData(headers);

      // バックエンド統合診断API呼び出し
      google.script.run
        .withSuccessHandler(function(diagnosticsResult) {
          
          displayIntegratedTestResults(diagnosticsResult);
          ClientMutex.release('runIntegratedColumnTest');
        })
        .withFailureHandler(function(error) {
          console.error('❌ 統合診断エラー:', error);
          showError('統合診断中にエラーが発生しました');
          ClientMutex.release('runIntegratedColumnTest');
        })
        .performIntegratedColumnDiagnostics(headers, columnMapping, sampleData);

      showInfo('列判定システムの統合診断を実行中…', 3000);

    } catch (error) {
      console.error('runIntegratedColumnTest エラー:', error);
      showError('統合テストの開始に失敗しました');
      ClientMutex.release('runIntegratedColumnTest');
    }
  }

  /**
   * テスト用サンプルデータ生成
   * @param {Array} headers - ヘッダー配列
   * @returns {Array} サンプルデータ
   */
  function generateTestSampleData(headers) {
    const sampleData = [];

    try {
      // サンプルデータ行を生成
      const testRow = Array(headers.length).fill(null);

      headers.forEach((header, index) => {
        const headerLower = String(header).toLowerCase();

        if (headerLower.includes('timestamp') || headerLower.includes('日時')) {
          testRow[index] = '2025/09/20 10:30:00';
        } else if (headerLower.includes('email') || headerLower.includes('メール')) {
          testRow[index] = 'test@example.com';
        } else if (headerLower.includes('answer') || headerLower.includes('回答')) {
          testRow[index] = 'テスト回答データ';
        } else if (headerLower.includes('reason') || headerLower.includes('理由')) {
          testRow[index] = 'テスト理由データ';
        } else if (headerLower.includes('class') || headerLower.includes('クラス')) {
          testRow[index] = '1年A組';
        } else if (headerLower.includes('name') || headerLower.includes('名前')) {
          testRow[index] = 'テスト太郎';
        } else {
          testRow[index] = `テストデータ${index + 1}`;
        }
      });

      sampleData.push(testRow);
      

      return sampleData;

    } catch (error) {
      console.error('generateTestSampleData エラー:', error);
      return [[]];
    }
  }

  /**
   * 統合テスト結果の表示
   * @param {Object} diagnostics - 診断結果
   */
  function displayIntegratedTestResults(diagnostics) {
    try {
      

      // 結果パネルを取得または作成
      let resultsPanel = document.getElementById('integrated-test-results');
      if (!resultsPanel) {
        resultsPanel = createIntegratedTestResultsPanel();
      }

      // 結果コンテンツの生成
      const resultsHTML = generateTestResultsHTML(diagnostics);
      resultsPanel.innerHTML = resultsHTML;

      // パネル表示
      resultsPanel.classList.remove('hidden');

      // 結果に応じた通知
      if (diagnostics.summary.overallScore >= 90) {
        showSuccess(`列判定システム検証完了！総合スコア: ${diagnostics.summary.overallScore}%`);
      } else if (diagnostics.summary.overallScore >= 70) {
        showInfo(`列判定システムに改善余地あり。総合スコア: ${diagnostics.summary.overallScore}%`);
      } else {
        showError(`列判定システムに問題があります。総合スコア: ${diagnostics.summary.overallScore}%`);
      }

      // 推奨事項の表示
      if (diagnostics.recommendations.length > 0) {
        const criticalRecs = diagnostics.recommendations.filter(r => r.priority === 'critical');
        if (criticalRecs.length > 0) {
          showError(`重要: ${criticalRecs[0].message}`);
        }
      }

    } catch (error) {
      console.error('displayIntegratedTestResults エラー:', error);
      showError('テスト結果の表示に失敗しました');
    }
  }

  /**
   * 統合テスト結果パネルの作成
   * @returns {HTMLElement} 結果パネル要素
   */
  function createIntegratedTestResultsPanel() {
    const panel = document.createElement('div');
    panel.id = 'integrated-test-results';
    panel.className = 'hidden mt-6 p-4 bg-gray-900/50 border border-gray-600 rounded-lg';

    // 適切な挿入位置を見つける
    const insertAfter = document.getElementById('ai-detection-info') ||
                       document.querySelector('section[data-section="column-mapping"]') ||
                       document.querySelector('.column-mapping-section');

    if (insertAfter && insertAfter.parentNode) {
      insertAfter.parentNode.insertBefore(panel, insertAfter.nextSibling);
    } else {
      document.body.appendChild(panel);
    }

    return panel;
  }

  /**
   * テスト結果HTML生成
   * @param {Object} diagnostics - 診断結果
   * @returns {string} 生成されたHTML
   */
  function generateTestResultsHTML(diagnostics) {
    const overallScore = diagnostics.summary.overallScore;
    const scoreColor = overallScore >= 90 ? 'green' : overallScore >= 70 ? 'yellow' : 'red';

    let html = `
      <div class="mb-4">
        <h3 class="text-lg font-semibold text-white mb-2">🔍 列判定システム統合診断結果</h3>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div class="bg-gray-800 p-3 rounded">
            <div class="text-sm text-gray-400">総合スコア</div>
            <div class="text-xl font-bold text-${scoreColor}-400">${overallScore}%</div>
          </div>
          <div class="bg-gray-800 p-3 rounded">
            <div class="text-sm text-gray-400">重大な問題</div>
            <div class="text-xl font-bold text-red-400">${diagnostics.summary.criticalIssues || 0}件</div>
          </div>
          <div class="bg-gray-800 p-3 rounded">
            <div class="text-sm text-gray-400">警告</div>
            <div class="text-xl font-bold text-yellow-400">${diagnostics.summary.warnings || 0}件</div>
          </div>
        </div>
      </div>
    `;

    // システム健全性
    if (diagnostics.systemHealth) {
      html += generateSystemHealthHTML(diagnostics.systemHealth);
    }

    // フィールドテスト結果
    if (diagnostics.columnTests) {
      html += generateFieldTestsHTML(diagnostics.columnTests);
    }

    // 推奨事項
    if (diagnostics.recommendations && diagnostics.recommendations.length > 0) {
      html += generateRecommendationsHTML(diagnostics.recommendations);
    }

    html += `
      <div class="text-xs text-gray-500 mt-4">
        診断実行時刻: ${new Date(diagnostics.timestamp).toLocaleString()}
      </div>
    `;

    return html;
  }

  /**
   * システム健全性HTML生成
   * @param {Object} systemHealth - システム健全性データ
   * @returns {string} HTML
   */
  function generateSystemHealthHTML(systemHealth) {
    return `
      <div class="mb-4">
        <h4 class="font-medium text-white mb-2">システム健全性</h4>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-sm">
          <div class="flex justify-between p-2 bg-gray-800 rounded">
            <span>バックエンド:</span>
            <span class="text-${getStatusColor(systemHealth.backend.status)}-400">
              ${systemHealth.backend.score}% (${systemHealth.backend.status})
            </span>
          </div>
          <div class="flex justify-between p-2 bg-gray-800 rounded">
            <span>フロントエンド:</span>
            <span class="text-${getStatusColor(systemHealth.frontend.status)}-400">
              ${systemHealth.frontend.score}% (${systemHealth.frontend.status})
            </span>
          </div>
          <div class="flex justify-between p-2 bg-gray-800 rounded">
            <span>統合:</span>
            <span class="text-${getStatusColor(systemHealth.integration.status)}-400">
              ${systemHealth.integration.score}% (${systemHealth.integration.status})
            </span>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * フィールドテストHTML生成
   * @param {Object} columnTests - フィールドテスト結果
   * @returns {string} HTML
   */
  function generateFieldTestsHTML(columnTests) {
    let html = `
      <div class="mb-4">
        <h4 class="font-medium text-white mb-2">フィールド別テスト結果</h4>
        <div class="space-y-1 text-sm">
    `;

    Object.entries(columnTests).forEach(([field, test]) => {
      const statusIcon = test.resolved ? '✅' : '❌';
      const severityColor = test.severity === 'critical' ? 'red' : test.severity === 'warning' ? 'yellow' : 'green';

      html += `
        <div class="flex justify-between items-center p-2 bg-gray-800 rounded">
          <span>${statusIcon} ${field}</span>
          <span class="text-${severityColor}-400">
            ${test.resolved ? `${test.confidence}% (${test.method})` : 'Not Resolved'}
          </span>
        </div>
      `;
    });

    html += `
        </div>
      </div>
    `;

    return html;
  }

  /**
   * 推奨事項HTML生成
   * @param {Array} recommendations - 推奨事項
   * @returns {string} HTML
   */
  function generateRecommendationsHTML(recommendations) {
    let html = `
      <div class="mb-4">
        <h4 class="font-medium text-white mb-2">推奨事項</h4>
        <div class="space-y-2 text-sm">
    `;

    recommendations.forEach(rec => {
      const priorityColor = rec.priority === 'critical' ? 'red' : rec.priority === 'high' ? 'orange' : 'yellow';
      html += `
        <div class="p-2 bg-gray-800 rounded">
          <div class="text-${priorityColor}-400 font-medium">${rec.priority.toUpperCase()}</div>
          <div class="text-gray-300">${rec.message}</div>
        </div>
      `;
    });

    html += `
        </div>
      </div>
    `;

    return html;
  }

  /**
   * ステータスに対応する色を取得
   * @param {string} status - ステータス
   * @returns {string} 色名
   */
  function getStatusColor(status) {
    switch (status) {
      case 'healthy': return 'green';
      case 'warning': return 'yellow';
      case 'critical': return 'red';
      case 'error': return 'red';
      default: return 'gray';
    }
  }




  // ドロップダウンの変更イベントリスナーを設定
  function setupDropdownEventListeners(dropdowns) {
    Object.keys(dropdowns).forEach((columnType) => {
      const dropdown = dropdowns[columnType];
      if (!dropdown) return;

      dropdown.addEventListener('change', function () {
        handleDropdownChange(columnType, this);
      });
    });

    // AI検出に戻すボタンのイベントリスナー
    const resetButton = document.getElementById('reset-to-ai');
    if (resetButton) {
      resetButton.addEventListener('click', function () {
        resetToAIDetection();
      });
    }
  }

  // ドロップダウン変更の処理
  function handleDropdownChange(columnType, dropdown) {
    const selectedValue = dropdown.value;
    console.log(`ドロップダウン変更: ${columnType} → ${selectedValue}`);

    // 既存のCSSクラスを削除
    dropdown.classList.remove('has-ai-selection', 'has-manual-selection');

    if (selectedValue === '') {
      // 選択解除
      hideConfidenceBadge(columnType);
    } else {
      // 手動選択
      dropdown.classList.add('has-manual-selection');
      showConfidenceBadge(columnType, 100, 'manual');

      // AI検出に戻すボタンを表示
      const resetButton = document.getElementById('reset-to-ai');
      if (resetButton) {
        resetButton.style.display = 'inline-block';
      }

      // 手動設定情報を表示
      const manualInfo = document.getElementById('manual-override-info');
      if (manualInfo) {
        manualInfo.classList.remove('hidden');
      }
    }

    // 選択状況を更新
    updateSelectionStatus();

    // 🆕 設定完了状況を更新
    updateCompletionStatus();

    // ✅ 統一関数で状態更新（列設定がある場合のみ）
    const currentMapping = getColumnMapping();
    if (Object.keys(currentMapping).length > 0) {
      updateSystemState({
        columnMapping: currentMapping,
        setupStatus: 'completed'
      });
    }
  }

  // ✅ CLAUDE.md準拠: AI判定閾値システム統一化（必須列重視）
  const AI_CONFIDENCE_THRESHOLDS = {
    answer: 45,              // 必須列: 閾値を下げて設定しやすく
    reason: 60,              // オプション列: 品質維持のため閾値上げ
    name: 65, class: 65      // オプション列: 明確な列種別
  };

  // 信頼度バッジを表示（V8ランタイム最適化版）
  function showConfidenceBadge(columnType, confidence, type) {
    // V8 Runtime 安全性: 引数検証
    if (!columnType || typeof confidence !== 'number' || !type) {
      console.warn('showConfidenceBadge: 不正な引数', { columnType, confidence, type });
      return;
    }

    const confidenceDiv = document.getElementById(`${columnType}-confidence`);
    if (!confidenceDiv) {
      console.warn(`showConfidenceBadge: 要素が見つかりません - ${columnType}-confidence`);
      return;
    }

    const badge = confidenceDiv.querySelector('.confidence-badge');
    if (!badge) {
      console.warn(`showConfidenceBadge: バッジ要素が見つかりません - ${columnType}`);
      return;
    }

    // ✅ CLAUDE.md準拠: パフォーマンス最適化 - switch文使用
    let badgeClass = '';
    let badgeText = '';

    switch (type) {
      case 'manual':
        badgeClass = 'manual';
        badgeText = '✋ 手動設定';
        break;
      case 'ai':
        badgeClass = 'high';
        badgeText = `🎯 AI判定 ${Math.round(confidence)}%`;
        break;
      case 'candidate':
        badgeClass = 'candidate';
        badgeText = `🔍 候補 ${Math.round(confidence)}%`;
        break;
      case 'low-confidence':
        badgeClass = 'low';
        badgeText = `📊 検討中 ${Math.round(confidence)}%`;
        break;
      default:
        // 統一閾値システムでのAI検出判定
        const threshold = AI_CONFIDENCE_THRESHOLDS[columnType] || 55;
        const roundedConfidence = Math.round(confidence);

        if (confidence >= threshold) {
          badgeClass = 'high';
          badgeText = `🤖 AI検出 ${roundedConfidence}%`;
        } else if (confidence >= Math.max(threshold * 0.7, 20)) {
          badgeClass = 'medium';
          badgeText = `🤖 AI検出 ${roundedConfidence}%`;
        } else {
          badgeClass = 'low';
          badgeText = `🤖 AI検出 ${roundedConfidence}%`;
        }
        break;
    }

    // ✅ V8ランタイム最適化: DOM操作を一括で実行
    badge.className = `confidence-badge ${badgeClass}`;
    badge.textContent = badgeText;
    confidenceDiv.classList.remove('hidden');
  }

  // 信頼度バッジを非表示
  function hideConfidenceBadge(columnType) {
    const confidenceDiv = document.getElementById(`${columnType}-confidence`);
    if (confidenceDiv) {
      confidenceDiv.classList.add('hidden');
    }
  }

  // AI検出情報を表示
  function displayAIDetectionInfo(mapping, confidence = {}) {
    const detailsDiv = document.getElementById('ai-detection-details');
    if (!detailsDiv) return;

    // 防御的チェック: mappingがundefined/nullの場合は早期リターン
    if (!mapping || typeof mapping !== 'object') {
      detailsDiv.innerHTML = '<div class="text-gray-400 text-sm">AI検出結果がありません</div>';
      return;
    }

    const details = [];
    const columnNames = {
      answerer: '回答列',
      reason: '理由列',
      class: 'クラス列',
      name: '名前列',
    };

    const actualMapping = mapping.mapping || {};
    Object.keys(columnNames).forEach((key) => {
      if (actualMapping[key] !== null && actualMapping[key] !== undefined) {
        const columnLabel = String.fromCharCode(65 + actualMapping[key]) + '列';
        const columnConfidence = confidence[key] || 0;
        details.push(`${columnNames[key]}: ${columnLabel} (信頼度: ${Math.round(columnConfidence)}%)`);
      }
    });

    // XSS対策: DOM操作で安全に詳細情報を設定
    detailsDiv.innerHTML = '';
    details.forEach(detail => {
      const div = document.createElement('div');
      div.textContent = `• ${detail}`;
      detailsDiv.appendChild(div);
    });
  }

  // 選択状況を更新
  function updateSelectionStatus() {
    const hasManualSelection =
      document.querySelectorAll('.modern-select.has-manual-selection').length > 0;
    const hasAISelection = document.querySelectorAll('.modern-select.has-ai-selection').length > 0;

    console.log('選択状況:', { hasManualSelection, hasAISelection });

    // AI検出情報とリセットボタンの表示制御
    const resetButton = document.getElementById('reset-to-ai');
    if (resetButton) {
      resetButton.style.display = hasManualSelection ? 'inline-block' : 'none';
    }
  }

  // AI検出結果に戻す
  function resetToAIDetection() {
    console.log('AI検出結果にリセット');

    if (!window.currentAIMapping) {
      showError('AI検出データがありません');
      return;
    }

    // 全てのドロップダウンをリセット
    const dropdowns = {
      answer: document.getElementById('answer-column-select'),
      reason: document.getElementById('reason-column-select'),
      class: document.getElementById('class-column-select'),
      name: document.getElementById('name-column-select'),
    };

    // AI検出結果を再設定
    setAIDetectionSelections(window.currentAIMapping, dropdowns);

    // 手動設定情報を非表示
    const manualInfo = document.getElementById('manual-override-info');
    if (manualInfo) {
      manualInfo.classList.add('hidden');
    }

    // リセットボタンを非表示
    const resetButton = document.getElementById('reset-to-ai');
    if (resetButton) {
      resetButton.style.display = 'none';
    }

    showSuccess('AI検出結果にリセットしました');
  }

  // 列マッピング確認
  function verifyColumnMapping() {
    if (!ClientMutex.acquire('verifyColumnMapping')) {
      showInfo('検証処理を実行中です…');
      return;
    }

    // 接続方式に応じて適切な方法でスプレッドシート情報を取得
    const sourceMethod = document.querySelector('input[name="source-method"]:checked').value;
    let spreadsheetId, sheetName;

    if (sourceMethod === 'url') {
      // URL入力方式
      const urlInput = document.getElementById('spreadsheet-url');
      const url = urlInput.value.trim();
      const spreadsheetRegex = /https:\/\/docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/;
      const match = url.match(spreadsheetRegex);

      if (match) {
        spreadsheetId = match[1];
      }
      sheetName = document.getElementById('detected-sheet-name').textContent.trim();
    } else {
      // 一覧選択方式
      spreadsheetId = document.getElementById('spreadsheet-select').value;
      sheetName = document.getElementById('sheet-select').value;
    }

    if (!spreadsheetId || !sheetName) {
      showError('検証するにはまず、スプレッドシートとシートを接続してください');
      return;
    }

    window.setLoading(true, '処理中...');

    console.log('verifyColumnMapping: 列マッピング検証開始', { spreadsheetId, sheetName });

    // ヘッダーは接続時に保持したものを使用（なければ最小化）
    let headers = Array.isArray(window.currentHeaders) ? window.currentHeaders : [];
    if (!headers.length) {
      const options = document.querySelectorAll('#answer-column-select option');
      headers = Array.from(options)
        .map((opt) => {
          const txt = opt.textContent || '';
          const parts = txt.split(': ');
          return parts.length > 1 ? parts.slice(1).join(': ') : '';
        })
        .filter(Boolean);
    }

    // ✅ CLAUDE.md準拠: シンプル構造の直接収集 - 新形式対応
    const columnMapping = getColumnMapping();

    // 信頼度データの収集（メタデータとして別管理）
    const confidence = {};
    ['answer', 'reason', 'class', 'name'].forEach((key) => {
      if (typeof columnMapping[key] === 'number') {
        const confidenceElement = document.getElementById(key + '-confidence');
        if (confidenceElement && !confidenceElement.classList.contains('hidden')) {
          const badge = confidenceElement.querySelector('.confidence-badge');
          if (badge) {
            const confidenceText = badge.textContent;
            const match = confidenceText.match(/(\d+)%/);
            if (match) {
              confidence[key] = parseInt(match[1]);
            }
          }
        }
      }
    });

    // 表示用に検証結果を描画
    displayVerificationResults({ ok: true });

    // ✅ 統一関数で状態更新
    const currentMapping = getColumnMapping();
    updateSystemState({
      spreadsheetId,
      sheetName,
      columnMapping: currentMapping,
      setupStatus: 'completed'
    });

    // ✅ 検証専用に変更：保存処理は下書き保存・公開ボタンで実行
    showSuccess('✅ 列マッピング検証完了');
    window.setLoading(false);
    ClientMutex.release('verifyColumnMapping');
  }

  // 検証結果の表示（V8ランタイム最適化版・必須/オプション対応）
  function displayVerificationResults(headerIndices) {
    console.log('検証結果の表示を開始:', headerIndices);

    // ✅ 必須列とオプション列を区別（新しい列設定ロジックに対応）
    const requiredColumns = ['answer']; // 必須列
    const optionalColumns = ['reason', 'class', 'name']; // オプション列
    const allColumns = [...requiredColumns, ...optionalColumns];
    let badgesAdded = 0;

    // V8 Runtime 最適化: DOM操作をバッチ化
    const badgeElements = [];

    allColumns.forEach(columnType => {
      const dropdown = document.getElementById(`${columnType}-column-select`);
      const confidenceDiv = document.getElementById(`${columnType}-confidence`);

      // V8 Runtime 安全性: 要素存在チェック
      if (!dropdown || dropdown.value === '') {
        return;
      }

      // 既存の検証済みバッジを削除（重複防止）
      const existingBadge = dropdown.parentElement.querySelector('.verification-badge');
      if (existingBadge) {
        existingBadge.remove();
      }

      // ✅ V8ランタイム最適化: CSSクラスベースでスタイル適用
      const verifiedBadge = document.createElement('span');
      verifiedBadge.className = 'verification-badge status-badge published';
      verifiedBadge.textContent = '✓ 検証済み';

      // バッチ操作用にエレメントを収集
      badgeElements.push({
        badge: verifiedBadge,
        container: confidenceDiv || dropdown.parentElement,
        columnType
      });
    });

    // ✅ CLAUDE.md準拠: Batch DOM操作実行
    badgeElements.forEach(({ badge, container, columnType }) => {
      try {
        container.appendChild(badge);
        badgesAdded++;
        
      } catch (error) {
        console.warn(`検証バッジ追加エラー: ${columnType}`, error);
      }
    });

    // 🎯 列マッピングセクション全体に検証完了マークを追加
    const sectionHeaders = document.querySelectorAll('section h2');
    let mappingSection = null;

    sectionHeaders.forEach(header => {
      const headerText = header.textContent || '';
      if (headerText.includes('AI列マッピング') || headerText.includes('列マッピング')) {
        mappingSection = header.closest('section');
      }
    });

    if (mappingSection) {
      // 既存の検証完了マークを削除
      const existingMark = mappingSection.querySelector('.section-verified-mark');
      if (existingMark) {
        existingMark.remove();
      }

      // セクション検証完了マークを追加
      const sectionMark = document.createElement('div');
      sectionMark.className = 'section-verified-mark';
      sectionMark.innerHTML = `
        <div class="flex items-center gap-2 mt-4 p-3 bg-green-900/20 border border-green-500/30 rounded-lg">
          <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
          </svg>
          <span class="text-green-400 font-medium">列マッピング設定が完了しました</span>
        </div>
      `;

      const actionButtons = mappingSection.querySelector('.action-buttons');
      if (actionButtons) {
        actionButtons.parentElement.insertBefore(sectionMark, actionButtons);
      } else {
        mappingSection.appendChild(sectionMark);
      }
    }

    
  }

  // ===========================================
  // 🛡️ 列設定保存の検証・堅牢化システム
  // ===========================================

  /**
   * 列設定データの包括的検証
   * @param {string} spreadsheetId - スプレッドシートID
   * @param {string} sheetName - シート名
   * @param {Array} headers - ヘッダー配列
   * @param {Object} columnMapping - 列マッピング（シンプル構造）
   * @param {Object} confidence - 信頼度データ（オプション）
   * @returns {Object} 検証結果
   */
  function validateColumnConfig(spreadsheetId, sheetName, headers, columnMapping, confidence = {}) {
    const validation = {
      isValid: true,
      errors: [],
      warnings: [],
      recommendations: []
    };

    try {
      // 🔍 基本パラメータ検証
      if (!spreadsheetId || typeof spreadsheetId !== 'string' || spreadsheetId.trim() === '') {
        validation.errors.push('スプレッドシートIDが無効です');
        validation.isValid = false;
      }

      if (!sheetName || typeof sheetName !== 'string' || sheetName.trim() === '') {
        validation.errors.push('シート名が無効です');
        validation.isValid = false;
      }

      // 🔍 ヘッダー配列検証
      if (!Array.isArray(headers) || headers.length === 0) {
        validation.errors.push('ヘッダー配列が無効または空です');
        validation.isValid = false;
      } else {
        const emptyHeaders = headers.filter((h, i) => !h || String(h).trim() === '');
        if (emptyHeaders.length > 0) {
          validation.warnings.push(`${emptyHeaders.length}個の空ヘッダーがあります`);
        }
      }

      // 🔍 列マッピング検証 - ✅ CLAUDE.md準拠: シンプル構造対応
      if (!columnMapping || typeof columnMapping !== 'object') {
        validation.errors.push('列マッピングが無効です');
        validation.isValid = false;
      } else {
        const mappingData = columnMapping; // ✅ 直接シンプル構造使用
        const confidenceData = confidence; // ✅ 別パラメータから取得

        // 必須フィールドの確認
        const requiredFields = ['answer'];
        const missingRequired = requiredFields.filter(field =>
          mappingData[field] === undefined || mappingData[field] === null || mappingData[field] < 0
        );

        if (missingRequired.length > 0) {
          validation.errors.push(`必須フィールドが不足: ${missingRequired.join(', ')}`);
          validation.isValid = false;
        }

        // 列インデックスの妥当性確認
        Object.keys(mappingData).forEach(field => {
          const index = mappingData[field];
          if (typeof index === 'number') {
            if (index < 0) {
              validation.errors.push(`${field}フィールドの列インデックスが負の値です`);
              validation.isValid = false;
            } else if (headers && index >= headers.length) {
              validation.errors.push(`${field}フィールドの列インデックス(${index})がヘッダー範囲外です`);
              validation.isValid = false;
            }
          }
        });

        // 信頼度データの確認
        const lowConfidenceFields = Object.keys(confidenceData).filter(field =>
          confidenceData[field] < 30
        );
        if (lowConfidenceFields.length > 0) {
          validation.warnings.push(`低信頼度フィールド: ${lowConfidenceFields.join(', ')}`);
          validation.recommendations.push('管理パネルで手動調整を検討してください');
        }

        // 重複列検出
        const usedIndices = Object.values(mappingData).filter(v => typeof v === 'number' && v >= 0);
        const duplicateIndices = usedIndices.filter((index, i, arr) => arr.indexOf(index) !== i);
        if (duplicateIndices.length > 0) {
          validation.warnings.push(`重複列インデックス: ${duplicateIndices.join(', ')}`);
          validation.recommendations.push('異なるフィールドが同じ列を指しています');
        }
      }

      // 🎯 設定品質スコア算出
      if (validation.isValid) {
        validation.qualityScore = calculateConfigScore(headers, columnMapping, confidence);
        if (validation.qualityScore < 70) {
          validation.warnings.push(`設定品質スコア: ${validation.qualityScore}% - 改善余地あり`);
        }
      }

      console.log('🛡️ validateColumnConfigurationData結果:', validation);
      return validation;

    } catch (error) {
      console.error('validateColumnConfigurationData エラー:', error);
      return {
        isValid: false,
        errors: ['検証処理中にエラーが発生しました'],
        error: error.message
      };
    }
  }

  /**
   * 設定品質スコア算出 - ✅ CLAUDE.md準拠: シンプル構造対応
   * @param {Array} headers - ヘッダー配列
   * @param {Object} columnMapping - 列マッピング（シンプル構造）
   * @param {Object} confidence - 信頼度データ（オプション）
   * @returns {number} 品質スコア (0-100)
   */
  function calculateConfigScore(headers, columnMapping, confidence = {}) {
    let score = 0;
    const maxScore = 100;

    try {
      const mappingData = columnMapping; // ✅ 直接シンプル構造使用
      const confidenceData = confidence; // ✅ 別パラメータから取得

      // フィールド存在スコア (40点) - 必須列重視の新ロジック
      const requiredFields = ['answer']; // 必須列: 30点
      const optionalFields = ['reason', 'class', 'name']; // オプション列: 10点

      // 必須列スコア (30点) - 回答列が最重要
      const requiredCompleted = requiredFields.filter(field =>
        mappingData[field] !== undefined && mappingData[field] !== null && mappingData[field] >= 0
      );
      score += (requiredCompleted.length / requiredFields.length) * 30;

      // オプション列スコア (10点) - 追加設定による品質向上
      const optionalCompleted = optionalFields.filter(field =>
        mappingData[field] !== undefined && mappingData[field] !== null && mappingData[field] >= 0
      );
      score += (optionalCompleted.length / optionalFields.length) * 10;

      // 信頼度の高さ (30点)
      const avgConfidence = Object.values(confidenceData).length > 0
        ? Object.values(confidenceData).reduce((sum, conf) => sum + conf, 0) / Object.values(confidenceData).length
        : 50;
      score += (avgConfidence / 100) * 30;

      // ヘッダー品質 (20点)
      const headerQuality = headers ?
        headers.filter(h => h && String(h).trim() !== '').length / headers.length * 100 : 0;
      score += (headerQuality / 100) * 20;

      // マッピング一意性 (10点)
      const usedIndices = Object.values(mappingData).filter(v => typeof v === 'number' && v >= 0);
      const uniqueness = usedIndices.length > 0 ?
        new Set(usedIndices).size / usedIndices.length * 100 : 100;
      score += (uniqueness / 100) * 10;

      return Math.round(Math.max(0, Math.min(maxScore, score)));

    } catch (error) {
      console.error('calculateConfigurationQualityScore エラー:', error);
      return 50; // デフォルトスコア
    }
  }

  /**
   * 設定保存のリトライ機構
   * @param {Object} config - 保存する設定
   * @param {number} maxRetries - 最大リトライ回数
   * @returns {Promise} 保存結果
   */
  function saveConfigWithRetry(config, maxRetries = 3) {
    return new Promise((resolve, reject) => {
      let attempt = 0;

      function attemptSave() {
        attempt++;
        console.log(`🔄 設定保存試行 ${attempt}/${maxRetries}`);

        google.script.run
          .withSuccessHandler(function(result) {
            if (result.success) {
              
              resolve(result);
            } else {
              console.warn(`⚠️ 設定保存失敗 (試行 ${attempt}):`, result.message || result.error);
              if (attempt < maxRetries) {
                // CLAUDE.md準拠: Promise-based指数バックオフ (setTimeout代替)
                const delay = Math.pow(2, attempt) * 1000;
                new Promise(resolve => {
                  const startTime = Date.now();
                  const checkTime = () => {
                    if (Date.now() - startTime >= delay) {
                      resolve();
                    } else {
                      requestAnimationFrame(checkTime);
                    }
                  };
                  checkTime();
                }).then(attemptSave);
              } else {
                reject(new Error(result.message || result.error || '設定保存に失敗しました'));
              }
            }
          })
          .withFailureHandler(function(error) {
            console.error(`❌ 設定保存エラー (試行 ${attempt}):`, error);
            if (attempt < maxRetries) {
              // CLAUDE.md準拠: Promise-based指数バックオフ (setTimeout代替)
              const delay = Math.pow(2, attempt) * 1000;
              new Promise(resolve => {
                const startTime = Date.now();
                const checkTime = () => {
                  if (Date.now() - startTime >= delay) {
                    resolve();
                  } else {
                    requestAnimationFrame(checkTime);
                  }
                };
                checkTime();
              }).then(attemptSave);
            } else {
              reject(error);
            }
          })
          .saveConfig(config);
      }

      attemptSave();
    });
  }


  // 🔒 列設定の保存（堅牢化版） - ✅ CLAUDE.md準拠: シンプル構造対応
  function saveColumnConfig(spreadsheetId, sheetName, headers, columnMapping, confidence = {}) {
    // 🔧 CLAUDE.md準拠: ClientMutexで重複実行防止
    if (!ClientMutex.acquire('saveColumnConfig')) {
      showInfo('列設定の保存処理を実行中です…');
      return;
    }

    try {
      // 🛡️ 入力データの検証 - ✅ CLAUDE.md準拠: シンプル構造対応
      const validationResult = validateColumnConfig(spreadsheetId, sheetName, headers, columnMapping, confidence);
      if (!validationResult.isValid) {
        showError(`列設定の検証に失敗: ${validationResult.errors.join(', ')}`);
        ClientMutex.release('saveColumnConfig');
        return;
      }

      // 🎯 ConfigJson最適化: 重複防止の単一責任設計
      const timestamp = new Date().toISOString();

    const baseConfig = {
      spreadsheetId,
      sheetName,
      headers: headers, // ✅ CLAUDE.md準拠: トップレベルheaders（UI表示用）
      columnMapping: columnMapping, // ✅ CLAUDE.md準拠: シンプル構造 {answer:4, reason:5, ...}
      displaySettings: getDisplaySettings(),
      verifiedAt: timestamp, // メタデータは別途管理
      confidence: confidence, // 信頼度データは別途管理
      setupComplete: true,
      setupStatus: 'completed',
      etag: (systemState && systemState.config && systemState.config.etag) || undefined,
    };

    // 🔧 CLAUDE.md準拠: const再代入エラー回避 - 条件分岐で安全な構築
    const optimizedConfig = systemState && systemState.config ? {
      ...baseConfig, // 新しい設定を基本とする
      // 既存設定から保持すべきフィールドのみ明示的に取得
      userId: systemState.config.userId,
      setupStatus: systemState.config.setupStatus,
      isPublished: systemState.config.isPublished,
      publishedAt: systemState.config.publishedAt,
      displaySettings: getDisplaySettings(),
      // 新しい設定で明示的に上書き（baseConfigで既に設定済みだが明示的に保証）
      spreadsheetId,
      sheetName,
      headers,
      columnMapping: {
        ...columnMapping,
        headers: headers,
        verifiedAt: timestamp // 統一されたタイムスタンプ
      }
    } : baseConfig;

      // 🎯 ConfigJson完全同期: Derived Fields自動更新
      const isSpreadsheetChanged = optimizedConfig.spreadsheetId !== systemState.config.spreadsheetId;
      if (isSpreadsheetChanged) {
        console.log('🔄 SpreadsheetId変更検出 - Derived Fields更新開始:', {
          oldId: systemState.config.spreadsheetId,
          newId: optimizedConfig.spreadsheetId
        });

        // sourceKey自動生成 (UserService.gsロジック準拠)
        optimizedConfig.sourceKey = 'sheet_' + optimizedConfig.spreadsheetId + '_' + Date.now();

        // spreadsheetUrl自動生成
        optimizedConfig.spreadsheetUrl = 'https://docs.google.com/spreadsheets/d/' + optimizedConfig.spreadsheetId + '/edit';

        // 古いフォーム情報をクリア（新しいスプレッドシートでは異なる可能性）
        optimizedConfig.formUrl = null;
        optimizedConfig.formTitle = null;

      }

      // 🎯 Object.assign残存分クリーンアップ（最小限） - ✅ CLAUDE.md準拠: verifiedAtはトップレベル保持

      // 🔗 フォーム自動連携: 既存フォーム検出・統合（安全版）
      if (!optimizedConfig.formUrl) {
        

        google.script.run
          .withSuccessHandler(function(formResult) {
            if (formResult.success && formResult.formData && formResult.formData.formUrl) {
              optimizedConfig.formUrl = formResult.formData.formUrl;
              optimizedConfig.formTitle = formResult.formData.formTitle;
            } else {
              console.log('ℹ️ フォーム連携なし（通常状態）');
            }
            executeConfigSave();
          })
          .withFailureHandler(function(error) {
            console.warn('⚠️ フォーム自動検出エラー（安全に継続）:', error.message);
            executeConfigSave();
          })
          .getFormInfo(spreadsheetId, sheetName);
        return;
      }

    // 通常の保存処理実行
    executeConfigSave();

    function executeConfigSave() {
      const logData = {
        spreadsheetId: optimizedConfig.spreadsheetId,
        sheetName: optimizedConfig.sheetName,
        hasColumnMapping: !!optimizedConfig.columnMapping,
        setupComplete: optimizedConfig.setupComplete,
        configSize: JSON.stringify(optimizedConfig).length
      };

      if (optimizedConfig.sourceKey) logData.sourceKey = optimizedConfig.sourceKey;
      if (optimizedConfig.spreadsheetUrl) logData.spreadsheetUrl = optimizedConfig.spreadsheetUrl;
      if (optimizedConfig.formUrl) logData.formUrl = optimizedConfig.formUrl;
      if (optimizedConfig.formTitle) logData.formTitle = optimizedConfig.formTitle;

      console.log('📋 Config保存準備:', logData);
      console.log('🔍 送信するcolumnMapping:', optimizedConfig.columnMapping);

      google.script.run
        .withSuccessHandler(function (result) {
          if (result.success) {
            console.log('✅ Config保存成功:', {
              spreadsheetId: optimizedConfig.spreadsheetId,
              savedHeaders: headers.length,
              hasMapping: !!columnMapping,
              setupComplete: true
            });

            // 🔧 CLAUDE.md準拠: systemState安全更新（競合回避）
            if (systemState && systemState.config) {
              // 明示的フィールドマージで意図しない上書きを防止
              systemState.config = {
                ...systemState.config,
                // 列設定関連のフィールドのみ更新
                spreadsheetId: optimizedConfig.spreadsheetId,
                sheetName: optimizedConfig.sheetName,
                headers: optimizedConfig.headers,
                columnMapping: optimizedConfig.columnMapping,
                setupComplete: optimizedConfig.setupComplete,
                lastModified: systemState.user?.lastModified || optimizedConfig.lastModified,
                // 🔧 楽観的ロック: 新しいETagを更新
                etag: result.etag || result.config?.etag || systemState.config.etag
              };
            }

            // ✅ 論理的整合性: UI状態を統一して更新
            updateResourceButtons(systemState.config);
            updateConfigSummary(systemState.config);
            showSuccess('列マッピング設定が完了しました');
          } else {
            if (result.error === 'etag_mismatch') {
              showInfo('設定が他で更新されました。画面を更新しました。もう一度保存してください。');
              if (typeof loadAndApplyCurrentConfig === 'function') {
                loadAndApplyCurrentConfig();
              }
            } else if (result.message || result.error) {
              console.warn('列設定の保存に失敗:', result.message || result.error);
            } else {
              console.warn('設定保存で予期しない応答:', result);
            }
          }
          ClientMutex.release('saveColumnConfig');
        })
        .withFailureHandler(function (error) {
          console.error('列設定保存エラー:', error);
          showError('列設定の保存に失敗しました');
          ClientMutex.release('saveColumnConfig');
        })
        .saveConfig(optimizedConfig);
    }

    } catch (error) {
      console.error('列設定保存処理エラー:', error);
      showError('列設定の保存処理に失敗しました: ' + error.message);
      ClientMutex.release('saveColumnConfig');
    }
  }

  // ✅ 列設定検証付きconfig取得関数
  function getValidatedConfig() {
    try {
      // 基本設定取得
      const config = getConfig();

      // スプレッドシート接続の確認
      if (!config.spreadsheetId || !config.sheetName) {
        return {
          config: null,
          validationError: 'データソースが接続されていません。まずスプレッドシートとシートを接続してください。'
        };
      }

      // 列マッピングの検証
      const columnMapping = getColumnMapping();
      if (!columnMapping.answer && columnMapping.answer !== 0) {
        return {
          config: null,
          validationError: '回答列が設定されていません。列マッピングで回答列を設定してください。'
        };
      }

      // ヘッダー情報の取得・確認
      let headers = Array.isArray(window.currentHeaders) ? window.currentHeaders : [];
      if (!headers.length) {
        const options = document.querySelectorAll('#answer-column-select option');
        headers = Array.from(options)
          .map((opt) => {
            const txt = opt.textContent || '';
            const parts = txt.split(': ');
            return parts.length > 1 ? parts.slice(1).join(': ') : '';
          })
          .filter(Boolean);
      }

      // 信頼度データの収集
      const confidence = {};
      ['answer', 'reason', 'class', 'name'].forEach((key) => {
        if (typeof columnMapping[key] === 'number') {
          const confidenceElement = document.getElementById(key + '-confidence');
          if (confidenceElement && !confidenceElement.classList.contains('hidden')) {
            const badge = confidenceElement.querySelector('.confidence-badge');
            if (badge) {
              const confidenceText = badge.textContent;
              const match = confidenceText.match(/(\d+)%/);
              if (match) {
                confidence[key] = parseInt(match[1]);
              }
            }
          }
        }
      });

      // 設定の統合
      const timestamp = new Date().toISOString();
      const validatedConfig = {
        ...config,
        headers: headers,
        columnMapping: columnMapping,
        confidence: confidence,
        verifiedAt: timestamp,
        setupComplete: true,
        setupStatus: 'completed'
      };

      return { config: validatedConfig, validationError: null };

    } catch (error) {
      console.error('設定検証エラー:', error);
      return {
        config: null,
        validationError: '設定の検証中にエラーが発生しました: ' + error.message
      };
    }
  }

  // 下書き保存（列設定検証・フォーム連携統合版）
  function saveDraft() {
    if (!ClientMutex.acquire('saveDraft')) {
      showInfo('保存処理を実行中です…');
      return;
    }

    try {
      // ✅ 列設定の検証と取得
      const { config, validationError } = getValidatedConfig();
      if (validationError) {
        showError(validationError);
        ClientMutex.release('saveDraft');
        return;
      }

      window.setLoading(true, '設定を保存中...');

      // ✅ フォーム連携処理（既存コードを統合）
      if (!config.formUrl && config.spreadsheetId && config.sheetName) {
        google.script.run
          .withSuccessHandler(function(formResult) {
            if (formResult.success && formResult.formData && formResult.formData.formUrl) {
              config.formUrl = formResult.formData.formUrl;
              config.formTitle = formResult.formData.formTitle;
            }
            executeDraftSave(config);
          })
          .withFailureHandler(function(error) {
            console.warn('⚠️ フォーム自動検出エラー（安全に継続）:', error.message);
            executeDraftSave(config);
          })
          .getFormInfo(config.spreadsheetId, config.sheetName);
      } else {
        executeDraftSave(config);
      }

    } catch (error) {
      console.error('下書き保存準備エラー:', error);
      showError('設定の準備に失敗しました: ' + error.message);
      ClientMutex.release('saveDraft');
    }

    function executeDraftSave(finalConfig) {
      google.script.run
        .withSuccessHandler(function (result) {
          if (result.success) {
            showSuccess('下書きを保存しました');

            // ✅ 論理的整合性: 保存後は最新config情報で更新
            systemState.config = { ...systemState.config, ...result.config };
            updateResourceButtons(systemState.config);
            updateConfigSummary(systemState.config);

            // ETag更新 - 楽観的ロック機構
            if (result.etag || result.config?.etag) {
              systemState.config.etag = result.etag || result.config.etag;
            }
          } else {
            showError(result.message || result.error || '設定の保存に失敗しました');
          }
          window.setLoading(false);
          ClientMutex.release('saveDraft');
        })
        .withFailureHandler(function (error) {
          console.error('保存エラー:', error);
          showError('下書きの保存に失敗しました');
          window.setLoading(false);
          ClientMutex.release('saveDraft');
        })
        .saveConfig(finalConfig, { isDraft: true });
    }
  }

  // アプリ公開（列設定検証・フォーム連携統合版）
  function publishApp() {
    if (!ClientMutex.acquire('publishApp')) {
      showInfo('公開処理を実行中です…');
      return;
    }

    try {
      // ✅ 列設定の検証と取得
      const { config, validationError } = getValidatedConfig();
      if (validationError) {
        showError(validationError);
        ClientMutex.release('publishApp');
        return;
      }

      window.setLoading(true, 'アプリを公開中...');

      // ✅ フォーム連携処理（既存コードを統合）
      if (!config.formUrl && config.spreadsheetId && config.sheetName) {
        google.script.run
          .withSuccessHandler(function(formResult) {
            if (formResult.success && formResult.formData && formResult.formData.formUrl) {
              config.formUrl = formResult.formData.formUrl;
              config.formTitle = formResult.formData.formTitle;
            }
            executePublish(config);
          })
          .withFailureHandler(function(error) {
            console.warn('⚠️ フォーム自動検出エラー（安全に継続）:', error.message);
            executePublish(config);
          })
          .getFormInfo(config.spreadsheetId, config.sheetName);
      } else {
        executePublish(config);
      }

    } catch (error) {
      console.error('公開準備エラー:', error);
      showError('公開の準備に失敗しました: ' + error.message);
      ClientMutex.release('publishApp');
    }

    function executePublish(publishConfig) {


      // 完全な設定でpublishAppを呼び出し
      google.script.run
        .withSuccessHandler(function (result) {
          if (result.success) {
            showSuccess('アプリを公開しました！');
            updatePublishStatus('published');

            // 公開後に最新の設定を取得してボタン状態を更新
            

            // 🎯 CLAUDE.md準拠: 公開成功後、systemState.configを直接更新
            const updatedConfig = {
              ...systemState.config,
              isPublished: true,
              publishedAt: result.publishedAt || new Date().toISOString(),
              setupComplete: true
            };

            // systemState.configを更新
            systemState.config = updatedConfig;

            // ✅ 論理的整合性: UI更新を統一
            updateResourceButtons(systemState.config);
            updateConfigSummary(systemState.config);

            // ETag更新 - 楽観的ロック機構
            if (result.etag || result.config?.etag) {
              systemState.config.etag = result.etag || result.config.etag;
            }

            // ✅ CLAUDE.md準拠 & 公開成功後：即座にフッターを更新（UX向上）
            // 遅延なしで直接フッター更新を実行
            (async () => {
              try {
                const adminData = await loadBatchedAdminData();
                console.log('🔍 Footer update - adminData:', adminData);
                if (adminData && adminData.boardInfo) {
                  // ✅ 既存のboardInfoを直接使用（正しいデータが既に含まれている）
                  currentBoardInfo = adminData.boardInfo;
                  updateFooterDisplay(adminData.boardInfo);
                }
              } catch (error) {
                console.warn('Footer refresh failed:', error);
              }
            })();
          } else {
            if (result.error === 'etag_mismatch') {
              showInfo('設定が他で更新されました。画面を更新してから再度公開してください。');
              if (typeof loadAndApplyCurrentConfig === 'function') {
                loadAndApplyCurrentConfig();
              }
            } else {
              showError(result.message || result.error || 'アプリの公開に失敗しました');
            }
          }
          window.setLoading(false);
          ClientMutex.release('publishApp');
        })
        .withFailureHandler(function (error) {
          console.error('公開エラー:', error);
          showError(
            'アプリの公開に失敗しました。データソースが正しく設定されているか確認してください。'
          );
          window.setLoading(false);
          ClientMutex.release('publishApp');
        })
        .publishApp(publishConfig);
    }
  }

  // フォーム情報の安全な収集（Zero-Dependency Architecture準拠）
  function getCurrentFormInfoSafe() {
    try {
      const isUrlMethod = !document.getElementById('url-method')?.classList?.contains('hidden');

      const titleElement = isUrlMethod ?
        document.getElementById('url-form-title') :
        document.getElementById('form-title');
      const urlElement = isUrlMethod ?
        document.getElementById('url-form-url') :
        document.getElementById('form-url');

      return {
        formUrl: (urlElement?.href !== '#' && urlElement?.href) || null,
        formTitle: (titleElement?.textContent !== '-' && titleElement?.textContent) || null
      };
    } catch (error) {
      console.warn('getCurrentFormInfoSafe error:', error.message);
      return { formUrl: null, formTitle: null };
    }
  }

  // ✅ CLAUDE.md準拠: 重複関数削除（シンプル化）
  // getColumnMapping() → getColumnMapping()に統一

  // ✅ CLAUDE.md準拠: 自然でシンプルな関数名
  function getDisplaySettings() {
    return {
      showNames: document.getElementById('show-names')?.checked || false,
      showReactions: document.getElementById('show-reactions')?.checked || false
    };
  }

  // ✅ CLAUDE.md準拠: よりシンプルで一貫した命名
  function getConfig() {
    const sourceMethod = document.querySelector('input[name="source-method"]:checked').value;

    let spreadsheetId, sheetName;

    if (sourceMethod === 'url') {
      // URL入力方式
      const urlInput = document.getElementById('spreadsheet-url');
      const url = urlInput.value.trim();
      const spreadsheetRegex = /https:\/\/docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/;
      const match = url.match(spreadsheetRegex);

      if (match) {
        spreadsheetId = match[1];
      }
      sheetName = document.getElementById('detected-sheet-name').textContent.trim();
    } else {
      // 一覧選択方式
      spreadsheetId = document.getElementById('spreadsheet-select').value;
      sheetName = document.getElementById('sheet-select').value;
    }


    // ✅ 完全なデータ収集（既存統一API活用）
    const formInfo = getCurrentFormInfoSafe();
    const columnMapping = getColumnMapping();

    return {
      spreadsheetId,
      sheetName,
      displaySettings: getDisplaySettings(),
      // 🔧 NEW: フォーム情報追加（安全な収集）
      formUrl: formInfo.formUrl,
      formTitle: formInfo.formTitle,
      // 🔧 NEW: 列マッピング追加（既存関数活用）
      columnMapping,
      etag: (systemState?.config?.etag) || undefined,
    };
  }

  // ✅ CLAUDE.md準拠: 自然な英語パターン（シンプル化）
  function getColumnMapping() {
    const dropdowns = {
      answer: document.getElementById('answer-column-select'),
      reason: document.getElementById('reason-column-select'),
      class: document.getElementById('class-column-select'),
      name: document.getElementById('name-column-select'),
    };

    // 🎯 最適構造: {answer: 4, reason: 5, class: 2} - 変換処理不要
    const columnMapping = {};

    Object.keys(dropdowns).forEach((columnType) => {
      const dropdown = dropdowns[columnType];
      if (!dropdown) return;
      const selectedValue = dropdown.value;
      if (selectedValue !== '') {
        columnMapping[columnType] = parseInt(selectedValue);
      }
    });

    console.log('✅ getColumnMapping (simplified):', columnMapping);
    return columnMapping;
  }

  // Get column confidence level
  function getColumnConfidence(columnType) {
    const elementId = columnType + '-confidence';
    const confidenceDiv = document.getElementById(elementId);
    if (!confidenceDiv || confidenceDiv.classList.contains('hidden')) {
      return 0;
    }

    const badge = confidenceDiv.querySelector('.confidence-badge');
    if (!badge) return 0;

    const text = badge.textContent;
    const match = text.match(/(\d+)%/);
    return match ? parseInt(match[1]) : badge.classList.contains('manual') ? 100 : 0;
  }


  // 公開ステータス更新
  function updatePublishStatus(status) {
    const badge = document.querySelector('.status-badge.unpublished') || document.querySelector('.status-badge.published');
    if (badge) {
      badge.className = 'status-badge ' + status;
      badge.textContent = status === 'published' ? '公開中' : '未公開';
    }
  }

  // ✅ V8ランタイム準拠: グローバルスコープでの変数初期化（重複実行防止機能付き）
  var lastConfigUpdate = null;  // V8ランタイム安全性: varによる適切な初期化

  function updateConfigSummary(config) {
    try {
      // V8ランタイム安全性: configの存在確認
      if (!config) {
        console.warn('updateConfigSummary: config is null or undefined');
        return;
      }

      // V8ランタイム安全性: lastConfigUpdate変数の確実な初期化
      if (typeof lastConfigUpdate === 'undefined') {
        lastConfigUpdate = null;
      }

      // 同一の設定データでの重複実行を防ぐ
      const configHash = JSON.stringify({
        isPublished: config.isPublished || false,
        spreadsheetId: config.spreadsheetId || '',
        spreadsheetName: config.spreadsheetName || '',
        sheetName: config.sheetName || '',
        lastModified: systemState.user?.lastModified || ''
      });

      // V8ランタイム安全性: lastConfigUpdateの存在確認
      if (lastConfigUpdate !== null && lastConfigUpdate === configHash) {
        return;
      }
      lastConfigUpdate = configHash;

      // ✅ CLAUDE.md準拠: Simple boolean check without over-engineering
      const isPublished = Boolean(config?.isPublished || config?.isActive);
      const publishBadge = document.getElementById('app-publish-status');
      if (publishBadge) {
        if (isPublished) {
          publishBadge.className = 'status-badge published';
          publishBadge.textContent = '公開中';
        } else {
          publishBadge.className = 'status-badge unpublished';
          publishBadge.textContent = '未公開';
        }
      }


      // シート名更新
      const sheetnameElement = document.getElementById('current-sheetname');
      if (sheetnameElement) {
        // ✅ 現在のシート名を取得（APIデータ優先）
        const sheetName = config?.sheetName || systemState.config?.sheetName;

        if (sheetName && sheetName.trim()) {
          sheetnameElement.textContent = sheetName;
          sheetnameElement.className = 'text-sm text-white';
          sheetnameElement.parentElement.style.display = '';
        } else {
          // シート名がない場合は要素自体を非表示
          sheetnameElement.parentElement.style.display = 'none';
        }
      }

      // displaySettings UIチェックボックスの更新
      if (config.displaySettings) {
        const showNamesCheckbox = document.getElementById('show-names');
        const showReactionsCheckbox = document.getElementById('show-reactions');

        if (showNamesCheckbox) {
          showNamesCheckbox.checked = Boolean(config.displaySettings.showNames);
        }
        if (showReactionsCheckbox) {
          showReactionsCheckbox.checked = Boolean(config.displaySettings.showReactions);
        }
      }

      // 最終更新時刻更新
      const timeElement = document.getElementById('last-updated-time');
      if (timeElement) {
        // ✅ Optimized: Use database lastModified instead of config lastModified
        const lastModified = systemState.user?.lastModified || config?.lastModified;

        if (lastModified) {
          const date = new Date(lastModified);
          const timeString = date.toLocaleString('ja-JP', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          });
          timeElement.textContent = timeString;
          timeElement.className = 'text-sm text-white';
          timeElement.parentElement.style.display = '';
        } else {
          // タイムスタンプがない場合は要素自体を非表示
          timeElement.parentElement.style.display = 'none';
        }
      }

      // スプレッドシートリンク更新（リソースセクション用）
      const openSheetBtn = document.getElementById('open-spreadsheet-btn');
      if (openSheetBtn && config?.spreadsheetId) {
        openSheetBtn.disabled = false;
        openSheetBtn.onclick = () => {
          const spreadsheetUrl =
            'https://docs.google.com/spreadsheets/d/' + config.spreadsheetId + '/edit';
          window.open(spreadsheetUrl, '_blank');
              };
        openSheetBtn.style.pointerEvents = 'auto';
      } else if (openSheetBtn) {
        openSheetBtn.onclick = (e) => {
          e.preventDefault();
          showError('スプレッドシートを選択してください');
        };
        openSheetBtn.style.opacity = '0.5';
        openSheetBtn.style.pointerEvents = 'auto';
      }
    } catch (error) {
      console.error('updateConfigSummary エラー:', error);
      console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        name: error.name,
        config: config ? JSON.stringify(config, null, 2) : 'null'
      });
    }
  }

  // =============================================================================
  // フッター：現在のボード情報表示機能
  // =============================================================================

  // グローバル変数
  let currentBoardInfo = null;

  // ✅ レガシー関数削除: loadBoardInfo() は loadBatchedAdminData() に統合済み

  // フッター表示更新
  function updateFooterDisplay(boardInfo) {
    const footer = document.getElementById('boardInfoFooter');
    const questionText = document.getElementById('currentQuestionText');
    const openBtn = document.getElementById('openBoardBtn');
    const copyBtn = document.getElementById('copyViewUrlBtn');
    const statusText = document.getElementById('boardStatus');

    // ✅ CLAUDE.md準拠: Simple boolean check without over-engineering
    const isPublished = Boolean(boardInfo?.isPublished || boardInfo?.isActive);


    if (!isPublished) {
      footer.classList.add('hidden');
      return;
    }

    // 公開時はフッターを表示
    footer.classList.remove('hidden');

    // 問題文設定
    questionText.textContent = boardInfo.questionText || 'エラーが発生しました';

    if (boardInfo.isActive && boardInfo.urls) {
      // ボタン表示・機能設定
      openBtn.style.display = 'block';
      copyBtn.style.display = 'block';

      openBtn.onclick = () => window.open(boardInfo.urls.view, '_blank');
      copyBtn.onclick = () => copyViewUrl(boardInfo.urls.view);

      // ステータス更新
      if (statusText) {
        statusText.textContent = '最終更新: ' + (boardInfo.lastUpdated || '不明');
      }
    } else {
      // 非アクティブ状態
      openBtn.style.display = 'none';
      copyBtn.style.display = 'none';
      if (statusText) {
        statusText.textContent = boardInfo.error || 'ボードが非アクティブです';
      }
    }
  }

  // 日時フォーマット関数
  function formatDate(dateString) {
    if (!dateString) return '--';
    try {
      const date = new Date(dateString);
      return date.toLocaleString('ja-JP', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
      });
    } catch (e) {
      return '--';
    }
  }

  // URLコピー機能（実用重視）
  function copyViewUrl(url) {
    if (!url) {
      showError('コピーするURLがありません');
      return;
    }

    // クリップボードにコピー
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard
        .writeText(url)
        .then(() => {
          showSuccess('閲覧用URLをコピーしました！');
          // ボタンを一時的に変更してフィードバック
          const btn = document.getElementById('copyViewUrlBtn');
          const originalText = btn.textContent;
          btn.textContent = '✅ コピー完了';
          btn.disabled = true;

          // ✅ CLAUDE.md準拠: V8 compliant Promise-based delay
          const createPromiseDelay = (ms) => new Promise(resolve => {
            const start = Date.now();
            const check = () => (Date.now() - start >= ms) ? resolve() : Promise.resolve().then(check);
            check();
          });

          createPromiseDelay(2000).then(() => {
            btn.textContent = originalText;
            btn.disabled = false;
          }).catch(() => {
            // Ensure button is reset even on error
            btn.textContent = originalText;
            btn.disabled = false;
          });
        })
        .catch(() => {
          fallbackCopyUrl(url);
        });
    } else {
      fallbackCopyUrl(url);
    }
  }

  // フォールバック（古いブラウザ用）
  function fallbackCopyUrl(url) {
    const textarea = document.createElement('textarea');
    textarea.value = url;
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand('copy');
      showSuccess('閲覧用URLをコピーしました！');
    } catch (err) {
      // 最終手段：URLを表示して手動コピーを促す
      prompt('以下のURLをコピーしてください:', url);
    }
    document.body.removeChild(textarea);
  }

  // アプリケーション名自動生成機能は削除（CLAUDE.md準拠）

  // 回答ボードを開く
  function openAnswerBoard() {
    google.script.run
      .withSuccessHandler(function (result) {
        if (result && result.appUrl) {
          window.open(result.appUrl, '_blank');
        } else {
          showError('回答ボードのURLが取得できませんでした');
        }
      })
      .withFailureHandler(function (error) {
        showError('回答ボードを開けませんでした: ' + error.message);
      })
      .getBoardInfo();
  }

  // アプリ設定画面を開く
  function openAppSetup() {
    // 通知トーストで遷移をユーザーに知らせる
    if (window.notifications) {
      window.notifications.info('⚙️ アプリ設定画面に移動中...', 2000);
    }

    // ✅ 現在のターゲットユーザーIDを取得
    const targetUserId = window.UNIFIED_CONFIG.targetUserId;

    google.script.run
      .withSuccessHandler(function (webAppUrl) {
        if (webAppUrl) {
          // ✅ userIdパラメータを付与してアプリ設定画面に遷移
          const appSetupUrl = webAppUrl + '?mode=appSetup' + (targetUserId ? '&userId=' + targetUserId : '');
          window.open(appSetupUrl, '_top');
        }
      })
      .withFailureHandler(function (error) {
        console.error('アプリ設定エラー:', error);
        if (window.notifications) {
          window.notifications.error('アプリ設定画面を開けませんでした。', 3000);
        }
      })
      .getWebAppUrl();
  }

</script>
